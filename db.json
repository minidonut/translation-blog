{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/header_img/about-bg.jpg","path":"img/header_img/about-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket2.png","path":"css/images/rocket2.png","modified":0,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/header_img/home-bg-2-dark.jpg","path":"img/header_img/home-bg-2-dark.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-temp/photo-1484852168632-238c9f9a78a4.jpg","path":"img/bg-temp/photo-1484852168632-238c9f9a78a4.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-temp/photo-1490225110719-148c048da5fe.jpg","path":"img/bg-temp/photo-1490225110719-148c048da5fe.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.jpg","path":"img/header_img/archive-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-temp/photo-1490030327837-eab3c250898d.jpg","path":"img/bg-temp/photo-1490030327837-eab3c250898d.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.jpg","path":"img/header_img/tag-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1522072803258},{"_id":"source/404.md","hash":"88cbdd6f043cce7425d26b523abbbc7e8b4264fa","modified":1521871186292},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1521292180321},{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1521292180321},{"_id":"source/_posts/Why-Composition-is-Harder-with-Classes.md","hash":"c2846742e78d1d45b9c957a517898259051208f7","modified":1524922634911},{"_id":"source/_posts/a-functional-programmers-introduction-to-javascript.md","hash":"d54e618e693e048096fb41fd469cf97336d83270","modified":1523007193338},{"_id":"source/_posts/abstraction-and-composition.md","hash":"864cd654064ce6a04c32c1938b6069aa4e47c992","modified":1524923330927},{"_id":"source/_posts/composable-datatype-with-functions.md","hash":"c9804a43158ed4fc4a3466cd991a57b1a75d8a2a","modified":1524922701487},{"_id":"source/_posts/composing-software-intro.md","hash":"ee9f38a9e104590caf8b36070c1d321812c60b07","modified":1525531623261},{"_id":"source/_posts/composing-software-translation-epilogue.md","hash":"b721253835fdc1bcde555f531efaf839fb707969","modified":1524926006680},{"_id":"source/_posts/functional-mixins.md","hash":"80642dffc3cf777f4c8dc3cc05450bcfa2b9258b","modified":1524922559870},{"_id":"source/_posts/functors-and-categories.md","hash":"e606e9a156d37aa50dcaf1b3b51964e5c743e13b","modified":1524922513634},{"_id":"source/_posts/higher-order-functions.md","hash":"a58f9c71834833dc4658ef6b658e082a5dffeeb9","modified":1523011033043},{"_id":"source/_posts/javaScript-factory-function-with-es6.md","hash":"dd72ec56397344a13d3c8eaecc292282f1e7c60d","modified":1524922598694},{"_id":"source/_posts/javascript-monads-made-simple.md","hash":"513a774f2f0a1d82abbd7d483e171c0a815d7b78","modified":1524922746075},{"_id":"source/_posts/mocking-is-a-code-smell.md","hash":"ed35058edd404bee3242c2be5dcb4fad3a3aa542","modified":1524922806787},{"_id":"source/_posts/nested-ternaries-are-great.md","hash":"3110f92e8dc9add1e573e185c8d496b11216f27c","modified":1524922874296},{"_id":"source/_posts/reduce.md","hash":"c318941202e53b35d5b13409e2636b02445696e2","modified":1524922422438},{"_id":"source/_posts/the-hidden-treasures-of-object-composition.md","hash":"75d7162c4a30ff58a9a4c7abfe830db5b1aef01f","modified":1524923330915},{"_id":"source/_posts/the-rise-and-fall-and-rise-of-functional-programming-composable-software.md","hash":"9c9c838ee6ca2e8f1e27aa311596747a974984bc","modified":1523010586614},{"_id":"source/_posts/why-learn-functional-programming-in-javascript.md","hash":"2c9d8679bfbb209b28531dd223cf73eb351a7723","modified":1524494772036},{"_id":"source/about/index.md","hash":"ccf180a557f38b487a73e91fcab9fff9b89ba991","modified":1521871220941},{"_id":"source/archive/index.md","hash":"becf250177179bde8303067d4e10c57deb3323f4","modified":1521870979885},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1521292180317},{"_id":"source/img/ironman-draw.png","hash":"4c265aee50a89a2d081b726f5d606c44c8077575","modified":1521869429371},{"_id":"source/tags/index.md","hash":"01b3935f0cb394aa47da708c2768936806dd576e","modified":1521873459571},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1521292180321},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1521292180321},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1521292180321},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1521292180321},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1521292180321},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1521292180321},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1521292180321},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1521292180321},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1521292180321},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1521292180321},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1521292180321},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1521292180321},{"_id":"themes/beantech/layout/index.ejs","hash":"9ec406021c3eb1fdbeebc4fede10ec83218d3ffd","modified":1521911773611},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1521292180321},{"_id":"themes/beantech/layout/layout.ejs","hash":"9caa39c65a0eab48c2272061c8ff7643374cfc0f","modified":1521865202252},{"_id":"themes/beantech/layout/page.ejs","hash":"84e506d6b4f33b34848ee35478e342bab9a3a782","modified":1521865203196},{"_id":"themes/beantech/layout/post.ejs","hash":"f30585bced798e2748b78faba26ea07894a9472e","modified":1524407788323},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1521292180321},{"_id":"source/_posts/50things-img/1_ESPL-XmY0BbboVotGOfAXg.png","hash":"4ad5c43d00aef882cd1f29832d3580dd580ffcfe","modified":1522567051724},{"_id":"source/_posts/50things-img/1_KSjWO6BXpJMu0oPtThNBvg.png","hash":"5e3cb3483c6ce4ce78704f17d1cb0d1fe765fe88","modified":1522567070471},{"_id":"source/_posts/50things-img/1_MzlkgsTBqO_vYZaqrH1ooA.png","hash":"c27c928e69c37f865ad611122e10b33f60f604dd","modified":1522567092417},{"_id":"source/_posts/50things-img/1_UR-BfhvP6gTJJOwNvgnbzQ.png","hash":"4b2fbf81f37c97d56d653e2fa0a103c8d36ff6f5","modified":1522567034966},{"_id":"source/_posts/50things-img/1_VKQLwRHbhu6OmQKHqcvd9g.png","hash":"5f24b943f2761b4023089016544bf4f6b221edf5","modified":1522567036234},{"_id":"source/_posts/50things-img/1_ZxShodBUnhn7M5jdI6R8Ng.png","hash":"069271566bcb3290bae486d64114e5b9b2cc3b94","modified":1522567038274},{"_id":"source/_posts/50things-img/1_a8w_qwhI5n1b5-CIq3oCyQ.png","hash":"060aff4b5fb0a3dfc602c609979bac16b590b2c1","modified":1522567047403},{"_id":"source/_posts/50things-img/1_csKTcF_9i1AkZ-fIDAuDmQ.png","hash":"fb1882555842d63d9623ac83dee1ce5817e544d1","modified":1522567049036},{"_id":"source/_posts/50things-img/1_z5nSSBgY_U6yw-sEPEEOJA.png","hash":"19d2ca369244efab9dbc197380fb1c4d9b50b693","modified":1522567037574},{"_id":"source/_posts/the-rise-and-fall-and-rise-of-functional-programming-composable-software/1_LSXnRbKzQ4yhq1fjZjvq6Q.png","hash":"52e5bfa887e5264e73ee800f117173b6928b4541","modified":1521865853729},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1521292180297},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"c7843f5f0a1601dbfc4213ee452efdc68f278370","modified":1521294010512},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"1a8c94c74876c898667a80cbdec4b7cc4cfee97e","modified":1521985798209},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1521292180321},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1521292180321},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1524407729590},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1521292180321},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1521292180321},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1521292180321},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1521292180321},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1521292180321},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1521292180321},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1521292180321},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"c79d30d6b67a4570257b2cf81157eebe8544b563","modified":1521872696907},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1521292180321},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1521292180321},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"dc772201c65dae4d6d5a20e2c4c13beb0e327d3e","modified":1521296029440},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1521292180321},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1521292180321},{"_id":"themes/beantech/source/css/rocket.styl","hash":"f3b2444e802462e32e872f967f685c36826c50d7","modified":1521864186350},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1521292180321},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1521292180321},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1521292180321},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1521292180321},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1521292180325},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1521292180325},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1521292180325},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1521292180325},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1521292180325},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1521292180325},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1521292180325},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1521292180325},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1521292180325},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1521292180325},{"_id":"source/_posts/50things-img/1_0EXUD3a7u9wu8QWnuMAu-Q.png","hash":"ef2c0fe7063d6794cbe432ffb7c538c2c1f9cb4f","modified":1522567039746},{"_id":"source/_posts/50things-img/1_2LSlFZkoTAdZWQl_k8OTPg.png","hash":"35f0c8bb6d814be642b503a27ab32230fabac84e","modified":1522567040866},{"_id":"source/_posts/50things-img/1_IGYztTe-inWGqaqko6a-zg.png","hash":"6708a903d0d079e151481f5c80fe0139bd58ab8b","modified":1522567054660},{"_id":"source/_posts/50things-img/1_MHckthNbpOtgCtMw5NjTiw.png","hash":"d13861a3525816e1a6cbe00596d61c1d14753b1e","modified":1522567081936},{"_id":"source/_posts/50things-img/1_UbQ3fgy9CFPYtZ03Dwuv-g.png","hash":"c11a095d70ffad8565df0a8c2b4ed929bd398b5b","modified":1522567118364},{"_id":"source/_posts/50things-img/1_VJ1FjSsnhuZQ7sF7JYud3w.png","hash":"371701a717aae6f0e96cec1cb9619c83b9752075","modified":1522567036194},{"_id":"source/_posts/50things-img/1_XqAKqa0-ozKIZ3UhYKuzww.png","hash":"c7d0a51fccc2113bb81dc5a3d1968731369b004d","modified":1522567036986},{"_id":"source/_posts/50things-img/1_XwZWcO-QvdbJnXrjqjJPPA.png","hash":"86d1a461b55ffe79215e0d1b8711cffab6069278","modified":1522567037746},{"_id":"source/_posts/50things-img/1_b6OLhAmsVRlBIaignHYfuQ.png","hash":"a3e6d55538ec290b99eb60fd50367ae29efd5335","modified":1522567050100},{"_id":"source/_posts/50things-img/1_erfx47qw2ort5rJEoeoLvw.gif","hash":"c3bb5ffe21a2b7f14d4e58e68e57a5ac0f12afa2","modified":1522567052612},{"_id":"source/_posts/50things-img/1_mJ5wwxjdCfizyfo-QofhZg.png","hash":"ae4914fba9f443d73df0267f9d3932fe9dc85292","modified":1522567090233},{"_id":"source/_posts/50things-img/1_pIj8Gp5sgWa6PYYUDbkjnQ.png","hash":"02ea806974c178ba6a9d83fc8fd8a55b177d894e","modified":1522567098442},{"_id":"source/_posts/50things-img/1_sW2GYv_71o7kFvVCRbZvOQ.png","hash":"9822269681b1deb6e4dd36a3e13bb0a93becfcf5","modified":1522567118280},{"_id":"source/_posts/50things-img/1_vLMznLG_Adlio9VSR02_Rg.png","hash":"f5eb4f36464cf1f5a2cf9b1ff05e1db74a1573f2","modified":1522567036982},{"_id":"source/img/header_img/about-bg.jpg","hash":"307ffdd5072d58e72617a04dbec32f287771b65d","modified":1521870846843},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1521292180321},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1521292180325},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1521292180325},{"_id":"source/_posts/50things-img/1_8uMz0241owLA_0sEn97JpQ.png","hash":"b344d68dc184d8c9902cb2b58a21927789118fd1","modified":1522567047847},{"_id":"source/_posts/50things-img/1_jWQY30u4frlSyIe21cnzQw.png","hash":"6efd4c09e99912bc1bebe840ceaaff54cde9de91","modified":1522567064102},{"_id":"source/_posts/50things-img/1_n3g_sGmvxI-w1kLq9guatQ.png","hash":"3ea9eab3ba04824a9ab49cc3babc5dbba7937c03","modified":1522567098698},{"_id":"source/_posts/50things-img/1_q70uY0MvGLyCQsFu7bIU_w.png","hash":"2f873e61014c1abd53f4bcba89b4823e119aa476","modified":1522567108091},{"_id":"source/_posts/50things-img/1_xJ2VXYUcM2C5F0DTGqu1cw.png","hash":"dea7f367a40500039db24487db1b1d69191c5f52","modified":1522567037198},{"_id":"source/_posts/50things-img/small/0_7kaYMIbUgp4FE9Dz_.png","hash":"36ad8f8c02a2b9ad22fd0472377a9b8e5bf53390","modified":1522567632419},{"_id":"source/_posts/50things-img/small/0_AlTodk2SH4SckJml_.png","hash":"ef3d10efdca782fbcb29293437280c63ed5ee828","modified":1522567632131},{"_id":"source/_posts/50things-img/small/0_NDeQef2AgcP78Fmx_.png","hash":"7ab316b33109ae24d5360a42951c094e483f469c","modified":1522567632023},{"_id":"source/_posts/50things-img/small/1_d7vkBNcVDkLM8zQJtXptdw.png","hash":"06d684fdf366ab7cd4b89d169c30b9bf2f88a189","modified":1522567632131},{"_id":"source/_posts/50things-img/small/1_y-Alub2wUojMUKmLHM6k5w.png","hash":"c7cb6d12fc390095d8ca39ed8da97ebfcf612e37","modified":1522567632231},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1521292180301},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1521292180321},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1521292180321},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"4ccb5e96cdcfed36c6bd0e4fff0218be5cdfdfeb","modified":1521296034605},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1521292180321},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"a2ac7e6539832e77f5dc52f9105c89934975469a","modified":1521863856064},{"_id":"themes/beantech/source/css/images/rocket2.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1521292180321},{"_id":"source/_posts/50things-img/1_4mCsVF3R1HJgnFTVmMBQtQ.png","hash":"2b34d8f293f85d3f6d0d0206bfc8cde32f994207","modified":1522567043783},{"_id":"source/_posts/50things-img/1_83QQUnBjVtitUlJZvMnl0A.png","hash":"12d041f7bc7955cdf244c068bc759f97e6174e6d","modified":1522567050504},{"_id":"source/_posts/50things-img/1_8AJ47Nu_FnTszjLso6vAbw.png","hash":"ce8409ae251e1cf944a57d4522c162538251cc73","modified":1522567045943},{"_id":"source/_posts/50things-img/1_lNoVoN0_BhVtto2EEN2pvQ.png","hash":"c3470b7e7867db0eb4f654de4c4841f4fdc78e96","modified":1522567078508},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1521292180317},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1521292180317},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1521292180325},{"_id":"source/_posts/50things-img/1_2lUUICFNXopu8n0v_t9XbQ.png","hash":"f2ff97abb9af021d040860bae3b52bc5e99d5b75","modified":1522567044907},{"_id":"source/_posts/50things-img/1_7Kd3hd_PgFzjt9vAgEFUyw.png","hash":"6d5c9d461855b62cd07cef942e7fba098d3ce25f","modified":1522567046271},{"_id":"source/_posts/50things-img/1_hheOSk1Qq6N3CkCZnbspHg.png","hash":"c5d57c4d530c03a6991c95f0bcca506e4d7198ee","modified":1522567059733},{"_id":"source/_posts/50things-img/1_jznDzq4tcdkPKm4qyHCFLw.png","hash":"c78a5e186efa19d25cc6bb89e8da37c8e89946cb","modified":1522567072439},{"_id":"source/_posts/50things-img/1_zhzAm22XWS6rEj5PiUBr-Q.png","hash":"3d52a1aae59eaf599e243251b02ccb0a66e90496","modified":1522567043467},{"_id":"source/img/header_img/home-bg-2-dark.jpg","hash":"bb92014b502fc2b4dd721f2cd30f4d476e3fa12b","modified":1521870513933},{"_id":"source/_posts/Why-Composition-is-Harder-with-Classes/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/a-functional-programmers-introduction-to-javascript/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/abstraction-and-composition/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/composable-datatype-with-functions/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/composing-software-intro/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/composing-software-translation-epilogue/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/functional-mixins/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/functors-and-categories/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/higher-order-functions/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/javaScript-factory-function-with-es6/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/javascript-monads-made-simple/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/mocking-is-a-code-smell/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/nested-ternaries-are-great/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/reduce/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/the-hidden-treasures-of-object-composition/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/the-rise-and-fall-and-rise-of-functional-programming-composable-software/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/_posts/why-learn-functional-programming-in-javascript/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/img/bg-temp/photo-1484852168632-238c9f9a78a4.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1521873339461},{"_id":"source/img/bg-temp/photo-1490225110719-148c048da5fe.jpg","hash":"cdc721632ad9d598635ac8ced962e5b06dbf3a67","modified":1521873340589},{"_id":"source/img/header_img/archive-bg.jpg","hash":"6cb69d4475c359323803f86cfa8a80c559dacce0","modified":1521870958860},{"_id":"source/_posts/50things-img/1_sEM54vviUonmagIaPNnOdw.png","hash":"1656ab6b98a1d00167faa723a010a07bfecf065d","modified":1522567121361},{"_id":"source/_posts/50things-img/1_jj1hAHdQ1rfOxtM14ByNow.gif","hash":"39843e0c171f784d17b85c4d99cf287bc2134265","modified":1522567068122},{"_id":"source/_posts/50things-img/1_mI77IGADAWgC5hFHsV2k4A.gif","hash":"8ed598b32fd9320c4e34a7681663ffe765f62f2b","modified":1522567097198},{"_id":"source/_posts/50things-img/1_unWp6dw_wMOHP2Ri5j9FDQ.png","hash":"7ae3a70d020a895e09344b31ab3df9086610dc07","modified":1522567124705},{"_id":"source/img/bg-temp/photo-1490030327837-eab3c250898d.jpg","hash":"17214a379afca15855bb258efcb0dd48052f1b2e","modified":1521873336949},{"_id":"source/img/header_img/tag-bg.jpg","hash":"7676463b9fe2901ffd77274faa42716dcbcda7b1","modified":1521871093607},{"_id":"source/_posts/50things-img/1_LAMD49tocxQj6UiVWSlfYw.gif","hash":"63e744dd301359f34030651279d9a4eb85a05f65","modified":1522567087177},{"_id":"source/_posts/50things-img/1_Q9wRWwqFFRTLHiSHIo7B-A.gif","hash":"39d57ce323eb9f1d1c62fef8efe11a29ac78216c","modified":1522567113876},{"_id":"source/_posts/50things-img/1_pW6BTsJ2UVKqdQJtlcRkbA.png","hash":"879db24e5401c000e89bf862d6b21a606184b4c1","modified":1522567115448},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1521292180301},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1521292180313},{"_id":"source/_posts/50things-img/1_pZUV4Q2lmXK5xSF_1QDuTw.png","hash":"2399a1402e5a8542b2a4d393b282c1e492f37f67","modified":1522567126193},{"_id":"source/_posts/50things-img/1_8p1bV2jh4O6RMlYtfrI7Gg.gif","hash":"f114ee84d48129b0f5d8fe3f79e4d21f6b1cd135","modified":1522567095678},{"_id":"source/_posts/50things-img/1_dysORLcBz1afIxuXlQ9eqA.gif","hash":"6209f00915710bcbfab68888865b4557694e424d","modified":1522567102399},{"_id":"source/_posts/50things-img/1_dJtphaiq-ULPE5lYHtdJ-w.gif","hash":"026533beec6291f1e0e4f1883d6f2310e4d1b707","modified":1522567121969},{"_id":"source/_posts/50things-img/1__COL-3Ja-hs14Y0bRnU2IA.gif","hash":"5fa85f4d4375735ad922fa49de984b7e7c9832d8","modified":1522567118452},{"_id":"public/post-sitemap.xml","hash":"efda7ce6bba8c04494b985da4ba92e192f067eaf","modified":1525531632750},{"_id":"public/page-sitemap.xml","hash":"db4e98192022562fe9fd5197f92c75ec6a48727a","modified":1524925425911},{"_id":"public/tag-sitemap.xml","hash":"8ea2a159d190c838370f62f320d21e970215ef44","modified":1525531632868},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1524925425979},{"_id":"public/sitemap.xml","hash":"2b437345efd23a532c26ec45d33d43ec5417020d","modified":1525531632928},{"_id":"public/404.html","hash":"e5eb311f075a5d19bcdf1138d7ed7e963360374b","modified":1524925425991},{"_id":"public/about/index.html","hash":"b2a3aafda4879de6ae21548038d169e0b51930a7","modified":1524925425991},{"_id":"public/tags/index.html","hash":"1fd182d82f78a8f575056de6c5193de62c9d1151","modified":1524925503625},{"_id":"public/2018/04/26/abstraction-and-composition/index.html","hash":"b82e81d04a07e4a397ea5da96877e83da47afe38","modified":1524925503631},{"_id":"public/2018/04/24/nested-ternaries-are-great/index.html","hash":"0a334d4f8663fd848d5c1ff3e4b254335718b7f1","modified":1524925425991},{"_id":"public/2018/04/23/the-hidden-treasures-of-object-composition/index.html","hash":"9295012b07c14bc321f9a63c862425b5bbb30168","modified":1524925425991},{"_id":"public/2018/04/19/mocking-is-a-code-smell/index.html","hash":"4c9f1bd65cdafc70dd0dcf32542e062ec380fd19","modified":1524925425991},{"_id":"public/2018/04/18/javascript-monads-made-simple/index.html","hash":"f90057aa4edb8a9ca5cf6907c903364bf820fc4f","modified":1524925425991},{"_id":"public/2018/04/14/composable-datatype-with-functions/index.html","hash":"9c6dee1dc15f5e40c6e748cc2b52e6adcbf514e6","modified":1524925425991},{"_id":"public/2018/04/12/Why-Composition-is-Harder-with-Classes/index.html","hash":"0ae9d70a3365799bc892ced9df50a6d0bab2cb35","modified":1524925425991},{"_id":"public/2018/04/08/javaScript-factory-function-with-es6/index.html","hash":"4cd7aac0464cf2a2175a4305665e957cc90bca85","modified":1524925425992},{"_id":"public/2018/04/07/functional-mixins/index.html","hash":"7124aa571d11eb6036aaed768330b51a56cadba1","modified":1524925425992},{"_id":"public/2018/04/07/functors-and-categories/index.html","hash":"f797dfb0cb7d9827bb4858d3a171a4715d1e2212","modified":1524925425992},{"_id":"public/2018/03/31/reduce/index.html","hash":"9aa80f59a570ec996201785694717a669d45750f","modified":1524925425992},{"_id":"public/2018/03/29/higher-order-functions/index.html","hash":"2e1c8de7f9f3d20ea7e13d8d22541c585b4bca76","modified":1524925425992},{"_id":"public/2018/03/28/a-functional-programmers-introduction-to-javascript/index.html","hash":"f7481656a89580bdcabc9b9d82e782a120b2c0df","modified":1524925425992},{"_id":"public/2018/03/24/why-learn-functional-programming-in-javascript/index.html","hash":"4703dafa16c59894deb83664e73a10ffedc6f832","modified":1524925425992},{"_id":"public/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/index.html","hash":"4b7e16093d8529176e0aeb200f0134a5a01b3fc0","modified":1524925425992},{"_id":"public/2018/03/16/composing-software-intro/index.html","hash":"c45d39d463bc01d6bfdb2cfeed95db210880a48b","modified":1525531632942},{"_id":"public/archive/index.html","hash":"8543b7fbd7a405ff47a9ddbfe312c2fc1ea4b72e","modified":1524925503634},{"_id":"public/archives/index.html","hash":"e376afbc20ba07e4581389e3bfaad94488bb61bb","modified":1524925503634},{"_id":"public/archives/archives/2/index.html","hash":"8c62538f550ef3caca2845e74ce0d6af77e6f4f9","modified":1524925503634},{"_id":"public/archives/2018/index.html","hash":"9837de6d87a855e51cbfbe134b911b27ca376771","modified":1524925503634},{"_id":"public/archives/2018/archives/2/index.html","hash":"ba9b1c6e42bb3af30a77646a4fbed9ee2d25ce81","modified":1524925503634},{"_id":"public/archives/2018/03/index.html","hash":"019262ef0377bdab53d02242ba1562f1dd751a8a","modified":1524925503634},{"_id":"public/archives/2018/04/index.html","hash":"8123d5564c3821a9f06b0b53704d744d82f89810","modified":1524925503634},{"_id":"public/index.html","hash":"5642b44412a2c188f69536ee05bce29456840a8f","modified":1524925503634},{"_id":"public/archives/2/index.html","hash":"d2a002d49daaba5733b126f395c68a72a050118a","modified":1524925503635},{"_id":"public/tags/자바스크립트/index.html","hash":"61e9ab814bd344dbd4ccea7f8d3b2cfc325868fc","modified":1524925503635},{"_id":"public/tags/자바스크립트/archives/2/index.html","hash":"ebd0db18e7342a8373c8069e91dfaa8c76c16235","modified":1524925503635},{"_id":"public/tags/함수형/index.html","hash":"c5ad85d1fb66b9b7d5df46cdb16c2a4d6c5f7d7c","modified":1524925503635},{"_id":"public/tags/함수형/archives/2/index.html","hash":"a5a54b389cf11b75ad1c7e4543092ad006fdfe57","modified":1524925503635},{"_id":"public/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524925426033},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1524925426045},{"_id":"public/img/ironman-draw.png","hash":"4c265aee50a89a2d081b726f5d606c44c8077575","modified":1524925426045},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1524925426045},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1524925426045},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1524925426045},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1524925426046},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1524925426046},{"_id":"public/css/images/rocket.png","hash":"a2ac7e6539832e77f5dc52f9105c89934975469a","modified":1524925426046},{"_id":"public/css/images/rocket2.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1524925426046},{"_id":"public/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/1_LSXnRbKzQ4yhq1fjZjvq6Q.png","hash":"52e5bfa887e5264e73ee800f117173b6928b4541","modified":1524925426046},{"_id":"public/img/header_img/about-bg.jpg","hash":"307ffdd5072d58e72617a04dbec32f287771b65d","modified":1524925426515},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1524925426518},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1524925426542},{"_id":"public/css/highlight.css","hash":"03d1f0a648e9bdf7b1f57d217313cbac5d0c7eb1","modified":1524925426542},{"_id":"public/css/rocket.css","hash":"b1c913820a30a2e90918253b87b6ac8f31d55513","modified":1524925426542},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1524925426542},{"_id":"public/css/toc.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1524925426542},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1524925426543},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1524925426543},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1524925426543},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1524925426543},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1524925426543},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1524925426543},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1524925426543},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1524925426543},{"_id":"public/css/beantech.min.css","hash":"dc772201c65dae4d6d5a20e2c4c13beb0e327d3e","modified":1524925426543},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1524925426543},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1524925426543},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1524925426543},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1524925426543},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1524925426543},{"_id":"public/css/bootstrap.min.css","hash":"4ccb5e96cdcfed36c6bd0e4fff0218be5cdfdfeb","modified":1524925426543},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1524925426543},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1524925426543},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1524925426544},{"_id":"public/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1524925426549},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1524925426549},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1524925426558},{"_id":"public/img/header_img/home-bg-2-dark.jpg","hash":"bb92014b502fc2b4dd721f2cd30f4d476e3fa12b","modified":1524925426564},{"_id":"public/img/bg-temp/photo-1484852168632-238c9f9a78a4.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426578},{"_id":"public/img/bg-temp/photo-1490225110719-148c048da5fe.jpg","hash":"cdc721632ad9d598635ac8ced962e5b06dbf3a67","modified":1524925426578},{"_id":"public/img/header_img/archive-bg.jpg","hash":"6cb69d4475c359323803f86cfa8a80c559dacce0","modified":1524925426578},{"_id":"public/2018/04/12/Why-Composition-is-Harder-with-Classes/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426579},{"_id":"public/2018/03/28/a-functional-programmers-introduction-to-javascript/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426579},{"_id":"public/2018/04/26/abstraction-and-composition/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426579},{"_id":"public/2018/04/14/composable-datatype-with-functions/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426579},{"_id":"public/2018/03/16/composing-software-intro/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426580},{"_id":"public/2018/04/07/functional-mixins/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426580},{"_id":"public/2018/04/07/functors-and-categories/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426580},{"_id":"public/2018/03/29/higher-order-functions/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426580},{"_id":"public/2018/04/08/javaScript-factory-function-with-es6/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426580},{"_id":"public/2018/04/18/javascript-monads-made-simple/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426580},{"_id":"public/2018/04/19/mocking-is-a-code-smell/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426581},{"_id":"public/2018/04/24/nested-ternaries-are-great/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426581},{"_id":"public/2018/03/31/reduce/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426581},{"_id":"public/2018/04/23/the-hidden-treasures-of-object-composition/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426581},{"_id":"public/2018/03/24/why-learn-functional-programming-in-javascript/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426581},{"_id":"public/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925426582},{"_id":"public/img/bg-temp/photo-1490030327837-eab3c250898d.jpg","hash":"17214a379afca15855bb258efcb0dd48052f1b2e","modified":1524925426592},{"_id":"public/img/header_img/tag-bg.jpg","hash":"7676463b9fe2901ffd77274faa42716dcbcda7b1","modified":1524925426592},{"_id":"public/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1524925426607},{"_id":"public/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1524925426608},{"_id":"public/2018/04/28/composing-software-translation-epilogue/index.html","hash":"c4830f407c7f593888067c92e4cf24615aa093c7","modified":1524926012457},{"_id":"public/archives/2018/04/archives/2/index.html","hash":"a299c6548fbf1c89046ae943529d9d9b9e59977d","modified":1524925503637},{"_id":"public/2018/04/28/composing-software-translation-epilogue/bg.jpg","hash":"44654e2667878ce5e9befa062b442feda46ab0ff","modified":1524925503656}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"페이지를 찾을 수 없습니다 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"페이지를 찾을 수 없습니다 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-03-24T05:59:46.292Z","updated":"2018-03-24T05:59:46.292Z","path":"404.html","title":"","comments":1,"_id":"cjgjh837h0000ifp68lvmyx0j","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T19:48:33.000Z","description":"Where one can no longer love, there one should pass by","header-img":"img/header_img/about-bg.jpg","comments":1,"_content":"\n\n> 번역글을 올리는 블로그입니다. \n\n> 개발과 디자인에 관한 번역글을 올릴예정입니다.\n\n> 오역 제보및 기타 문의사항은 minidonut03@gmail.com 으로 보내주세요 :D (매일 19:00에 확인)\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Where one can no longer love, there one should pass by\"\nheader-img: \"img/header_img/about-bg.jpg\"\ncomments: true\n---\n\n\n> 번역글을 올리는 블로그입니다. \n\n> 개발과 디자인에 관한 번역글을 올릴예정입니다.\n\n> 오역 제보및 기타 문의사항은 minidonut03@gmail.com 으로 보내주세요 :D (매일 19:00에 확인)\n","updated":"2018-03-24T06:00:20.941Z","path":"about/index.html","_id":"cjgjh83bw0002ifp6twvwgcs5","content":"<blockquote>\n<p>번역글을 올리는 블로그입니다.</p>\n</blockquote>\n<blockquote>\n<p>개발과 디자인에 관한 번역글을 올릴예정입니다.</p>\n</blockquote>\n<blockquote>\n<p>오역 제보및 기타 문의사항은 <a href=\"mailto:minidonut03@gmail.com\" target=\"_blank\" rel=\"noopener\">minidonut03@gmail.com</a> 으로 보내주세요 :D (매일 19:00에 확인)</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>번역글을 올리는 블로그입니다.</p>\n</blockquote>\n<blockquote>\n<p>개발과 디자인에 관한 번역글을 올릴예정입니다.</p>\n</blockquote>\n<blockquote>\n<p>오역 제보및 기타 문의사항은 <a href=\"mailto:minidonut03@gmail.com\" target=\"_blank\" rel=\"noopener\">minidonut03@gmail.com</a> 으로 보내주세요 :D (매일 19:00에 확인)</p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.jpg","comments":0,"date":"2017-03-20T11:49:56.000Z","description":"Archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.jpg\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Archives\"\n---\n","updated":"2018-03-24T05:56:19.885Z","path":"archive/index.html","_id":"cjgjh83c40004ifp6thwlw4z2","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.jpg\"\n---\n","date":"2018-03-24T06:37:39.571Z","updated":"2018-03-24T06:37:39.571Z","path":"tags/index.html","comments":1,"_id":"cjgjh83cj0007ifp6zouh6740","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"클래스로 합성하기가 까다로운 이유","catalog":true,"date":"2018-04-12T04:35:23.000Z","subtitle":"Why Composition is Harder with Classes","header-img":"bg.jpg","readingTime":13,"catagories":["개발"],"preview":"이전 글에서 우리는 팩토리 함수라는 주제를 살펴봤고 여기에 함수형 믹스인도 함께 사용해서 얼마나 쉽게 객체를 합성할 수 있는지 알게 됐습니다. 이제 클래스에 대해 좀 더 자세히 알아보겠습니다. `class`의 어떤 매커니즘이 합성과 연관되어 있는지 살펴 보겠습니다. 또한 클래스를 유용하게 사용한 사례와 클래스를 안전하게 사용하는 방법에 대해 살펴 보겠습니다. ES6에는 우리에게 익숙한  `class`구문이 있습니다. 팩토리 같은걸 왜 신경 써야하는지 궁금 할 수 있습니다.  가장 분명한 차이점은 생성자 함수와  `class`가  `new`  키워드를 필요로 한다는 것입니다.  그렇다면 실제로  `new`는 무슨일을 하는 걸까요?","_content":"\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/why-composition-is-harder-with-classes-c3e627dcd0aa)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/)\n\n이전 글에서 우리는 팩토리 함수라는 주제를 살펴봤고 여기에 함수형 믹스인도 함께 사용해서 얼마나 쉽게 객체를 합성할 수 있는지 알게 됐습니다. 이제 클래스에 대해 좀 더 자세히 알아보겠습니다. `class`의 어떤 매커니즘이 합성과 연관되어 있는지 살펴 보겠습니다.\n\n또한 클래스를 유용하게 사용한 사례와 클래스를 안전하게 사용하는 방법에 대해 살펴 보겠습니다.\n\nES6에는 우리에게 익숙한  `class`구문이 있습니다. 팩토리 같은걸 왜 신경 써야하는지 궁금 할 수 있습니다.  가장 분명한 차이점은 생성자 함수와  `class`가  `new`  키워드를 필요로 한다는 것입니다.  그렇다면 실제로  `new`는 무슨일을 하는 걸까요?\n\n-   새 객체를 만들고 이를 생성자 함수의  `this`  객체에 바인딩합니다.\n-   명시적으로 어떤 객체를 리턴하지 않으면  암시적으로 `this` 객체를 리턴합니다.\n-   인스턴스의 `[[Prototype]]` (내부 참조)을  `Constructor.prototype`  으로 설정합니다. 즉,  `Object.getPrototypeOf(instance) === Constructor.prototype`이 됩니다.\n-   `instance.constructor === Constructor`이 되도록 설정합니다.\n\n이 모든 것은 팩토리 함수와 다르게 클래스는 함수형 믹스인을 구성하는 좋은 솔루션이 아니라는 것을 의미합니다.  `class` 사용하여 합성을 할 수는 있지만 훨씬 복잡한 과정입니다. 이 과정에서 드는 추가 비용을 따져봤을 때 별다른 노력을 기울일 가치가 없습니다.\n\n## 프로토타입 위임^delegation^\n\n결국 클래스를 팩토리 함수로 리팩토링해야 할 수도 있습니다. 이 때 다른 코드에 있는 호출자가 `new`  키워드를 사용하고 있었다면 리팩토링이 우리가 모르는 사이에 여러가지 방법으로 클라이언트 코드를 손상시킬 수 있습니다.  우선, 클래스 및 생성자 함수와 달리 팩토리 함수는 프로토타입 링크를 자동으로 연결하지 않습니다.\n\n프로토타입 위임에는  `[[Prototype]]`  링크가 사용됩니다. 수백만개의 객체가있는 경우 메모리를 절약하는 괜찮은 방법입니다. 16ms 렌더링 루프 사이클 안에 객체의 수만 가지 속성에 액세스해야 하는 경우 프로그램 성능을 미세하게 쥐어 짜는데 사용됩니다.  \n\n메모리나 성능을 미세한 부분까지 최적화할 필요가  없다면,  `[[Prototype]]`  링크는 이익보다 해를 더 끼칠 수 있습니다.  JavaScript의 `instanceof` 연산자는 프로토타입 체인으로 동작하지만, 불행하게도  `instanceof`는 두 가지 방법으로 사용자를 속일 수 있습니다.\n\nES5의  `Constructor.prototype`  링크는 동적이며 재구성 가능했습니다. 추상 팩토리를 만들어야 하는 경우 편리한 기능이 될 수 있었습니다. 그러나 이 기능을 사용했을 때 만약  `Constructor.prototype`이 인스턴스의  `[[Prototype]]`과 같은 메모리를 참조하고 있지 않은 경우  `instanceof`는  `false`를 리턴하게 됩니다. :\n\n```javascript\nclass User {  \n  constructor ({userName, avatar}) {  \n    this.userName = userName;  \n    this.avatar = avatar;  \n  }  \n}\n\nconst currentUser = new User({  \n  userName: 'Foo',  \n  avatar: 'foo.png'  \n});\n\nUser.prototype = {};\n\nconsole.log(  \n  currentUser instanceof User, // <-- false -- Oops!\n\n// But it clearly has the correct shape:  \n  // { avatar: \"foo.png\", userName: \"Foo\" }  \n  currentUser  \n);\n```\n\nChrome에서 `Constructor.prototype`  속성을  `configurable: false`로 설정하면 이러한 문제를 해결할 수 있습니다.  그러나 Babel은 현재 이 동작을 미러링하지 않으므로 Babel로 컴파일된 코드는 ES5 생성자처럼 동작합니다. V8 엔진에서 `Constructor.prototype` 속성을 재설정 하려고 하면 자동으로 실패합니다.  어느 쪽이든, 당신은 예상 하지 못한 결과를 얻게 됩니다. 더 안좋은 점은 같은 동작을 하지 않는다는 것입니다.  왠만하면 `Constructor.prototype`을 재할당하지 마세요.\n\n보다 일반적인 문제는 JavaScript에 여러 실행 컨텍스트(동일한 코드가 서로 다른 물리적 메모리 주소에 액세스하는 메모리 샌드 박스)가 있다는 것입니다. 예를 들어 부모 프레임에 생성자가 있고 자식인  `iframe`에 동일한 생성자가있는 경우 부모 프레임의  `Constructor.prototype`은  `iframe`의 `Constructor.prototype`과 동일한 메모리 위치를 참조하지 않습니다.  JavaScript에서 객체의 값을 얻기 위해 메모리를 참조하는 것은 내부적으로 감춰진 채 작동하며 서로 다른 프레임은 물리적 메모리에서 서로 다른 위치를 가리키므로  `===` 검사는 실패합니다.\n\n`instanceof`의  또 다른 문제점은 구조적인 타입 체크가 아닌 명칭 타입 체크라는 점입니다. 즉,  `class`로 시작한 다음 나중에 추상 팩토리로 전환하면  `instanceof`를 사용하는 모든 클라이언트 코드는 새 구현을 이해하지 못합니다.  동일한 인터페이스 계약을 만족시킨다해도 말이지요.  예를 들어, 음악 플레이어 인터페이스를 구축해야 한다고 가정해 보겠습니다.  나중에 제품 팀에서 비디오에 대한 지원을 추가하라고 지시합니다.  나중에 360도 동영상에 대한 지원을 요청합니다. 그들은 모두 동일한 컨트롤을 필요로 합니다 : 재생, 정지, 되감기, 빨리 감기.\n\n그러나  `instanceof`검사를 사용하는 경우 비디오 인터페이스 클래스의 멤버는   이미 코드베이스에있는`foo instanceof AudioInterface` 검사를 만족하지 않습니다.\n\n제대로 구현되었다면 `false`를 리턴할 것입니다. 다른 언어의 공유 인터페이스는 클래스가 특정 인터페이스를 구현했다고 선언하도록 하여 이 문제를 해결합니다.  JavaScript에서는 현재 불가능합니다.\n\nJavaScript에서  `instanceof`를 처리하는 가장 좋은 방법은 프로토타입 링크 위임이 필요하지 않은 경우 이를 중단하고 모든 호출에 대해  `instanceof`  실패하게 만드는 것입니다. 그렇게하면 신뢰성이 확보될 것입니다.\n\n> 처음부터 `instanceof`가 하는 말을 듣지 않으면 그것은 결코 거짓말하지 않을 것이다.\n\n## .constructor 속성\n\n`.constructor`는 자주 사용하는 속성은 아닙니다. 그러나 매우 유용하게 활용 할 수 있으며 객체 인스턴스에 포함시키는 것이 좋습니다.  이를 타입 검사(`instanceof`가 안전하지 않은 것과 같은 이유 때문에 안전하지 않은)용도로 사용하려고 하지 않으면 대부분 무해합니다.\n\n**이론적으로**  `.constructor`는 전달받은 객체의 새 인스턴스를 리턴하는 제네릭 함수를 만드는 데 유용합니다.\n\n**실제로** JavaScript에는 새 인스턴스를 만드는 여러 가지 방법이 있습니다. 생성자를 이해한다고 해서 이를 사용해 새 객체를 인스턴스화하는 방법을 아는 것은 아닙니다.  주어진 객체로부터 빈 인스턴스를 생성하는 것 같은 사소한 용도로 사용할 때 조차도 문제가 발생할 수 있습니다. :\n\n```javascript\n// Return an empty instance of any object type?  \nconst empty = ({ constructor } = {}) => constructor ?  \n  new constructor() :  \n  undefined  \n;\n\nconst foo = [10];\n\nconsole.log(  \n  empty(foo) // []  \n);\n```\n\n`Array` 객체에 대해선 잘 작동하는 것 처럼 보입니다. 그렇다면 `Promise`로 시도해 보겠습니다.\n\n```javascript\n// Return an empty instance of any type?  \nconst empty = ({ constructor } = {}) => constructor ?  \n  new constructor() :  \n  undefined  \n;\n\nconst foo = Promise.resolve(10);\n\nconsole.log(  \n  empty(foo) // [TypeError: Promise resolver undefined is  \n             //  not a function]  \n);\n```\n\n코드에 있는  `new`  키워드가 보입니까?  그것이 대부분의 문제를 일으킵니다.  `new` 키워드를 팩토리 함수에서 사용하는 것은 안전하지 않습니다.  때로는 오류가 발생할 수 있습니다.\n\n이 작업을 올바르게 수행하려면  `new` 키워드가 필요 없는 표준 팩토리 함수를 사용하여 값을 새 인스턴스에 전달해야 합니다.  이 작업에 대한 스펙이 있습니다: 모든 팩토리 함수나 생성자에서 호출될 수 있는 `.of()`라는 정적 메소드입니다.  [`.of()`](https://github.com/fantasyland/fantasy-land) 메소드는 어떤 데이터를 전달받든 간에 이를 포함한 새 인스턴스를 리턴하는 팩토리입니다.\n\n`.of()`  를 사용하여 더 나은 버전의 generic  `empty()`  함수를 만들 수 있습니다.\n\n```javascript\n// Return an empty instance of any type?  \nconst empty = ({ constructor } = {}) => constructor.of ?  \n  constructor.of() :  \n  undefined  \n;\n\nconst foo = [23];\n\nconsole.log(  \n  empty(foo) // []  \n);\n```\n\n안타깝게도 정적 메소드  `.of()`는 이제서야 관심과 지원을 받기 시작했습니다. `Promise`는 `.of()`처럼 동작하는 정적 메소드를 가지고 있지만 이는 `.resolve()`라는 이름을 가지고 있습니다.  따라서 프로미스는 우리의 generic `empty()`함수에서 작동하지 않습니다.\n\n```javascript\n// Return an empty instance of any type?  \nconst empty = ({ constructor } = {}) => constructor.of ?  \n  constructor.of() :  \n  undefined  \n;\n\nconst foo = Promise.resolve(10);\n\nconsole.log(  \n  empty(foo) // undefined  \n);\n```\n\n마찬가지로 이 글을 쓰는 시점에서 JavaScript의 `String`,  `Number`,  `Object`, `Map`, `WeakMap` 또는 `Set`에도 아직 `.of()`가 없습니다. \n\n`.of()` 메소드가 표준 데이터 타입들을 지원하기 시작하면`.constructor`  속성은 언어의 훨씬 유용한 기능이 될 수 있습니다.  함수자^Functor^, 모나드^Monad^ 등 다양한 대수적 자료형^Algebraic^ ^datatype^을 다루는 함수형 유틸리티 라이브러리를 빌드하는 데 사용할 수 있습니다.\n\n `.constructor`  및  `.of()`를 팩토리에 쉽게 추가 해보겠습니다.\n\n```javascript\nconst createUser = ({  \n  userName = 'Anonymous',  \n  avatar = 'anon.png'  \n} = {}) => ({  \n  userName,  \n  avatar,  \n  constructor: createUser  \n});\n\ncreateUser.of = createUser;\n\n// testing .of and .constructor:  \nconst empty = ({ constructor } = {}) => constructor.of ?  \n  constructor.of() :  \n  undefined  \n;\n\nconst foo = createUser({ userName: 'Empty', avatar: 'me.png' });\n\nconsole.log(  \n  empty(foo), // { avatar: \"anon.png\", userName: \"Anonymous\" }  \n  foo.constructor === createUser.of, // true  \n  createUser.of === createUser       // true  \n);\n```\n\n`.constructor` 속성이 이터레이터에 노출되지 않기 위해선  `Object.create()`를 사용해 이를 프로토타입 체인에 연결하면 됩니다.\n\n```javascript\n const createUser = ({  \n  userName = 'Anonymous',  \n  avatar = 'anon.png'  \n} = {}) => Object.assign(  \n  Object.create({  \n    constructor: createUser  \n  }), {  \n    userName,  \n    avatar  \n  }  \n);\n```\n\n## 클래스에서 팩토리로\n\n팩토리는 다음과 같은 방법으로 코드의 유연성을 높일 수 있습니다.\n\n-   클라이언트 코드에서 구현 세부사항을 분리합니다.\n-   임의의 객체를 생성할 수 있습니다. e.g. 가비지 콜렉터를 길들이기 위한 객체 풀을 사용할 때\n-   어떤 종류의 타입 검사라도 제공하지 않는 것이 좋습니다. 이는 실행 컨텍스트에 걸쳐 코드를 망가트릴 수 있습니다. 추상 팩토리로 전환할 때도 바람직하지 않습니다.  API 클라이언트가  `instanceof`  및 기타 신뢰할 수 없는 타입 검사를 사용할 여지를 남기면 안됩니다. \n-   팩토리는 타입을 보증하지 않으므로 동적으로 구현을 변경하여 추상 팩토리로 재사용할 수 있습니다.  e.g. 미디어 플레이어의 `.play()` 메소드가 여러 미디어 유형에서 동작 할 수 있도록 구현하기\n-   팩토리는 쉽게 합성할 수 있습니다.\n\n위의 기능들을 클래스로도 구현할 수 있으나 팩토리로 하는 것이 더 쉽습니다. 버그가 숨어있을 가능성이 낮고, 단순하며, 코드가 짧습니다.\n\n이러한 이유 때문에  `class`를 팩토리로 리팩토링하는 것이 바람직합니다. 그러나 이 과정에서 복잡한 오류들이 발생할 수 있습니다.  클래스에서 팩토리로 리팩토링하는 것은 모든 객체 지향 언어에서 공통적으로 필요한 부분입니다. 이 주제에 대해 관심있으면 Martin Fowler, Kent Beck, John Brant, William Opdyke 및 Don Roberts의  [\"Refactoring: Improving the Design of Existing Code\"](https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref%3Das_li_ss_tl%3Fie%3DUTF8%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3De7d5f652bc860f02c27ec352e1b8342c)를 살펴보기 바랍니다.\n\n`new`는  함수 호출 동작을 변경하기 때문에 클래스 또는 생성자 함수를 팩토리 함수로 변경하는 것은 잠재적으로 큰 변화를 일으킬 수 있습니다. 다시 말해서,  클라이언트에게 `new`를 사용하도록 강요하는 것은 객체 생성 코드의 구현방식에 종속되는 것 입니다.  이 경우 `new` 키워드로 인해 호출 API가 먹통이 되어버릴 수 있습니다.\n\n다음과 같은 암시적인 동작들은 코드의 제어흐름을 크게 바꿔버립니다.\n\n-   팩토리 인스턴스에  `[[Prototype]]`  링크가 없으면 호출자는  `instanceof`검사를 할 수 없습니다.\n-   팩토리 인스턴스에  `.constructor`  속성이 없으면 이 인스턴스에 의존하는 코드가 손상 될 수 있습니다.\n\n위 두 문제는 수동으로 속성을 연결하여 해결할 수 있습니다.\n\n또한 `new` 사용하지 않을 경우 `this`가  팩토리를 사용하는 코드에서 동적으로 바인딩 될 수 있음을 염두에 두어야합니다.  팩토리 함수의 정적 속성에 추상 팩토리 프로토타입을 저장하려는 경우 문제가 복잡해 질 수 있습니다.\n\n또 다른 문제가 있습니다. 모든 `class` 호출에는  `new` 가 필요합니다.  `new`를 빼먹으면 ES6은 다음과같이 에러를 던집니다.\n\n```javascript\nclass Foo {};\n\n// TypeError: Class constructor Foo cannot be invoked without 'new'  \nconst Bar = Foo();\n```\n\nES6+에서는 일반적으로 화살표 함수를 사용해서 팩토리를 구현합니다. 그러나 화살표 함수는 `this`를 바인딩 하지 않기 때문에 `new`  로 화살표 함수를 호출하면 오류가 발생합니다.\n\n```javascript\nconst foo = () => ({});\n\n// TypeError: foo is not a constructor  \nconst bar = new foo();\n```\n\n따라서 클래스를 화살표 함수 팩토리로 리팩토링하려고 하면 ES6는 오류를 발생시키며 이는 정상입니다.  실패하는 것은 좋은 일입니다.\n\n그러나 화살표 함수를 표준 함수로 컴파일하면  **_실패하지 않습니다_** ^fail^ ^to^ ^fail^.  오류를 발생시키지 않으며 이는 좋지 않습니다.  앱을 개발하는 동안에는 \"작동\"하지만 언제 실패할지 모르는 코드가 됩니다.\n\n코드를 변경하지 않고 컴파일러(e.g. Babel) 설정을 변경하는것 만으로도 애플리케이션이 손상 될 수 있습니다.  주의하십시오 :\n\n> **_경고 :_**  `class`를  화살표 함수 팩토리로 리팩토링하는 것은 컴파일러(Babel)에서는 작동하는 것 처럼 보일 수 있습니다. 그러나 팩토리 코드가 기본 화살표 함수로 컴파일되면 호출 코드에서 `new`  사용할 수 없기 때문에 앱이 중단됩니다.\n\n### new가 필요한 코드는 개방 / 폐쇄 원칙을 위반합니다\n\n API는 확장성에대해 열려있고 변경-취약성에 대해 닫혀있어야 합니다. 클래스를 확장하는 일반적인 방법은 유연한 팩토리로 바꾸는 것이지만 이는 코드를 망가트릴 수도 있습니다. `new` 키워드가 필요한 코드는 확장성에 대해 닫혀있고 취약성에 대해 열려있습니다. 즉, 우리가 원하는 상황의 정 반대입니다.\n\n이는 생각보다 큰 문제입니다.  `class`  API가 공개되어 있거나 거대한 앱을 여러 팀이 함께 작업하는 경우 리팩토링이 사용자가 알지 못하는 코드를 깨뜨릴 수 있습니다. 따라서 클래스 방식을 _완전히_ 폐기하고 팩토리 함수로 대체하는 것이 더 좋습니다.\n\n이 과정을 사소하게 여길 경우 조용히 해결할 수있는 작은 기술적인 문제를 훨씬 비싼 리팩토링으로 바꿉니다!\n\n저는  `new`가 일으키는 두통이 상당히 비싸다는 것을 알았습니다. \n\n> 클래스대신에 팩토리를 내보내십시오(export).\n\n## `class`  키워드 및 확장\n\nJavaScript는 `class`  키워드를 보다 아름다운 객체 생성 패턴으로 만들 예정이었습니다. 그러나 실패했습니다.\n\n### 친숙한 구문\n\nJavaScript에서 `class`의 주된 목적은 다른 언어를 닮은 친숙한 구문을 제공하는 것이 었습니다. 그러나 과연 다른 언어의  `class`를 모방 할 필요가 있을까요?\n\n우리는 팩토리를 투명하고 친숙한 구문으로 구현할 수 있습니다.  종종 객체 리터럴로 충분하며 많은 인스턴스를 만들어야하는 경우 팩토리를 사용하면 됩니다.\n\nJava 및 C ++에서 팩토리는 클래스보다 복잡합니다. 그러나 훨씬 유연하기 때문에 어쨌든 사용할 가치가 있습니다.  JavaScript에서 팩토리는 클래스보다 덜 복잡하고 더 유연합니다.\n\nClass  vs:\n\n```javascript\nclass User {  \n  constructor ({userName, avatar}) {  \n    this.userName = userName;  \n    this.avatar = avatar;  \n  }  \n}\n\nconst currentUser = new User({  \n  userName: 'Foo',  \n  avatar: 'foo.png'  \n});\n```\n\nFactory (기능은 동일합니다)\n\n```javascript\nconst createUser = ({ userName, avatar }) => ({  \n  userName,  \n  avatar  \n});\n\nconst currentUser = createUser({  \n  userName: 'Foo',  \n  avatar: 'foo.png'  \n});\n```\n\nJavaScript와 화살표 함수에 익숙하다면 팩토리 구문이 명확하고 읽기가 쉬울 것 입니다.  어쩌면 당신은 그저  `new`  키워드를 보고싶어 하는 것일 수도 있습니다.  `new`  키워드를 피해야 하는 좋은 이유가 있습니다.  [[Familiarity bias may be holding you back]](https://medium.com/javascript-scene/familiarity-bias-is-holding-you-back-its-time-to-embrace-arrow-functions-3d37e1a9bb75).\n\n다른 논쟁거리들을 더 알아보겠습니다.\n\n## 성능 및 메모리\n\n> 프로토타입 위임을 제대로 사용하는 사례는 드뭅니다.\n\n`class` 구문은  ES5의 생성자함수 구문보다 약간 좋지만 기본 목적은 프로토타입 체인을 연결하는 것이며 프로토타입 위임을 제대로 사용하는 사례는 거의 없습니다.  이는 본질적으로 퍼포먼스에 관한 문제입니다.\n\n`class`는 두 종류의 성능 최적화를 제공합니다. 속성 접근 최적화 및 프로토타입의 공유 메모리입니다.\n\n대부분의 최신 장치는 기가 바이트 단위의 RAM을 가지며 모든 유형의 클로저 스코프 및 속성 접근은 수십만 ops/초 단위로 측정되므로 일반적인 애플리케이션의 맥락에선 성능 차이를  _거의 측정 할 수 없습니다_.\n\n물론 예외가 있습니다.  RxJS는 `class` 인스턴스를 사용합니다. 클로저 스코프에 접근하는것보다 빠르기 때문입니다. 그러나 RxJS는 16ms 렌더 루프내에 수십만개의 연산을 처리할지도 모르는 범용 유틸리티 라이브러리입니다.\n\nThreeJS는 클래스를 사용하지만 마찬가지로 16ms마다 수천 개의 객체를 조작하는 게임 엔진에 사용할 수있는 3D 렌더링 라이브러리입니다.\n\nThreeJS 및 RxJS와 같은 라이브러리는 가능한 극단적으로 최적화하는 것이 이치에 맞습니다.\n\n애플리케이션을 설계할 때는 때이른 최적화^premature^ ^optimization^를 지양하고 큰 영향을 줄 수있는 곳에서만 노력을 집중해야합니다.  예를 들자면 애플리케이션의 네트워크 호출 및 페이로드, 애니메이션, 애셋 캐싱 전략 등이 있습니다.\n\n성능 문제가 눈에 보이고, 앱 코드를 프로파일링해 실제 병목 현상을 찾아낸 경우가 아니라면 성능을 미세 조정하지 마십시오.\n\n대신 유지 관리 및 유연성을 위한 최적화를 해야합니다.\n\n## 타입 검사\n\nJavaScript의 클래스는 동적이며  `instanceof` 는 실행 컨텍스트에 종속되어 있기 때문에  `class` 기반의 타입 검사는 신뢰할 수 없습니다. 이로 인해 버그가 발생하고 애플리케이션이 너무 경직될 수 있습니다. \n\n## `extends`를 사용한 클래스 상속\n\n클래스 상속은 몇 가지 잘 알려진 문제를 반복적으로 일으킵니다.\n\n-   **단단한 결합 문제** ^The^ ^tight^ ^coupling^ ^problem^ :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.\n-   **깨지기 쉬운 기초 클래스 문제**^The^ ^fragile^ ^base^ ^class^ ^problem^  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.\n-   **경직된 계층 구조 문제**^The^ ^inflexible^ ^hierarchy^ ^problem^ :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.\n-   **중복 필요성 문제**^The^ ^duplication^ ^by^ ^necessity^ ^problem^ : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.\n-   **고릴라 / 바나나 문제**^The^ ^gorilla/banana^ ^problem^ :  \"... 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. \"~ Joe Armstrong,  [\"Coders at Work \"](http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN)\n\n`extends` 의 유일한 쓰임새는 단일 조상^single-ancestor^ 클래스 분류법을 만드는 것입니다.  영리한 해커가 이것을 읽고 말합니다. \"글쎄..  클래스를 합성하면 되잖아. \" 저는 이렇게 대답하겠습니다. \"이제는 클래스 상속 대신 객체 합성을 사용하고 있으며 JavaScript는  `extends` 없이도 이를 쉽게 할 수 있습니다. \"\n\n## 충분히 조심한다면 클래스를 사용해도 괜찮습니다.\n\n지금까지 수많은 주의사항들을 봤습니다. 이제는 클래스를 안전하게 사용하는데 도움이 되는 몇 가지 명확한 가이드라인을 알아봅시다.\n\n-   `instanceof` 피하기 - JavaScript는 동적이고 여러 실행 컨텍스트를 가지고 있기 때문에 진실된 답변을 내놓지 않습니다. 코드를 추상 팩토리로 전환하는 과정에서도 문제가 발생할 수 있습니다.\n-   `extends`  피하기 - 단일 계층을 두 번 이상 상속하지 마십시오.   \"클래스 상속보다는 객체 합성을 우선해라\", Gang of Four,  [\"디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소\"](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&qid=1494993475&sr=8-1&keywords=design+patterns&linkCode=ll1&tag=eejs-20&linkId=6c553f16325f3939e5abadd4ee04e8b4)\n-   `export class` 피하기 - 성능을 위해 내부적으로는  `class`   사용하되 인스턴스를 생성하는 팩토리를 내보내십시오. 사용자가 클래스를 상속하지 못하게하고 호출자가  `new`를 사용하지 못하도록 해야합니다.\n-   `new`  피하기 -  의미상 자연스러울 지라도 직접 사용하는 것을 피하고, 다른 사람이 이를 사용하도록 강요하지 마십시오. (팩토리를 내보내면 됩니다)\n\n다음은 클래스를 사용해도 괜찮은 경우입니다.\n\n-   **React 또는 Angular 같은 UI 프레임워크를 제작중인 경우**  이들은 모두 컴포넌트 클래스를 팩토리로 감싸고 인스턴스 생성을 책임지게 합니다. 즉, 사용자가  `new`를 사용할 필요가 없습니다.\n-   **클래스 상속을 사용하지 않을 경우**  그대신 객체 합성, 함수 합성, 고차 함수, 고차원 컴포넌트 또는 모듈을 사용해보십시오. 이 모든 것은 클래스 상속보다 더 나은 코드 재사용 패턴입니다.\n-   **성능을 최적화하는 경우**  그대신 호출자가  `new`를 사용할 필요가 없어야 하며  `extends`라는 함정에 빠지지 않도록 팩토리를 `export`해야 합니다.\n\n이 세가지 경우를 제외한 대부분의 상황에선 팩토리가 더 나은 방법이 될 것 입니다.\n\n팩토리는 JavaScript의 클래스 또는 생성자 함수보다 간단합니다.  항상 가장 간단한 솔루션부터 시작하여 필요한 경우에만 보다 복잡한 솔루션으로 나아가야 합니다.\n\n[**다음: 함수형 자료구조 >**](https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/)","source":"_posts/Why-Composition-is-Harder-with-Classes.md","raw":"---\ntitle: 클래스로 합성하기가 까다로운 이유\ncatalog: true\ndate: 2018-04-12 13:35:23\nsubtitle: Why Composition is Harder with Classes\nheader-img: \"bg.jpg\"\nreadingTime: 13\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 이전 글에서 우리는 팩토리 함수라는 주제를 살펴봤고 여기에 함수형 믹스인도 함께 사용해서 얼마나 쉽게 객체를 합성할 수 있는지 알게 됐습니다. 이제 클래스에 대해 좀 더 자세히 알아보겠습니다. `class`의 어떤 매커니즘이 합성과 연관되어 있는지 살펴 보겠습니다. 또한 클래스를 유용하게 사용한 사례와 클래스를 안전하게 사용하는 방법에 대해 살펴 보겠습니다. ES6에는 우리에게 익숙한  `class`구문이 있습니다. 팩토리 같은걸 왜 신경 써야하는지 궁금 할 수 있습니다.  가장 분명한 차이점은 생성자 함수와  `class`가  `new`  키워드를 필요로 한다는 것입니다.  그렇다면 실제로  `new`는 무슨일을 하는 걸까요?\n---\n\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/why-composition-is-harder-with-classes-c3e627dcd0aa)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/)\n\n이전 글에서 우리는 팩토리 함수라는 주제를 살펴봤고 여기에 함수형 믹스인도 함께 사용해서 얼마나 쉽게 객체를 합성할 수 있는지 알게 됐습니다. 이제 클래스에 대해 좀 더 자세히 알아보겠습니다. `class`의 어떤 매커니즘이 합성과 연관되어 있는지 살펴 보겠습니다.\n\n또한 클래스를 유용하게 사용한 사례와 클래스를 안전하게 사용하는 방법에 대해 살펴 보겠습니다.\n\nES6에는 우리에게 익숙한  `class`구문이 있습니다. 팩토리 같은걸 왜 신경 써야하는지 궁금 할 수 있습니다.  가장 분명한 차이점은 생성자 함수와  `class`가  `new`  키워드를 필요로 한다는 것입니다.  그렇다면 실제로  `new`는 무슨일을 하는 걸까요?\n\n-   새 객체를 만들고 이를 생성자 함수의  `this`  객체에 바인딩합니다.\n-   명시적으로 어떤 객체를 리턴하지 않으면  암시적으로 `this` 객체를 리턴합니다.\n-   인스턴스의 `[[Prototype]]` (내부 참조)을  `Constructor.prototype`  으로 설정합니다. 즉,  `Object.getPrototypeOf(instance) === Constructor.prototype`이 됩니다.\n-   `instance.constructor === Constructor`이 되도록 설정합니다.\n\n이 모든 것은 팩토리 함수와 다르게 클래스는 함수형 믹스인을 구성하는 좋은 솔루션이 아니라는 것을 의미합니다.  `class` 사용하여 합성을 할 수는 있지만 훨씬 복잡한 과정입니다. 이 과정에서 드는 추가 비용을 따져봤을 때 별다른 노력을 기울일 가치가 없습니다.\n\n## 프로토타입 위임^delegation^\n\n결국 클래스를 팩토리 함수로 리팩토링해야 할 수도 있습니다. 이 때 다른 코드에 있는 호출자가 `new`  키워드를 사용하고 있었다면 리팩토링이 우리가 모르는 사이에 여러가지 방법으로 클라이언트 코드를 손상시킬 수 있습니다.  우선, 클래스 및 생성자 함수와 달리 팩토리 함수는 프로토타입 링크를 자동으로 연결하지 않습니다.\n\n프로토타입 위임에는  `[[Prototype]]`  링크가 사용됩니다. 수백만개의 객체가있는 경우 메모리를 절약하는 괜찮은 방법입니다. 16ms 렌더링 루프 사이클 안에 객체의 수만 가지 속성에 액세스해야 하는 경우 프로그램 성능을 미세하게 쥐어 짜는데 사용됩니다.  \n\n메모리나 성능을 미세한 부분까지 최적화할 필요가  없다면,  `[[Prototype]]`  링크는 이익보다 해를 더 끼칠 수 있습니다.  JavaScript의 `instanceof` 연산자는 프로토타입 체인으로 동작하지만, 불행하게도  `instanceof`는 두 가지 방법으로 사용자를 속일 수 있습니다.\n\nES5의  `Constructor.prototype`  링크는 동적이며 재구성 가능했습니다. 추상 팩토리를 만들어야 하는 경우 편리한 기능이 될 수 있었습니다. 그러나 이 기능을 사용했을 때 만약  `Constructor.prototype`이 인스턴스의  `[[Prototype]]`과 같은 메모리를 참조하고 있지 않은 경우  `instanceof`는  `false`를 리턴하게 됩니다. :\n\n```javascript\nclass User {  \n  constructor ({userName, avatar}) {  \n    this.userName = userName;  \n    this.avatar = avatar;  \n  }  \n}\n\nconst currentUser = new User({  \n  userName: 'Foo',  \n  avatar: 'foo.png'  \n});\n\nUser.prototype = {};\n\nconsole.log(  \n  currentUser instanceof User, // <-- false -- Oops!\n\n// But it clearly has the correct shape:  \n  // { avatar: \"foo.png\", userName: \"Foo\" }  \n  currentUser  \n);\n```\n\nChrome에서 `Constructor.prototype`  속성을  `configurable: false`로 설정하면 이러한 문제를 해결할 수 있습니다.  그러나 Babel은 현재 이 동작을 미러링하지 않으므로 Babel로 컴파일된 코드는 ES5 생성자처럼 동작합니다. V8 엔진에서 `Constructor.prototype` 속성을 재설정 하려고 하면 자동으로 실패합니다.  어느 쪽이든, 당신은 예상 하지 못한 결과를 얻게 됩니다. 더 안좋은 점은 같은 동작을 하지 않는다는 것입니다.  왠만하면 `Constructor.prototype`을 재할당하지 마세요.\n\n보다 일반적인 문제는 JavaScript에 여러 실행 컨텍스트(동일한 코드가 서로 다른 물리적 메모리 주소에 액세스하는 메모리 샌드 박스)가 있다는 것입니다. 예를 들어 부모 프레임에 생성자가 있고 자식인  `iframe`에 동일한 생성자가있는 경우 부모 프레임의  `Constructor.prototype`은  `iframe`의 `Constructor.prototype`과 동일한 메모리 위치를 참조하지 않습니다.  JavaScript에서 객체의 값을 얻기 위해 메모리를 참조하는 것은 내부적으로 감춰진 채 작동하며 서로 다른 프레임은 물리적 메모리에서 서로 다른 위치를 가리키므로  `===` 검사는 실패합니다.\n\n`instanceof`의  또 다른 문제점은 구조적인 타입 체크가 아닌 명칭 타입 체크라는 점입니다. 즉,  `class`로 시작한 다음 나중에 추상 팩토리로 전환하면  `instanceof`를 사용하는 모든 클라이언트 코드는 새 구현을 이해하지 못합니다.  동일한 인터페이스 계약을 만족시킨다해도 말이지요.  예를 들어, 음악 플레이어 인터페이스를 구축해야 한다고 가정해 보겠습니다.  나중에 제품 팀에서 비디오에 대한 지원을 추가하라고 지시합니다.  나중에 360도 동영상에 대한 지원을 요청합니다. 그들은 모두 동일한 컨트롤을 필요로 합니다 : 재생, 정지, 되감기, 빨리 감기.\n\n그러나  `instanceof`검사를 사용하는 경우 비디오 인터페이스 클래스의 멤버는   이미 코드베이스에있는`foo instanceof AudioInterface` 검사를 만족하지 않습니다.\n\n제대로 구현되었다면 `false`를 리턴할 것입니다. 다른 언어의 공유 인터페이스는 클래스가 특정 인터페이스를 구현했다고 선언하도록 하여 이 문제를 해결합니다.  JavaScript에서는 현재 불가능합니다.\n\nJavaScript에서  `instanceof`를 처리하는 가장 좋은 방법은 프로토타입 링크 위임이 필요하지 않은 경우 이를 중단하고 모든 호출에 대해  `instanceof`  실패하게 만드는 것입니다. 그렇게하면 신뢰성이 확보될 것입니다.\n\n> 처음부터 `instanceof`가 하는 말을 듣지 않으면 그것은 결코 거짓말하지 않을 것이다.\n\n## .constructor 속성\n\n`.constructor`는 자주 사용하는 속성은 아닙니다. 그러나 매우 유용하게 활용 할 수 있으며 객체 인스턴스에 포함시키는 것이 좋습니다.  이를 타입 검사(`instanceof`가 안전하지 않은 것과 같은 이유 때문에 안전하지 않은)용도로 사용하려고 하지 않으면 대부분 무해합니다.\n\n**이론적으로**  `.constructor`는 전달받은 객체의 새 인스턴스를 리턴하는 제네릭 함수를 만드는 데 유용합니다.\n\n**실제로** JavaScript에는 새 인스턴스를 만드는 여러 가지 방법이 있습니다. 생성자를 이해한다고 해서 이를 사용해 새 객체를 인스턴스화하는 방법을 아는 것은 아닙니다.  주어진 객체로부터 빈 인스턴스를 생성하는 것 같은 사소한 용도로 사용할 때 조차도 문제가 발생할 수 있습니다. :\n\n```javascript\n// Return an empty instance of any object type?  \nconst empty = ({ constructor } = {}) => constructor ?  \n  new constructor() :  \n  undefined  \n;\n\nconst foo = [10];\n\nconsole.log(  \n  empty(foo) // []  \n);\n```\n\n`Array` 객체에 대해선 잘 작동하는 것 처럼 보입니다. 그렇다면 `Promise`로 시도해 보겠습니다.\n\n```javascript\n// Return an empty instance of any type?  \nconst empty = ({ constructor } = {}) => constructor ?  \n  new constructor() :  \n  undefined  \n;\n\nconst foo = Promise.resolve(10);\n\nconsole.log(  \n  empty(foo) // [TypeError: Promise resolver undefined is  \n             //  not a function]  \n);\n```\n\n코드에 있는  `new`  키워드가 보입니까?  그것이 대부분의 문제를 일으킵니다.  `new` 키워드를 팩토리 함수에서 사용하는 것은 안전하지 않습니다.  때로는 오류가 발생할 수 있습니다.\n\n이 작업을 올바르게 수행하려면  `new` 키워드가 필요 없는 표준 팩토리 함수를 사용하여 값을 새 인스턴스에 전달해야 합니다.  이 작업에 대한 스펙이 있습니다: 모든 팩토리 함수나 생성자에서 호출될 수 있는 `.of()`라는 정적 메소드입니다.  [`.of()`](https://github.com/fantasyland/fantasy-land) 메소드는 어떤 데이터를 전달받든 간에 이를 포함한 새 인스턴스를 리턴하는 팩토리입니다.\n\n`.of()`  를 사용하여 더 나은 버전의 generic  `empty()`  함수를 만들 수 있습니다.\n\n```javascript\n// Return an empty instance of any type?  \nconst empty = ({ constructor } = {}) => constructor.of ?  \n  constructor.of() :  \n  undefined  \n;\n\nconst foo = [23];\n\nconsole.log(  \n  empty(foo) // []  \n);\n```\n\n안타깝게도 정적 메소드  `.of()`는 이제서야 관심과 지원을 받기 시작했습니다. `Promise`는 `.of()`처럼 동작하는 정적 메소드를 가지고 있지만 이는 `.resolve()`라는 이름을 가지고 있습니다.  따라서 프로미스는 우리의 generic `empty()`함수에서 작동하지 않습니다.\n\n```javascript\n// Return an empty instance of any type?  \nconst empty = ({ constructor } = {}) => constructor.of ?  \n  constructor.of() :  \n  undefined  \n;\n\nconst foo = Promise.resolve(10);\n\nconsole.log(  \n  empty(foo) // undefined  \n);\n```\n\n마찬가지로 이 글을 쓰는 시점에서 JavaScript의 `String`,  `Number`,  `Object`, `Map`, `WeakMap` 또는 `Set`에도 아직 `.of()`가 없습니다. \n\n`.of()` 메소드가 표준 데이터 타입들을 지원하기 시작하면`.constructor`  속성은 언어의 훨씬 유용한 기능이 될 수 있습니다.  함수자^Functor^, 모나드^Monad^ 등 다양한 대수적 자료형^Algebraic^ ^datatype^을 다루는 함수형 유틸리티 라이브러리를 빌드하는 데 사용할 수 있습니다.\n\n `.constructor`  및  `.of()`를 팩토리에 쉽게 추가 해보겠습니다.\n\n```javascript\nconst createUser = ({  \n  userName = 'Anonymous',  \n  avatar = 'anon.png'  \n} = {}) => ({  \n  userName,  \n  avatar,  \n  constructor: createUser  \n});\n\ncreateUser.of = createUser;\n\n// testing .of and .constructor:  \nconst empty = ({ constructor } = {}) => constructor.of ?  \n  constructor.of() :  \n  undefined  \n;\n\nconst foo = createUser({ userName: 'Empty', avatar: 'me.png' });\n\nconsole.log(  \n  empty(foo), // { avatar: \"anon.png\", userName: \"Anonymous\" }  \n  foo.constructor === createUser.of, // true  \n  createUser.of === createUser       // true  \n);\n```\n\n`.constructor` 속성이 이터레이터에 노출되지 않기 위해선  `Object.create()`를 사용해 이를 프로토타입 체인에 연결하면 됩니다.\n\n```javascript\n const createUser = ({  \n  userName = 'Anonymous',  \n  avatar = 'anon.png'  \n} = {}) => Object.assign(  \n  Object.create({  \n    constructor: createUser  \n  }), {  \n    userName,  \n    avatar  \n  }  \n);\n```\n\n## 클래스에서 팩토리로\n\n팩토리는 다음과 같은 방법으로 코드의 유연성을 높일 수 있습니다.\n\n-   클라이언트 코드에서 구현 세부사항을 분리합니다.\n-   임의의 객체를 생성할 수 있습니다. e.g. 가비지 콜렉터를 길들이기 위한 객체 풀을 사용할 때\n-   어떤 종류의 타입 검사라도 제공하지 않는 것이 좋습니다. 이는 실행 컨텍스트에 걸쳐 코드를 망가트릴 수 있습니다. 추상 팩토리로 전환할 때도 바람직하지 않습니다.  API 클라이언트가  `instanceof`  및 기타 신뢰할 수 없는 타입 검사를 사용할 여지를 남기면 안됩니다. \n-   팩토리는 타입을 보증하지 않으므로 동적으로 구현을 변경하여 추상 팩토리로 재사용할 수 있습니다.  e.g. 미디어 플레이어의 `.play()` 메소드가 여러 미디어 유형에서 동작 할 수 있도록 구현하기\n-   팩토리는 쉽게 합성할 수 있습니다.\n\n위의 기능들을 클래스로도 구현할 수 있으나 팩토리로 하는 것이 더 쉽습니다. 버그가 숨어있을 가능성이 낮고, 단순하며, 코드가 짧습니다.\n\n이러한 이유 때문에  `class`를 팩토리로 리팩토링하는 것이 바람직합니다. 그러나 이 과정에서 복잡한 오류들이 발생할 수 있습니다.  클래스에서 팩토리로 리팩토링하는 것은 모든 객체 지향 언어에서 공통적으로 필요한 부분입니다. 이 주제에 대해 관심있으면 Martin Fowler, Kent Beck, John Brant, William Opdyke 및 Don Roberts의  [\"Refactoring: Improving the Design of Existing Code\"](https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref%3Das_li_ss_tl%3Fie%3DUTF8%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3De7d5f652bc860f02c27ec352e1b8342c)를 살펴보기 바랍니다.\n\n`new`는  함수 호출 동작을 변경하기 때문에 클래스 또는 생성자 함수를 팩토리 함수로 변경하는 것은 잠재적으로 큰 변화를 일으킬 수 있습니다. 다시 말해서,  클라이언트에게 `new`를 사용하도록 강요하는 것은 객체 생성 코드의 구현방식에 종속되는 것 입니다.  이 경우 `new` 키워드로 인해 호출 API가 먹통이 되어버릴 수 있습니다.\n\n다음과 같은 암시적인 동작들은 코드의 제어흐름을 크게 바꿔버립니다.\n\n-   팩토리 인스턴스에  `[[Prototype]]`  링크가 없으면 호출자는  `instanceof`검사를 할 수 없습니다.\n-   팩토리 인스턴스에  `.constructor`  속성이 없으면 이 인스턴스에 의존하는 코드가 손상 될 수 있습니다.\n\n위 두 문제는 수동으로 속성을 연결하여 해결할 수 있습니다.\n\n또한 `new` 사용하지 않을 경우 `this`가  팩토리를 사용하는 코드에서 동적으로 바인딩 될 수 있음을 염두에 두어야합니다.  팩토리 함수의 정적 속성에 추상 팩토리 프로토타입을 저장하려는 경우 문제가 복잡해 질 수 있습니다.\n\n또 다른 문제가 있습니다. 모든 `class` 호출에는  `new` 가 필요합니다.  `new`를 빼먹으면 ES6은 다음과같이 에러를 던집니다.\n\n```javascript\nclass Foo {};\n\n// TypeError: Class constructor Foo cannot be invoked without 'new'  \nconst Bar = Foo();\n```\n\nES6+에서는 일반적으로 화살표 함수를 사용해서 팩토리를 구현합니다. 그러나 화살표 함수는 `this`를 바인딩 하지 않기 때문에 `new`  로 화살표 함수를 호출하면 오류가 발생합니다.\n\n```javascript\nconst foo = () => ({});\n\n// TypeError: foo is not a constructor  \nconst bar = new foo();\n```\n\n따라서 클래스를 화살표 함수 팩토리로 리팩토링하려고 하면 ES6는 오류를 발생시키며 이는 정상입니다.  실패하는 것은 좋은 일입니다.\n\n그러나 화살표 함수를 표준 함수로 컴파일하면  **_실패하지 않습니다_** ^fail^ ^to^ ^fail^.  오류를 발생시키지 않으며 이는 좋지 않습니다.  앱을 개발하는 동안에는 \"작동\"하지만 언제 실패할지 모르는 코드가 됩니다.\n\n코드를 변경하지 않고 컴파일러(e.g. Babel) 설정을 변경하는것 만으로도 애플리케이션이 손상 될 수 있습니다.  주의하십시오 :\n\n> **_경고 :_**  `class`를  화살표 함수 팩토리로 리팩토링하는 것은 컴파일러(Babel)에서는 작동하는 것 처럼 보일 수 있습니다. 그러나 팩토리 코드가 기본 화살표 함수로 컴파일되면 호출 코드에서 `new`  사용할 수 없기 때문에 앱이 중단됩니다.\n\n### new가 필요한 코드는 개방 / 폐쇄 원칙을 위반합니다\n\n API는 확장성에대해 열려있고 변경-취약성에 대해 닫혀있어야 합니다. 클래스를 확장하는 일반적인 방법은 유연한 팩토리로 바꾸는 것이지만 이는 코드를 망가트릴 수도 있습니다. `new` 키워드가 필요한 코드는 확장성에 대해 닫혀있고 취약성에 대해 열려있습니다. 즉, 우리가 원하는 상황의 정 반대입니다.\n\n이는 생각보다 큰 문제입니다.  `class`  API가 공개되어 있거나 거대한 앱을 여러 팀이 함께 작업하는 경우 리팩토링이 사용자가 알지 못하는 코드를 깨뜨릴 수 있습니다. 따라서 클래스 방식을 _완전히_ 폐기하고 팩토리 함수로 대체하는 것이 더 좋습니다.\n\n이 과정을 사소하게 여길 경우 조용히 해결할 수있는 작은 기술적인 문제를 훨씬 비싼 리팩토링으로 바꿉니다!\n\n저는  `new`가 일으키는 두통이 상당히 비싸다는 것을 알았습니다. \n\n> 클래스대신에 팩토리를 내보내십시오(export).\n\n## `class`  키워드 및 확장\n\nJavaScript는 `class`  키워드를 보다 아름다운 객체 생성 패턴으로 만들 예정이었습니다. 그러나 실패했습니다.\n\n### 친숙한 구문\n\nJavaScript에서 `class`의 주된 목적은 다른 언어를 닮은 친숙한 구문을 제공하는 것이 었습니다. 그러나 과연 다른 언어의  `class`를 모방 할 필요가 있을까요?\n\n우리는 팩토리를 투명하고 친숙한 구문으로 구현할 수 있습니다.  종종 객체 리터럴로 충분하며 많은 인스턴스를 만들어야하는 경우 팩토리를 사용하면 됩니다.\n\nJava 및 C ++에서 팩토리는 클래스보다 복잡합니다. 그러나 훨씬 유연하기 때문에 어쨌든 사용할 가치가 있습니다.  JavaScript에서 팩토리는 클래스보다 덜 복잡하고 더 유연합니다.\n\nClass  vs:\n\n```javascript\nclass User {  \n  constructor ({userName, avatar}) {  \n    this.userName = userName;  \n    this.avatar = avatar;  \n  }  \n}\n\nconst currentUser = new User({  \n  userName: 'Foo',  \n  avatar: 'foo.png'  \n});\n```\n\nFactory (기능은 동일합니다)\n\n```javascript\nconst createUser = ({ userName, avatar }) => ({  \n  userName,  \n  avatar  \n});\n\nconst currentUser = createUser({  \n  userName: 'Foo',  \n  avatar: 'foo.png'  \n});\n```\n\nJavaScript와 화살표 함수에 익숙하다면 팩토리 구문이 명확하고 읽기가 쉬울 것 입니다.  어쩌면 당신은 그저  `new`  키워드를 보고싶어 하는 것일 수도 있습니다.  `new`  키워드를 피해야 하는 좋은 이유가 있습니다.  [[Familiarity bias may be holding you back]](https://medium.com/javascript-scene/familiarity-bias-is-holding-you-back-its-time-to-embrace-arrow-functions-3d37e1a9bb75).\n\n다른 논쟁거리들을 더 알아보겠습니다.\n\n## 성능 및 메모리\n\n> 프로토타입 위임을 제대로 사용하는 사례는 드뭅니다.\n\n`class` 구문은  ES5의 생성자함수 구문보다 약간 좋지만 기본 목적은 프로토타입 체인을 연결하는 것이며 프로토타입 위임을 제대로 사용하는 사례는 거의 없습니다.  이는 본질적으로 퍼포먼스에 관한 문제입니다.\n\n`class`는 두 종류의 성능 최적화를 제공합니다. 속성 접근 최적화 및 프로토타입의 공유 메모리입니다.\n\n대부분의 최신 장치는 기가 바이트 단위의 RAM을 가지며 모든 유형의 클로저 스코프 및 속성 접근은 수십만 ops/초 단위로 측정되므로 일반적인 애플리케이션의 맥락에선 성능 차이를  _거의 측정 할 수 없습니다_.\n\n물론 예외가 있습니다.  RxJS는 `class` 인스턴스를 사용합니다. 클로저 스코프에 접근하는것보다 빠르기 때문입니다. 그러나 RxJS는 16ms 렌더 루프내에 수십만개의 연산을 처리할지도 모르는 범용 유틸리티 라이브러리입니다.\n\nThreeJS는 클래스를 사용하지만 마찬가지로 16ms마다 수천 개의 객체를 조작하는 게임 엔진에 사용할 수있는 3D 렌더링 라이브러리입니다.\n\nThreeJS 및 RxJS와 같은 라이브러리는 가능한 극단적으로 최적화하는 것이 이치에 맞습니다.\n\n애플리케이션을 설계할 때는 때이른 최적화^premature^ ^optimization^를 지양하고 큰 영향을 줄 수있는 곳에서만 노력을 집중해야합니다.  예를 들자면 애플리케이션의 네트워크 호출 및 페이로드, 애니메이션, 애셋 캐싱 전략 등이 있습니다.\n\n성능 문제가 눈에 보이고, 앱 코드를 프로파일링해 실제 병목 현상을 찾아낸 경우가 아니라면 성능을 미세 조정하지 마십시오.\n\n대신 유지 관리 및 유연성을 위한 최적화를 해야합니다.\n\n## 타입 검사\n\nJavaScript의 클래스는 동적이며  `instanceof` 는 실행 컨텍스트에 종속되어 있기 때문에  `class` 기반의 타입 검사는 신뢰할 수 없습니다. 이로 인해 버그가 발생하고 애플리케이션이 너무 경직될 수 있습니다. \n\n## `extends`를 사용한 클래스 상속\n\n클래스 상속은 몇 가지 잘 알려진 문제를 반복적으로 일으킵니다.\n\n-   **단단한 결합 문제** ^The^ ^tight^ ^coupling^ ^problem^ :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.\n-   **깨지기 쉬운 기초 클래스 문제**^The^ ^fragile^ ^base^ ^class^ ^problem^  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.\n-   **경직된 계층 구조 문제**^The^ ^inflexible^ ^hierarchy^ ^problem^ :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.\n-   **중복 필요성 문제**^The^ ^duplication^ ^by^ ^necessity^ ^problem^ : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.\n-   **고릴라 / 바나나 문제**^The^ ^gorilla/banana^ ^problem^ :  \"... 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. \"~ Joe Armstrong,  [\"Coders at Work \"](http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN)\n\n`extends` 의 유일한 쓰임새는 단일 조상^single-ancestor^ 클래스 분류법을 만드는 것입니다.  영리한 해커가 이것을 읽고 말합니다. \"글쎄..  클래스를 합성하면 되잖아. \" 저는 이렇게 대답하겠습니다. \"이제는 클래스 상속 대신 객체 합성을 사용하고 있으며 JavaScript는  `extends` 없이도 이를 쉽게 할 수 있습니다. \"\n\n## 충분히 조심한다면 클래스를 사용해도 괜찮습니다.\n\n지금까지 수많은 주의사항들을 봤습니다. 이제는 클래스를 안전하게 사용하는데 도움이 되는 몇 가지 명확한 가이드라인을 알아봅시다.\n\n-   `instanceof` 피하기 - JavaScript는 동적이고 여러 실행 컨텍스트를 가지고 있기 때문에 진실된 답변을 내놓지 않습니다. 코드를 추상 팩토리로 전환하는 과정에서도 문제가 발생할 수 있습니다.\n-   `extends`  피하기 - 단일 계층을 두 번 이상 상속하지 마십시오.   \"클래스 상속보다는 객체 합성을 우선해라\", Gang of Four,  [\"디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소\"](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&qid=1494993475&sr=8-1&keywords=design+patterns&linkCode=ll1&tag=eejs-20&linkId=6c553f16325f3939e5abadd4ee04e8b4)\n-   `export class` 피하기 - 성능을 위해 내부적으로는  `class`   사용하되 인스턴스를 생성하는 팩토리를 내보내십시오. 사용자가 클래스를 상속하지 못하게하고 호출자가  `new`를 사용하지 못하도록 해야합니다.\n-   `new`  피하기 -  의미상 자연스러울 지라도 직접 사용하는 것을 피하고, 다른 사람이 이를 사용하도록 강요하지 마십시오. (팩토리를 내보내면 됩니다)\n\n다음은 클래스를 사용해도 괜찮은 경우입니다.\n\n-   **React 또는 Angular 같은 UI 프레임워크를 제작중인 경우**  이들은 모두 컴포넌트 클래스를 팩토리로 감싸고 인스턴스 생성을 책임지게 합니다. 즉, 사용자가  `new`를 사용할 필요가 없습니다.\n-   **클래스 상속을 사용하지 않을 경우**  그대신 객체 합성, 함수 합성, 고차 함수, 고차원 컴포넌트 또는 모듈을 사용해보십시오. 이 모든 것은 클래스 상속보다 더 나은 코드 재사용 패턴입니다.\n-   **성능을 최적화하는 경우**  그대신 호출자가  `new`를 사용할 필요가 없어야 하며  `extends`라는 함정에 빠지지 않도록 팩토리를 `export`해야 합니다.\n\n이 세가지 경우를 제외한 대부분의 상황에선 팩토리가 더 나은 방법이 될 것 입니다.\n\n팩토리는 JavaScript의 클래스 또는 생성자 함수보다 간단합니다.  항상 가장 간단한 솔루션부터 시작하여 필요한 경우에만 보다 복잡한 솔루션으로 나아가야 합니다.\n\n[**다음: 함수형 자료구조 >**](https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/)","slug":"Why-Composition-is-Harder-with-Classes","published":1,"updated":"2018-04-28T13:37:14.911Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83bo0001ifp64uwl31wz","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/why-composition-is-harder-with-classes-c3e627dcd0aa\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/\">다음&gt;</a></p>\n</blockquote>\n<p>이전 글에서 우리는 팩토리 함수라는 주제를 살펴봤고 여기에 함수형 믹스인도 함께 사용해서 얼마나 쉽게 객체를 합성할 수 있는지 알게 됐습니다. 이제 클래스에 대해 좀 더 자세히 알아보겠습니다. <code>class</code>의 어떤 매커니즘이 합성과 연관되어 있는지 살펴 보겠습니다.</p>\n<p>또한 클래스를 유용하게 사용한 사례와 클래스를 안전하게 사용하는 방법에 대해 살펴 보겠습니다.</p>\n<p>ES6에는 우리에게 익숙한  <code>class</code>구문이 있습니다. 팩토리 같은걸 왜 신경 써야하는지 궁금 할 수 있습니다.  가장 분명한 차이점은 생성자 함수와  <code>class</code>가  <code>new</code>  키워드를 필요로 한다는 것입니다.  그렇다면 실제로  <code>new</code>는 무슨일을 하는 걸까요?</p>\n<ul>\n<li>새 객체를 만들고 이를 생성자 함수의  <code>this</code>  객체에 바인딩합니다.</li>\n<li>명시적으로 어떤 객체를 리턴하지 않으면  암시적으로 <code>this</code> 객체를 리턴합니다.</li>\n<li>인스턴스의 <code>[[Prototype]]</code> (내부 참조)을  <code>Constructor.prototype</code>  으로 설정합니다. 즉,  <code>Object.getPrototypeOf(instance) === Constructor.prototype</code>이 됩니다.</li>\n<li><code>instance.constructor === Constructor</code>이 되도록 설정합니다.</li>\n</ul>\n<p>이 모든 것은 팩토리 함수와 다르게 클래스는 함수형 믹스인을 구성하는 좋은 솔루션이 아니라는 것을 의미합니다.  <code>class</code> 사용하여 합성을 할 수는 있지만 훨씬 복잡한 과정입니다. 이 과정에서 드는 추가 비용을 따져봤을 때 별다른 노력을 기울일 가치가 없습니다.</p>\n<h2 id=\"프로토타입-위임delegation\">프로토타입 위임<sup>delegation</sup></h2>\n<p>결국 클래스를 팩토리 함수로 리팩토링해야 할 수도 있습니다. 이 때 다른 코드에 있는 호출자가 <code>new</code>  키워드를 사용하고 있었다면 리팩토링이 우리가 모르는 사이에 여러가지 방법으로 클라이언트 코드를 손상시킬 수 있습니다.  우선, 클래스 및 생성자 함수와 달리 팩토리 함수는 프로토타입 링크를 자동으로 연결하지 않습니다.</p>\n<p>프로토타입 위임에는  <code>[[Prototype]]</code>  링크가 사용됩니다. 수백만개의 객체가있는 경우 메모리를 절약하는 괜찮은 방법입니다. 16ms 렌더링 루프 사이클 안에 객체의 수만 가지 속성에 액세스해야 하는 경우 프로그램 성능을 미세하게 쥐어 짜는데 사용됩니다.</p>\n<p>메모리나 성능을 미세한 부분까지 최적화할 필요가  없다면,  <code>[[Prototype]]</code>  링크는 이익보다 해를 더 끼칠 수 있습니다.  JavaScript의 <code>instanceof</code> 연산자는 프로토타입 체인으로 동작하지만, 불행하게도  <code>instanceof</code>는 두 가지 방법으로 사용자를 속일 수 있습니다.</p>\n<p>ES5의  <code>Constructor.prototype</code>  링크는 동적이며 재구성 가능했습니다. 추상 팩토리를 만들어야 하는 경우 편리한 기능이 될 수 있었습니다. 그러나 이 기능을 사용했을 때 만약  <code>Constructor.prototype</code>이 인스턴스의  <code>[[Prototype]]</code>과 같은 메모리를 참조하고 있지 않은 경우  <code>instanceof</code>는  <code>false</code>를 리턴하게 됩니다. :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (&#123;userName, avatar&#125;) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.userName = userName;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.avatar = avatar;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> currentUser = <span class=\"keyword\">new</span> User(&#123;  </span><br><span class=\"line\">  userName: <span class=\"string\">'Foo'</span>,  </span><br><span class=\"line\">  avatar: <span class=\"string\">'foo.png'</span>  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">User.prototype = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  currentUser <span class=\"keyword\">instanceof</span> User, <span class=\"comment\">// &lt;-- false -- Oops!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// But it clearly has the correct shape:  </span></span><br><span class=\"line\">  <span class=\"comment\">// &#123; avatar: \"foo.png\", userName: \"Foo\" &#125;  </span></span><br><span class=\"line\">  currentUser  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>Chrome에서 <code>Constructor.prototype</code>  속성을  <code>configurable: false</code>로 설정하면 이러한 문제를 해결할 수 있습니다.  그러나 Babel은 현재 이 동작을 미러링하지 않으므로 Babel로 컴파일된 코드는 ES5 생성자처럼 동작합니다. V8 엔진에서 <code>Constructor.prototype</code> 속성을 재설정 하려고 하면 자동으로 실패합니다.  어느 쪽이든, 당신은 예상 하지 못한 결과를 얻게 됩니다. 더 안좋은 점은 같은 동작을 하지 않는다는 것입니다.  왠만하면 <code>Constructor.prototype</code>을 재할당하지 마세요.</p>\n<p>보다 일반적인 문제는 JavaScript에 여러 실행 컨텍스트(동일한 코드가 서로 다른 물리적 메모리 주소에 액세스하는 메모리 샌드 박스)가 있다는 것입니다. 예를 들어 부모 프레임에 생성자가 있고 자식인  <code>iframe</code>에 동일한 생성자가있는 경우 부모 프레임의  <code>Constructor.prototype</code>은  <code>iframe</code>의 <code>Constructor.prototype</code>과 동일한 메모리 위치를 참조하지 않습니다.  JavaScript에서 객체의 값을 얻기 위해 메모리를 참조하는 것은 내부적으로 감춰진 채 작동하며 서로 다른 프레임은 물리적 메모리에서 서로 다른 위치를 가리키므로  <code>===</code> 검사는 실패합니다.</p>\n<p><code>instanceof</code>의  또 다른 문제점은 구조적인 타입 체크가 아닌 명칭 타입 체크라는 점입니다. 즉,  <code>class</code>로 시작한 다음 나중에 추상 팩토리로 전환하면  <code>instanceof</code>를 사용하는 모든 클라이언트 코드는 새 구현을 이해하지 못합니다.  동일한 인터페이스 계약을 만족시킨다해도 말이지요.  예를 들어, 음악 플레이어 인터페이스를 구축해야 한다고 가정해 보겠습니다.  나중에 제품 팀에서 비디오에 대한 지원을 추가하라고 지시합니다.  나중에 360도 동영상에 대한 지원을 요청합니다. 그들은 모두 동일한 컨트롤을 필요로 합니다 : 재생, 정지, 되감기, 빨리 감기.</p>\n<p>그러나  <code>instanceof</code>검사를 사용하는 경우 비디오 인터페이스 클래스의 멤버는   이미 코드베이스에있는<code>foo instanceof AudioInterface</code> 검사를 만족하지 않습니다.</p>\n<p>제대로 구현되었다면 <code>false</code>를 리턴할 것입니다. 다른 언어의 공유 인터페이스는 클래스가 특정 인터페이스를 구현했다고 선언하도록 하여 이 문제를 해결합니다.  JavaScript에서는 현재 불가능합니다.</p>\n<p>JavaScript에서  <code>instanceof</code>를 처리하는 가장 좋은 방법은 프로토타입 링크 위임이 필요하지 않은 경우 이를 중단하고 모든 호출에 대해  <code>instanceof</code>  실패하게 만드는 것입니다. 그렇게하면 신뢰성이 확보될 것입니다.</p>\n<blockquote>\n<p>처음부터 <code>instanceof</code>가 하는 말을 듣지 않으면 그것은 결코 거짓말하지 않을 것이다.</p>\n</blockquote>\n<h2 id=\"constructor-속성\">.constructor 속성</h2>\n<p><code>.constructor</code>는 자주 사용하는 속성은 아닙니다. 그러나 매우 유용하게 활용 할 수 있으며 객체 인스턴스에 포함시키는 것이 좋습니다.  이를 타입 검사(<code>instanceof</code>가 안전하지 않은 것과 같은 이유 때문에 안전하지 않은)용도로 사용하려고 하지 않으면 대부분 무해합니다.</p>\n<p><strong>이론적으로</strong>  <code>.constructor</code>는 전달받은 객체의 새 인스턴스를 리턴하는 제네릭 함수를 만드는 데 유용합니다.</p>\n<p><strong>실제로</strong> JavaScript에는 새 인스턴스를 만드는 여러 가지 방법이 있습니다. 생성자를 이해한다고 해서 이를 사용해 새 객체를 인스턴스화하는 방법을 아는 것은 아닙니다.  주어진 객체로부터 빈 인스턴스를 생성하는 것 같은 사소한 용도로 사용할 때 조차도 문제가 발생할 수 있습니다. :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Return an empty instance of any object type?  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> empty = <span class=\"function\">(<span class=\"params\">&#123; constructor &#125; = &#123;&#125;</span>) =&gt;</span> <span class=\"keyword\">constructor</span> ?  </span><br><span class=\"line\">  new <span class=\"keyword\">constructor</span>() :  </span><br><span class=\"line\">  undefined  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">const foo = [10];</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(  </span><br><span class=\"line\">  empty(foo) // []  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>Array</code> 객체에 대해선 잘 작동하는 것 처럼 보입니다. 그렇다면 <code>Promise</code>로 시도해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Return an empty instance of any type?  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> empty = <span class=\"function\">(<span class=\"params\">&#123; constructor &#125; = &#123;&#125;</span>) =&gt;</span> <span class=\"keyword\">constructor</span> ?  </span><br><span class=\"line\">  new <span class=\"keyword\">constructor</span>() :  </span><br><span class=\"line\">  undefined  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">const foo = Promise.resolve(10);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(  </span><br><span class=\"line\">  empty(foo) // [TypeError: Promise resolver undefined is  </span><br><span class=\"line\">             //  not a function]  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>코드에 있는  <code>new</code>  키워드가 보입니까?  그것이 대부분의 문제를 일으킵니다.  <code>new</code> 키워드를 팩토리 함수에서 사용하는 것은 안전하지 않습니다.  때로는 오류가 발생할 수 있습니다.</p>\n<p>이 작업을 올바르게 수행하려면  <code>new</code> 키워드가 필요 없는 표준 팩토리 함수를 사용하여 값을 새 인스턴스에 전달해야 합니다.  이 작업에 대한 스펙이 있습니다: 모든 팩토리 함수나 생성자에서 호출될 수 있는 <code>.of()</code>라는 정적 메소드입니다.  <a href=\"https://github.com/fantasyland/fantasy-land\" target=\"_blank\" rel=\"noopener\"><code>.of()</code></a> 메소드는 어떤 데이터를 전달받든 간에 이를 포함한 새 인스턴스를 리턴하는 팩토리입니다.</p>\n<p><code>.of()</code>  를 사용하여 더 나은 버전의 generic  <code>empty()</code>  함수를 만들 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Return an empty instance of any type?  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> empty = <span class=\"function\">(<span class=\"params\">&#123; constructor &#125; = &#123;&#125;</span>) =&gt;</span> <span class=\"keyword\">constructor</span>.of ?  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>.of() :  </span><br><span class=\"line\">  undefined  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">const foo = [23];</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(  </span><br><span class=\"line\">  empty(foo) // []  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>안타깝게도 정적 메소드  <code>.of()</code>는 이제서야 관심과 지원을 받기 시작했습니다. <code>Promise</code>는 <code>.of()</code>처럼 동작하는 정적 메소드를 가지고 있지만 이는 <code>.resolve()</code>라는 이름을 가지고 있습니다.  따라서 프로미스는 우리의 generic <code>empty()</code>함수에서 작동하지 않습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Return an empty instance of any type?  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> empty = <span class=\"function\">(<span class=\"params\">&#123; constructor &#125; = &#123;&#125;</span>) =&gt;</span> <span class=\"keyword\">constructor</span>.of ?  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>.of() :  </span><br><span class=\"line\">  undefined  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">const foo = Promise.resolve(10);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(  </span><br><span class=\"line\">  empty(foo) // undefined  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>마찬가지로 이 글을 쓰는 시점에서 JavaScript의 <code>String</code>,  <code>Number</code>,  <code>Object</code>, <code>Map</code>, <code>WeakMap</code> 또는 <code>Set</code>에도 아직 <code>.of()</code>가 없습니다.</p>\n<p><code>.of()</code> 메소드가 표준 데이터 타입들을 지원하기 시작하면<code>.constructor</code>  속성은 언어의 훨씬 유용한 기능이 될 수 있습니다.  함수자<sup>Functor</sup>, 모나드<sup>Monad</sup> 등 다양한 대수적 자료형<sup>Algebraic</sup> <sup>datatype</sup>을 다루는 함수형 유틸리티 라이브러리를 빌드하는 데 사용할 수 있습니다.</p>\n<p><code>.constructor</code>  및  <code>.of()</code>를 팩토리에 쉽게 추가 해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = (&#123;  </span><br><span class=\"line\">  userName = <span class=\"string\">'Anonymous'</span>,  </span><br><span class=\"line\">  avatar = <span class=\"string\">'anon.png'</span>  </span><br><span class=\"line\">&#125; = &#123;&#125;) =&gt; (&#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar,  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>: createUser  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">createUser.of = createUser;</span><br><span class=\"line\"></span><br><span class=\"line\">// testing .of and .<span class=\"keyword\">constructor</span>:  </span><br><span class=\"line\">const empty = (&#123; <span class=\"keyword\">constructor</span> &#125; = &#123;&#125;) =&gt; <span class=\"keyword\">constructor</span>.of ?  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>.of() :  </span><br><span class=\"line\">  undefined  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">const foo = createUser(&#123; userName: <span class=\"string\">'Empty'</span>, <span class=\"attr\">avatar</span>: <span class=\"string\">'me.png'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  empty(foo), <span class=\"comment\">// &#123; avatar: \"anon.png\", userName: \"Anonymous\" &#125;  </span></span><br><span class=\"line\">  foo.constructor === createUser.of, <span class=\"comment\">// true  </span></span><br><span class=\"line\">  createUser.of === createUser       <span class=\"comment\">// true  </span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>.constructor</code> 속성이 이터레이터에 노출되지 않기 위해선  <code>Object.create()</code>를 사용해 이를 프로토타입 체인에 연결하면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">const</span> createUser = (&#123;  </span><br><span class=\"line\">  userName = <span class=\"string\">'Anonymous'</span>,  </span><br><span class=\"line\">  avatar = <span class=\"string\">'anon.png'</span>  </span><br><span class=\"line\">&#125; = &#123;&#125;) =&gt; <span class=\"built_in\">Object</span>.assign(  </span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.create(&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: createUser  </span><br><span class=\"line\">  &#125;), &#123;  </span><br><span class=\"line\">    userName,  </span><br><span class=\"line\">    avatar  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"클래스에서-팩토리로\">클래스에서 팩토리로</h2>\n<p>팩토리는 다음과 같은 방법으로 코드의 유연성을 높일 수 있습니다.</p>\n<ul>\n<li>클라이언트 코드에서 구현 세부사항을 분리합니다.</li>\n<li>임의의 객체를 생성할 수 있습니다. e.g. 가비지 콜렉터를 길들이기 위한 객체 풀을 사용할 때</li>\n<li>어떤 종류의 타입 검사라도 제공하지 않는 것이 좋습니다. 이는 실행 컨텍스트에 걸쳐 코드를 망가트릴 수 있습니다. 추상 팩토리로 전환할 때도 바람직하지 않습니다.  API 클라이언트가  <code>instanceof</code>  및 기타 신뢰할 수 없는 타입 검사를 사용할 여지를 남기면 안됩니다.</li>\n<li>팩토리는 타입을 보증하지 않으므로 동적으로 구현을 변경하여 추상 팩토리로 재사용할 수 있습니다.  e.g. 미디어 플레이어의 <code>.play()</code> 메소드가 여러 미디어 유형에서 동작 할 수 있도록 구현하기</li>\n<li>팩토리는 쉽게 합성할 수 있습니다.</li>\n</ul>\n<p>위의 기능들을 클래스로도 구현할 수 있으나 팩토리로 하는 것이 더 쉽습니다. 버그가 숨어있을 가능성이 낮고, 단순하며, 코드가 짧습니다.</p>\n<p>이러한 이유 때문에  <code>class</code>를 팩토리로 리팩토링하는 것이 바람직합니다. 그러나 이 과정에서 복잡한 오류들이 발생할 수 있습니다.  클래스에서 팩토리로 리팩토링하는 것은 모든 객체 지향 언어에서 공통적으로 필요한 부분입니다. 이 주제에 대해 관심있으면 Martin Fowler, Kent Beck, John Brant, William Opdyke 및 Don Roberts의  <a href=\"https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref%3Das_li_ss_tl%3Fie%3DUTF8%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3De7d5f652bc860f02c27ec352e1b8342c\" target=\"_blank\" rel=\"noopener\">&quot;Refactoring: Improving the Design of Existing Code&quot;</a>를 살펴보기 바랍니다.</p>\n<p><code>new</code>는  함수 호출 동작을 변경하기 때문에 클래스 또는 생성자 함수를 팩토리 함수로 변경하는 것은 잠재적으로 큰 변화를 일으킬 수 있습니다. 다시 말해서,  클라이언트에게 <code>new</code>를 사용하도록 강요하는 것은 객체 생성 코드의 구현방식에 종속되는 것 입니다.  이 경우 <code>new</code> 키워드로 인해 호출 API가 먹통이 되어버릴 수 있습니다.</p>\n<p>다음과 같은 암시적인 동작들은 코드의 제어흐름을 크게 바꿔버립니다.</p>\n<ul>\n<li>팩토리 인스턴스에  <code>[[Prototype]]</code>  링크가 없으면 호출자는  <code>instanceof</code>검사를 할 수 없습니다.</li>\n<li>팩토리 인스턴스에  <code>.constructor</code>  속성이 없으면 이 인스턴스에 의존하는 코드가 손상 될 수 있습니다.</li>\n</ul>\n<p>위 두 문제는 수동으로 속성을 연결하여 해결할 수 있습니다.</p>\n<p>또한 <code>new</code> 사용하지 않을 경우 <code>this</code>가  팩토리를 사용하는 코드에서 동적으로 바인딩 될 수 있음을 염두에 두어야합니다.  팩토리 함수의 정적 속성에 추상 팩토리 프로토타입을 저장하려는 경우 문제가 복잡해 질 수 있습니다.</p>\n<p>또 다른 문제가 있습니다. 모든 <code>class</code> 호출에는  <code>new</code> 가 필요합니다.  <code>new</code>를 빼먹으면 ES6은 다음과같이 에러를 던집니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TypeError: Class constructor Foo cannot be invoked without 'new'  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Bar = Foo();</span><br></pre></td></tr></table></figure>\n<p>ES6+에서는 일반적으로 화살표 함수를 사용해서 팩토리를 구현합니다. 그러나 화살표 함수는 <code>this</code>를 바인딩 하지 않기 때문에 <code>new</code>  로 화살표 함수를 호출하면 오류가 발생합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TypeError: foo is not a constructor  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"keyword\">new</span> foo();</span><br></pre></td></tr></table></figure>\n<p>따라서 클래스를 화살표 함수 팩토리로 리팩토링하려고 하면 ES6는 오류를 발생시키며 이는 정상입니다.  실패하는 것은 좋은 일입니다.</p>\n<p>그러나 화살표 함수를 표준 함수로 컴파일하면  <strong><em>실패하지 않습니다</em></strong> <sup>fail</sup> <sup>to</sup> <sup>fail</sup>.  오류를 발생시키지 않으며 이는 좋지 않습니다.  앱을 개발하는 동안에는 &quot;작동&quot;하지만 언제 실패할지 모르는 코드가 됩니다.</p>\n<p>코드를 변경하지 않고 컴파일러(e.g. Babel) 설정을 변경하는것 만으로도 애플리케이션이 손상 될 수 있습니다.  주의하십시오 :</p>\n<blockquote>\n<p><strong><em>경고 :</em></strong>  <code>class</code>를  화살표 함수 팩토리로 리팩토링하는 것은 컴파일러(Babel)에서는 작동하는 것 처럼 보일 수 있습니다. 그러나 팩토리 코드가 기본 화살표 함수로 컴파일되면 호출 코드에서 <code>new</code>  사용할 수 없기 때문에 앱이 중단됩니다.</p>\n</blockquote>\n<h3 id=\"new가-필요한-코드는-개방-폐쇄-원칙을-위반합니다\">new가 필요한 코드는 개방 / 폐쇄 원칙을 위반합니다</h3>\n<p>API는 확장성에대해 열려있고 변경-취약성에 대해 닫혀있어야 합니다. 클래스를 확장하는 일반적인 방법은 유연한 팩토리로 바꾸는 것이지만 이는 코드를 망가트릴 수도 있습니다. <code>new</code> 키워드가 필요한 코드는 확장성에 대해 닫혀있고 취약성에 대해 열려있습니다. 즉, 우리가 원하는 상황의 정 반대입니다.</p>\n<p>이는 생각보다 큰 문제입니다.  <code>class</code>  API가 공개되어 있거나 거대한 앱을 여러 팀이 함께 작업하는 경우 리팩토링이 사용자가 알지 못하는 코드를 깨뜨릴 수 있습니다. 따라서 클래스 방식을 <em>완전히</em> 폐기하고 팩토리 함수로 대체하는 것이 더 좋습니다.</p>\n<p>이 과정을 사소하게 여길 경우 조용히 해결할 수있는 작은 기술적인 문제를 훨씬 비싼 리팩토링으로 바꿉니다!</p>\n<p>저는  <code>new</code>가 일으키는 두통이 상당히 비싸다는 것을 알았습니다.</p>\n<blockquote>\n<p>클래스대신에 팩토리를 내보내십시오(export).</p>\n</blockquote>\n<h2 id=\"class-키워드-및-확장\"><code>class</code>  키워드 및 확장</h2>\n<p>JavaScript는 <code>class</code>  키워드를 보다 아름다운 객체 생성 패턴으로 만들 예정이었습니다. 그러나 실패했습니다.</p>\n<h3 id=\"친숙한-구문\">친숙한 구문</h3>\n<p>JavaScript에서 <code>class</code>의 주된 목적은 다른 언어를 닮은 친숙한 구문을 제공하는 것이 었습니다. 그러나 과연 다른 언어의  <code>class</code>를 모방 할 필요가 있을까요?</p>\n<p>우리는 팩토리를 투명하고 친숙한 구문으로 구현할 수 있습니다.  종종 객체 리터럴로 충분하며 많은 인스턴스를 만들어야하는 경우 팩토리를 사용하면 됩니다.</p>\n<p>Java 및 C ++에서 팩토리는 클래스보다 복잡합니다. 그러나 훨씬 유연하기 때문에 어쨌든 사용할 가치가 있습니다.  JavaScript에서 팩토리는 클래스보다 덜 복잡하고 더 유연합니다.</p>\n<p>Class  vs:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (&#123;userName, avatar&#125;) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.userName = userName;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.avatar = avatar;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> currentUser = <span class=\"keyword\">new</span> User(&#123;  </span><br><span class=\"line\">  userName: <span class=\"string\">'Foo'</span>,  </span><br><span class=\"line\">  avatar: <span class=\"string\">'foo.png'</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Factory (기능은 동일합니다)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = <span class=\"function\">(<span class=\"params\">&#123; userName, avatar &#125;</span>) =&gt;</span> (&#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> currentUser = createUser(&#123;  </span><br><span class=\"line\">  userName: <span class=\"string\">'Foo'</span>,  </span><br><span class=\"line\">  avatar: <span class=\"string\">'foo.png'</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>JavaScript와 화살표 함수에 익숙하다면 팩토리 구문이 명확하고 읽기가 쉬울 것 입니다.  어쩌면 당신은 그저  <code>new</code>  키워드를 보고싶어 하는 것일 수도 있습니다.  <code>new</code>  키워드를 피해야 하는 좋은 이유가 있습니다.  <a href=\"https://medium.com/javascript-scene/familiarity-bias-is-holding-you-back-its-time-to-embrace-arrow-functions-3d37e1a9bb75\" target=\"_blank\" rel=\"noopener\">[Familiarity bias may be holding you back]</a>.</p>\n<p>다른 논쟁거리들을 더 알아보겠습니다.</p>\n<h2 id=\"성능-및-메모리\">성능 및 메모리</h2>\n<blockquote>\n<p>프로토타입 위임을 제대로 사용하는 사례는 드뭅니다.</p>\n</blockquote>\n<p><code>class</code> 구문은  ES5의 생성자함수 구문보다 약간 좋지만 기본 목적은 프로토타입 체인을 연결하는 것이며 프로토타입 위임을 제대로 사용하는 사례는 거의 없습니다.  이는 본질적으로 퍼포먼스에 관한 문제입니다.</p>\n<p><code>class</code>는 두 종류의 성능 최적화를 제공합니다. 속성 접근 최적화 및 프로토타입의 공유 메모리입니다.</p>\n<p>대부분의 최신 장치는 기가 바이트 단위의 RAM을 가지며 모든 유형의 클로저 스코프 및 속성 접근은 수십만 ops/초 단위로 측정되므로 일반적인 애플리케이션의 맥락에선 성능 차이를  <em>거의 측정 할 수 없습니다</em>.</p>\n<p>물론 예외가 있습니다.  RxJS는 <code>class</code> 인스턴스를 사용합니다. 클로저 스코프에 접근하는것보다 빠르기 때문입니다. 그러나 RxJS는 16ms 렌더 루프내에 수십만개의 연산을 처리할지도 모르는 범용 유틸리티 라이브러리입니다.</p>\n<p>ThreeJS는 클래스를 사용하지만 마찬가지로 16ms마다 수천 개의 객체를 조작하는 게임 엔진에 사용할 수있는 3D 렌더링 라이브러리입니다.</p>\n<p>ThreeJS 및 RxJS와 같은 라이브러리는 가능한 극단적으로 최적화하는 것이 이치에 맞습니다.</p>\n<p>애플리케이션을 설계할 때는 때이른 최적화<sup>premature</sup> <sup>optimization</sup>를 지양하고 큰 영향을 줄 수있는 곳에서만 노력을 집중해야합니다.  예를 들자면 애플리케이션의 네트워크 호출 및 페이로드, 애니메이션, 애셋 캐싱 전략 등이 있습니다.</p>\n<p>성능 문제가 눈에 보이고, 앱 코드를 프로파일링해 실제 병목 현상을 찾아낸 경우가 아니라면 성능을 미세 조정하지 마십시오.</p>\n<p>대신 유지 관리 및 유연성을 위한 최적화를 해야합니다.</p>\n<h2 id=\"타입-검사\">타입 검사</h2>\n<p>JavaScript의 클래스는 동적이며  <code>instanceof</code> 는 실행 컨텍스트에 종속되어 있기 때문에  <code>class</code> 기반의 타입 검사는 신뢰할 수 없습니다. 이로 인해 버그가 발생하고 애플리케이션이 너무 경직될 수 있습니다.</p>\n<h2 id=\"extends를-사용한-클래스-상속\"><code>extends</code>를 사용한 클래스 상속</h2>\n<p>클래스 상속은 몇 가지 잘 알려진 문제를 반복적으로 일으킵니다.</p>\n<ul>\n<li><strong>단단한 결합 문제</strong> <sup>The</sup> <sup>tight</sup> <sup>coupling</sup> <sup>problem</sup> :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.</li>\n<li><strong>깨지기 쉬운 기초 클래스 문제</strong><sup>The</sup> <sup>fragile</sup> <sup>base</sup> <sup>class</sup> <sup>problem</sup>  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.</li>\n<li><strong>경직된 계층 구조 문제</strong><sup>The</sup> <sup>inflexible</sup> <sup>hierarchy</sup> <sup>problem</sup> :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.</li>\n<li><strong>중복 필요성 문제</strong><sup>The</sup> <sup>duplication</sup> <sup>by</sup> <sup>necessity</sup> <sup>problem</sup> : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.</li>\n<li><strong>고릴라 / 바나나 문제</strong><sup>The</sup> <sup>gorilla/banana</sup> <sup>problem</sup> :  &quot;… 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. &quot;~ Joe Armstrong,  <a href=\"http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN\" target=\"_blank\" rel=\"noopener\">&quot;Coders at Work &quot;</a></li>\n</ul>\n<p><code>extends</code> 의 유일한 쓰임새는 단일 조상<sup>single-ancestor</sup> 클래스 분류법을 만드는 것입니다.  영리한 해커가 이것을 읽고 말합니다. &quot;글쎄…  클래스를 합성하면 되잖아. &quot; 저는 이렇게 대답하겠습니다. &quot;이제는 클래스 상속 대신 객체 합성을 사용하고 있으며 JavaScript는  <code>extends</code> 없이도 이를 쉽게 할 수 있습니다. &quot;</p>\n<h2 id=\"충분히-조심한다면-클래스를-사용해도-괜찮습니다\">충분히 조심한다면 클래스를 사용해도 괜찮습니다.</h2>\n<p>지금까지 수많은 주의사항들을 봤습니다. 이제는 클래스를 안전하게 사용하는데 도움이 되는 몇 가지 명확한 가이드라인을 알아봅시다.</p>\n<ul>\n<li><code>instanceof</code> 피하기 - JavaScript는 동적이고 여러 실행 컨텍스트를 가지고 있기 때문에 진실된 답변을 내놓지 않습니다. 코드를 추상 팩토리로 전환하는 과정에서도 문제가 발생할 수 있습니다.</li>\n<li><code>extends</code>  피하기 - 단일 계층을 두 번 이상 상속하지 마십시오.   “클래스 상속보다는 객체 합성을 우선해라”, Gang of Four,  <a href=\"https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;qid=1494993475&amp;sr=8-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6c553f16325f3939e5abadd4ee04e8b4\" target=\"_blank\" rel=\"noopener\">“디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소”</a></li>\n<li><code>export class</code> 피하기 - 성능을 위해 내부적으로는  <code>class</code>   사용하되 인스턴스를 생성하는 팩토리를 내보내십시오. 사용자가 클래스를 상속하지 못하게하고 호출자가  <code>new</code>를 사용하지 못하도록 해야합니다.</li>\n<li><code>new</code>  피하기 -  의미상 자연스러울 지라도 직접 사용하는 것을 피하고, 다른 사람이 이를 사용하도록 강요하지 마십시오. (팩토리를 내보내면 됩니다)</li>\n</ul>\n<p>다음은 클래스를 사용해도 괜찮은 경우입니다.</p>\n<ul>\n<li><strong>React 또는 Angular 같은 UI 프레임워크를 제작중인 경우</strong>  이들은 모두 컴포넌트 클래스를 팩토리로 감싸고 인스턴스 생성을 책임지게 합니다. 즉, 사용자가  <code>new</code>를 사용할 필요가 없습니다.</li>\n<li><strong>클래스 상속을 사용하지 않을 경우</strong>  그대신 객체 합성, 함수 합성, 고차 함수, 고차원 컴포넌트 또는 모듈을 사용해보십시오. 이 모든 것은 클래스 상속보다 더 나은 코드 재사용 패턴입니다.</li>\n<li><strong>성능을 최적화하는 경우</strong>  그대신 호출자가  <code>new</code>를 사용할 필요가 없어야 하며  <code>extends</code>라는 함정에 빠지지 않도록 팩토리를 <code>export</code>해야 합니다.</li>\n</ul>\n<p>이 세가지 경우를 제외한 대부분의 상황에선 팩토리가 더 나은 방법이 될 것 입니다.</p>\n<p>팩토리는 JavaScript의 클래스 또는 생성자 함수보다 간단합니다.  항상 가장 간단한 솔루션부터 시작하여 필요한 경우에만 보다 복잡한 솔루션으로 나아가야 합니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/\"><strong>다음: 함수형 자료구조 &gt;</strong></a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/why-composition-is-harder-with-classes-c3e627dcd0aa\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/\">다음&gt;</a></p>\n</blockquote>\n<p>이전 글에서 우리는 팩토리 함수라는 주제를 살펴봤고 여기에 함수형 믹스인도 함께 사용해서 얼마나 쉽게 객체를 합성할 수 있는지 알게 됐습니다. 이제 클래스에 대해 좀 더 자세히 알아보겠습니다. <code>class</code>의 어떤 매커니즘이 합성과 연관되어 있는지 살펴 보겠습니다.</p>\n<p>또한 클래스를 유용하게 사용한 사례와 클래스를 안전하게 사용하는 방법에 대해 살펴 보겠습니다.</p>\n<p>ES6에는 우리에게 익숙한  <code>class</code>구문이 있습니다. 팩토리 같은걸 왜 신경 써야하는지 궁금 할 수 있습니다.  가장 분명한 차이점은 생성자 함수와  <code>class</code>가  <code>new</code>  키워드를 필요로 한다는 것입니다.  그렇다면 실제로  <code>new</code>는 무슨일을 하는 걸까요?</p>\n<ul>\n<li>새 객체를 만들고 이를 생성자 함수의  <code>this</code>  객체에 바인딩합니다.</li>\n<li>명시적으로 어떤 객체를 리턴하지 않으면  암시적으로 <code>this</code> 객체를 리턴합니다.</li>\n<li>인스턴스의 <code>[[Prototype]]</code> (내부 참조)을  <code>Constructor.prototype</code>  으로 설정합니다. 즉,  <code>Object.getPrototypeOf(instance) === Constructor.prototype</code>이 됩니다.</li>\n<li><code>instance.constructor === Constructor</code>이 되도록 설정합니다.</li>\n</ul>\n<p>이 모든 것은 팩토리 함수와 다르게 클래스는 함수형 믹스인을 구성하는 좋은 솔루션이 아니라는 것을 의미합니다.  <code>class</code> 사용하여 합성을 할 수는 있지만 훨씬 복잡한 과정입니다. 이 과정에서 드는 추가 비용을 따져봤을 때 별다른 노력을 기울일 가치가 없습니다.</p>\n<h2>프로토타입 위임<sup>delegation</sup></h2>\n<p>결국 클래스를 팩토리 함수로 리팩토링해야 할 수도 있습니다. 이 때 다른 코드에 있는 호출자가 <code>new</code>  키워드를 사용하고 있었다면 리팩토링이 우리가 모르는 사이에 여러가지 방법으로 클라이언트 코드를 손상시킬 수 있습니다.  우선, 클래스 및 생성자 함수와 달리 팩토리 함수는 프로토타입 링크를 자동으로 연결하지 않습니다.</p>\n<p>프로토타입 위임에는  <code>[[Prototype]]</code>  링크가 사용됩니다. 수백만개의 객체가있는 경우 메모리를 절약하는 괜찮은 방법입니다. 16ms 렌더링 루프 사이클 안에 객체의 수만 가지 속성에 액세스해야 하는 경우 프로그램 성능을 미세하게 쥐어 짜는데 사용됩니다.</p>\n<p>메모리나 성능을 미세한 부분까지 최적화할 필요가  없다면,  <code>[[Prototype]]</code>  링크는 이익보다 해를 더 끼칠 수 있습니다.  JavaScript의 <code>instanceof</code> 연산자는 프로토타입 체인으로 동작하지만, 불행하게도  <code>instanceof</code>는 두 가지 방법으로 사용자를 속일 수 있습니다.</p>\n<p>ES5의  <code>Constructor.prototype</code>  링크는 동적이며 재구성 가능했습니다. 추상 팩토리를 만들어야 하는 경우 편리한 기능이 될 수 있었습니다. 그러나 이 기능을 사용했을 때 만약  <code>Constructor.prototype</code>이 인스턴스의  <code>[[Prototype]]</code>과 같은 메모리를 참조하고 있지 않은 경우  <code>instanceof</code>는  <code>false</code>를 리턴하게 됩니다. :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (&#123;userName, avatar&#125;) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.userName = userName;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.avatar = avatar;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> currentUser = <span class=\"keyword\">new</span> User(&#123;  </span><br><span class=\"line\">  userName: <span class=\"string\">'Foo'</span>,  </span><br><span class=\"line\">  avatar: <span class=\"string\">'foo.png'</span>  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">User.prototype = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  currentUser <span class=\"keyword\">instanceof</span> User, <span class=\"comment\">// &lt;-- false -- Oops!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// But it clearly has the correct shape:  </span></span><br><span class=\"line\">  <span class=\"comment\">// &#123; avatar: \"foo.png\", userName: \"Foo\" &#125;  </span></span><br><span class=\"line\">  currentUser  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>Chrome에서 <code>Constructor.prototype</code>  속성을  <code>configurable: false</code>로 설정하면 이러한 문제를 해결할 수 있습니다.  그러나 Babel은 현재 이 동작을 미러링하지 않으므로 Babel로 컴파일된 코드는 ES5 생성자처럼 동작합니다. V8 엔진에서 <code>Constructor.prototype</code> 속성을 재설정 하려고 하면 자동으로 실패합니다.  어느 쪽이든, 당신은 예상 하지 못한 결과를 얻게 됩니다. 더 안좋은 점은 같은 동작을 하지 않는다는 것입니다.  왠만하면 <code>Constructor.prototype</code>을 재할당하지 마세요.</p>\n<p>보다 일반적인 문제는 JavaScript에 여러 실행 컨텍스트(동일한 코드가 서로 다른 물리적 메모리 주소에 액세스하는 메모리 샌드 박스)가 있다는 것입니다. 예를 들어 부모 프레임에 생성자가 있고 자식인  <code>iframe</code>에 동일한 생성자가있는 경우 부모 프레임의  <code>Constructor.prototype</code>은  <code>iframe</code>의 <code>Constructor.prototype</code>과 동일한 메모리 위치를 참조하지 않습니다.  JavaScript에서 객체의 값을 얻기 위해 메모리를 참조하는 것은 내부적으로 감춰진 채 작동하며 서로 다른 프레임은 물리적 메모리에서 서로 다른 위치를 가리키므로  <code>===</code> 검사는 실패합니다.</p>\n<p><code>instanceof</code>의  또 다른 문제점은 구조적인 타입 체크가 아닌 명칭 타입 체크라는 점입니다. 즉,  <code>class</code>로 시작한 다음 나중에 추상 팩토리로 전환하면  <code>instanceof</code>를 사용하는 모든 클라이언트 코드는 새 구현을 이해하지 못합니다.  동일한 인터페이스 계약을 만족시킨다해도 말이지요.  예를 들어, 음악 플레이어 인터페이스를 구축해야 한다고 가정해 보겠습니다.  나중에 제품 팀에서 비디오에 대한 지원을 추가하라고 지시합니다.  나중에 360도 동영상에 대한 지원을 요청합니다. 그들은 모두 동일한 컨트롤을 필요로 합니다 : 재생, 정지, 되감기, 빨리 감기.</p>\n<p>그러나  <code>instanceof</code>검사를 사용하는 경우 비디오 인터페이스 클래스의 멤버는   이미 코드베이스에있는<code>foo instanceof AudioInterface</code> 검사를 만족하지 않습니다.</p>\n<p>제대로 구현되었다면 <code>false</code>를 리턴할 것입니다. 다른 언어의 공유 인터페이스는 클래스가 특정 인터페이스를 구현했다고 선언하도록 하여 이 문제를 해결합니다.  JavaScript에서는 현재 불가능합니다.</p>\n<p>JavaScript에서  <code>instanceof</code>를 처리하는 가장 좋은 방법은 프로토타입 링크 위임이 필요하지 않은 경우 이를 중단하고 모든 호출에 대해  <code>instanceof</code>  실패하게 만드는 것입니다. 그렇게하면 신뢰성이 확보될 것입니다.</p>\n<blockquote>\n<p>처음부터 <code>instanceof</code>가 하는 말을 듣지 않으면 그것은 결코 거짓말하지 않을 것이다.</p>\n</blockquote>\n<h2>.constructor 속성</h2>\n<p><code>.constructor</code>는 자주 사용하는 속성은 아닙니다. 그러나 매우 유용하게 활용 할 수 있으며 객체 인스턴스에 포함시키는 것이 좋습니다.  이를 타입 검사(<code>instanceof</code>가 안전하지 않은 것과 같은 이유 때문에 안전하지 않은)용도로 사용하려고 하지 않으면 대부분 무해합니다.</p>\n<p><strong>이론적으로</strong>  <code>.constructor</code>는 전달받은 객체의 새 인스턴스를 리턴하는 제네릭 함수를 만드는 데 유용합니다.</p>\n<p><strong>실제로</strong> JavaScript에는 새 인스턴스를 만드는 여러 가지 방법이 있습니다. 생성자를 이해한다고 해서 이를 사용해 새 객체를 인스턴스화하는 방법을 아는 것은 아닙니다.  주어진 객체로부터 빈 인스턴스를 생성하는 것 같은 사소한 용도로 사용할 때 조차도 문제가 발생할 수 있습니다. :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Return an empty instance of any object type?  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> empty = <span class=\"function\">(<span class=\"params\">&#123; constructor &#125; = &#123;&#125;</span>) =&gt;</span> <span class=\"keyword\">constructor</span> ?  </span><br><span class=\"line\">  new <span class=\"keyword\">constructor</span>() :  </span><br><span class=\"line\">  undefined  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">const foo = [10];</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(  </span><br><span class=\"line\">  empty(foo) // []  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>Array</code> 객체에 대해선 잘 작동하는 것 처럼 보입니다. 그렇다면 <code>Promise</code>로 시도해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Return an empty instance of any type?  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> empty = <span class=\"function\">(<span class=\"params\">&#123; constructor &#125; = &#123;&#125;</span>) =&gt;</span> <span class=\"keyword\">constructor</span> ?  </span><br><span class=\"line\">  new <span class=\"keyword\">constructor</span>() :  </span><br><span class=\"line\">  undefined  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">const foo = Promise.resolve(10);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(  </span><br><span class=\"line\">  empty(foo) // [TypeError: Promise resolver undefined is  </span><br><span class=\"line\">             //  not a function]  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>코드에 있는  <code>new</code>  키워드가 보입니까?  그것이 대부분의 문제를 일으킵니다.  <code>new</code> 키워드를 팩토리 함수에서 사용하는 것은 안전하지 않습니다.  때로는 오류가 발생할 수 있습니다.</p>\n<p>이 작업을 올바르게 수행하려면  <code>new</code> 키워드가 필요 없는 표준 팩토리 함수를 사용하여 값을 새 인스턴스에 전달해야 합니다.  이 작업에 대한 스펙이 있습니다: 모든 팩토리 함수나 생성자에서 호출될 수 있는 <code>.of()</code>라는 정적 메소드입니다.  <a href=\"https://github.com/fantasyland/fantasy-land\" target=\"_blank\" rel=\"noopener\"><code>.of()</code></a> 메소드는 어떤 데이터를 전달받든 간에 이를 포함한 새 인스턴스를 리턴하는 팩토리입니다.</p>\n<p><code>.of()</code>  를 사용하여 더 나은 버전의 generic  <code>empty()</code>  함수를 만들 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Return an empty instance of any type?  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> empty = <span class=\"function\">(<span class=\"params\">&#123; constructor &#125; = &#123;&#125;</span>) =&gt;</span> <span class=\"keyword\">constructor</span>.of ?  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>.of() :  </span><br><span class=\"line\">  undefined  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">const foo = [23];</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(  </span><br><span class=\"line\">  empty(foo) // []  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>안타깝게도 정적 메소드  <code>.of()</code>는 이제서야 관심과 지원을 받기 시작했습니다. <code>Promise</code>는 <code>.of()</code>처럼 동작하는 정적 메소드를 가지고 있지만 이는 <code>.resolve()</code>라는 이름을 가지고 있습니다.  따라서 프로미스는 우리의 generic <code>empty()</code>함수에서 작동하지 않습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Return an empty instance of any type?  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> empty = <span class=\"function\">(<span class=\"params\">&#123; constructor &#125; = &#123;&#125;</span>) =&gt;</span> <span class=\"keyword\">constructor</span>.of ?  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>.of() :  </span><br><span class=\"line\">  undefined  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">const foo = Promise.resolve(10);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(  </span><br><span class=\"line\">  empty(foo) // undefined  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>마찬가지로 이 글을 쓰는 시점에서 JavaScript의 <code>String</code>,  <code>Number</code>,  <code>Object</code>, <code>Map</code>, <code>WeakMap</code> 또는 <code>Set</code>에도 아직 <code>.of()</code>가 없습니다.</p>\n<p><code>.of()</code> 메소드가 표준 데이터 타입들을 지원하기 시작하면<code>.constructor</code>  속성은 언어의 훨씬 유용한 기능이 될 수 있습니다.  함수자<sup>Functor</sup>, 모나드<sup>Monad</sup> 등 다양한 대수적 자료형<sup>Algebraic</sup> <sup>datatype</sup>을 다루는 함수형 유틸리티 라이브러리를 빌드하는 데 사용할 수 있습니다.</p>\n<p><code>.constructor</code>  및  <code>.of()</code>를 팩토리에 쉽게 추가 해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = (&#123;  </span><br><span class=\"line\">  userName = <span class=\"string\">'Anonymous'</span>,  </span><br><span class=\"line\">  avatar = <span class=\"string\">'anon.png'</span>  </span><br><span class=\"line\">&#125; = &#123;&#125;) =&gt; (&#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar,  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>: createUser  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">createUser.of = createUser;</span><br><span class=\"line\"></span><br><span class=\"line\">// testing .of and .<span class=\"keyword\">constructor</span>:  </span><br><span class=\"line\">const empty = (&#123; <span class=\"keyword\">constructor</span> &#125; = &#123;&#125;) =&gt; <span class=\"keyword\">constructor</span>.of ?  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>.of() :  </span><br><span class=\"line\">  undefined  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">const foo = createUser(&#123; userName: <span class=\"string\">'Empty'</span>, <span class=\"attr\">avatar</span>: <span class=\"string\">'me.png'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  empty(foo), <span class=\"comment\">// &#123; avatar: \"anon.png\", userName: \"Anonymous\" &#125;  </span></span><br><span class=\"line\">  foo.constructor === createUser.of, <span class=\"comment\">// true  </span></span><br><span class=\"line\">  createUser.of === createUser       <span class=\"comment\">// true  </span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>.constructor</code> 속성이 이터레이터에 노출되지 않기 위해선  <code>Object.create()</code>를 사용해 이를 프로토타입 체인에 연결하면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">const</span> createUser = (&#123;  </span><br><span class=\"line\">  userName = <span class=\"string\">'Anonymous'</span>,  </span><br><span class=\"line\">  avatar = <span class=\"string\">'anon.png'</span>  </span><br><span class=\"line\">&#125; = &#123;&#125;) =&gt; <span class=\"built_in\">Object</span>.assign(  </span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.create(&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: createUser  </span><br><span class=\"line\">  &#125;), &#123;  </span><br><span class=\"line\">    userName,  </span><br><span class=\"line\">    avatar  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2>클래스에서 팩토리로</h2>\n<p>팩토리는 다음과 같은 방법으로 코드의 유연성을 높일 수 있습니다.</p>\n<ul>\n<li>클라이언트 코드에서 구현 세부사항을 분리합니다.</li>\n<li>임의의 객체를 생성할 수 있습니다. e.g. 가비지 콜렉터를 길들이기 위한 객체 풀을 사용할 때</li>\n<li>어떤 종류의 타입 검사라도 제공하지 않는 것이 좋습니다. 이는 실행 컨텍스트에 걸쳐 코드를 망가트릴 수 있습니다. 추상 팩토리로 전환할 때도 바람직하지 않습니다.  API 클라이언트가  <code>instanceof</code>  및 기타 신뢰할 수 없는 타입 검사를 사용할 여지를 남기면 안됩니다.</li>\n<li>팩토리는 타입을 보증하지 않으므로 동적으로 구현을 변경하여 추상 팩토리로 재사용할 수 있습니다.  e.g. 미디어 플레이어의 <code>.play()</code> 메소드가 여러 미디어 유형에서 동작 할 수 있도록 구현하기</li>\n<li>팩토리는 쉽게 합성할 수 있습니다.</li>\n</ul>\n<p>위의 기능들을 클래스로도 구현할 수 있으나 팩토리로 하는 것이 더 쉽습니다. 버그가 숨어있을 가능성이 낮고, 단순하며, 코드가 짧습니다.</p>\n<p>이러한 이유 때문에  <code>class</code>를 팩토리로 리팩토링하는 것이 바람직합니다. 그러나 이 과정에서 복잡한 오류들이 발생할 수 있습니다.  클래스에서 팩토리로 리팩토링하는 것은 모든 객체 지향 언어에서 공통적으로 필요한 부분입니다. 이 주제에 대해 관심있으면 Martin Fowler, Kent Beck, John Brant, William Opdyke 및 Don Roberts의  <a href=\"https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref%3Das_li_ss_tl%3Fie%3DUTF8%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3De7d5f652bc860f02c27ec352e1b8342c\" target=\"_blank\" rel=\"noopener\">&quot;Refactoring: Improving the Design of Existing Code&quot;</a>를 살펴보기 바랍니다.</p>\n<p><code>new</code>는  함수 호출 동작을 변경하기 때문에 클래스 또는 생성자 함수를 팩토리 함수로 변경하는 것은 잠재적으로 큰 변화를 일으킬 수 있습니다. 다시 말해서,  클라이언트에게 <code>new</code>를 사용하도록 강요하는 것은 객체 생성 코드의 구현방식에 종속되는 것 입니다.  이 경우 <code>new</code> 키워드로 인해 호출 API가 먹통이 되어버릴 수 있습니다.</p>\n<p>다음과 같은 암시적인 동작들은 코드의 제어흐름을 크게 바꿔버립니다.</p>\n<ul>\n<li>팩토리 인스턴스에  <code>[[Prototype]]</code>  링크가 없으면 호출자는  <code>instanceof</code>검사를 할 수 없습니다.</li>\n<li>팩토리 인스턴스에  <code>.constructor</code>  속성이 없으면 이 인스턴스에 의존하는 코드가 손상 될 수 있습니다.</li>\n</ul>\n<p>위 두 문제는 수동으로 속성을 연결하여 해결할 수 있습니다.</p>\n<p>또한 <code>new</code> 사용하지 않을 경우 <code>this</code>가  팩토리를 사용하는 코드에서 동적으로 바인딩 될 수 있음을 염두에 두어야합니다.  팩토리 함수의 정적 속성에 추상 팩토리 프로토타입을 저장하려는 경우 문제가 복잡해 질 수 있습니다.</p>\n<p>또 다른 문제가 있습니다. 모든 <code>class</code> 호출에는  <code>new</code> 가 필요합니다.  <code>new</code>를 빼먹으면 ES6은 다음과같이 에러를 던집니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TypeError: Class constructor Foo cannot be invoked without 'new'  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Bar = Foo();</span><br></pre></td></tr></table></figure>\n<p>ES6+에서는 일반적으로 화살표 함수를 사용해서 팩토리를 구현합니다. 그러나 화살표 함수는 <code>this</code>를 바인딩 하지 않기 때문에 <code>new</code>  로 화살표 함수를 호출하면 오류가 발생합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TypeError: foo is not a constructor  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"keyword\">new</span> foo();</span><br></pre></td></tr></table></figure>\n<p>따라서 클래스를 화살표 함수 팩토리로 리팩토링하려고 하면 ES6는 오류를 발생시키며 이는 정상입니다.  실패하는 것은 좋은 일입니다.</p>\n<p>그러나 화살표 함수를 표준 함수로 컴파일하면  <strong><em>실패하지 않습니다</em></strong> <sup>fail</sup> <sup>to</sup> <sup>fail</sup>.  오류를 발생시키지 않으며 이는 좋지 않습니다.  앱을 개발하는 동안에는 &quot;작동&quot;하지만 언제 실패할지 모르는 코드가 됩니다.</p>\n<p>코드를 변경하지 않고 컴파일러(e.g. Babel) 설정을 변경하는것 만으로도 애플리케이션이 손상 될 수 있습니다.  주의하십시오 :</p>\n<blockquote>\n<p><strong><em>경고 :</em></strong>  <code>class</code>를  화살표 함수 팩토리로 리팩토링하는 것은 컴파일러(Babel)에서는 작동하는 것 처럼 보일 수 있습니다. 그러나 팩토리 코드가 기본 화살표 함수로 컴파일되면 호출 코드에서 <code>new</code>  사용할 수 없기 때문에 앱이 중단됩니다.</p>\n</blockquote>\n<h3>new가 필요한 코드는 개방 / 폐쇄 원칙을 위반합니다</h3>\n<p>API는 확장성에대해 열려있고 변경-취약성에 대해 닫혀있어야 합니다. 클래스를 확장하는 일반적인 방법은 유연한 팩토리로 바꾸는 것이지만 이는 코드를 망가트릴 수도 있습니다. <code>new</code> 키워드가 필요한 코드는 확장성에 대해 닫혀있고 취약성에 대해 열려있습니다. 즉, 우리가 원하는 상황의 정 반대입니다.</p>\n<p>이는 생각보다 큰 문제입니다.  <code>class</code>  API가 공개되어 있거나 거대한 앱을 여러 팀이 함께 작업하는 경우 리팩토링이 사용자가 알지 못하는 코드를 깨뜨릴 수 있습니다. 따라서 클래스 방식을 <em>완전히</em> 폐기하고 팩토리 함수로 대체하는 것이 더 좋습니다.</p>\n<p>이 과정을 사소하게 여길 경우 조용히 해결할 수있는 작은 기술적인 문제를 훨씬 비싼 리팩토링으로 바꿉니다!</p>\n<p>저는  <code>new</code>가 일으키는 두통이 상당히 비싸다는 것을 알았습니다.</p>\n<blockquote>\n<p>클래스대신에 팩토리를 내보내십시오(export).</p>\n</blockquote>\n<h2><code>class</code>  키워드 및 확장</h2>\n<p>JavaScript는 <code>class</code>  키워드를 보다 아름다운 객체 생성 패턴으로 만들 예정이었습니다. 그러나 실패했습니다.</p>\n<h3>친숙한 구문</h3>\n<p>JavaScript에서 <code>class</code>의 주된 목적은 다른 언어를 닮은 친숙한 구문을 제공하는 것이 었습니다. 그러나 과연 다른 언어의  <code>class</code>를 모방 할 필요가 있을까요?</p>\n<p>우리는 팩토리를 투명하고 친숙한 구문으로 구현할 수 있습니다.  종종 객체 리터럴로 충분하며 많은 인스턴스를 만들어야하는 경우 팩토리를 사용하면 됩니다.</p>\n<p>Java 및 C ++에서 팩토리는 클래스보다 복잡합니다. 그러나 훨씬 유연하기 때문에 어쨌든 사용할 가치가 있습니다.  JavaScript에서 팩토리는 클래스보다 덜 복잡하고 더 유연합니다.</p>\n<p>Class  vs:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (&#123;userName, avatar&#125;) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.userName = userName;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.avatar = avatar;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> currentUser = <span class=\"keyword\">new</span> User(&#123;  </span><br><span class=\"line\">  userName: <span class=\"string\">'Foo'</span>,  </span><br><span class=\"line\">  avatar: <span class=\"string\">'foo.png'</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Factory (기능은 동일합니다)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = <span class=\"function\">(<span class=\"params\">&#123; userName, avatar &#125;</span>) =&gt;</span> (&#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> currentUser = createUser(&#123;  </span><br><span class=\"line\">  userName: <span class=\"string\">'Foo'</span>,  </span><br><span class=\"line\">  avatar: <span class=\"string\">'foo.png'</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>JavaScript와 화살표 함수에 익숙하다면 팩토리 구문이 명확하고 읽기가 쉬울 것 입니다.  어쩌면 당신은 그저  <code>new</code>  키워드를 보고싶어 하는 것일 수도 있습니다.  <code>new</code>  키워드를 피해야 하는 좋은 이유가 있습니다.  <a href=\"https://medium.com/javascript-scene/familiarity-bias-is-holding-you-back-its-time-to-embrace-arrow-functions-3d37e1a9bb75\" target=\"_blank\" rel=\"noopener\">[Familiarity bias may be holding you back]</a>.</p>\n<p>다른 논쟁거리들을 더 알아보겠습니다.</p>\n<h2>성능 및 메모리</h2>\n<blockquote>\n<p>프로토타입 위임을 제대로 사용하는 사례는 드뭅니다.</p>\n</blockquote>\n<p><code>class</code> 구문은  ES5의 생성자함수 구문보다 약간 좋지만 기본 목적은 프로토타입 체인을 연결하는 것이며 프로토타입 위임을 제대로 사용하는 사례는 거의 없습니다.  이는 본질적으로 퍼포먼스에 관한 문제입니다.</p>\n<p><code>class</code>는 두 종류의 성능 최적화를 제공합니다. 속성 접근 최적화 및 프로토타입의 공유 메모리입니다.</p>\n<p>대부분의 최신 장치는 기가 바이트 단위의 RAM을 가지며 모든 유형의 클로저 스코프 및 속성 접근은 수십만 ops/초 단위로 측정되므로 일반적인 애플리케이션의 맥락에선 성능 차이를  <em>거의 측정 할 수 없습니다</em>.</p>\n<p>물론 예외가 있습니다.  RxJS는 <code>class</code> 인스턴스를 사용합니다. 클로저 스코프에 접근하는것보다 빠르기 때문입니다. 그러나 RxJS는 16ms 렌더 루프내에 수십만개의 연산을 처리할지도 모르는 범용 유틸리티 라이브러리입니다.</p>\n<p>ThreeJS는 클래스를 사용하지만 마찬가지로 16ms마다 수천 개의 객체를 조작하는 게임 엔진에 사용할 수있는 3D 렌더링 라이브러리입니다.</p>\n<p>ThreeJS 및 RxJS와 같은 라이브러리는 가능한 극단적으로 최적화하는 것이 이치에 맞습니다.</p>\n<p>애플리케이션을 설계할 때는 때이른 최적화<sup>premature</sup> <sup>optimization</sup>를 지양하고 큰 영향을 줄 수있는 곳에서만 노력을 집중해야합니다.  예를 들자면 애플리케이션의 네트워크 호출 및 페이로드, 애니메이션, 애셋 캐싱 전략 등이 있습니다.</p>\n<p>성능 문제가 눈에 보이고, 앱 코드를 프로파일링해 실제 병목 현상을 찾아낸 경우가 아니라면 성능을 미세 조정하지 마십시오.</p>\n<p>대신 유지 관리 및 유연성을 위한 최적화를 해야합니다.</p>\n<h2>타입 검사</h2>\n<p>JavaScript의 클래스는 동적이며  <code>instanceof</code> 는 실행 컨텍스트에 종속되어 있기 때문에  <code>class</code> 기반의 타입 검사는 신뢰할 수 없습니다. 이로 인해 버그가 발생하고 애플리케이션이 너무 경직될 수 있습니다.</p>\n<h2><code>extends</code>를 사용한 클래스 상속</h2>\n<p>클래스 상속은 몇 가지 잘 알려진 문제를 반복적으로 일으킵니다.</p>\n<ul>\n<li><strong>단단한 결합 문제</strong> <sup>The</sup> <sup>tight</sup> <sup>coupling</sup> <sup>problem</sup> :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.</li>\n<li><strong>깨지기 쉬운 기초 클래스 문제</strong><sup>The</sup> <sup>fragile</sup> <sup>base</sup> <sup>class</sup> <sup>problem</sup>  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.</li>\n<li><strong>경직된 계층 구조 문제</strong><sup>The</sup> <sup>inflexible</sup> <sup>hierarchy</sup> <sup>problem</sup> :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.</li>\n<li><strong>중복 필요성 문제</strong><sup>The</sup> <sup>duplication</sup> <sup>by</sup> <sup>necessity</sup> <sup>problem</sup> : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.</li>\n<li><strong>고릴라 / 바나나 문제</strong><sup>The</sup> <sup>gorilla/banana</sup> <sup>problem</sup> :  &quot;… 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. &quot;~ Joe Armstrong,  <a href=\"http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN\" target=\"_blank\" rel=\"noopener\">&quot;Coders at Work &quot;</a></li>\n</ul>\n<p><code>extends</code> 의 유일한 쓰임새는 단일 조상<sup>single-ancestor</sup> 클래스 분류법을 만드는 것입니다.  영리한 해커가 이것을 읽고 말합니다. &quot;글쎄…  클래스를 합성하면 되잖아. &quot; 저는 이렇게 대답하겠습니다. &quot;이제는 클래스 상속 대신 객체 합성을 사용하고 있으며 JavaScript는  <code>extends</code> 없이도 이를 쉽게 할 수 있습니다. &quot;</p>\n<h2>충분히 조심한다면 클래스를 사용해도 괜찮습니다.</h2>\n<p>지금까지 수많은 주의사항들을 봤습니다. 이제는 클래스를 안전하게 사용하는데 도움이 되는 몇 가지 명확한 가이드라인을 알아봅시다.</p>\n<ul>\n<li><code>instanceof</code> 피하기 - JavaScript는 동적이고 여러 실행 컨텍스트를 가지고 있기 때문에 진실된 답변을 내놓지 않습니다. 코드를 추상 팩토리로 전환하는 과정에서도 문제가 발생할 수 있습니다.</li>\n<li><code>extends</code>  피하기 - 단일 계층을 두 번 이상 상속하지 마십시오.   “클래스 상속보다는 객체 합성을 우선해라”, Gang of Four,  <a href=\"https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;qid=1494993475&amp;sr=8-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6c553f16325f3939e5abadd4ee04e8b4\" target=\"_blank\" rel=\"noopener\">“디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소”</a></li>\n<li><code>export class</code> 피하기 - 성능을 위해 내부적으로는  <code>class</code>   사용하되 인스턴스를 생성하는 팩토리를 내보내십시오. 사용자가 클래스를 상속하지 못하게하고 호출자가  <code>new</code>를 사용하지 못하도록 해야합니다.</li>\n<li><code>new</code>  피하기 -  의미상 자연스러울 지라도 직접 사용하는 것을 피하고, 다른 사람이 이를 사용하도록 강요하지 마십시오. (팩토리를 내보내면 됩니다)</li>\n</ul>\n<p>다음은 클래스를 사용해도 괜찮은 경우입니다.</p>\n<ul>\n<li><strong>React 또는 Angular 같은 UI 프레임워크를 제작중인 경우</strong>  이들은 모두 컴포넌트 클래스를 팩토리로 감싸고 인스턴스 생성을 책임지게 합니다. 즉, 사용자가  <code>new</code>를 사용할 필요가 없습니다.</li>\n<li><strong>클래스 상속을 사용하지 않을 경우</strong>  그대신 객체 합성, 함수 합성, 고차 함수, 고차원 컴포넌트 또는 모듈을 사용해보십시오. 이 모든 것은 클래스 상속보다 더 나은 코드 재사용 패턴입니다.</li>\n<li><strong>성능을 최적화하는 경우</strong>  그대신 호출자가  <code>new</code>를 사용할 필요가 없어야 하며  <code>extends</code>라는 함정에 빠지지 않도록 팩토리를 <code>export</code>해야 합니다.</li>\n</ul>\n<p>이 세가지 경우를 제외한 대부분의 상황에선 팩토리가 더 나은 방법이 될 것 입니다.</p>\n<p>팩토리는 JavaScript의 클래스 또는 생성자 함수보다 간단합니다.  항상 가장 간단한 솔루션부터 시작하여 필요한 경우에만 보다 복잡한 솔루션으로 나아가야 합니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/\"><strong>다음: 함수형 자료구조 &gt;</strong></a></p>\n"},{"title":"함수형 프로그래머를 위한 JavaScript 개요","catalog":true,"date":"2018-03-28T04:31:41.000Z","subtitle":"A Functional Programmer’s Introduction to JavaScript","header-img":"bg.jpg","readingTime":13,"catagories":["개발"],"preview":"이 편은 JavaScript 또는 ES6 +에 익숙하지 않은 독자를 위한 간단한 입문 글입니다. 당신이 초보자이든 숙련된 JavaScript 개발자이든 아마 새로 배울 것들이 있을 겁니다.  사실 이번 편은 단순히 주제의 겉표면을 훑으며 관심을 환기하기 위해 작성됐습니다. 더 많이 알고 싶다면 더 깊게 탐구하면 됩니다. 이 글은 계속 연재될 것이며 아직 다룰 주제들은 많이 남아있습니다. 코딩을 배우는 가장 좋은 방법은 직접 작성해보는 것입니다. CodePen이나  Babel REPL과 같은 대화 형 JavaScript 프로그래밍 환경을 사용하는 것이 좋습니다. NodeJS 또는 브라우저 콘솔의 REPL을 사용해도 됩니다. 표현식과 값Expressions and Values 표현식은 값으로 평가되는 코드 덩어리입니다. 다음은 JavaScript에서 유효한 표현식입니다.","_content":"\n\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/a-functional-programmers-introduction-to-javascript-composing-software-d670d14ede30)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/03/29/higher-order-functions)\n\n이 편은 JavaScript 또는 ES6 +에 익숙하지 않은 독자를 위한 간단한 입문 글입니다. 당신이 초보자이든 숙련된 JavaScript 개발자이든 아마 새로 배울 것들이 있을 겁니다.  사실 이번 편은 단순히 주제의 겉표면을 훑으며 관심을 환기하기 위해 작성됐습니다. 더 많이 알고 싶다면 더 깊게 탐구하면 됩니다. 이 글은 계속 연재될 것이며 아직 다룰 주제들은 많이 남아있습니다.\n\n코딩을 배우는 가장 좋은 방법은 직접 작성해보는 것입니다.  [CodePen](https://codepen.io/)  이나  [Babel REPL](https://babeljs.io/repl/)  과 같은 대화 형 JavaScript 프로그래밍 환경을 사용하는 것이 좋습니다.\n\nNodeJS 또는 브라우저 콘솔의 REPL을 사용해도 됩니다.\n\n## 표현식과 값Expressions and Values\n\n표현식은 값으로 평가되는 코드 덩어리입니다.\n\n다음은 JavaScript에서 유효한 표현식입니다.\n```javascript\n  7; \n\n  7 + 1;  // 8 \n\n  7 * 2;  // 14 \n\n  'Hello'; // Hello\n```\n\n표현식의 값에는 이름을 붙일 수 있습니다.  이 때 표현식이 먼저 평가되고 결과 값이 이름에 저장됩니다.  변수를 선언하기 위해  `const`  키워드를 사용합니다.  여러 방법이 있지만, `const`를 가장 많이 사용하게 될 것입니다.  따라서 우리는 지금부터  `const`  를 사용 할 것입니다 :\n```javascript\n  const hello = 'Hello';   \n  hello; // Hello \n```\n## var, let 및 const\n\nJavaScript는 `const` 외에도   `var`  과  `let`이라는 두 종류의 변수 선언 키워드가 있습니다.  저는 이들을 순서에 맞게 사용할 것입니다.  기본적으로 가장 엄격한 선언인  `const`를  선택합니다.  `const`  키워드로 선언 된 변수는 재 할당 할 수 없습니다.  즉, 선언할 때 최종 값이 저장됩니다.  이는 엄격하다고 여겨질 수도 있지만, 제약은 좋은 것입니다.  \"이 변수에 할당 된 값은 변경되지 않을 것입니다\"라는 신호입니다.  함수 전체나 블록 스코프를 찾아볼 필요 없이 변수의 의미를 즉시 이해할 수 있습니다.\n\n변수를 재 할당하는 것이 유용할 때가 있습니다.  예를 들어 함수형으로 접근하지 않고 직접 명령을 반복 실행할 경우 `let`으로  선언된 카운터 변수에 반복하여 할당 할 수 있습니다.\n\n`var`은-이건 적어도 **변수**입니다-라는 약한 의미를 가집니다.  ES6으로 프로그래밍하기 시작한 이후 저는 실제 프로젝트에서  `var`  를 의도적으로 선언 한 적이 없습니다.\n\n`let`  또는  `const` 로 선언된 변수를 다시 선언하면 오류가 발생합니다.  REPL (Read, Eval, Print Loop) 환경에서 실험적인 목적으로 코딩을 할 경우 이들 대신  `var`  를 사용하여 변수를 선언하는게 적합합니다.  \n\n실제 프로그램을 작성할 때 기본적으로 `const`를 사용하기 때문에 이 글에서도 `const`를 사용할 것입니다. 다만 실험을 위해서라면 자유롭게 `var`  을 사용하십시오.\n## 타입\n\n지금까지 두 가지 타입을 보았습니다 : 숫자와 문자열.  이 외에도 JavaScript에는 부울 (  `true`  또는  `false`  ), 배열, 객체 등이 있습니다.  우리는 나중에 다른 타입을 얻을 것입니다.\n\n배열은 순서가 있는 목록입니다.  다양한 항목을 담을 수있는 상자라고 생각하면 됩니다.  다음은 배열 리터럴 표기법입니다.\n\n```javascript\n  [1, 2, 3]; \n```\n변수에 할당할 수 있습니다.\n```javascript\n  const arr = [1, 2, 3]; \n```\nJavaScript의 객체는 key : value 쌍의 모음입니다.  표기법은 다음과 같습니다.\n```javascript\n  {   \n\t  key : 'value'   \n  } \n```\n물론 변수에 할당 할 수 있습니다.\n```javascript\n  const foo = {   \n\t  bar : 'bar'   \n  } \n```\n변수의 이름과 값으로 객체를 생성할 수 있습니다.\n```javascript\n  const a = 'a';   \n  const oldA = {a : a};  // long, redundant way   \n  const oA = {a};  // short an sweet! \n```\n다시 한번 해보겠습니다.\n```javascript\n  const b = 'b';   \n  const oB = {b}; \n```\n객체들로 새로운 객체를 쉽게 합성할 수 있습니다.\n```javascript\n  const c = {...oA, ...oB};  // {a : 'a', b : 'b'} \n```\n`...`은 객체 스프레드 연산자입니다.  `oA` 의 프로퍼티들을 반복하여 새로운 객체에 할당한 다음  `oB`  대해 동일한 작업을 수행합니다. 이 때 키가 중복되는 경우 이미 존재하는 키를 덮어씁니다.  이 글을 쓰는 시점에서 객체 스프레드는 아직 대중적인 브라우저에서 사용할 수 없는 실험적인 기능입니다. 브라우저가 지원하지 않을 경우 `Object.assign()`으로 대체 할 수 있습니다.\n```javascript\n  const d = Object.assign ({}, oA, oB);  \n  // {a : 'a', b : 'b'} \n```\n`Object.assign()` 은 객체 스프레드보다 조금만 더 타이핑하면 됩니다. 수많은 객체를 합성해야 하는 경우 타이핑을 줄일 수 있습니다.  `Object.assign()`  을 사용할 때 최종적으로 리턴될 객체를 첫 번째 매개 변수로 전달해야합니다.  속성들을 복사 할 개체 말입니다.  만약 이를 생략하면 첫 번째 인수로 전달한 객체가 변경됩니다.\n\n제 경험상, 새로운 객체를 만드는 것이 아닌 기존의 객체를 변경하는 것은 일반적으로 버그를 일으킬 여지가 많습니다. `Object.assign()`을 사용할 때는 이를 주의하십시오.\n\n## 해체 혹은 비구조화^destructuring^^[MDN 번역문서에는 비구조화라고 번역되어있습니다. 그러나 다른 많은 번역글에서 해체라고 번역이 되었으며 역자는 해체라는 용어를 사용하겠습니다.]\n\n객체와 배열 모두 해체를 지원합니다. 즉, 객체에서 값을 꺼내 변수에 할당 할 수 있습니다.\n```javascript\n  const [t, u] = [ 'a', 'b'];\n  t;  // 'a'   \n  u;  // 'b' \n\n  const blep = {   \n\t  blop: 'blop'\n  };   \n  \n  // The following is equivalent to\n  // const blop = blep.blop;   \n  const {blop} = blep;   \n  blop;  // 'blop' \n\n  // Also equivalent to\n  // const a = this.state.a;\n  const {a} = this.state;\n```\n위의 배열 예제 처럼 동시에 여러 변수에 할당할 수 있습니다. 다음은 Redux 프로젝트에서 자주 볼 수 있는 코드입니다.\n```javascript\n  const {type, payload} = action; \n```\nReducer에서 다음과 같이 사용합니다. (Reducer는 나중 글에서 설명할 것입니다)\n```javascript\n  const myReducer = (state = {}, action = {}) => {   \n\t  const {type, payload} = action;   \n\t  switch (type) {   \n\t\t  case 'FOO': return Object.assign ({}, state, payload);   \n\t\t  default : return state;   \n\t  }   \n  }; \n```\n새로운 이름으로 할당 할 수 있습니다.\n```javascript\n const { blop: bloop } = blep;   \n bloop; // 'blop'` \n```\n`blep.blop`  을  `bloop`에 할당했다 라고 읽으면 됩니다.\n\n## 비교 및 삼항 연산자\n\n값을 비교할 때는 완전 항등 연산자(\"triple equals\"라고 함)를 사용합니다.\n```javascript\n  3 + 1 === 4;  // true \n```\n물론 다른 항등 연산자가 있습니다.  공식적으로 \"동등\"연산자라고합니다.  비공식적으로 \"double equals\"라고 합니다. double equals는 한두가지 정도 의미있게 사용할  상황이 있습니다. 그 외에는 항상  `===`  연산자로 비교하는 것이 좋습니다.\n\n이외에도 다음과같은 비교 연산자들이 있습니다.\n\n-   `>`  보다 큼\n-   `<`  보다 작음\n-   `>=`  크거나 같음\n-   `<=`  작거나 같음\n-   `!=`  같지 않음\n-   `!==` 엄격하게 같지 않음\n-   `&&`  논리 곱\n-   `||`  논리 합\n\n삼항 표현식은 삼항 연산자를 사용한 표현식입니다. 조건이 참이냐 거짓이냐에 따라 다른 값으로 평가됩니다.\n```javascript\n  14 - 7 === 7?  'Yep!'  : 'Nope.';  // Yep! \n```\n## 함수\n\nJavaScript에는 함수 표현식이 있으며 이는 변수에 할당 할 수 있습니다.\n```javascript\n  const double = x => x * 2; \n```\n위 코드는 수학에서의 함수  `f(x) = 2x`  와 같습니다.  소리내어 읽을 경우 `f` `x`는 `2x` 라고 읽습니다. 이 함수는  `x`에 특정한 값을 적용 할 때만 의미가 생깁니다. 다른 식에서 이 함수를 사용하려면  `f(2)`라고 쓰면 됩니다.  `f(2)`  는  `4`와 같은 의미입니다.\n\n즉,  `f(2) = 4`  입니다.  수학의 함수는 입력에서 출력으로의 매핑이라고 생각할 수 있습니다.  이 경우  `f(x)`  는  `x`  에 대한 입력 값을 입력 값과  `2`  의 곱과 동일한 해당 출력 값에 매핑하는 것입니다.\n\n자바 스크립트에서 함수 표현식의 값은 함수 그 자체입니다.\n```javascript\n  double;  // [Function : double] \n```\n`.toString()`  메서드를 사용하여 함수 정의를 볼 수 있습니다.\n```javascript\n  double.toString ();  // 'x => x * 2' \n```\n특정 인수(값)에 함수를 적용하려면 함수를 호출해야합니다.  함수 호출이란 인수에 함수를 적용하고 평가된 값을 리턴받는 것입니다.\n\n`<functionName>(argument1, argument2, ...rest)` 와 같은 문법으로 함수를 호출 할 수 있습니다.  예를 들어 double 함수를 호출하려면 괄호를 추가하고 double 값을 전달하면됩니다.\n```javascript\n  double(2);  // 4 \n```\n일부 함수형 언어들과는 달리 괄호가 필수입니다. 괄호가 없으면 함수는 호출되지 않습니다 :\n```javascript\n  double 4;  // SyntaxError : Unexpected number \n```\n## 서명 혹은 시그니처\n\n함수들은 다음과 같이 서명을 가집니다.\n\n1.  함수 이름(선택사항)\n2.  인자 타입 목록(매개 변수의 이름은 선택사항)\n3.  리턴 타입\n\nJavaScript의 함수서명에는 타입을 명시하지 않아도 됩니다.  JavaScript 엔진은 런타임에 타입을 파악합니다.  충분한 단서들을 제공할 경우 IDE (Integrated Development Environment) 및  [Tern.js](http://ternjs.net/)  와 같은 개발자 도구에서는 데이터 흐름을 분석하여 서명을 유추해내기도 합니다.\n\n자바 스크립트는 함수 서명에 대한 표준이 없기 때문에 여러 표준들이 경쟁을 하는 상황입니다. JSDoc은 오랫동안 쓰여왔지만 장황하고 다소 어색합니다.  대부분의 사람들은 코드에 대한 주석을 최신화하는데 별로 관심이 없기에 많은 JS 개발자가 더 이상 사용하지 않습니다.\n\n가장 인기 있는 두 표준 TypeScript와 Flow가 있습니다. 저는 둘중 어떠한 것이 더 나은지 확실하지 않습니다. 따라서 저는   [Rtype](https://github.com/ericelliott/rtype)을 사용합니다. 어떤 사람들은 커리^curry^를 위해 하스켈 전용  [Hindley-Milner Type](http://web.cs.wpi.edu/~cs4536/c12/milner-damas_principal_types.pdf) 을 꺼내들기도 합니다. 저는 JavaScript 문서화를 위해 얼른 좋은 표기법이 표준화되어야 한다고 봅니다. 그러나 지금 나와있는 해결책 중 어느것도 완벽하다고 할 수 없습니다.  당분간 여러분이 사용하고있는 것과는 약간 다른 문법으로 쓰인 다양한 유형의 서명들을 이해하기 위해 최선을 다해야 할 것입니다.\n```\n  functionName (param1 : Type, param2 : Type) => Type \n```\ndouble 함수의 서명은 다음과 같습니다.\n```\n  double (x : n) => Number \n```\nJavaScript는 강제로 주석을 달지 않아도 된다는 사실에도 불구하고, 함수를 사용할 때 그리고 합성할 때 효율적으로 의사소통을 하기 위해 서명에 의미를 재빨리 파악할 수 있는 것이 중요합니다. 함수 합성에 관련된 대부분의 라이브러리들은 동일한 타입의 서명을 가진 함수를 전달할 것을 요구합니다.\n\n## 기본 매개 변수 값^default^ ^parameter^ ^values^\n\nJavaScript는 기본 매개 변수 값을 지원합니다.  다음 함수는 전달받은 값을 그대로 리턴하는 항등^identity^함수입니다.  그러나 `undefined`를 인수로 전달받거나 아무 인수도 전달받지 않은 경우 0을 리턴합니다.\n```javascript\n  const orZero = (n = 0) => n; \n```\n기본값을 설정하려면  `n = 0` 처럼 `=`  연산자를 사용하여 매개 변수에 값을 할당하기만 하면 됩니다.  이런 식으로 기본값을 지정하면  [Tern.js](http://ternjs.net/)  , Flow 또는 TypeScript를 사용할 때 함수의 형식과 서명을 주석으로 명시하지 않아도 이를 자동으로 유추 할 수 있습니다.\n\n기본 매개 변수값을 지정하고 텍스트 에디터나 IDE에 관련 플러그인을 설치하면 함수를 사용하려고 할 때 함수 서명이 표시됩니다. 또한 함수를 사용하는 방법을 파악하기 쉽습니다. 이는 코드 자체가 곧 문서가 될 수 있는 중요한 접근방법입니다.\n\n> 참고 : 기본값이 있는 매개 변수는 함수의  `.length`  속성에서 제외됩니다. 즉 `length`값을 참조하는 autocurry 라이브러리를 사용할 때 문제가 발생할 수 있습니다. 그러나 일부 currying 라이브러리 (예 :  `lodash/curry`  )에서는 함수 인자의 개수^arity^를 임의로 전달 하는 옵션이 있습니다.\n\n## 해체-할당과 기본값\n\nJavaScript 함수에서 객체 리터럴을 받아 해제-할당하면 이를 보통 인수처럼 사용할 수 있습니다. 이 때도 마찬가지로 기본 매개 변수 기능을 사용하여 기본값을 할당 할 수 있습니다.\n```javascript\n  const createUser = ({   \n\t  name = 'Anonymous',   \n\t  avatarThumbnail = '/avatars/anonymous.png'   \n  }) => ({   \n\t  name,   \n\t  avatarThumbnail   \n  }); \n\n  const george = createUser ({   \n\t  name : 'George'   \n\t  avataThumbnail : 'avatars/shades-emoji.png'   \n  }); \n\n  george;   \n  /*   \n  {   \n\t  name : 'george'   \n\t  avatarThumbnail : 'avatars/shades-emoji.png'   \n  }   \n  */ \n```\n## 나머지와 스프레드 연산자\n\n나머지 연산자`...`를 사용해서 함수의 정해지지 않은 인수들을 배열로 참조할 수 있습니다.\n\n예를 들어 다음 함수는 첫 번째 인수를 버리고 나머지를 배열로 리턴합니다.\n```javascript\n  const aTail = (head, ...tail) => tail;   \n  aTail(1, 2, 3);  // [2, 3] \n```\n나머지 구문은 개별 요소를 배열로 만듭니다. 스프레드는 반대의 역할을합니다. 즉, 주어진 배열을 개별 요소로 퍼트립니다. 나머지와 스프레드는 같은 형태를 가지지만 사용법이 다릅니다. 이를 주의해서 다음 코드를 참고하세요:\n```javascript\n  const shiftToLast = (head, ...tail) => [...tail, head];   \n  \n  /* 첫 번째 ...tail은 나머지연산자가 사용되었고 뒤에는 스프레드\n     연산자가 사용되었습니다.*/\n  \n  shiftToLast(1, 2, 3);  // [2, 3, 1] \n```\nJavaScript의 배열에 있는 iterator는 스프레드 연산자가 사용될 때 함께 호출됩니다. iterator는 배열의 요소 값들을 반복해서 리턴합니다. `[...tail, head]`  표현식에서 iterator는 나머지 구문으로 전달받은  `tail` 배열에서 값을 하나씩 꺼내 새로운 배열 리터럴에 복사합니다. `head`는 이미 개별 요소이기 때문에 배열의 끝 부분에 붙이면 됩니다.\n\n## 커링^currying^\n\n커리된 함수는 한 번에 하나씩 여러 인자를 받는 함수입니다. 인자를 받아 그 다음인자의 입력을 기다리는 함수를 리턴합니다. 모든 인자가 채워지면 최종 값이 리턴됩니다.\n\n커링 및 부분 적용^partial^ ^application^은 함수를 반환하는 행위입니다.\n```javascript\n  const highpass = cutoff => n => n >= cutoff;   \n  const gt4 = highpass(4);  // highpass() returns a new function\n```\n꼭 화살표 구문을 사용할 필요는 없습니다. JavaScript에는  `function`  키워드가 있습니다. 다만 `function`  키워드를 쓰면 타이핑을 조금 더 해야할 뿐입니다. 즉 아래의 `highpass`는 위의 정의와 동일합니다.\n```javascript\n  const highpass = function highpass(cutoff) {   \n\t  return function(n) {   \n\t\t  return n >= cutoff;   \n\t  };   \n  }; \n```\n화살표는 \"함수\"를 뜻합니다. 그러나 몇 가지 중요한 차이가 있습니다. ( `=>` 은 기본적으로 `this`가 없기 때문에 생성자로 사용할 수 없습니다)  이 주제에 관해선 나중에 더 깊게 알아볼 것입니다. 그러니 지금 당장은  `x => x`  라는 코드를 \"  `x` 를 받아  `x`를 리턴하는 **함수**\"라고 생각하십시오.  따라서 \n```javascript\n  const highpass = cutoff => n => n >= cutoff;\n```\n라는 코드는 다음처럼 읽으면 됩니다:\n\n>`highpass`  는  `cutoff`  를 받고  `n`을 받은 이후에  `n >= cutoff`  의 결과를 리턴하는 함수를 리턴하는 함수\n\n함수를 리턴하는`highpass()` 를 사용해 보다 특화된 함수를 만들 수 있습니다.\n```javascript\n  const gt4 = highpass(4); \n\n  gt4(6);  // true   \n  gt4(3);  // false \n```\nautocurry를 사용하면 최대한 유연한 방식으로 함수를 커링할 수 있습니다. \n```javascript\n  const add3 = curry((a, b, c) => a + b + c);\n```\nautocurry된 add3 함수는 다양한 방법으로 사용할 수 있습니다.\n```javascript\n  add3(1, 2, 3); // 6   \n  add3(1, 2)(3); // 6   \n  add3(1)(2, 3); // 6   \n  add3(1)(2)(3); // 6 \n```\n하스켈 팬에게는 죄송한 일이지만, JavaScript에서는 autocurry를 하기 위해 Lodash와 같은 라이브러리를 사용해야 합니다.\n```\n $ npm install --save lodash \n```\n`npm`으로 설치 한 다음 코드 상단에서 `import`하면 됩니다 :\n```javascript\n  import curry from 'lodash/curry';\n```\n아니면 다음처럼 마술을 부리면 됩니다.\n```javascript\n  // Tiny, recursive autocurry  \n  const curry = (f, arr = []) => (...args) => \n\t  (a => a.length === f.length ? f(...a) : curry(f, a))\n\t  ([...arr, ...args]);\n```\n## 함수 합성\n\n당연히 함수를 합성 할 수 있습니다. 함수 합성은 한 함수의 리턴 값을 다른 함수의 인수로 전달하는 과정입니다.  수학 표기법 :\n```\n f . g\n```\n\n는 JavaScript에서 다음과 같이 표현됩니다.\n```javascript\n  f (g (x)) \n```\n그리고 내부적으로 다음과 같이 계산됩니다 :\n\n1.  `x`  가 평가됩니다.\n2.  `x`에 `g()`가 적용됩니다.\n3.  `g(x)`의 반환 값에 `f()`가 적용됩니다.\n\n예 :\n```javascript\n  const inc = n => n + 1;   \n  inc(double(2));  // 5 \n```\n값  `2`  는  `double()`  으로 전달되어  `4`  를 생성합니다.  `4`  는  `inc()`  로 전달되고  `5`  평가됩니다.\n\n어떤 표현식을 함수의 인수로 전달할 수 있습니다.  이 때 표현식이 먼저 평가된 후 함수가 적용됩니다.\n```javascript\n  inc(double(2) * double(2));  // 17 \n```\n`double(2)`  은  `4` 로 평가되므로  `inc(4 * 4)` 가 된 후  `inc(16)`  로 평가되고  `17`이 리턴됩니다.\n\n함수 합성은 함수형 프로그래밍의 핵심입니다.  \n\n## 배열\n\n배열에는 몇 가지 내장 된 메소드가 있습니다.  메소드는 객체와 관련된 함수입니다. 일반적으로 객체의 속성^property^으로 존재합니다.\n```javascript\n  const arr = [1, 2, 3];   \n  arr.map(double);  // [2, 4, 6] \n```\n이 경우  `arr`  이 객체이고  `.map()` 함수가 값으로 할당되어있는 속성입니다.    이 함수를 호출하면 인수에 적용될 뿐만 아니라 `this`  라는 특수 매개 변수에도 적용됩니다.  `this`  매개 변수는 메소드가 호출 될 때 자동으로 설정됩니다. `map()` 메소드에서 배열의 값에 접근할 때`this`를 참조합니다.\n\n`double`  함수를 호출하는 `map`에 전달하는걸 잘 보십시오. `map`  은 함수를 인수로 받아여 배열의 각 항목에 적용합니다.  그리고 `double()`  의해 리턴 된 값으로 새로운 배열을 생성하여 리턴합니다.\n\n원래의  `arr`  값은 변하지 않습니다.\n```javascript\n  arr;  // [1, 2, 3] \n```\n## 메소드 체이닝\n\n메소드를 호출을 연결할 수도 있습니다.  메소드 체인은 리턴 값을 따로 변수에 저장하여 다시 참조 할 필요없이 함수의 리턴 값에 메소드를 계속해서 호출하는 프로세스입니다.\n```javascript\n  const arr = [1, 2, 3];   \n  arr.map(double).map(double);  // [4, 8, 12] \n```\n**predicate**  는 부울 값 (  `true`  또는  `false`  )을 리턴하는 함수입니다.  `.filter()`  메소드는 predicate를 인수로 받아 배열의 개별 항목에 적용합니다. 이 때 조건을 통과한(`true`를 반환) 항목만 선택하여 새 배열에 포함시켜 리턴합니다.\n```javascript\n  [2, 4, 6].filter(gt4);  // [4, 6] \n```\n배열에서 조건에 맞는 항목을 골라 매핑하는 상황은 자주 발생합니다.\n```javascript\n  [2, 4, 6].filter(gt4).map(double);  //[8, 12] \n```\n참고 : 이 시리즈의 뒷부분에는 선택과 매핑을 동시에 하는 더 효율적인 방법인 `transducer`가 나옵니다.  \n\n## 결론\n\n머리가 핑핑 돌고 있습니까? 걱정하지 마세요. 지금까지 배운 것들은 단지 맛보기에  지나지 않습니다. 앞으로도 계속 이 주제들이 반복적으로 그리고 좀 더 깊은 이해를 위해 등장할 것입니다.   \n\n[**다음: 고차 함수 >**](https://midojeong.github.io/2018/03/29/higher-order-functions)\n\n","source":"_posts/a-functional-programmers-introduction-to-javascript.md","raw":"---\ntitle: 함수형 프로그래머를 위한 JavaScript 개요\ncatalog: true\ndate: 2018-03-28 13:31:41\nsubtitle: \"A Functional Programmer’s Introduction to JavaScript\"\nheader-img: \"bg.jpg\"\nreadingTime: 13\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 이 편은 JavaScript 또는 ES6 +에 익숙하지 않은 독자를 위한 간단한 입문 글입니다. 당신이 초보자이든 숙련된 JavaScript 개발자이든 아마 새로 배울 것들이 있을 겁니다.  사실 이번 편은 단순히 주제의 겉표면을 훑으며 관심을 환기하기 위해 작성됐습니다. 더 많이 알고 싶다면 더 깊게 탐구하면 됩니다. 이 글은 계속 연재될 것이며 아직 다룰 주제들은 많이 남아있습니다. 코딩을 배우는 가장 좋은 방법은 직접 작성해보는 것입니다. CodePen이나  Babel REPL과 같은 대화 형 JavaScript 프로그래밍 환경을 사용하는 것이 좋습니다. NodeJS 또는 브라우저 콘솔의 REPL을 사용해도 됩니다. 표현식과 값Expressions and Values 표현식은 값으로 평가되는 코드 덩어리입니다. 다음은 JavaScript에서 유효한 표현식입니다.\n---\n\n\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/a-functional-programmers-introduction-to-javascript-composing-software-d670d14ede30)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/03/29/higher-order-functions)\n\n이 편은 JavaScript 또는 ES6 +에 익숙하지 않은 독자를 위한 간단한 입문 글입니다. 당신이 초보자이든 숙련된 JavaScript 개발자이든 아마 새로 배울 것들이 있을 겁니다.  사실 이번 편은 단순히 주제의 겉표면을 훑으며 관심을 환기하기 위해 작성됐습니다. 더 많이 알고 싶다면 더 깊게 탐구하면 됩니다. 이 글은 계속 연재될 것이며 아직 다룰 주제들은 많이 남아있습니다.\n\n코딩을 배우는 가장 좋은 방법은 직접 작성해보는 것입니다.  [CodePen](https://codepen.io/)  이나  [Babel REPL](https://babeljs.io/repl/)  과 같은 대화 형 JavaScript 프로그래밍 환경을 사용하는 것이 좋습니다.\n\nNodeJS 또는 브라우저 콘솔의 REPL을 사용해도 됩니다.\n\n## 표현식과 값Expressions and Values\n\n표현식은 값으로 평가되는 코드 덩어리입니다.\n\n다음은 JavaScript에서 유효한 표현식입니다.\n```javascript\n  7; \n\n  7 + 1;  // 8 \n\n  7 * 2;  // 14 \n\n  'Hello'; // Hello\n```\n\n표현식의 값에는 이름을 붙일 수 있습니다.  이 때 표현식이 먼저 평가되고 결과 값이 이름에 저장됩니다.  변수를 선언하기 위해  `const`  키워드를 사용합니다.  여러 방법이 있지만, `const`를 가장 많이 사용하게 될 것입니다.  따라서 우리는 지금부터  `const`  를 사용 할 것입니다 :\n```javascript\n  const hello = 'Hello';   \n  hello; // Hello \n```\n## var, let 및 const\n\nJavaScript는 `const` 외에도   `var`  과  `let`이라는 두 종류의 변수 선언 키워드가 있습니다.  저는 이들을 순서에 맞게 사용할 것입니다.  기본적으로 가장 엄격한 선언인  `const`를  선택합니다.  `const`  키워드로 선언 된 변수는 재 할당 할 수 없습니다.  즉, 선언할 때 최종 값이 저장됩니다.  이는 엄격하다고 여겨질 수도 있지만, 제약은 좋은 것입니다.  \"이 변수에 할당 된 값은 변경되지 않을 것입니다\"라는 신호입니다.  함수 전체나 블록 스코프를 찾아볼 필요 없이 변수의 의미를 즉시 이해할 수 있습니다.\n\n변수를 재 할당하는 것이 유용할 때가 있습니다.  예를 들어 함수형으로 접근하지 않고 직접 명령을 반복 실행할 경우 `let`으로  선언된 카운터 변수에 반복하여 할당 할 수 있습니다.\n\n`var`은-이건 적어도 **변수**입니다-라는 약한 의미를 가집니다.  ES6으로 프로그래밍하기 시작한 이후 저는 실제 프로젝트에서  `var`  를 의도적으로 선언 한 적이 없습니다.\n\n`let`  또는  `const` 로 선언된 변수를 다시 선언하면 오류가 발생합니다.  REPL (Read, Eval, Print Loop) 환경에서 실험적인 목적으로 코딩을 할 경우 이들 대신  `var`  를 사용하여 변수를 선언하는게 적합합니다.  \n\n실제 프로그램을 작성할 때 기본적으로 `const`를 사용하기 때문에 이 글에서도 `const`를 사용할 것입니다. 다만 실험을 위해서라면 자유롭게 `var`  을 사용하십시오.\n## 타입\n\n지금까지 두 가지 타입을 보았습니다 : 숫자와 문자열.  이 외에도 JavaScript에는 부울 (  `true`  또는  `false`  ), 배열, 객체 등이 있습니다.  우리는 나중에 다른 타입을 얻을 것입니다.\n\n배열은 순서가 있는 목록입니다.  다양한 항목을 담을 수있는 상자라고 생각하면 됩니다.  다음은 배열 리터럴 표기법입니다.\n\n```javascript\n  [1, 2, 3]; \n```\n변수에 할당할 수 있습니다.\n```javascript\n  const arr = [1, 2, 3]; \n```\nJavaScript의 객체는 key : value 쌍의 모음입니다.  표기법은 다음과 같습니다.\n```javascript\n  {   \n\t  key : 'value'   \n  } \n```\n물론 변수에 할당 할 수 있습니다.\n```javascript\n  const foo = {   \n\t  bar : 'bar'   \n  } \n```\n변수의 이름과 값으로 객체를 생성할 수 있습니다.\n```javascript\n  const a = 'a';   \n  const oldA = {a : a};  // long, redundant way   \n  const oA = {a};  // short an sweet! \n```\n다시 한번 해보겠습니다.\n```javascript\n  const b = 'b';   \n  const oB = {b}; \n```\n객체들로 새로운 객체를 쉽게 합성할 수 있습니다.\n```javascript\n  const c = {...oA, ...oB};  // {a : 'a', b : 'b'} \n```\n`...`은 객체 스프레드 연산자입니다.  `oA` 의 프로퍼티들을 반복하여 새로운 객체에 할당한 다음  `oB`  대해 동일한 작업을 수행합니다. 이 때 키가 중복되는 경우 이미 존재하는 키를 덮어씁니다.  이 글을 쓰는 시점에서 객체 스프레드는 아직 대중적인 브라우저에서 사용할 수 없는 실험적인 기능입니다. 브라우저가 지원하지 않을 경우 `Object.assign()`으로 대체 할 수 있습니다.\n```javascript\n  const d = Object.assign ({}, oA, oB);  \n  // {a : 'a', b : 'b'} \n```\n`Object.assign()` 은 객체 스프레드보다 조금만 더 타이핑하면 됩니다. 수많은 객체를 합성해야 하는 경우 타이핑을 줄일 수 있습니다.  `Object.assign()`  을 사용할 때 최종적으로 리턴될 객체를 첫 번째 매개 변수로 전달해야합니다.  속성들을 복사 할 개체 말입니다.  만약 이를 생략하면 첫 번째 인수로 전달한 객체가 변경됩니다.\n\n제 경험상, 새로운 객체를 만드는 것이 아닌 기존의 객체를 변경하는 것은 일반적으로 버그를 일으킬 여지가 많습니다. `Object.assign()`을 사용할 때는 이를 주의하십시오.\n\n## 해체 혹은 비구조화^destructuring^^[MDN 번역문서에는 비구조화라고 번역되어있습니다. 그러나 다른 많은 번역글에서 해체라고 번역이 되었으며 역자는 해체라는 용어를 사용하겠습니다.]\n\n객체와 배열 모두 해체를 지원합니다. 즉, 객체에서 값을 꺼내 변수에 할당 할 수 있습니다.\n```javascript\n  const [t, u] = [ 'a', 'b'];\n  t;  // 'a'   \n  u;  // 'b' \n\n  const blep = {   \n\t  blop: 'blop'\n  };   \n  \n  // The following is equivalent to\n  // const blop = blep.blop;   \n  const {blop} = blep;   \n  blop;  // 'blop' \n\n  // Also equivalent to\n  // const a = this.state.a;\n  const {a} = this.state;\n```\n위의 배열 예제 처럼 동시에 여러 변수에 할당할 수 있습니다. 다음은 Redux 프로젝트에서 자주 볼 수 있는 코드입니다.\n```javascript\n  const {type, payload} = action; \n```\nReducer에서 다음과 같이 사용합니다. (Reducer는 나중 글에서 설명할 것입니다)\n```javascript\n  const myReducer = (state = {}, action = {}) => {   \n\t  const {type, payload} = action;   \n\t  switch (type) {   \n\t\t  case 'FOO': return Object.assign ({}, state, payload);   \n\t\t  default : return state;   \n\t  }   \n  }; \n```\n새로운 이름으로 할당 할 수 있습니다.\n```javascript\n const { blop: bloop } = blep;   \n bloop; // 'blop'` \n```\n`blep.blop`  을  `bloop`에 할당했다 라고 읽으면 됩니다.\n\n## 비교 및 삼항 연산자\n\n값을 비교할 때는 완전 항등 연산자(\"triple equals\"라고 함)를 사용합니다.\n```javascript\n  3 + 1 === 4;  // true \n```\n물론 다른 항등 연산자가 있습니다.  공식적으로 \"동등\"연산자라고합니다.  비공식적으로 \"double equals\"라고 합니다. double equals는 한두가지 정도 의미있게 사용할  상황이 있습니다. 그 외에는 항상  `===`  연산자로 비교하는 것이 좋습니다.\n\n이외에도 다음과같은 비교 연산자들이 있습니다.\n\n-   `>`  보다 큼\n-   `<`  보다 작음\n-   `>=`  크거나 같음\n-   `<=`  작거나 같음\n-   `!=`  같지 않음\n-   `!==` 엄격하게 같지 않음\n-   `&&`  논리 곱\n-   `||`  논리 합\n\n삼항 표현식은 삼항 연산자를 사용한 표현식입니다. 조건이 참이냐 거짓이냐에 따라 다른 값으로 평가됩니다.\n```javascript\n  14 - 7 === 7?  'Yep!'  : 'Nope.';  // Yep! \n```\n## 함수\n\nJavaScript에는 함수 표현식이 있으며 이는 변수에 할당 할 수 있습니다.\n```javascript\n  const double = x => x * 2; \n```\n위 코드는 수학에서의 함수  `f(x) = 2x`  와 같습니다.  소리내어 읽을 경우 `f` `x`는 `2x` 라고 읽습니다. 이 함수는  `x`에 특정한 값을 적용 할 때만 의미가 생깁니다. 다른 식에서 이 함수를 사용하려면  `f(2)`라고 쓰면 됩니다.  `f(2)`  는  `4`와 같은 의미입니다.\n\n즉,  `f(2) = 4`  입니다.  수학의 함수는 입력에서 출력으로의 매핑이라고 생각할 수 있습니다.  이 경우  `f(x)`  는  `x`  에 대한 입력 값을 입력 값과  `2`  의 곱과 동일한 해당 출력 값에 매핑하는 것입니다.\n\n자바 스크립트에서 함수 표현식의 값은 함수 그 자체입니다.\n```javascript\n  double;  // [Function : double] \n```\n`.toString()`  메서드를 사용하여 함수 정의를 볼 수 있습니다.\n```javascript\n  double.toString ();  // 'x => x * 2' \n```\n특정 인수(값)에 함수를 적용하려면 함수를 호출해야합니다.  함수 호출이란 인수에 함수를 적용하고 평가된 값을 리턴받는 것입니다.\n\n`<functionName>(argument1, argument2, ...rest)` 와 같은 문법으로 함수를 호출 할 수 있습니다.  예를 들어 double 함수를 호출하려면 괄호를 추가하고 double 값을 전달하면됩니다.\n```javascript\n  double(2);  // 4 \n```\n일부 함수형 언어들과는 달리 괄호가 필수입니다. 괄호가 없으면 함수는 호출되지 않습니다 :\n```javascript\n  double 4;  // SyntaxError : Unexpected number \n```\n## 서명 혹은 시그니처\n\n함수들은 다음과 같이 서명을 가집니다.\n\n1.  함수 이름(선택사항)\n2.  인자 타입 목록(매개 변수의 이름은 선택사항)\n3.  리턴 타입\n\nJavaScript의 함수서명에는 타입을 명시하지 않아도 됩니다.  JavaScript 엔진은 런타임에 타입을 파악합니다.  충분한 단서들을 제공할 경우 IDE (Integrated Development Environment) 및  [Tern.js](http://ternjs.net/)  와 같은 개발자 도구에서는 데이터 흐름을 분석하여 서명을 유추해내기도 합니다.\n\n자바 스크립트는 함수 서명에 대한 표준이 없기 때문에 여러 표준들이 경쟁을 하는 상황입니다. JSDoc은 오랫동안 쓰여왔지만 장황하고 다소 어색합니다.  대부분의 사람들은 코드에 대한 주석을 최신화하는데 별로 관심이 없기에 많은 JS 개발자가 더 이상 사용하지 않습니다.\n\n가장 인기 있는 두 표준 TypeScript와 Flow가 있습니다. 저는 둘중 어떠한 것이 더 나은지 확실하지 않습니다. 따라서 저는   [Rtype](https://github.com/ericelliott/rtype)을 사용합니다. 어떤 사람들은 커리^curry^를 위해 하스켈 전용  [Hindley-Milner Type](http://web.cs.wpi.edu/~cs4536/c12/milner-damas_principal_types.pdf) 을 꺼내들기도 합니다. 저는 JavaScript 문서화를 위해 얼른 좋은 표기법이 표준화되어야 한다고 봅니다. 그러나 지금 나와있는 해결책 중 어느것도 완벽하다고 할 수 없습니다.  당분간 여러분이 사용하고있는 것과는 약간 다른 문법으로 쓰인 다양한 유형의 서명들을 이해하기 위해 최선을 다해야 할 것입니다.\n```\n  functionName (param1 : Type, param2 : Type) => Type \n```\ndouble 함수의 서명은 다음과 같습니다.\n```\n  double (x : n) => Number \n```\nJavaScript는 강제로 주석을 달지 않아도 된다는 사실에도 불구하고, 함수를 사용할 때 그리고 합성할 때 효율적으로 의사소통을 하기 위해 서명에 의미를 재빨리 파악할 수 있는 것이 중요합니다. 함수 합성에 관련된 대부분의 라이브러리들은 동일한 타입의 서명을 가진 함수를 전달할 것을 요구합니다.\n\n## 기본 매개 변수 값^default^ ^parameter^ ^values^\n\nJavaScript는 기본 매개 변수 값을 지원합니다.  다음 함수는 전달받은 값을 그대로 리턴하는 항등^identity^함수입니다.  그러나 `undefined`를 인수로 전달받거나 아무 인수도 전달받지 않은 경우 0을 리턴합니다.\n```javascript\n  const orZero = (n = 0) => n; \n```\n기본값을 설정하려면  `n = 0` 처럼 `=`  연산자를 사용하여 매개 변수에 값을 할당하기만 하면 됩니다.  이런 식으로 기본값을 지정하면  [Tern.js](http://ternjs.net/)  , Flow 또는 TypeScript를 사용할 때 함수의 형식과 서명을 주석으로 명시하지 않아도 이를 자동으로 유추 할 수 있습니다.\n\n기본 매개 변수값을 지정하고 텍스트 에디터나 IDE에 관련 플러그인을 설치하면 함수를 사용하려고 할 때 함수 서명이 표시됩니다. 또한 함수를 사용하는 방법을 파악하기 쉽습니다. 이는 코드 자체가 곧 문서가 될 수 있는 중요한 접근방법입니다.\n\n> 참고 : 기본값이 있는 매개 변수는 함수의  `.length`  속성에서 제외됩니다. 즉 `length`값을 참조하는 autocurry 라이브러리를 사용할 때 문제가 발생할 수 있습니다. 그러나 일부 currying 라이브러리 (예 :  `lodash/curry`  )에서는 함수 인자의 개수^arity^를 임의로 전달 하는 옵션이 있습니다.\n\n## 해체-할당과 기본값\n\nJavaScript 함수에서 객체 리터럴을 받아 해제-할당하면 이를 보통 인수처럼 사용할 수 있습니다. 이 때도 마찬가지로 기본 매개 변수 기능을 사용하여 기본값을 할당 할 수 있습니다.\n```javascript\n  const createUser = ({   \n\t  name = 'Anonymous',   \n\t  avatarThumbnail = '/avatars/anonymous.png'   \n  }) => ({   \n\t  name,   \n\t  avatarThumbnail   \n  }); \n\n  const george = createUser ({   \n\t  name : 'George'   \n\t  avataThumbnail : 'avatars/shades-emoji.png'   \n  }); \n\n  george;   \n  /*   \n  {   \n\t  name : 'george'   \n\t  avatarThumbnail : 'avatars/shades-emoji.png'   \n  }   \n  */ \n```\n## 나머지와 스프레드 연산자\n\n나머지 연산자`...`를 사용해서 함수의 정해지지 않은 인수들을 배열로 참조할 수 있습니다.\n\n예를 들어 다음 함수는 첫 번째 인수를 버리고 나머지를 배열로 리턴합니다.\n```javascript\n  const aTail = (head, ...tail) => tail;   \n  aTail(1, 2, 3);  // [2, 3] \n```\n나머지 구문은 개별 요소를 배열로 만듭니다. 스프레드는 반대의 역할을합니다. 즉, 주어진 배열을 개별 요소로 퍼트립니다. 나머지와 스프레드는 같은 형태를 가지지만 사용법이 다릅니다. 이를 주의해서 다음 코드를 참고하세요:\n```javascript\n  const shiftToLast = (head, ...tail) => [...tail, head];   \n  \n  /* 첫 번째 ...tail은 나머지연산자가 사용되었고 뒤에는 스프레드\n     연산자가 사용되었습니다.*/\n  \n  shiftToLast(1, 2, 3);  // [2, 3, 1] \n```\nJavaScript의 배열에 있는 iterator는 스프레드 연산자가 사용될 때 함께 호출됩니다. iterator는 배열의 요소 값들을 반복해서 리턴합니다. `[...tail, head]`  표현식에서 iterator는 나머지 구문으로 전달받은  `tail` 배열에서 값을 하나씩 꺼내 새로운 배열 리터럴에 복사합니다. `head`는 이미 개별 요소이기 때문에 배열의 끝 부분에 붙이면 됩니다.\n\n## 커링^currying^\n\n커리된 함수는 한 번에 하나씩 여러 인자를 받는 함수입니다. 인자를 받아 그 다음인자의 입력을 기다리는 함수를 리턴합니다. 모든 인자가 채워지면 최종 값이 리턴됩니다.\n\n커링 및 부분 적용^partial^ ^application^은 함수를 반환하는 행위입니다.\n```javascript\n  const highpass = cutoff => n => n >= cutoff;   \n  const gt4 = highpass(4);  // highpass() returns a new function\n```\n꼭 화살표 구문을 사용할 필요는 없습니다. JavaScript에는  `function`  키워드가 있습니다. 다만 `function`  키워드를 쓰면 타이핑을 조금 더 해야할 뿐입니다. 즉 아래의 `highpass`는 위의 정의와 동일합니다.\n```javascript\n  const highpass = function highpass(cutoff) {   \n\t  return function(n) {   \n\t\t  return n >= cutoff;   \n\t  };   \n  }; \n```\n화살표는 \"함수\"를 뜻합니다. 그러나 몇 가지 중요한 차이가 있습니다. ( `=>` 은 기본적으로 `this`가 없기 때문에 생성자로 사용할 수 없습니다)  이 주제에 관해선 나중에 더 깊게 알아볼 것입니다. 그러니 지금 당장은  `x => x`  라는 코드를 \"  `x` 를 받아  `x`를 리턴하는 **함수**\"라고 생각하십시오.  따라서 \n```javascript\n  const highpass = cutoff => n => n >= cutoff;\n```\n라는 코드는 다음처럼 읽으면 됩니다:\n\n>`highpass`  는  `cutoff`  를 받고  `n`을 받은 이후에  `n >= cutoff`  의 결과를 리턴하는 함수를 리턴하는 함수\n\n함수를 리턴하는`highpass()` 를 사용해 보다 특화된 함수를 만들 수 있습니다.\n```javascript\n  const gt4 = highpass(4); \n\n  gt4(6);  // true   \n  gt4(3);  // false \n```\nautocurry를 사용하면 최대한 유연한 방식으로 함수를 커링할 수 있습니다. \n```javascript\n  const add3 = curry((a, b, c) => a + b + c);\n```\nautocurry된 add3 함수는 다양한 방법으로 사용할 수 있습니다.\n```javascript\n  add3(1, 2, 3); // 6   \n  add3(1, 2)(3); // 6   \n  add3(1)(2, 3); // 6   \n  add3(1)(2)(3); // 6 \n```\n하스켈 팬에게는 죄송한 일이지만, JavaScript에서는 autocurry를 하기 위해 Lodash와 같은 라이브러리를 사용해야 합니다.\n```\n $ npm install --save lodash \n```\n`npm`으로 설치 한 다음 코드 상단에서 `import`하면 됩니다 :\n```javascript\n  import curry from 'lodash/curry';\n```\n아니면 다음처럼 마술을 부리면 됩니다.\n```javascript\n  // Tiny, recursive autocurry  \n  const curry = (f, arr = []) => (...args) => \n\t  (a => a.length === f.length ? f(...a) : curry(f, a))\n\t  ([...arr, ...args]);\n```\n## 함수 합성\n\n당연히 함수를 합성 할 수 있습니다. 함수 합성은 한 함수의 리턴 값을 다른 함수의 인수로 전달하는 과정입니다.  수학 표기법 :\n```\n f . g\n```\n\n는 JavaScript에서 다음과 같이 표현됩니다.\n```javascript\n  f (g (x)) \n```\n그리고 내부적으로 다음과 같이 계산됩니다 :\n\n1.  `x`  가 평가됩니다.\n2.  `x`에 `g()`가 적용됩니다.\n3.  `g(x)`의 반환 값에 `f()`가 적용됩니다.\n\n예 :\n```javascript\n  const inc = n => n + 1;   \n  inc(double(2));  // 5 \n```\n값  `2`  는  `double()`  으로 전달되어  `4`  를 생성합니다.  `4`  는  `inc()`  로 전달되고  `5`  평가됩니다.\n\n어떤 표현식을 함수의 인수로 전달할 수 있습니다.  이 때 표현식이 먼저 평가된 후 함수가 적용됩니다.\n```javascript\n  inc(double(2) * double(2));  // 17 \n```\n`double(2)`  은  `4` 로 평가되므로  `inc(4 * 4)` 가 된 후  `inc(16)`  로 평가되고  `17`이 리턴됩니다.\n\n함수 합성은 함수형 프로그래밍의 핵심입니다.  \n\n## 배열\n\n배열에는 몇 가지 내장 된 메소드가 있습니다.  메소드는 객체와 관련된 함수입니다. 일반적으로 객체의 속성^property^으로 존재합니다.\n```javascript\n  const arr = [1, 2, 3];   \n  arr.map(double);  // [2, 4, 6] \n```\n이 경우  `arr`  이 객체이고  `.map()` 함수가 값으로 할당되어있는 속성입니다.    이 함수를 호출하면 인수에 적용될 뿐만 아니라 `this`  라는 특수 매개 변수에도 적용됩니다.  `this`  매개 변수는 메소드가 호출 될 때 자동으로 설정됩니다. `map()` 메소드에서 배열의 값에 접근할 때`this`를 참조합니다.\n\n`double`  함수를 호출하는 `map`에 전달하는걸 잘 보십시오. `map`  은 함수를 인수로 받아여 배열의 각 항목에 적용합니다.  그리고 `double()`  의해 리턴 된 값으로 새로운 배열을 생성하여 리턴합니다.\n\n원래의  `arr`  값은 변하지 않습니다.\n```javascript\n  arr;  // [1, 2, 3] \n```\n## 메소드 체이닝\n\n메소드를 호출을 연결할 수도 있습니다.  메소드 체인은 리턴 값을 따로 변수에 저장하여 다시 참조 할 필요없이 함수의 리턴 값에 메소드를 계속해서 호출하는 프로세스입니다.\n```javascript\n  const arr = [1, 2, 3];   \n  arr.map(double).map(double);  // [4, 8, 12] \n```\n**predicate**  는 부울 값 (  `true`  또는  `false`  )을 리턴하는 함수입니다.  `.filter()`  메소드는 predicate를 인수로 받아 배열의 개별 항목에 적용합니다. 이 때 조건을 통과한(`true`를 반환) 항목만 선택하여 새 배열에 포함시켜 리턴합니다.\n```javascript\n  [2, 4, 6].filter(gt4);  // [4, 6] \n```\n배열에서 조건에 맞는 항목을 골라 매핑하는 상황은 자주 발생합니다.\n```javascript\n  [2, 4, 6].filter(gt4).map(double);  //[8, 12] \n```\n참고 : 이 시리즈의 뒷부분에는 선택과 매핑을 동시에 하는 더 효율적인 방법인 `transducer`가 나옵니다.  \n\n## 결론\n\n머리가 핑핑 돌고 있습니까? 걱정하지 마세요. 지금까지 배운 것들은 단지 맛보기에  지나지 않습니다. 앞으로도 계속 이 주제들이 반복적으로 그리고 좀 더 깊은 이해를 위해 등장할 것입니다.   \n\n[**다음: 고차 함수 >**](https://midojeong.github.io/2018/03/29/higher-order-functions)\n\n","slug":"a-functional-programmers-introduction-to-javascript","published":1,"updated":"2018-04-06T09:33:13.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83c20003ifp6cjmcoqvc","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/a-functional-programmers-introduction-to-javascript-composing-software-d670d14ede30\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/03/29/higher-order-functions\">다음&gt;</a></p>\n</blockquote>\n<p>이 편은 JavaScript 또는 ES6 +에 익숙하지 않은 독자를 위한 간단한 입문 글입니다. 당신이 초보자이든 숙련된 JavaScript 개발자이든 아마 새로 배울 것들이 있을 겁니다.  사실 이번 편은 단순히 주제의 겉표면을 훑으며 관심을 환기하기 위해 작성됐습니다. 더 많이 알고 싶다면 더 깊게 탐구하면 됩니다. 이 글은 계속 연재될 것이며 아직 다룰 주제들은 많이 남아있습니다.</p>\n<p>코딩을 배우는 가장 좋은 방법은 직접 작성해보는 것입니다.  <a href=\"https://codepen.io/\" target=\"_blank\" rel=\"noopener\">CodePen</a>  이나  <a href=\"https://babeljs.io/repl/\" target=\"_blank\" rel=\"noopener\">Babel REPL</a>  과 같은 대화 형 JavaScript 프로그래밍 환경을 사용하는 것이 좋습니다.</p>\n<p>NodeJS 또는 브라우저 콘솔의 REPL을 사용해도 됩니다.</p>\n<h2 id=\"표현식과-값expressions-and-values\">표현식과 값Expressions and Values</h2>\n<p>표현식은 값으로 평가되는 코드 덩어리입니다.</p>\n<p>다음은 JavaScript에서 유효한 표현식입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">7</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7</span> + <span class=\"number\">1</span>;  <span class=\"comment\">// 8 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7</span> * <span class=\"number\">2</span>;  <span class=\"comment\">// 14 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'Hello'</span>; <span class=\"comment\">// Hello</span></span><br></pre></td></tr></table></figure>\n<p>표현식의 값에는 이름을 붙일 수 있습니다.  이 때 표현식이 먼저 평가되고 결과 값이 이름에 저장됩니다.  변수를 선언하기 위해  <code>const</code>  키워드를 사용합니다.  여러 방법이 있지만, <code>const</code>를 가장 많이 사용하게 될 것입니다.  따라서 우리는 지금부터  <code>const</code>  를 사용 할 것입니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"string\">'Hello'</span>;   </span><br><span class=\"line\">hello; <span class=\"comment\">// Hello</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"var-let-및-const\">var, let 및 const</h2>\n<p>JavaScript는 <code>const</code> 외에도   <code>var</code>  과  <code>let</code>이라는 두 종류의 변수 선언 키워드가 있습니다.  저는 이들을 순서에 맞게 사용할 것입니다.  기본적으로 가장 엄격한 선언인  <code>const</code>를  선택합니다.  <code>const</code>  키워드로 선언 된 변수는 재 할당 할 수 없습니다.  즉, 선언할 때 최종 값이 저장됩니다.  이는 엄격하다고 여겨질 수도 있지만, 제약은 좋은 것입니다.  &quot;이 변수에 할당 된 값은 변경되지 않을 것입니다&quot;라는 신호입니다.  함수 전체나 블록 스코프를 찾아볼 필요 없이 변수의 의미를 즉시 이해할 수 있습니다.</p>\n<p>변수를 재 할당하는 것이 유용할 때가 있습니다.  예를 들어 함수형으로 접근하지 않고 직접 명령을 반복 실행할 경우 <code>let</code>으로  선언된 카운터 변수에 반복하여 할당 할 수 있습니다.</p>\n<p><code>var</code>은-이건 적어도 <strong>변수</strong>입니다-라는 약한 의미를 가집니다.  ES6으로 프로그래밍하기 시작한 이후 저는 실제 프로젝트에서  <code>var</code>  를 의도적으로 선언 한 적이 없습니다.</p>\n<p><code>let</code>  또는  <code>const</code> 로 선언된 변수를 다시 선언하면 오류가 발생합니다.  REPL (Read, Eval, Print Loop) 환경에서 실험적인 목적으로 코딩을 할 경우 이들 대신  <code>var</code>  를 사용하여 변수를 선언하는게 적합합니다.</p>\n<p>실제 프로그램을 작성할 때 기본적으로 <code>const</code>를 사용하기 때문에 이 글에서도 <code>const</code>를 사용할 것입니다. 다만 실험을 위해서라면 자유롭게 <code>var</code>  을 사용하십시오.</p>\n<h2 id=\"타입\">타입</h2>\n<p>지금까지 두 가지 타입을 보았습니다 : 숫자와 문자열.  이 외에도 JavaScript에는 부울 (  <code>true</code>  또는  <code>false</code>  ), 배열, 객체 등이 있습니다.  우리는 나중에 다른 타입을 얻을 것입니다.</p>\n<p>배열은 순서가 있는 목록입니다.  다양한 항목을 담을 수있는 상자라고 생각하면 됩니다.  다음은 배열 리터럴 표기법입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>변수에 할당할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>JavaScript의 객체는 key : value 쌍의 모음입니다.  표기법은 다음과 같습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;   </span><br><span class=\"line\"> key : <span class=\"string\">'value'</span>   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>물론 변수에 할당 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;   </span><br><span class=\"line\"> bar : <span class=\"string\">'bar'</span>   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>변수의 이름과 값으로 객체를 생성할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"string\">'a'</span>;   </span><br><span class=\"line\"><span class=\"keyword\">const</span> oldA = &#123;<span class=\"attr\">a</span> : a&#125;;  <span class=\"comment\">// long, redundant way   </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> oA = &#123;a&#125;;  <span class=\"comment\">// short an sweet!</span></span><br></pre></td></tr></table></figure>\n<p>다시 한번 해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"string\">'b'</span>;   </span><br><span class=\"line\"><span class=\"keyword\">const</span> oB = &#123;b&#125;;</span><br></pre></td></tr></table></figure>\n<p>객체들로 새로운 객체를 쉽게 합성할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> c = &#123;...oA, ...oB&#125;;  <span class=\"comment\">// &#123;a : 'a', b : 'b'&#125;</span></span><br></pre></td></tr></table></figure>\n<p><code>...</code>은 객체 스프레드 연산자입니다.  <code>oA</code> 의 프로퍼티들을 반복하여 새로운 객체에 할당한 다음  <code>oB</code>  대해 동일한 작업을 수행합니다. 이 때 키가 중복되는 경우 이미 존재하는 키를 덮어씁니다.  이 글을 쓰는 시점에서 객체 스프레드는 아직 대중적인 브라우저에서 사용할 수 없는 실험적인 기능입니다. 브라우저가 지원하지 않을 경우 <code>Object.assign()</code>으로 대체 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"built_in\">Object</span>.assign (&#123;&#125;, oA, oB);  </span><br><span class=\"line\"><span class=\"comment\">// &#123;a : 'a', b : 'b'&#125;</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.assign()</code> 은 객체 스프레드보다 조금만 더 타이핑하면 됩니다. 수많은 객체를 합성해야 하는 경우 타이핑을 줄일 수 있습니다.  <code>Object.assign()</code>  을 사용할 때 최종적으로 리턴될 객체를 첫 번째 매개 변수로 전달해야합니다.  속성들을 복사 할 개체 말입니다.  만약 이를 생략하면 첫 번째 인수로 전달한 객체가 변경됩니다.</p>\n<p>제 경험상, 새로운 객체를 만드는 것이 아닌 기존의 객체를 변경하는 것은 일반적으로 버그를 일으킬 여지가 많습니다. <code>Object.assign()</code>을 사용할 때는 이를 주의하십시오.</p>\n<h2 id=\"해체-혹은-비구조화destructuring1\">해체 혹은 비구조화<sup>destructuring</sup><sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h2>\n<p>객체와 배열 모두 해체를 지원합니다. 즉, 객체에서 값을 꺼내 변수에 할당 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [t, u] = [ <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\">t;  <span class=\"comment\">// 'a'   </span></span><br><span class=\"line\">u;  <span class=\"comment\">// 'b' </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> blep = &#123;   </span><br><span class=\"line\"> blop: <span class=\"string\">'blop'</span></span><br><span class=\"line\">&#125;;   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The following is equivalent to</span></span><br><span class=\"line\"><span class=\"comment\">// const blop = blep.blop;   </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;blop&#125; = blep;   </span><br><span class=\"line\">blop;  <span class=\"comment\">// 'blop' </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Also equivalent to</span></span><br><span class=\"line\"><span class=\"comment\">// const a = this.state.a;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;a&#125; = <span class=\"keyword\">this</span>.state;</span><br></pre></td></tr></table></figure>\n<p>위의 배열 예제 처럼 동시에 여러 변수에 할당할 수 있습니다. 다음은 Redux 프로젝트에서 자주 볼 수 있는 코드입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;type, payload&#125; = action;</span><br></pre></td></tr></table></figure>\n<p>Reducer에서 다음과 같이 사용합니다. (Reducer는 나중 글에서 설명할 것입니다)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myReducer = <span class=\"function\">(<span class=\"params\">state = &#123;&#125;, action = &#123;&#125;</span>) =&gt;</span> &#123;   </span><br><span class=\"line\"> <span class=\"keyword\">const</span> &#123;type, payload&#125; = action;   </span><br><span class=\"line\"> <span class=\"keyword\">switch</span> (type) &#123;   </span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'FOO'</span>: <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign (&#123;&#125;, state, payload);   </span><br><span class=\"line\">  <span class=\"keyword\">default</span> : <span class=\"keyword\">return</span> state;   </span><br><span class=\"line\"> &#125;   </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>새로운 이름으로 할당 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"attr\">blop</span>: bloop &#125; = blep;   </span><br><span class=\"line\">bloop; <span class=\"comment\">// 'blop'`</span></span><br></pre></td></tr></table></figure>\n<p><code>blep.blop</code>  을  <code>bloop</code>에 할당했다 라고 읽으면 됩니다.</p>\n<h2 id=\"비교-및-삼항-연산자\">비교 및 삼항 연산자</h2>\n<p>값을 비교할 때는 완전 항등 연산자(&quot;triple equals&quot;라고 함)를 사용합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span> + <span class=\"number\">1</span> === <span class=\"number\">4</span>;  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>물론 다른 항등 연산자가 있습니다.  공식적으로 &quot;동등&quot;연산자라고합니다.  비공식적으로 &quot;double equals&quot;라고 합니다. double equals는 한두가지 정도 의미있게 사용할  상황이 있습니다. 그 외에는 항상  <code>===</code>  연산자로 비교하는 것이 좋습니다.</p>\n<p>이외에도 다음과같은 비교 연산자들이 있습니다.</p>\n<ul>\n<li><code>&gt;</code>  보다 큼</li>\n<li><code>&lt;</code>  보다 작음</li>\n<li><code>&gt;=</code>  크거나 같음</li>\n<li><code>&lt;=</code>  작거나 같음</li>\n<li><code>!=</code>  같지 않음</li>\n<li><code>!==</code> 엄격하게 같지 않음</li>\n<li><code>&amp;&amp;</code>  논리 곱</li>\n<li><code>||</code>  논리 합</li>\n</ul>\n<p>삼항 표현식은 삼항 연산자를 사용한 표현식입니다. 조건이 참이냐 거짓이냐에 따라 다른 값으로 평가됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">14</span> - <span class=\"number\">7</span> === <span class=\"number\">7</span>?  <span class=\"string\">'Yep!'</span>  : <span class=\"string\">'Nope.'</span>;  <span class=\"comment\">// Yep!</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"함수\">함수</h2>\n<p>JavaScript에는 함수 표현식이 있으며 이는 변수에 할당 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>위 코드는 수학에서의 함수  <code>f(x) = 2x</code>  와 같습니다.  소리내어 읽을 경우 <code>f</code> <code>x</code>는 <code>2x</code> 라고 읽습니다. 이 함수는  <code>x</code>에 특정한 값을 적용 할 때만 의미가 생깁니다. 다른 식에서 이 함수를 사용하려면  <code>f(2)</code>라고 쓰면 됩니다.  <code>f(2)</code>  는  <code>4</code>와 같은 의미입니다.</p>\n<p>즉,  <code>f(2) = 4</code>  입니다.  수학의 함수는 입력에서 출력으로의 매핑이라고 생각할 수 있습니다.  이 경우  <code>f(x)</code>  는  <code>x</code>  에 대한 입력 값을 입력 값과  <code>2</code>  의 곱과 동일한 해당 출력 값에 매핑하는 것입니다.</p>\n<p>자바 스크립트에서 함수 표현식의 값은 함수 그 자체입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double;  <span class=\"comment\">// [Function : double]</span></span><br></pre></td></tr></table></figure>\n<p><code>.toString()</code>  메서드를 사용하여 함수 정의를 볼 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double.toString ();  <span class=\"comment\">// 'x =&gt; x * 2'</span></span><br></pre></td></tr></table></figure>\n<p>특정 인수(값)에 함수를 적용하려면 함수를 호출해야합니다.  함수 호출이란 인수에 함수를 적용하고 평가된 값을 리턴받는 것입니다.</p>\n<p><code>&lt;functionName&gt;(argument1, argument2, ...rest)</code> 와 같은 문법으로 함수를 호출 할 수 있습니다.  예를 들어 double 함수를 호출하려면 괄호를 추가하고 double 값을 전달하면됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double(<span class=\"number\">2</span>);  <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p>일부 함수형 언어들과는 달리 괄호가 필수입니다. 괄호가 없으면 함수는 호출되지 않습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double <span class=\"number\">4</span>;  <span class=\"comment\">// SyntaxError : Unexpected number</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"서명-혹은-시그니처\">서명 혹은 시그니처</h2>\n<p>함수들은 다음과 같이 서명을 가집니다.</p>\n<ol>\n<li>함수 이름(선택사항)</li>\n<li>인자 타입 목록(매개 변수의 이름은 선택사항)</li>\n<li>리턴 타입</li>\n</ol>\n<p>JavaScript의 함수서명에는 타입을 명시하지 않아도 됩니다.  JavaScript 엔진은 런타임에 타입을 파악합니다.  충분한 단서들을 제공할 경우 IDE (Integrated Development Environment) 및  <a href=\"http://ternjs.net/\" target=\"_blank\" rel=\"noopener\">Tern.js</a>  와 같은 개발자 도구에서는 데이터 흐름을 분석하여 서명을 유추해내기도 합니다.</p>\n<p>자바 스크립트는 함수 서명에 대한 표준이 없기 때문에 여러 표준들이 경쟁을 하는 상황입니다. JSDoc은 오랫동안 쓰여왔지만 장황하고 다소 어색합니다.  대부분의 사람들은 코드에 대한 주석을 최신화하는데 별로 관심이 없기에 많은 JS 개발자가 더 이상 사용하지 않습니다.</p>\n<p>가장 인기 있는 두 표준 TypeScript와 Flow가 있습니다. 저는 둘중 어떠한 것이 더 나은지 확실하지 않습니다. 따라서 저는   <a href=\"https://github.com/ericelliott/rtype\" target=\"_blank\" rel=\"noopener\">Rtype</a>을 사용합니다. 어떤 사람들은 커리<sup>curry</sup>를 위해 하스켈 전용  <a href=\"http://web.cs.wpi.edu/~cs4536/c12/milner-damas_principal_types.pdf\" target=\"_blank\" rel=\"noopener\">Hindley-Milner Type</a> 을 꺼내들기도 합니다. 저는 JavaScript 문서화를 위해 얼른 좋은 표기법이 표준화되어야 한다고 봅니다. 그러나 지금 나와있는 해결책 중 어느것도 완벽하다고 할 수 없습니다.  당분간 여러분이 사용하고있는 것과는 약간 다른 문법으로 쓰인 다양한 유형의 서명들을 이해하기 위해 최선을 다해야 할 것입니다.</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">functionName (param1 : <span class=\"keyword\">Type</span>, param2 : <span class=\"keyword\">Type</span>) =&gt; <span class=\"keyword\">Type</span></span><br></pre></td></tr></table></figure>\n<p>double 함수의 서명은 다음과 같습니다.</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">double</span> (x : n) =&gt; Number</span><br></pre></td></tr></table></figure>\n<p>JavaScript는 강제로 주석을 달지 않아도 된다는 사실에도 불구하고, 함수를 사용할 때 그리고 합성할 때 효율적으로 의사소통을 하기 위해 서명에 의미를 재빨리 파악할 수 있는 것이 중요합니다. 함수 합성에 관련된 대부분의 라이브러리들은 동일한 타입의 서명을 가진 함수를 전달할 것을 요구합니다.</p>\n<h2 id=\"기본-매개-변수-값default-parameter-values\">기본 매개 변수 값<sup>default</sup> <sup>parameter</sup> <sup>values</sup></h2>\n<p>JavaScript는 기본 매개 변수 값을 지원합니다.  다음 함수는 전달받은 값을 그대로 리턴하는 항등<sup>identity</sup>함수입니다.  그러나 <code>undefined</code>를 인수로 전달받거나 아무 인수도 전달받지 않은 경우 0을 리턴합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> orZero = <span class=\"function\">(<span class=\"params\">n = <span class=\"number\">0</span></span>) =&gt;</span> n;</span><br></pre></td></tr></table></figure>\n<p>기본값을 설정하려면  <code>n = 0</code> 처럼 <code>=</code>  연산자를 사용하여 매개 변수에 값을 할당하기만 하면 됩니다.  이런 식으로 기본값을 지정하면  <a href=\"http://ternjs.net/\" target=\"_blank\" rel=\"noopener\">Tern.js</a>  , Flow 또는 TypeScript를 사용할 때 함수의 형식과 서명을 주석으로 명시하지 않아도 이를 자동으로 유추 할 수 있습니다.</p>\n<p>기본 매개 변수값을 지정하고 텍스트 에디터나 IDE에 관련 플러그인을 설치하면 함수를 사용하려고 할 때 함수 서명이 표시됩니다. 또한 함수를 사용하는 방법을 파악하기 쉽습니다. 이는 코드 자체가 곧 문서가 될 수 있는 중요한 접근방법입니다.</p>\n<blockquote>\n<p>참고 : 기본값이 있는 매개 변수는 함수의  <code>.length</code>  속성에서 제외됩니다. 즉 <code>length</code>값을 참조하는 autocurry 라이브러리를 사용할 때 문제가 발생할 수 있습니다. 그러나 일부 currying 라이브러리 (예 :  <code>lodash/curry</code>  )에서는 함수 인자의 개수<sup>arity</sup>를 임의로 전달 하는 옵션이 있습니다.</p>\n</blockquote>\n<h2 id=\"해체-할당과-기본값\">해체-할당과 기본값</h2>\n<p>JavaScript 함수에서 객체 리터럴을 받아 해제-할당하면 이를 보통 인수처럼 사용할 수 있습니다. 이 때도 마찬가지로 기본 매개 변수 기능을 사용하여 기본값을 할당 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = (&#123;   </span><br><span class=\"line\"> name = <span class=\"string\">'Anonymous'</span>,   </span><br><span class=\"line\"> avatarThumbnail = <span class=\"string\">'/avatars/anonymous.png'</span>   </span><br><span class=\"line\">&#125;) =&gt; (&#123;   </span><br><span class=\"line\"> name,   </span><br><span class=\"line\"> avatarThumbnail   </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> george = createUser (&#123;   </span><br><span class=\"line\"> name : <span class=\"string\">'George'</span>   </span><br><span class=\"line\"> avataThumbnail : <span class=\"string\">'avatars/shades-emoji.png'</span>   </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">george;   </span><br><span class=\"line\"><span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">&#123;   </span></span><br><span class=\"line\"><span class=\"comment\"> name : 'george'   </span></span><br><span class=\"line\"><span class=\"comment\"> avatarThumbnail : 'avatars/shades-emoji.png'   </span></span><br><span class=\"line\"><span class=\"comment\">&#125;   </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"나머지와-스프레드-연산자\">나머지와 스프레드 연산자</h2>\n<p>나머지 연산자<code>...</code>를 사용해서 함수의 정해지지 않은 인수들을 배열로 참조할 수 있습니다.</p>\n<p>예를 들어 다음 함수는 첫 번째 인수를 버리고 나머지를 배열로 리턴합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> aTail = <span class=\"function\">(<span class=\"params\">head, ...tail</span>) =&gt;</span> tail;   </span><br><span class=\"line\">aTail(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// [2, 3]</span></span><br></pre></td></tr></table></figure>\n<p>나머지 구문은 개별 요소를 배열로 만듭니다. 스프레드는 반대의 역할을합니다. 즉, 주어진 배열을 개별 요소로 퍼트립니다. 나머지와 스프레드는 같은 형태를 가지지만 사용법이 다릅니다. 이를 주의해서 다음 코드를 참고하세요:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> shiftToLast = <span class=\"function\">(<span class=\"params\">head, ...tail</span>) =&gt;</span> [...tail, head];   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 첫 번째 ...tail은 나머지연산자가 사용되었고 뒤에는 스프레드</span></span><br><span class=\"line\"><span class=\"comment\">   연산자가 사용되었습니다.*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">shiftToLast(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// [2, 3, 1]</span></span><br></pre></td></tr></table></figure>\n<p>JavaScript의 배열에 있는 iterator는 스프레드 연산자가 사용될 때 함께 호출됩니다. iterator는 배열의 요소 값들을 반복해서 리턴합니다. <code>[...tail, head]</code>  표현식에서 iterator는 나머지 구문으로 전달받은  <code>tail</code> 배열에서 값을 하나씩 꺼내 새로운 배열 리터럴에 복사합니다. <code>head</code>는 이미 개별 요소이기 때문에 배열의 끝 부분에 붙이면 됩니다.</p>\n<h2 id=\"커링currying\">커링<sup>currying</sup></h2>\n<p>커리된 함수는 한 번에 하나씩 여러 인자를 받는 함수입니다. 인자를 받아 그 다음인자의 입력을 기다리는 함수를 리턴합니다. 모든 인자가 채워지면 최종 값이 리턴됩니다.</p>\n<p>커링 및 부분 적용<sup>partial</sup> <sup>application</sup>은 함수를 반환하는 행위입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> highpass = <span class=\"function\"><span class=\"params\">cutoff</span> =&gt;</span> n =&gt; n &gt;= cutoff;   </span><br><span class=\"line\"><span class=\"keyword\">const</span> gt4 = highpass(<span class=\"number\">4</span>);  <span class=\"comment\">// highpass() returns a new function</span></span><br></pre></td></tr></table></figure>\n<p>꼭 화살표 구문을 사용할 필요는 없습니다. JavaScript에는  <code>function</code>  키워드가 있습니다. 다만 <code>function</code>  키워드를 쓰면 타이핑을 조금 더 해야할 뿐입니다. 즉 아래의 <code>highpass</code>는 위의 정의와 동일합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> highpass = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">highpass</span>(<span class=\"params\">cutoff</span>) </span>&#123;   </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>) </span>&#123;   </span><br><span class=\"line\">  <span class=\"keyword\">return</span> n &gt;= cutoff;   </span><br><span class=\"line\"> &#125;;   </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>화살표는 &quot;함수&quot;를 뜻합니다. 그러나 몇 가지 중요한 차이가 있습니다. ( <code>=&gt;</code> 은 기본적으로 <code>this</code>가 없기 때문에 생성자로 사용할 수 없습니다)  이 주제에 관해선 나중에 더 깊게 알아볼 것입니다. 그러니 지금 당장은  <code>x =&gt; x</code>  라는 코드를 &quot;  <code>x</code> 를 받아  <code>x</code>를 리턴하는 <strong>함수</strong>&quot;라고 생각하십시오.  따라서</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> highpass = <span class=\"function\"><span class=\"params\">cutoff</span> =&gt;</span> n =&gt; n &gt;= cutoff;</span><br></pre></td></tr></table></figure>\n<p>라는 코드는 다음처럼 읽으면 됩니다:</p>\n<blockquote>\n<p><code>highpass</code>  는  <code>cutoff</code>  를 받고  <code>n</code>을 받은 이후에  <code>n &gt;= cutoff</code>  의 결과를 리턴하는 함수를 리턴하는 함수</p>\n</blockquote>\n<p>함수를 리턴하는<code>highpass()</code> 를 사용해 보다 특화된 함수를 만들 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gt4 = highpass(<span class=\"number\">4</span>); </span><br><span class=\"line\"></span><br><span class=\"line\">gt4(<span class=\"number\">6</span>);  <span class=\"comment\">// true   </span></span><br><span class=\"line\">gt4(<span class=\"number\">3</span>);  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>autocurry를 사용하면 최대한 유연한 방식으로 함수를 커링할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add3 = curry(<span class=\"function\">(<span class=\"params\">a, b, c</span>) =&gt;</span> a + b + c);</span><br></pre></td></tr></table></figure>\n<p>autocurry된 add3 함수는 다양한 방법으로 사용할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add3(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 6   </span></span><br><span class=\"line\">add3(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>); <span class=\"comment\">// 6   </span></span><br><span class=\"line\">add3(<span class=\"number\">1</span>)(<span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 6   </span></span><br><span class=\"line\">add3(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n<p>하스켈 팬에게는 죄송한 일이지만, JavaScript에서는 autocurry를 하기 위해 Lodash와 같은 라이브러리를 사용해야 합니다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install --save lodash</span></span><br></pre></td></tr></table></figure>\n<p><code>npm</code>으로 설치 한 다음 코드 상단에서 <code>import</code>하면 됩니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> curry <span class=\"keyword\">from</span> <span class=\"string\">'lodash/curry'</span>;</span><br></pre></td></tr></table></figure>\n<p>아니면 다음처럼 마술을 부리면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Tiny, recursive autocurry  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> curry = <span class=\"function\">(<span class=\"params\">f, arr = []</span>) =&gt;</span> (...args) =&gt; </span><br><span class=\"line\"> (<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a.length === f.length ? f(...a) : curry(f, a))</span><br><span class=\"line\"> ([...arr, ...args]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"함수-합성\">함수 합성</h2>\n<p>당연히 함수를 합성 할 수 있습니다. 함수 합성은 한 함수의 리턴 값을 다른 함수의 인수로 전달하는 과정입니다.  수학 표기법 :</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">f</span> . g</span><br></pre></td></tr></table></figure>\n<p>는 JavaScript에서 다음과 같이 표현됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f (g (x))</span><br></pre></td></tr></table></figure>\n<p>그리고 내부적으로 다음과 같이 계산됩니다 :</p>\n<ol>\n<li><code>x</code>  가 평가됩니다.</li>\n<li><code>x</code>에 <code>g()</code>가 적용됩니다.</li>\n<li><code>g(x)</code>의 반환 값에 <code>f()</code>가 적용됩니다.</li>\n</ol>\n<p>예 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inc = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;   </span><br><span class=\"line\">inc(double(<span class=\"number\">2</span>));  <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>값  <code>2</code>  는  <code>double()</code>  으로 전달되어  <code>4</code>  를 생성합니다.  <code>4</code>  는  <code>inc()</code>  로 전달되고  <code>5</code>  평가됩니다.</p>\n<p>어떤 표현식을 함수의 인수로 전달할 수 있습니다.  이 때 표현식이 먼저 평가된 후 함수가 적용됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inc(double(<span class=\"number\">2</span>) * double(<span class=\"number\">2</span>));  <span class=\"comment\">// 17</span></span><br></pre></td></tr></table></figure>\n<p><code>double(2)</code>  은  <code>4</code> 로 평가되므로  <code>inc(4 * 4)</code> 가 된 후  <code>inc(16)</code>  로 평가되고  <code>17</code>이 리턴됩니다.</p>\n<p>함수 합성은 함수형 프로그래밍의 핵심입니다.</p>\n<h2 id=\"배열\">배열</h2>\n<p>배열에는 몇 가지 내장 된 메소드가 있습니다.  메소드는 객체와 관련된 함수입니다. 일반적으로 객체의 속성<sup>property</sup>으로 존재합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];   </span><br><span class=\"line\">arr.map(double);  <span class=\"comment\">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>\n<p>이 경우  <code>arr</code>  이 객체이고  <code>.map()</code> 함수가 값으로 할당되어있는 속성입니다.    이 함수를 호출하면 인수에 적용될 뿐만 아니라 <code>this</code>  라는 특수 매개 변수에도 적용됩니다.  <code>this</code>  매개 변수는 메소드가 호출 될 때 자동으로 설정됩니다. <code>map()</code> 메소드에서 배열의 값에 접근할 때<code>this</code>를 참조합니다.</p>\n<p><code>double</code>  함수를 호출하는 <code>map</code>에 전달하는걸 잘 보십시오. <code>map</code>  은 함수를 인수로 받아여 배열의 각 항목에 적용합니다.  그리고 <code>double()</code>  의해 리턴 된 값으로 새로운 배열을 생성하여 리턴합니다.</p>\n<p>원래의  <code>arr</code>  값은 변하지 않습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr;  <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"메소드-체이닝\">메소드 체이닝</h2>\n<p>메소드를 호출을 연결할 수도 있습니다.  메소드 체인은 리턴 값을 따로 변수에 저장하여 다시 참조 할 필요없이 함수의 리턴 값에 메소드를 계속해서 호출하는 프로세스입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];   </span><br><span class=\"line\">arr.map(double).map(double);  <span class=\"comment\">// [4, 8, 12]</span></span><br></pre></td></tr></table></figure>\n<p><strong>predicate</strong>  는 부울 값 (  <code>true</code>  또는  <code>false</code>  )을 리턴하는 함수입니다.  <code>.filter()</code>  메소드는 predicate를 인수로 받아 배열의 개별 항목에 적용합니다. 이 때 조건을 통과한(<code>true</code>를 반환) 항목만 선택하여 새 배열에 포함시켜 리턴합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>].filter(gt4);  <span class=\"comment\">// [4, 6]</span></span><br></pre></td></tr></table></figure>\n<p>배열에서 조건에 맞는 항목을 골라 매핑하는 상황은 자주 발생합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>].filter(gt4).map(double);  <span class=\"comment\">//[8, 12]</span></span><br></pre></td></tr></table></figure>\n<p>참고 : 이 시리즈의 뒷부분에는 선택과 매핑을 동시에 하는 더 효율적인 방법인 <code>transducer</code>가 나옵니다.</p>\n<h2 id=\"결론\">결론</h2>\n<p>머리가 핑핑 돌고 있습니까? 걱정하지 마세요. 지금까지 배운 것들은 단지 맛보기에  지나지 않습니다. 앞으로도 계속 이 주제들이 반복적으로 그리고 좀 더 깊은 이해를 위해 등장할 것입니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/03/29/higher-order-functions\"><strong>다음: 고차 함수 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>MDN 번역문서에는 비구조화라고 번역되어있습니다. 그러나 다른 많은 번역글에서 해체라고 번역이 되었으며 역자는 해체라는 용어를 사용하겠습니다. <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/a-functional-programmers-introduction-to-javascript-composing-software-d670d14ede30\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/03/29/higher-order-functions\">다음&gt;</a></p>\n</blockquote>\n<p>이 편은 JavaScript 또는 ES6 +에 익숙하지 않은 독자를 위한 간단한 입문 글입니다. 당신이 초보자이든 숙련된 JavaScript 개발자이든 아마 새로 배울 것들이 있을 겁니다.  사실 이번 편은 단순히 주제의 겉표면을 훑으며 관심을 환기하기 위해 작성됐습니다. 더 많이 알고 싶다면 더 깊게 탐구하면 됩니다. 이 글은 계속 연재될 것이며 아직 다룰 주제들은 많이 남아있습니다.</p>\n<p>코딩을 배우는 가장 좋은 방법은 직접 작성해보는 것입니다.  <a href=\"https://codepen.io/\" target=\"_blank\" rel=\"noopener\">CodePen</a>  이나  <a href=\"https://babeljs.io/repl/\" target=\"_blank\" rel=\"noopener\">Babel REPL</a>  과 같은 대화 형 JavaScript 프로그래밍 환경을 사용하는 것이 좋습니다.</p>\n<p>NodeJS 또는 브라우저 콘솔의 REPL을 사용해도 됩니다.</p>\n<h2>표현식과 값Expressions and Values</h2>\n<p>표현식은 값으로 평가되는 코드 덩어리입니다.</p>\n<p>다음은 JavaScript에서 유효한 표현식입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">7</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7</span> + <span class=\"number\">1</span>;  <span class=\"comment\">// 8 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7</span> * <span class=\"number\">2</span>;  <span class=\"comment\">// 14 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'Hello'</span>; <span class=\"comment\">// Hello</span></span><br></pre></td></tr></table></figure>\n<p>표현식의 값에는 이름을 붙일 수 있습니다.  이 때 표현식이 먼저 평가되고 결과 값이 이름에 저장됩니다.  변수를 선언하기 위해  <code>const</code>  키워드를 사용합니다.  여러 방법이 있지만, <code>const</code>를 가장 많이 사용하게 될 것입니다.  따라서 우리는 지금부터  <code>const</code>  를 사용 할 것입니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"string\">'Hello'</span>;   </span><br><span class=\"line\">hello; <span class=\"comment\">// Hello</span></span><br></pre></td></tr></table></figure>\n<h2>var, let 및 const</h2>\n<p>JavaScript는 <code>const</code> 외에도   <code>var</code>  과  <code>let</code>이라는 두 종류의 변수 선언 키워드가 있습니다.  저는 이들을 순서에 맞게 사용할 것입니다.  기본적으로 가장 엄격한 선언인  <code>const</code>를  선택합니다.  <code>const</code>  키워드로 선언 된 변수는 재 할당 할 수 없습니다.  즉, 선언할 때 최종 값이 저장됩니다.  이는 엄격하다고 여겨질 수도 있지만, 제약은 좋은 것입니다.  &quot;이 변수에 할당 된 값은 변경되지 않을 것입니다&quot;라는 신호입니다.  함수 전체나 블록 스코프를 찾아볼 필요 없이 변수의 의미를 즉시 이해할 수 있습니다.</p>\n<p>변수를 재 할당하는 것이 유용할 때가 있습니다.  예를 들어 함수형으로 접근하지 않고 직접 명령을 반복 실행할 경우 <code>let</code>으로  선언된 카운터 변수에 반복하여 할당 할 수 있습니다.</p>\n<p><code>var</code>은-이건 적어도 <strong>변수</strong>입니다-라는 약한 의미를 가집니다.  ES6으로 프로그래밍하기 시작한 이후 저는 실제 프로젝트에서  <code>var</code>  를 의도적으로 선언 한 적이 없습니다.</p>\n<p><code>let</code>  또는  <code>const</code> 로 선언된 변수를 다시 선언하면 오류가 발생합니다.  REPL (Read, Eval, Print Loop) 환경에서 실험적인 목적으로 코딩을 할 경우 이들 대신  <code>var</code>  를 사용하여 변수를 선언하는게 적합합니다.</p>\n<p>실제 프로그램을 작성할 때 기본적으로 <code>const</code>를 사용하기 때문에 이 글에서도 <code>const</code>를 사용할 것입니다. 다만 실험을 위해서라면 자유롭게 <code>var</code>  을 사용하십시오.</p>\n<h2>타입</h2>\n<p>지금까지 두 가지 타입을 보았습니다 : 숫자와 문자열.  이 외에도 JavaScript에는 부울 (  <code>true</code>  또는  <code>false</code>  ), 배열, 객체 등이 있습니다.  우리는 나중에 다른 타입을 얻을 것입니다.</p>\n<p>배열은 순서가 있는 목록입니다.  다양한 항목을 담을 수있는 상자라고 생각하면 됩니다.  다음은 배열 리터럴 표기법입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>변수에 할당할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>JavaScript의 객체는 key : value 쌍의 모음입니다.  표기법은 다음과 같습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;   </span><br><span class=\"line\"> key : <span class=\"string\">'value'</span>   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>물론 변수에 할당 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;   </span><br><span class=\"line\"> bar : <span class=\"string\">'bar'</span>   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>변수의 이름과 값으로 객체를 생성할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"string\">'a'</span>;   </span><br><span class=\"line\"><span class=\"keyword\">const</span> oldA = &#123;<span class=\"attr\">a</span> : a&#125;;  <span class=\"comment\">// long, redundant way   </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> oA = &#123;a&#125;;  <span class=\"comment\">// short an sweet!</span></span><br></pre></td></tr></table></figure>\n<p>다시 한번 해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"string\">'b'</span>;   </span><br><span class=\"line\"><span class=\"keyword\">const</span> oB = &#123;b&#125;;</span><br></pre></td></tr></table></figure>\n<p>객체들로 새로운 객체를 쉽게 합성할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> c = &#123;...oA, ...oB&#125;;  <span class=\"comment\">// &#123;a : 'a', b : 'b'&#125;</span></span><br></pre></td></tr></table></figure>\n<p><code>...</code>은 객체 스프레드 연산자입니다.  <code>oA</code> 의 프로퍼티들을 반복하여 새로운 객체에 할당한 다음  <code>oB</code>  대해 동일한 작업을 수행합니다. 이 때 키가 중복되는 경우 이미 존재하는 키를 덮어씁니다.  이 글을 쓰는 시점에서 객체 스프레드는 아직 대중적인 브라우저에서 사용할 수 없는 실험적인 기능입니다. 브라우저가 지원하지 않을 경우 <code>Object.assign()</code>으로 대체 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"built_in\">Object</span>.assign (&#123;&#125;, oA, oB);  </span><br><span class=\"line\"><span class=\"comment\">// &#123;a : 'a', b : 'b'&#125;</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.assign()</code> 은 객체 스프레드보다 조금만 더 타이핑하면 됩니다. 수많은 객체를 합성해야 하는 경우 타이핑을 줄일 수 있습니다.  <code>Object.assign()</code>  을 사용할 때 최종적으로 리턴될 객체를 첫 번째 매개 변수로 전달해야합니다.  속성들을 복사 할 개체 말입니다.  만약 이를 생략하면 첫 번째 인수로 전달한 객체가 변경됩니다.</p>\n<p>제 경험상, 새로운 객체를 만드는 것이 아닌 기존의 객체를 변경하는 것은 일반적으로 버그를 일으킬 여지가 많습니다. <code>Object.assign()</code>을 사용할 때는 이를 주의하십시오.</p>\n<h2>해체 혹은 비구조화<sup>destructuring</sup><sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h2>\n<p>객체와 배열 모두 해체를 지원합니다. 즉, 객체에서 값을 꺼내 변수에 할당 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [t, u] = [ <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\">t;  <span class=\"comment\">// 'a'   </span></span><br><span class=\"line\">u;  <span class=\"comment\">// 'b' </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> blep = &#123;   </span><br><span class=\"line\"> blop: <span class=\"string\">'blop'</span></span><br><span class=\"line\">&#125;;   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The following is equivalent to</span></span><br><span class=\"line\"><span class=\"comment\">// const blop = blep.blop;   </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;blop&#125; = blep;   </span><br><span class=\"line\">blop;  <span class=\"comment\">// 'blop' </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Also equivalent to</span></span><br><span class=\"line\"><span class=\"comment\">// const a = this.state.a;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;a&#125; = <span class=\"keyword\">this</span>.state;</span><br></pre></td></tr></table></figure>\n<p>위의 배열 예제 처럼 동시에 여러 변수에 할당할 수 있습니다. 다음은 Redux 프로젝트에서 자주 볼 수 있는 코드입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;type, payload&#125; = action;</span><br></pre></td></tr></table></figure>\n<p>Reducer에서 다음과 같이 사용합니다. (Reducer는 나중 글에서 설명할 것입니다)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myReducer = <span class=\"function\">(<span class=\"params\">state = &#123;&#125;, action = &#123;&#125;</span>) =&gt;</span> &#123;   </span><br><span class=\"line\"> <span class=\"keyword\">const</span> &#123;type, payload&#125; = action;   </span><br><span class=\"line\"> <span class=\"keyword\">switch</span> (type) &#123;   </span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'FOO'</span>: <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign (&#123;&#125;, state, payload);   </span><br><span class=\"line\">  <span class=\"keyword\">default</span> : <span class=\"keyword\">return</span> state;   </span><br><span class=\"line\"> &#125;   </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>새로운 이름으로 할당 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"attr\">blop</span>: bloop &#125; = blep;   </span><br><span class=\"line\">bloop; <span class=\"comment\">// 'blop'`</span></span><br></pre></td></tr></table></figure>\n<p><code>blep.blop</code>  을  <code>bloop</code>에 할당했다 라고 읽으면 됩니다.</p>\n<h2>비교 및 삼항 연산자</h2>\n<p>값을 비교할 때는 완전 항등 연산자(&quot;triple equals&quot;라고 함)를 사용합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span> + <span class=\"number\">1</span> === <span class=\"number\">4</span>;  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>물론 다른 항등 연산자가 있습니다.  공식적으로 &quot;동등&quot;연산자라고합니다.  비공식적으로 &quot;double equals&quot;라고 합니다. double equals는 한두가지 정도 의미있게 사용할  상황이 있습니다. 그 외에는 항상  <code>===</code>  연산자로 비교하는 것이 좋습니다.</p>\n<p>이외에도 다음과같은 비교 연산자들이 있습니다.</p>\n<ul>\n<li><code>&gt;</code>  보다 큼</li>\n<li><code>&lt;</code>  보다 작음</li>\n<li><code>&gt;=</code>  크거나 같음</li>\n<li><code>&lt;=</code>  작거나 같음</li>\n<li><code>!=</code>  같지 않음</li>\n<li><code>!==</code> 엄격하게 같지 않음</li>\n<li><code>&amp;&amp;</code>  논리 곱</li>\n<li><code>||</code>  논리 합</li>\n</ul>\n<p>삼항 표현식은 삼항 연산자를 사용한 표현식입니다. 조건이 참이냐 거짓이냐에 따라 다른 값으로 평가됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">14</span> - <span class=\"number\">7</span> === <span class=\"number\">7</span>?  <span class=\"string\">'Yep!'</span>  : <span class=\"string\">'Nope.'</span>;  <span class=\"comment\">// Yep!</span></span><br></pre></td></tr></table></figure>\n<h2>함수</h2>\n<p>JavaScript에는 함수 표현식이 있으며 이는 변수에 할당 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>위 코드는 수학에서의 함수  <code>f(x) = 2x</code>  와 같습니다.  소리내어 읽을 경우 <code>f</code> <code>x</code>는 <code>2x</code> 라고 읽습니다. 이 함수는  <code>x</code>에 특정한 값을 적용 할 때만 의미가 생깁니다. 다른 식에서 이 함수를 사용하려면  <code>f(2)</code>라고 쓰면 됩니다.  <code>f(2)</code>  는  <code>4</code>와 같은 의미입니다.</p>\n<p>즉,  <code>f(2) = 4</code>  입니다.  수학의 함수는 입력에서 출력으로의 매핑이라고 생각할 수 있습니다.  이 경우  <code>f(x)</code>  는  <code>x</code>  에 대한 입력 값을 입력 값과  <code>2</code>  의 곱과 동일한 해당 출력 값에 매핑하는 것입니다.</p>\n<p>자바 스크립트에서 함수 표현식의 값은 함수 그 자체입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double;  <span class=\"comment\">// [Function : double]</span></span><br></pre></td></tr></table></figure>\n<p><code>.toString()</code>  메서드를 사용하여 함수 정의를 볼 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double.toString ();  <span class=\"comment\">// 'x =&gt; x * 2'</span></span><br></pre></td></tr></table></figure>\n<p>특정 인수(값)에 함수를 적용하려면 함수를 호출해야합니다.  함수 호출이란 인수에 함수를 적용하고 평가된 값을 리턴받는 것입니다.</p>\n<p><code>&lt;functionName&gt;(argument1, argument2, ...rest)</code> 와 같은 문법으로 함수를 호출 할 수 있습니다.  예를 들어 double 함수를 호출하려면 괄호를 추가하고 double 값을 전달하면됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double(<span class=\"number\">2</span>);  <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p>일부 함수형 언어들과는 달리 괄호가 필수입니다. 괄호가 없으면 함수는 호출되지 않습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double <span class=\"number\">4</span>;  <span class=\"comment\">// SyntaxError : Unexpected number</span></span><br></pre></td></tr></table></figure>\n<h2>서명 혹은 시그니처</h2>\n<p>함수들은 다음과 같이 서명을 가집니다.</p>\n<ol>\n<li>함수 이름(선택사항)</li>\n<li>인자 타입 목록(매개 변수의 이름은 선택사항)</li>\n<li>리턴 타입</li>\n</ol>\n<p>JavaScript의 함수서명에는 타입을 명시하지 않아도 됩니다.  JavaScript 엔진은 런타임에 타입을 파악합니다.  충분한 단서들을 제공할 경우 IDE (Integrated Development Environment) 및  <a href=\"http://ternjs.net/\" target=\"_blank\" rel=\"noopener\">Tern.js</a>  와 같은 개발자 도구에서는 데이터 흐름을 분석하여 서명을 유추해내기도 합니다.</p>\n<p>자바 스크립트는 함수 서명에 대한 표준이 없기 때문에 여러 표준들이 경쟁을 하는 상황입니다. JSDoc은 오랫동안 쓰여왔지만 장황하고 다소 어색합니다.  대부분의 사람들은 코드에 대한 주석을 최신화하는데 별로 관심이 없기에 많은 JS 개발자가 더 이상 사용하지 않습니다.</p>\n<p>가장 인기 있는 두 표준 TypeScript와 Flow가 있습니다. 저는 둘중 어떠한 것이 더 나은지 확실하지 않습니다. 따라서 저는   <a href=\"https://github.com/ericelliott/rtype\" target=\"_blank\" rel=\"noopener\">Rtype</a>을 사용합니다. 어떤 사람들은 커리<sup>curry</sup>를 위해 하스켈 전용  <a href=\"http://web.cs.wpi.edu/~cs4536/c12/milner-damas_principal_types.pdf\" target=\"_blank\" rel=\"noopener\">Hindley-Milner Type</a> 을 꺼내들기도 합니다. 저는 JavaScript 문서화를 위해 얼른 좋은 표기법이 표준화되어야 한다고 봅니다. 그러나 지금 나와있는 해결책 중 어느것도 완벽하다고 할 수 없습니다.  당분간 여러분이 사용하고있는 것과는 약간 다른 문법으로 쓰인 다양한 유형의 서명들을 이해하기 위해 최선을 다해야 할 것입니다.</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">functionName (param1 : <span class=\"keyword\">Type</span>, param2 : <span class=\"keyword\">Type</span>) =&gt; <span class=\"keyword\">Type</span></span><br></pre></td></tr></table></figure>\n<p>double 함수의 서명은 다음과 같습니다.</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">double</span> (x : n) =&gt; Number</span><br></pre></td></tr></table></figure>\n<p>JavaScript는 강제로 주석을 달지 않아도 된다는 사실에도 불구하고, 함수를 사용할 때 그리고 합성할 때 효율적으로 의사소통을 하기 위해 서명에 의미를 재빨리 파악할 수 있는 것이 중요합니다. 함수 합성에 관련된 대부분의 라이브러리들은 동일한 타입의 서명을 가진 함수를 전달할 것을 요구합니다.</p>\n<h2>기본 매개 변수 값<sup>default</sup> <sup>parameter</sup> <sup>values</sup></h2>\n<p>JavaScript는 기본 매개 변수 값을 지원합니다.  다음 함수는 전달받은 값을 그대로 리턴하는 항등<sup>identity</sup>함수입니다.  그러나 <code>undefined</code>를 인수로 전달받거나 아무 인수도 전달받지 않은 경우 0을 리턴합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> orZero = <span class=\"function\">(<span class=\"params\">n = <span class=\"number\">0</span></span>) =&gt;</span> n;</span><br></pre></td></tr></table></figure>\n<p>기본값을 설정하려면  <code>n = 0</code> 처럼 <code>=</code>  연산자를 사용하여 매개 변수에 값을 할당하기만 하면 됩니다.  이런 식으로 기본값을 지정하면  <a href=\"http://ternjs.net/\" target=\"_blank\" rel=\"noopener\">Tern.js</a>  , Flow 또는 TypeScript를 사용할 때 함수의 형식과 서명을 주석으로 명시하지 않아도 이를 자동으로 유추 할 수 있습니다.</p>\n<p>기본 매개 변수값을 지정하고 텍스트 에디터나 IDE에 관련 플러그인을 설치하면 함수를 사용하려고 할 때 함수 서명이 표시됩니다. 또한 함수를 사용하는 방법을 파악하기 쉽습니다. 이는 코드 자체가 곧 문서가 될 수 있는 중요한 접근방법입니다.</p>\n<blockquote>\n<p>참고 : 기본값이 있는 매개 변수는 함수의  <code>.length</code>  속성에서 제외됩니다. 즉 <code>length</code>값을 참조하는 autocurry 라이브러리를 사용할 때 문제가 발생할 수 있습니다. 그러나 일부 currying 라이브러리 (예 :  <code>lodash/curry</code>  )에서는 함수 인자의 개수<sup>arity</sup>를 임의로 전달 하는 옵션이 있습니다.</p>\n</blockquote>\n<h2>해체-할당과 기본값</h2>\n<p>JavaScript 함수에서 객체 리터럴을 받아 해제-할당하면 이를 보통 인수처럼 사용할 수 있습니다. 이 때도 마찬가지로 기본 매개 변수 기능을 사용하여 기본값을 할당 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = (&#123;   </span><br><span class=\"line\"> name = <span class=\"string\">'Anonymous'</span>,   </span><br><span class=\"line\"> avatarThumbnail = <span class=\"string\">'/avatars/anonymous.png'</span>   </span><br><span class=\"line\">&#125;) =&gt; (&#123;   </span><br><span class=\"line\"> name,   </span><br><span class=\"line\"> avatarThumbnail   </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> george = createUser (&#123;   </span><br><span class=\"line\"> name : <span class=\"string\">'George'</span>   </span><br><span class=\"line\"> avataThumbnail : <span class=\"string\">'avatars/shades-emoji.png'</span>   </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">george;   </span><br><span class=\"line\"><span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">&#123;   </span></span><br><span class=\"line\"><span class=\"comment\"> name : 'george'   </span></span><br><span class=\"line\"><span class=\"comment\"> avatarThumbnail : 'avatars/shades-emoji.png'   </span></span><br><span class=\"line\"><span class=\"comment\">&#125;   </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2>나머지와 스프레드 연산자</h2>\n<p>나머지 연산자<code>...</code>를 사용해서 함수의 정해지지 않은 인수들을 배열로 참조할 수 있습니다.</p>\n<p>예를 들어 다음 함수는 첫 번째 인수를 버리고 나머지를 배열로 리턴합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> aTail = <span class=\"function\">(<span class=\"params\">head, ...tail</span>) =&gt;</span> tail;   </span><br><span class=\"line\">aTail(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// [2, 3]</span></span><br></pre></td></tr></table></figure>\n<p>나머지 구문은 개별 요소를 배열로 만듭니다. 스프레드는 반대의 역할을합니다. 즉, 주어진 배열을 개별 요소로 퍼트립니다. 나머지와 스프레드는 같은 형태를 가지지만 사용법이 다릅니다. 이를 주의해서 다음 코드를 참고하세요:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> shiftToLast = <span class=\"function\">(<span class=\"params\">head, ...tail</span>) =&gt;</span> [...tail, head];   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 첫 번째 ...tail은 나머지연산자가 사용되었고 뒤에는 스프레드</span></span><br><span class=\"line\"><span class=\"comment\">   연산자가 사용되었습니다.*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">shiftToLast(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// [2, 3, 1]</span></span><br></pre></td></tr></table></figure>\n<p>JavaScript의 배열에 있는 iterator는 스프레드 연산자가 사용될 때 함께 호출됩니다. iterator는 배열의 요소 값들을 반복해서 리턴합니다. <code>[...tail, head]</code>  표현식에서 iterator는 나머지 구문으로 전달받은  <code>tail</code> 배열에서 값을 하나씩 꺼내 새로운 배열 리터럴에 복사합니다. <code>head</code>는 이미 개별 요소이기 때문에 배열의 끝 부분에 붙이면 됩니다.</p>\n<h2>커링<sup>currying</sup></h2>\n<p>커리된 함수는 한 번에 하나씩 여러 인자를 받는 함수입니다. 인자를 받아 그 다음인자의 입력을 기다리는 함수를 리턴합니다. 모든 인자가 채워지면 최종 값이 리턴됩니다.</p>\n<p>커링 및 부분 적용<sup>partial</sup> <sup>application</sup>은 함수를 반환하는 행위입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> highpass = <span class=\"function\"><span class=\"params\">cutoff</span> =&gt;</span> n =&gt; n &gt;= cutoff;   </span><br><span class=\"line\"><span class=\"keyword\">const</span> gt4 = highpass(<span class=\"number\">4</span>);  <span class=\"comment\">// highpass() returns a new function</span></span><br></pre></td></tr></table></figure>\n<p>꼭 화살표 구문을 사용할 필요는 없습니다. JavaScript에는  <code>function</code>  키워드가 있습니다. 다만 <code>function</code>  키워드를 쓰면 타이핑을 조금 더 해야할 뿐입니다. 즉 아래의 <code>highpass</code>는 위의 정의와 동일합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> highpass = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">highpass</span>(<span class=\"params\">cutoff</span>) </span>&#123;   </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>) </span>&#123;   </span><br><span class=\"line\">  <span class=\"keyword\">return</span> n &gt;= cutoff;   </span><br><span class=\"line\"> &#125;;   </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>화살표는 &quot;함수&quot;를 뜻합니다. 그러나 몇 가지 중요한 차이가 있습니다. ( <code>=&gt;</code> 은 기본적으로 <code>this</code>가 없기 때문에 생성자로 사용할 수 없습니다)  이 주제에 관해선 나중에 더 깊게 알아볼 것입니다. 그러니 지금 당장은  <code>x =&gt; x</code>  라는 코드를 &quot;  <code>x</code> 를 받아  <code>x</code>를 리턴하는 <strong>함수</strong>&quot;라고 생각하십시오.  따라서</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> highpass = <span class=\"function\"><span class=\"params\">cutoff</span> =&gt;</span> n =&gt; n &gt;= cutoff;</span><br></pre></td></tr></table></figure>\n<p>라는 코드는 다음처럼 읽으면 됩니다:</p>\n<blockquote>\n<p><code>highpass</code>  는  <code>cutoff</code>  를 받고  <code>n</code>을 받은 이후에  <code>n &gt;= cutoff</code>  의 결과를 리턴하는 함수를 리턴하는 함수</p>\n</blockquote>\n<p>함수를 리턴하는<code>highpass()</code> 를 사용해 보다 특화된 함수를 만들 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gt4 = highpass(<span class=\"number\">4</span>); </span><br><span class=\"line\"></span><br><span class=\"line\">gt4(<span class=\"number\">6</span>);  <span class=\"comment\">// true   </span></span><br><span class=\"line\">gt4(<span class=\"number\">3</span>);  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>autocurry를 사용하면 최대한 유연한 방식으로 함수를 커링할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add3 = curry(<span class=\"function\">(<span class=\"params\">a, b, c</span>) =&gt;</span> a + b + c);</span><br></pre></td></tr></table></figure>\n<p>autocurry된 add3 함수는 다양한 방법으로 사용할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add3(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 6   </span></span><br><span class=\"line\">add3(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>); <span class=\"comment\">// 6   </span></span><br><span class=\"line\">add3(<span class=\"number\">1</span>)(<span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 6   </span></span><br><span class=\"line\">add3(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n<p>하스켈 팬에게는 죄송한 일이지만, JavaScript에서는 autocurry를 하기 위해 Lodash와 같은 라이브러리를 사용해야 합니다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install --save lodash</span></span><br></pre></td></tr></table></figure>\n<p><code>npm</code>으로 설치 한 다음 코드 상단에서 <code>import</code>하면 됩니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> curry <span class=\"keyword\">from</span> <span class=\"string\">'lodash/curry'</span>;</span><br></pre></td></tr></table></figure>\n<p>아니면 다음처럼 마술을 부리면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Tiny, recursive autocurry  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> curry = <span class=\"function\">(<span class=\"params\">f, arr = []</span>) =&gt;</span> (...args) =&gt; </span><br><span class=\"line\"> (<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a.length === f.length ? f(...a) : curry(f, a))</span><br><span class=\"line\"> ([...arr, ...args]);</span><br></pre></td></tr></table></figure>\n<h2>함수 합성</h2>\n<p>당연히 함수를 합성 할 수 있습니다. 함수 합성은 한 함수의 리턴 값을 다른 함수의 인수로 전달하는 과정입니다.  수학 표기법 :</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">f</span> . g</span><br></pre></td></tr></table></figure>\n<p>는 JavaScript에서 다음과 같이 표현됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f (g (x))</span><br></pre></td></tr></table></figure>\n<p>그리고 내부적으로 다음과 같이 계산됩니다 :</p>\n<ol>\n<li><code>x</code>  가 평가됩니다.</li>\n<li><code>x</code>에 <code>g()</code>가 적용됩니다.</li>\n<li><code>g(x)</code>의 반환 값에 <code>f()</code>가 적용됩니다.</li>\n</ol>\n<p>예 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inc = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;   </span><br><span class=\"line\">inc(double(<span class=\"number\">2</span>));  <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>값  <code>2</code>  는  <code>double()</code>  으로 전달되어  <code>4</code>  를 생성합니다.  <code>4</code>  는  <code>inc()</code>  로 전달되고  <code>5</code>  평가됩니다.</p>\n<p>어떤 표현식을 함수의 인수로 전달할 수 있습니다.  이 때 표현식이 먼저 평가된 후 함수가 적용됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inc(double(<span class=\"number\">2</span>) * double(<span class=\"number\">2</span>));  <span class=\"comment\">// 17</span></span><br></pre></td></tr></table></figure>\n<p><code>double(2)</code>  은  <code>4</code> 로 평가되므로  <code>inc(4 * 4)</code> 가 된 후  <code>inc(16)</code>  로 평가되고  <code>17</code>이 리턴됩니다.</p>\n<p>함수 합성은 함수형 프로그래밍의 핵심입니다.</p>\n<h2>배열</h2>\n<p>배열에는 몇 가지 내장 된 메소드가 있습니다.  메소드는 객체와 관련된 함수입니다. 일반적으로 객체의 속성<sup>property</sup>으로 존재합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];   </span><br><span class=\"line\">arr.map(double);  <span class=\"comment\">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>\n<p>이 경우  <code>arr</code>  이 객체이고  <code>.map()</code> 함수가 값으로 할당되어있는 속성입니다.    이 함수를 호출하면 인수에 적용될 뿐만 아니라 <code>this</code>  라는 특수 매개 변수에도 적용됩니다.  <code>this</code>  매개 변수는 메소드가 호출 될 때 자동으로 설정됩니다. <code>map()</code> 메소드에서 배열의 값에 접근할 때<code>this</code>를 참조합니다.</p>\n<p><code>double</code>  함수를 호출하는 <code>map</code>에 전달하는걸 잘 보십시오. <code>map</code>  은 함수를 인수로 받아여 배열의 각 항목에 적용합니다.  그리고 <code>double()</code>  의해 리턴 된 값으로 새로운 배열을 생성하여 리턴합니다.</p>\n<p>원래의  <code>arr</code>  값은 변하지 않습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr;  <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<h2>메소드 체이닝</h2>\n<p>메소드를 호출을 연결할 수도 있습니다.  메소드 체인은 리턴 값을 따로 변수에 저장하여 다시 참조 할 필요없이 함수의 리턴 값에 메소드를 계속해서 호출하는 프로세스입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];   </span><br><span class=\"line\">arr.map(double).map(double);  <span class=\"comment\">// [4, 8, 12]</span></span><br></pre></td></tr></table></figure>\n<p><strong>predicate</strong>  는 부울 값 (  <code>true</code>  또는  <code>false</code>  )을 리턴하는 함수입니다.  <code>.filter()</code>  메소드는 predicate를 인수로 받아 배열의 개별 항목에 적용합니다. 이 때 조건을 통과한(<code>true</code>를 반환) 항목만 선택하여 새 배열에 포함시켜 리턴합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>].filter(gt4);  <span class=\"comment\">// [4, 6]</span></span><br></pre></td></tr></table></figure>\n<p>배열에서 조건에 맞는 항목을 골라 매핑하는 상황은 자주 발생합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>].filter(gt4).map(double);  <span class=\"comment\">//[8, 12]</span></span><br></pre></td></tr></table></figure>\n<p>참고 : 이 시리즈의 뒷부분에는 선택과 매핑을 동시에 하는 더 효율적인 방법인 <code>transducer</code>가 나옵니다.</p>\n<h2>결론</h2>\n<p>머리가 핑핑 돌고 있습니까? 걱정하지 마세요. 지금까지 배운 것들은 단지 맛보기에  지나지 않습니다. 앞으로도 계속 이 주제들이 반복적으로 그리고 좀 더 깊은 이해를 위해 등장할 것입니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/03/29/higher-order-functions\"><strong>다음: 고차 함수 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>MDN 번역문서에는 비구조화라고 번역되어있습니다. 그러나 다른 많은 번역글에서 해체라고 번역이 되었으며 역자는 해체라는 용어를 사용하겠습니다. <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n"},{"title":"합성과 추상화","catalog":true,"date":"2018-04-26T05:34:15.000Z","subtitle":"Abstraction & Composition","header-img":"bg.jpg","readingTime":6,"catagories":["개발"],"preview":"소프트웨어 개발자로서 성숙해질수록 기본적인 것들에 더 큰 가치를 부여하게 됩니다. 초보자였을 때 사소해 보였던 깨달음들이 그동안의 경험들과 함께 심오한 의미를 갖게됩니다. 구글 사전에 따르면 추상화란  “그 연관성, 속성 또는 구체적인 사례와는 독립적인 무언가를 추려내는 과정” 입니다. abstraction은 라틴어 동사  _abstrahere_ 에서 왔습니다. 이는 없애 버리다(to draw away)라는 의미 입니다.  전 이러한 깨달음을 좋아합니다.  추상화는 사물을 제거하는 것입니다. 그러나 무엇을 제거하고 무엇을 남겨야 합니까?","_content":"\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/abstraction-composition-cb2849d5bdd6)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/) \n\n소프트웨어 개발자로서 성숙해질수록 기본적인 것들에 더 큰 가치를 부여하게 됩니다. 초보자였을 때 사소해 보였던 깨달음들이 그동안의 경험들과 함께 심오한 의미를 갖게됩니다.\n\n> \"가라데라는 무술에서 [...] 검은띠에 대한 자존심의 상징은 검은 염료가 희게 퇴색할 정도로 길게 입으라는 것 처럼 다시 초심으로 돌아가라는 의미 입니다.\"~ John Maeda,  [\"The Laws of Simplicity (Simplicity: Design, Technology, Business, Life)\"](https://www.amazon.com/Laws-Simplicity-Design-Technology-Business/dp/0262134721/ref%3Das_li_ss_tl%3Fie%3DUTF8%26qid%3D1516330765%26sr%3D8-1%26keywords%3Dthe%2Blaws%2Bof%2Bsimplicity%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3D287b1d3357fa799ce7563584e098c5d8)\n\n구글 사전에 따르면 추상화란  “그 연관성, 속성 또는 구체적인 사례와는 독립적인 무언가를 추려내는 과정” 입니다.\n\n abstraction은 라틴어 동사  _abstrahere_ 에서 왔습니다. 이는 없애 버리다(to draw away)라는 의미 입니다.  전 이러한 깨달음을 좋아합니다.  추상화는 사물을 제거하는 것입니다. 그러나 무엇을 제거하고 무엇을 남겨야 합니까?\n\n때로는 단어를 다른 언어로 번역 한 다음 영어로 다시 번역하여 우리가 일반적으로 생각하지 않는 다른 연관성을 느끼는 것을 좋아합니다.  \"추상화\"를 이디시어로 번역하면 그 결과는 \"absentminded(무관심한, 넋이 나간)\"입니다.  전 이것도 좋아합니다.  무관심한 사람은 자동 조종 장치로 달리고 있는 것이나 마찬가지입니다. 하고있는 일에 대해 적극적으로 생각하지 않고 ... 그냥 하고 있습니다.\n\n추상화를 통해 우리는 자동 조종 장치로 안전하게 달릴 수 있습니다.  모든 소프트웨어는 자동화입니다.  컴퓨터로 할 수 있는 모든 일들은 충분한 시간이 주어지면  종이, 잉크 그리고  비둘기로 할 수 있습니다.  소프트웨어는 수동으로 수행하려면 많은 시간이 소요될 수 있는 작은 세부 사항까지 모두 처리합니다.\n\n모든 소프트웨어는 추상화의 결과물입니다. 우리가 이러한 혜택을 누리는 동안 모든 힘든 작업들과 세부 사항들을 숨기고 있습니다.\n\n소프트웨어 프로세스는 반복적입니다.  문제를 분석하는 단계에서 반복되는 내용을 처음부터 다시 구현하려면 불필요한 작업을 많이 해야 합니다. 바보같은 짓이며 비실용적입니다.\n\n대신에 우리는 여러 종류의 구성 요소(함수, 모듈, 클래스 등)를 만들고 이름 (ID)을 부여하고 원하는 만큼 여러번 재사용함으로써 중복을 제거합니다.\n\n분해 과정은 추상화 과정입니다.  성공적인 추상화의 결과물은 개별적인 쓰임새가 있는 유용하고 재구성 가능한 요소들의 집합입니다.  이로부터 우리는 소프트웨어 아키텍처의 중요한 원칙을 얻게되었습니다.\n\n소프트웨어 솔루션은 내부 구성 요소의 구현 세부 사항을 변경하지 않고도 해당 구성 요소로 분해 할 수 있어야 하며 새로운 솔루션으로 재구성 가능해야합니다.\n\n## 추상화는 단순화 작업입니다.\n\n> \"단순함이란 명백한 부분을 제거하고 의미있는 부분을 남기는 것 입니다.\"- John Maeda,  [\"The Laws of Simplicity (Simplicity: Design, Technology, Business, Life)\"](https://www.amazon.com/Laws-Simplicity-Design-Technology-Business/dp/0262134721/ref%3Das_li_ss_tl%3Fie%3DUTF8%26qid%3D1516330765%26sr%3D8-1%26keywords%3Dthe%2Blaws%2Bof%2Bsimplicity%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3D287b1d3357fa799ce7563584e098c5d8)\n\n추상화 프로세스에는 두 가지 요소가 있습니다.\n\n-   **일반화**^Generalization^ 는 반복되는 패턴에서  _유사점_  (명백함)을 찾고 추상화 뒤에 이를 숨기는 과정입니다.\n-   **전문화**^Specialization^  는 각 유스케이스별로  무엇이 근본적으로 다른지  찾아 이를 남기는 과정입니다.\n\n추상화란 어떤 개념의 에센스를 추출하는 과정입니다.  서로 다른 영역의 서로 다른 문제들 사이의 공통점을 탐구함으로써 우리의 정신은 잠시 바깥으로 나가 다른 관점에서 문제를 바라보는 방법을 배웁니다.  문제의 본질을 파악해서 나온 좋은 해결책은 다른 많은 문제에 적용할 수 있다는 것을 알게됩니다.  솔루션을 잘 코딩하면 소프트웨어의 복잡성을 근본적으로 줄일 수 있습니다.\n\n> \"깊은 깨달음으로 한 가지를 만지면 모든 것을 만질 수 있습니다.\"~ 팃낙한\n\n이 원칙은 애플리케이션을 빌드하기 위해 필요한 코드를 크게 줄이는데 사용할 수 있습니다.\n\n## 소프트웨어 추상화\n\n소프트웨어 추상화는 다음과 같은 다양한 형태를 취합니다.\n\n-   알고리즘^Algorithm^\n-   자료구조^Data^ ^Structure^\n-   모듈^Module^\n-   클래스^Class^\n-   프레임 워크^Framework^\n\n그리고 제 개인적 취향인 :\n\n> \"때때로 우아한 구현은 단지 함수뿐입니다.  메소드가 아닙니다. 클래스도 아닙니다. 프레임워크도 아니고 그저 함수입니다.\"~ John Carmack\n\n함수는 추상화에 필요한 훌륭한 특징들을 가지고 있습니다.\n\n-   **Identity**  - 이름을 붙이고 다른 맥락에서 이를 다시 사용할 수 있는 특징입니다.\n-   **Composition**  -간단한 함수들을 합성해 고차 함수를 만들 수 있습니다.\n\n## 합성을 통한 추상화\n\n소프트웨어를 추상화할 때 가장 유용한 함수는 수학 함수의 모듈러 특성을 공유하는  _순수 함수_  입니다.  수학의 함수는 동일한 입력을 받았을 때 항상 동일한 출력을 반환합니다.  함수를 입력과 출력 사이의 관계로 볼 수 있습니다.  어떤 입력  `A`가  주어지면 함수  `f`  는  `B`를 출력합니다. 이 때  `f`  가  `A`  와  `B` 사이의  관계를 정의한다고 말할 수 있습니다.\n\n```\nf: A -> B\n```\n\n마찬가지로  `B`  와  `C`  사이의 관계를 정의하는 또 다른 함수  `g`  가 있을 때,\n\n```\ng: B -> C\n```\n\n이는  `A`  에서  `C`로의 직접적인 관계를 정의하는 또 다른 함수  `h`가 있음을 의미합니다.\n\n```\nh: A -> C\n```\n\n\n이러한 관계는 문제공간의 구조를 형성하며 함수를 합성하는 방법이 애플리케이션의 구조를 결정합니다.\n\n좋은 추상화는 내부 구조를 숨기며 단순화합니다. 마치 `h` 함수가`A -> B -> C`를  `A -> C` 로 단순화하는 것과 비슷합니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*uFTKDgI0kT878E97K14V1A.png)\n\n## 적은 코드로 더 많은 작업을 수행하는 방법\n\n추상화는 적은 코드로 더 많은 일을 할 수있는 열쇠입니다.  예를 들어, 단순히 두 개의 숫자를 더하는 함수가 있다고 가정 해보겠습니다.\n\n```javascript\n  const add = (a, b) => a + b; \n```\n\n그러나 이를 반복적으로 사용하는 패턴이 있을 때 숫자하나를 고정시켜주는게 좋습니다.\n\n```javascript\n  const a = add(1, 1);   \n  const b = add(a, 1);   \n  const c = add(b, 1);   \n  // ... \n```\n\n우리는 add 함수를 커링할 수 있습니다.\n\n```javascript\n  const add = a => b => a + b; \n```\n\n그리고 나서 첫 번째 인수를 받아 새 함수를 반환하는 프로그램을 만듭니다.\n\n```javascript\n  const inc = add(1); \n```\n\n이제는  `1` 씩 더해야 할 때  `add`  대신  `inc`를 사용할 수 있으므로 필요한 코드의 양이 줄어들었습니다.\n\n```javascript\n  const a = inc(1);   \n  const b = inc(a);   \n  const c = inc(b);   \n  // ... \n```\n\n이 경우  `inc`  는 add의  특수한  버전일 뿐입니다.  모든 커링은 추상화입니다.  사실, 모든 고차 함수는 하나 이상의 인수를 전달하여 특화시킬 수 있는 일반화입니다.\n\n예를 들어,  `Array.prototype.map()`은 배열의 각 요소에 함수를 적용하는 아이디어를 추상화한 고차 함수입니다.  보다 명확하게하기 위해  `map`을 커리된 함수로 작성해 보겠습니다.\n\n```javascript\n  const map = f => arr => arr.map(f); \n```\n\n이 버전의  `map`은 특정 함수를 취한 다음 처리 할 배열을 인수로 받는 함수를 리턴합니다.\n\n```javascript\nconst f = n => n * 2;\n\nconst doubleAll = map(f);  \nconst doubled = doubleAll([1, 2, 3]);  \n// => [2, 4, 6]\n```\n\n`doubleAll`의 코드가 얼마나 짧은지 보입니까 ? `map(f)`  - 이게 전부입니다!  이것이 전체 정의입니다.  추상화를 기본 요소로 삼으면 새로운 코드를 거의 만들지 않고도 매우 복잡한 기능들을 구현할 수 있습니다.\n\n## 결론\n\n소프트웨어 개발자는 모든 시간을 추상화하는데 사용합니다. 그럼에도 추상화 또는 합성에 대한 기본적인 이해가 거의 없는 경우가 많습니다.\n\n어떤 것을 추상화할 때는 충분한 시간을 들여 생각해야 합니다. 그리고 `map`  ,  `filter`  및  `reduce`  와 같은 유용한 추상화들을 알고 있어야합니다.  마지막으로 좋은 추상화의 특징을 알아보는 법을 배워야 합니다.\n\n-   단순한^Simple^\n-   간결한^Concise^\n-   재사용 가능한^Reusable^\n-   독립적인^Independent^\n-   분해가능한^Decomposable^\n-   재구성가능한^Recomposable^","source":"_posts/abstraction-and-composition.md","raw":"---\ntitle: 합성과 추상화\ncatalog: true\ndate: 2018-04-26 14:34:15\nsubtitle: Abstraction & Composition\nheader-img: \"bg.jpg\"\nreadingTime: 6\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 소프트웨어 개발자로서 성숙해질수록 기본적인 것들에 더 큰 가치를 부여하게 됩니다. 초보자였을 때 사소해 보였던 깨달음들이 그동안의 경험들과 함께 심오한 의미를 갖게됩니다. 구글 사전에 따르면 추상화란  “그 연관성, 속성 또는 구체적인 사례와는 독립적인 무언가를 추려내는 과정” 입니다. abstraction은 라틴어 동사  _abstrahere_ 에서 왔습니다. 이는 없애 버리다(to draw away)라는 의미 입니다.  전 이러한 깨달음을 좋아합니다.  추상화는 사물을 제거하는 것입니다. 그러나 무엇을 제거하고 무엇을 남겨야 합니까?\n---\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/abstraction-composition-cb2849d5bdd6)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/) \n\n소프트웨어 개발자로서 성숙해질수록 기본적인 것들에 더 큰 가치를 부여하게 됩니다. 초보자였을 때 사소해 보였던 깨달음들이 그동안의 경험들과 함께 심오한 의미를 갖게됩니다.\n\n> \"가라데라는 무술에서 [...] 검은띠에 대한 자존심의 상징은 검은 염료가 희게 퇴색할 정도로 길게 입으라는 것 처럼 다시 초심으로 돌아가라는 의미 입니다.\"~ John Maeda,  [\"The Laws of Simplicity (Simplicity: Design, Technology, Business, Life)\"](https://www.amazon.com/Laws-Simplicity-Design-Technology-Business/dp/0262134721/ref%3Das_li_ss_tl%3Fie%3DUTF8%26qid%3D1516330765%26sr%3D8-1%26keywords%3Dthe%2Blaws%2Bof%2Bsimplicity%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3D287b1d3357fa799ce7563584e098c5d8)\n\n구글 사전에 따르면 추상화란  “그 연관성, 속성 또는 구체적인 사례와는 독립적인 무언가를 추려내는 과정” 입니다.\n\n abstraction은 라틴어 동사  _abstrahere_ 에서 왔습니다. 이는 없애 버리다(to draw away)라는 의미 입니다.  전 이러한 깨달음을 좋아합니다.  추상화는 사물을 제거하는 것입니다. 그러나 무엇을 제거하고 무엇을 남겨야 합니까?\n\n때로는 단어를 다른 언어로 번역 한 다음 영어로 다시 번역하여 우리가 일반적으로 생각하지 않는 다른 연관성을 느끼는 것을 좋아합니다.  \"추상화\"를 이디시어로 번역하면 그 결과는 \"absentminded(무관심한, 넋이 나간)\"입니다.  전 이것도 좋아합니다.  무관심한 사람은 자동 조종 장치로 달리고 있는 것이나 마찬가지입니다. 하고있는 일에 대해 적극적으로 생각하지 않고 ... 그냥 하고 있습니다.\n\n추상화를 통해 우리는 자동 조종 장치로 안전하게 달릴 수 있습니다.  모든 소프트웨어는 자동화입니다.  컴퓨터로 할 수 있는 모든 일들은 충분한 시간이 주어지면  종이, 잉크 그리고  비둘기로 할 수 있습니다.  소프트웨어는 수동으로 수행하려면 많은 시간이 소요될 수 있는 작은 세부 사항까지 모두 처리합니다.\n\n모든 소프트웨어는 추상화의 결과물입니다. 우리가 이러한 혜택을 누리는 동안 모든 힘든 작업들과 세부 사항들을 숨기고 있습니다.\n\n소프트웨어 프로세스는 반복적입니다.  문제를 분석하는 단계에서 반복되는 내용을 처음부터 다시 구현하려면 불필요한 작업을 많이 해야 합니다. 바보같은 짓이며 비실용적입니다.\n\n대신에 우리는 여러 종류의 구성 요소(함수, 모듈, 클래스 등)를 만들고 이름 (ID)을 부여하고 원하는 만큼 여러번 재사용함으로써 중복을 제거합니다.\n\n분해 과정은 추상화 과정입니다.  성공적인 추상화의 결과물은 개별적인 쓰임새가 있는 유용하고 재구성 가능한 요소들의 집합입니다.  이로부터 우리는 소프트웨어 아키텍처의 중요한 원칙을 얻게되었습니다.\n\n소프트웨어 솔루션은 내부 구성 요소의 구현 세부 사항을 변경하지 않고도 해당 구성 요소로 분해 할 수 있어야 하며 새로운 솔루션으로 재구성 가능해야합니다.\n\n## 추상화는 단순화 작업입니다.\n\n> \"단순함이란 명백한 부분을 제거하고 의미있는 부분을 남기는 것 입니다.\"- John Maeda,  [\"The Laws of Simplicity (Simplicity: Design, Technology, Business, Life)\"](https://www.amazon.com/Laws-Simplicity-Design-Technology-Business/dp/0262134721/ref%3Das_li_ss_tl%3Fie%3DUTF8%26qid%3D1516330765%26sr%3D8-1%26keywords%3Dthe%2Blaws%2Bof%2Bsimplicity%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3D287b1d3357fa799ce7563584e098c5d8)\n\n추상화 프로세스에는 두 가지 요소가 있습니다.\n\n-   **일반화**^Generalization^ 는 반복되는 패턴에서  _유사점_  (명백함)을 찾고 추상화 뒤에 이를 숨기는 과정입니다.\n-   **전문화**^Specialization^  는 각 유스케이스별로  무엇이 근본적으로 다른지  찾아 이를 남기는 과정입니다.\n\n추상화란 어떤 개념의 에센스를 추출하는 과정입니다.  서로 다른 영역의 서로 다른 문제들 사이의 공통점을 탐구함으로써 우리의 정신은 잠시 바깥으로 나가 다른 관점에서 문제를 바라보는 방법을 배웁니다.  문제의 본질을 파악해서 나온 좋은 해결책은 다른 많은 문제에 적용할 수 있다는 것을 알게됩니다.  솔루션을 잘 코딩하면 소프트웨어의 복잡성을 근본적으로 줄일 수 있습니다.\n\n> \"깊은 깨달음으로 한 가지를 만지면 모든 것을 만질 수 있습니다.\"~ 팃낙한\n\n이 원칙은 애플리케이션을 빌드하기 위해 필요한 코드를 크게 줄이는데 사용할 수 있습니다.\n\n## 소프트웨어 추상화\n\n소프트웨어 추상화는 다음과 같은 다양한 형태를 취합니다.\n\n-   알고리즘^Algorithm^\n-   자료구조^Data^ ^Structure^\n-   모듈^Module^\n-   클래스^Class^\n-   프레임 워크^Framework^\n\n그리고 제 개인적 취향인 :\n\n> \"때때로 우아한 구현은 단지 함수뿐입니다.  메소드가 아닙니다. 클래스도 아닙니다. 프레임워크도 아니고 그저 함수입니다.\"~ John Carmack\n\n함수는 추상화에 필요한 훌륭한 특징들을 가지고 있습니다.\n\n-   **Identity**  - 이름을 붙이고 다른 맥락에서 이를 다시 사용할 수 있는 특징입니다.\n-   **Composition**  -간단한 함수들을 합성해 고차 함수를 만들 수 있습니다.\n\n## 합성을 통한 추상화\n\n소프트웨어를 추상화할 때 가장 유용한 함수는 수학 함수의 모듈러 특성을 공유하는  _순수 함수_  입니다.  수학의 함수는 동일한 입력을 받았을 때 항상 동일한 출력을 반환합니다.  함수를 입력과 출력 사이의 관계로 볼 수 있습니다.  어떤 입력  `A`가  주어지면 함수  `f`  는  `B`를 출력합니다. 이 때  `f`  가  `A`  와  `B` 사이의  관계를 정의한다고 말할 수 있습니다.\n\n```\nf: A -> B\n```\n\n마찬가지로  `B`  와  `C`  사이의 관계를 정의하는 또 다른 함수  `g`  가 있을 때,\n\n```\ng: B -> C\n```\n\n이는  `A`  에서  `C`로의 직접적인 관계를 정의하는 또 다른 함수  `h`가 있음을 의미합니다.\n\n```\nh: A -> C\n```\n\n\n이러한 관계는 문제공간의 구조를 형성하며 함수를 합성하는 방법이 애플리케이션의 구조를 결정합니다.\n\n좋은 추상화는 내부 구조를 숨기며 단순화합니다. 마치 `h` 함수가`A -> B -> C`를  `A -> C` 로 단순화하는 것과 비슷합니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*uFTKDgI0kT878E97K14V1A.png)\n\n## 적은 코드로 더 많은 작업을 수행하는 방법\n\n추상화는 적은 코드로 더 많은 일을 할 수있는 열쇠입니다.  예를 들어, 단순히 두 개의 숫자를 더하는 함수가 있다고 가정 해보겠습니다.\n\n```javascript\n  const add = (a, b) => a + b; \n```\n\n그러나 이를 반복적으로 사용하는 패턴이 있을 때 숫자하나를 고정시켜주는게 좋습니다.\n\n```javascript\n  const a = add(1, 1);   \n  const b = add(a, 1);   \n  const c = add(b, 1);   \n  // ... \n```\n\n우리는 add 함수를 커링할 수 있습니다.\n\n```javascript\n  const add = a => b => a + b; \n```\n\n그리고 나서 첫 번째 인수를 받아 새 함수를 반환하는 프로그램을 만듭니다.\n\n```javascript\n  const inc = add(1); \n```\n\n이제는  `1` 씩 더해야 할 때  `add`  대신  `inc`를 사용할 수 있으므로 필요한 코드의 양이 줄어들었습니다.\n\n```javascript\n  const a = inc(1);   \n  const b = inc(a);   \n  const c = inc(b);   \n  // ... \n```\n\n이 경우  `inc`  는 add의  특수한  버전일 뿐입니다.  모든 커링은 추상화입니다.  사실, 모든 고차 함수는 하나 이상의 인수를 전달하여 특화시킬 수 있는 일반화입니다.\n\n예를 들어,  `Array.prototype.map()`은 배열의 각 요소에 함수를 적용하는 아이디어를 추상화한 고차 함수입니다.  보다 명확하게하기 위해  `map`을 커리된 함수로 작성해 보겠습니다.\n\n```javascript\n  const map = f => arr => arr.map(f); \n```\n\n이 버전의  `map`은 특정 함수를 취한 다음 처리 할 배열을 인수로 받는 함수를 리턴합니다.\n\n```javascript\nconst f = n => n * 2;\n\nconst doubleAll = map(f);  \nconst doubled = doubleAll([1, 2, 3]);  \n// => [2, 4, 6]\n```\n\n`doubleAll`의 코드가 얼마나 짧은지 보입니까 ? `map(f)`  - 이게 전부입니다!  이것이 전체 정의입니다.  추상화를 기본 요소로 삼으면 새로운 코드를 거의 만들지 않고도 매우 복잡한 기능들을 구현할 수 있습니다.\n\n## 결론\n\n소프트웨어 개발자는 모든 시간을 추상화하는데 사용합니다. 그럼에도 추상화 또는 합성에 대한 기본적인 이해가 거의 없는 경우가 많습니다.\n\n어떤 것을 추상화할 때는 충분한 시간을 들여 생각해야 합니다. 그리고 `map`  ,  `filter`  및  `reduce`  와 같은 유용한 추상화들을 알고 있어야합니다.  마지막으로 좋은 추상화의 특징을 알아보는 법을 배워야 합니다.\n\n-   단순한^Simple^\n-   간결한^Concise^\n-   재사용 가능한^Reusable^\n-   독립적인^Independent^\n-   분해가능한^Decomposable^\n-   재구성가능한^Recomposable^","slug":"abstraction-and-composition","published":1,"updated":"2018-04-28T13:48:50.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83ce0006ifp6nwryvtyn","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/abstraction-composition-cb2849d5bdd6\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a></p>\n</blockquote>\n<p>소프트웨어 개발자로서 성숙해질수록 기본적인 것들에 더 큰 가치를 부여하게 됩니다. 초보자였을 때 사소해 보였던 깨달음들이 그동안의 경험들과 함께 심오한 의미를 갖게됩니다.</p>\n<blockquote>\n<p>“가라데라는 무술에서 […] 검은띠에 대한 자존심의 상징은 검은 염료가 희게 퇴색할 정도로 길게 입으라는 것 처럼 다시 초심으로 돌아가라는 의미 입니다.”~ John Maeda,  <a href=\"https://www.amazon.com/Laws-Simplicity-Design-Technology-Business/dp/0262134721/ref%3Das_li_ss_tl%3Fie%3DUTF8%26qid%3D1516330765%26sr%3D8-1%26keywords%3Dthe%2Blaws%2Bof%2Bsimplicity%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3D287b1d3357fa799ce7563584e098c5d8\" target=\"_blank\" rel=\"noopener\">“The Laws of Simplicity (Simplicity: Design, Technology, Business, Life)”</a></p>\n</blockquote>\n<p>구글 사전에 따르면 추상화란  “그 연관성, 속성 또는 구체적인 사례와는 독립적인 무언가를 추려내는 과정” 입니다.</p>\n<p>abstraction은 라틴어 동사  <em>abstrahere</em> 에서 왔습니다. 이는 없애 버리다(to draw away)라는 의미 입니다.  전 이러한 깨달음을 좋아합니다.  추상화는 사물을 제거하는 것입니다. 그러나 무엇을 제거하고 무엇을 남겨야 합니까?</p>\n<p>때로는 단어를 다른 언어로 번역 한 다음 영어로 다시 번역하여 우리가 일반적으로 생각하지 않는 다른 연관성을 느끼는 것을 좋아합니다.  &quot;추상화&quot;를 이디시어로 번역하면 그 결과는 &quot;absentminded(무관심한, 넋이 나간)&quot;입니다.  전 이것도 좋아합니다.  무관심한 사람은 자동 조종 장치로 달리고 있는 것이나 마찬가지입니다. 하고있는 일에 대해 적극적으로 생각하지 않고 … 그냥 하고 있습니다.</p>\n<p>추상화를 통해 우리는 자동 조종 장치로 안전하게 달릴 수 있습니다.  모든 소프트웨어는 자동화입니다.  컴퓨터로 할 수 있는 모든 일들은 충분한 시간이 주어지면  종이, 잉크 그리고  비둘기로 할 수 있습니다.  소프트웨어는 수동으로 수행하려면 많은 시간이 소요될 수 있는 작은 세부 사항까지 모두 처리합니다.</p>\n<p>모든 소프트웨어는 추상화의 결과물입니다. 우리가 이러한 혜택을 누리는 동안 모든 힘든 작업들과 세부 사항들을 숨기고 있습니다.</p>\n<p>소프트웨어 프로세스는 반복적입니다.  문제를 분석하는 단계에서 반복되는 내용을 처음부터 다시 구현하려면 불필요한 작업을 많이 해야 합니다. 바보같은 짓이며 비실용적입니다.</p>\n<p>대신에 우리는 여러 종류의 구성 요소(함수, 모듈, 클래스 등)를 만들고 이름 (ID)을 부여하고 원하는 만큼 여러번 재사용함으로써 중복을 제거합니다.</p>\n<p>분해 과정은 추상화 과정입니다.  성공적인 추상화의 결과물은 개별적인 쓰임새가 있는 유용하고 재구성 가능한 요소들의 집합입니다.  이로부터 우리는 소프트웨어 아키텍처의 중요한 원칙을 얻게되었습니다.</p>\n<p>소프트웨어 솔루션은 내부 구성 요소의 구현 세부 사항을 변경하지 않고도 해당 구성 요소로 분해 할 수 있어야 하며 새로운 솔루션으로 재구성 가능해야합니다.</p>\n<h2 id=\"추상화는-단순화-작업입니다\">추상화는 단순화 작업입니다.</h2>\n<blockquote>\n<p>“단순함이란 명백한 부분을 제거하고 의미있는 부분을 남기는 것 입니다.”- John Maeda,  <a href=\"https://www.amazon.com/Laws-Simplicity-Design-Technology-Business/dp/0262134721/ref%3Das_li_ss_tl%3Fie%3DUTF8%26qid%3D1516330765%26sr%3D8-1%26keywords%3Dthe%2Blaws%2Bof%2Bsimplicity%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3D287b1d3357fa799ce7563584e098c5d8\" target=\"_blank\" rel=\"noopener\">“The Laws of Simplicity (Simplicity: Design, Technology, Business, Life)”</a></p>\n</blockquote>\n<p>추상화 프로세스에는 두 가지 요소가 있습니다.</p>\n<ul>\n<li><strong>일반화</strong><sup>Generalization</sup> 는 반복되는 패턴에서  <em>유사점</em>  (명백함)을 찾고 추상화 뒤에 이를 숨기는 과정입니다.</li>\n<li><strong>전문화</strong><sup>Specialization</sup>  는 각 유스케이스별로  무엇이 근본적으로 다른지  찾아 이를 남기는 과정입니다.</li>\n</ul>\n<p>추상화란 어떤 개념의 에센스를 추출하는 과정입니다.  서로 다른 영역의 서로 다른 문제들 사이의 공통점을 탐구함으로써 우리의 정신은 잠시 바깥으로 나가 다른 관점에서 문제를 바라보는 방법을 배웁니다.  문제의 본질을 파악해서 나온 좋은 해결책은 다른 많은 문제에 적용할 수 있다는 것을 알게됩니다.  솔루션을 잘 코딩하면 소프트웨어의 복잡성을 근본적으로 줄일 수 있습니다.</p>\n<blockquote>\n<p>“깊은 깨달음으로 한 가지를 만지면 모든 것을 만질 수 있습니다.”~ 팃낙한</p>\n</blockquote>\n<p>이 원칙은 애플리케이션을 빌드하기 위해 필요한 코드를 크게 줄이는데 사용할 수 있습니다.</p>\n<h2 id=\"소프트웨어-추상화\">소프트웨어 추상화</h2>\n<p>소프트웨어 추상화는 다음과 같은 다양한 형태를 취합니다.</p>\n<ul>\n<li>알고리즘<sup>Algorithm</sup></li>\n<li>자료구조<sup>Data</sup> <sup>Structure</sup></li>\n<li>모듈<sup>Module</sup></li>\n<li>클래스<sup>Class</sup></li>\n<li>프레임 워크<sup>Framework</sup></li>\n</ul>\n<p>그리고 제 개인적 취향인 :</p>\n<blockquote>\n<p>“때때로 우아한 구현은 단지 함수뿐입니다.  메소드가 아닙니다. 클래스도 아닙니다. 프레임워크도 아니고 그저 함수입니다.”~ John Carmack</p>\n</blockquote>\n<p>함수는 추상화에 필요한 훌륭한 특징들을 가지고 있습니다.</p>\n<ul>\n<li><strong>Identity</strong>  - 이름을 붙이고 다른 맥락에서 이를 다시 사용할 수 있는 특징입니다.</li>\n<li><strong>Composition</strong>  -간단한 함수들을 합성해 고차 함수를 만들 수 있습니다.</li>\n</ul>\n<h2 id=\"합성을-통한-추상화\">합성을 통한 추상화</h2>\n<p>소프트웨어를 추상화할 때 가장 유용한 함수는 수학 함수의 모듈러 특성을 공유하는  <em>순수 함수</em>  입니다.  수학의 함수는 동일한 입력을 받았을 때 항상 동일한 출력을 반환합니다.  함수를 입력과 출력 사이의 관계로 볼 수 있습니다.  어떤 입력  <code>A</code>가  주어지면 함수  <code>f</code>  는  <code>B</code>를 출력합니다. 이 때  <code>f</code>  가  <code>A</code>  와  <code>B</code> 사이의  관계를 정의한다고 말할 수 있습니다.</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">f</span>: A -&gt;</span> B</span><br></pre></td></tr></table></figure>\n<p>마찬가지로  <code>B</code>  와  <code>C</code>  사이의 관계를 정의하는 또 다른 함수  <code>g</code>  가 있을 때,</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">g</span>: B -&gt;</span> C</span><br></pre></td></tr></table></figure>\n<p>이는  <code>A</code>  에서  <code>C</code>로의 직접적인 관계를 정의하는 또 다른 함수  <code>h</code>가 있음을 의미합니다.</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">h</span>: A -&gt;</span> C</span><br></pre></td></tr></table></figure>\n<p>이러한 관계는 문제공간의 구조를 형성하며 함수를 합성하는 방법이 애플리케이션의 구조를 결정합니다.</p>\n<p>좋은 추상화는 내부 구조를 숨기며 단순화합니다. 마치 <code>h</code> 함수가<code>A -&gt; B -&gt; C</code>를  <code>A -&gt; C</code> 로 단순화하는 것과 비슷합니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uFTKDgI0kT878E97K14V1A.png\" alt=\"\"></p>\n<h2 id=\"적은-코드로-더-많은-작업을-수행하는-방법\">적은 코드로 더 많은 작업을 수행하는 방법</h2>\n<p>추상화는 적은 코드로 더 많은 일을 할 수있는 열쇠입니다.  예를 들어, 단순히 두 개의 숫자를 더하는 함수가 있다고 가정 해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure>\n<p>그러나 이를 반복적으로 사용하는 패턴이 있을 때 숫자하나를 고정시켜주는게 좋습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = add(<span class=\"number\">1</span>, <span class=\"number\">1</span>);   </span><br><span class=\"line\"><span class=\"keyword\">const</span> b = add(a, <span class=\"number\">1</span>);   </span><br><span class=\"line\"><span class=\"keyword\">const</span> c = add(b, <span class=\"number\">1</span>);   </span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<p>우리는 add 함수를 커링할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> b =&gt; a + b;</span><br></pre></td></tr></table></figure>\n<p>그리고 나서 첫 번째 인수를 받아 새 함수를 반환하는 프로그램을 만듭니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inc = add(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>이제는  <code>1</code> 씩 더해야 할 때  <code>add</code>  대신  <code>inc</code>를 사용할 수 있으므로 필요한 코드의 양이 줄어들었습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = inc(<span class=\"number\">1</span>);   </span><br><span class=\"line\"><span class=\"keyword\">const</span> b = inc(a);   </span><br><span class=\"line\"><span class=\"keyword\">const</span> c = inc(b);   </span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<p>이 경우  <code>inc</code>  는 add의  특수한  버전일 뿐입니다.  모든 커링은 추상화입니다.  사실, 모든 고차 함수는 하나 이상의 인수를 전달하여 특화시킬 수 있는 일반화입니다.</p>\n<p>예를 들어,  <code>Array.prototype.map()</code>은 배열의 각 요소에 함수를 적용하는 아이디어를 추상화한 고차 함수입니다.  보다 명확하게하기 위해  <code>map</code>을 커리된 함수로 작성해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> arr =&gt; arr.map(f);</span><br></pre></td></tr></table></figure>\n<p>이 버전의  <code>map</code>은 특정 함수를 취한 다음 처리 할 배열을 인수로 받는 함수를 리턴합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> doubleAll = map(f);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> doubled = doubleAll([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);  </span><br><span class=\"line\"><span class=\"comment\">// =&gt; [2, 4, 6]</span></span><br></pre></td></tr></table></figure>\n<p><code>doubleAll</code>의 코드가 얼마나 짧은지 보입니까 ? <code>map(f)</code>  - 이게 전부입니다!  이것이 전체 정의입니다.  추상화를 기본 요소로 삼으면 새로운 코드를 거의 만들지 않고도 매우 복잡한 기능들을 구현할 수 있습니다.</p>\n<h2 id=\"결론\">결론</h2>\n<p>소프트웨어 개발자는 모든 시간을 추상화하는데 사용합니다. 그럼에도 추상화 또는 합성에 대한 기본적인 이해가 거의 없는 경우가 많습니다.</p>\n<p>어떤 것을 추상화할 때는 충분한 시간을 들여 생각해야 합니다. 그리고 <code>map</code>  ,  <code>filter</code>  및  <code>reduce</code>  와 같은 유용한 추상화들을 알고 있어야합니다.  마지막으로 좋은 추상화의 특징을 알아보는 법을 배워야 합니다.</p>\n<ul>\n<li>단순한<sup>Simple</sup></li>\n<li>간결한<sup>Concise</sup></li>\n<li>재사용 가능한<sup>Reusable</sup></li>\n<li>독립적인<sup>Independent</sup></li>\n<li>분해가능한<sup>Decomposable</sup></li>\n<li>재구성가능한<sup>Recomposable</sup></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/abstraction-composition-cb2849d5bdd6\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a></p>\n</blockquote>\n<p>소프트웨어 개발자로서 성숙해질수록 기본적인 것들에 더 큰 가치를 부여하게 됩니다. 초보자였을 때 사소해 보였던 깨달음들이 그동안의 경험들과 함께 심오한 의미를 갖게됩니다.</p>\n<blockquote>\n<p>“가라데라는 무술에서 […] 검은띠에 대한 자존심의 상징은 검은 염료가 희게 퇴색할 정도로 길게 입으라는 것 처럼 다시 초심으로 돌아가라는 의미 입니다.”~ John Maeda,  <a href=\"https://www.amazon.com/Laws-Simplicity-Design-Technology-Business/dp/0262134721/ref%3Das_li_ss_tl%3Fie%3DUTF8%26qid%3D1516330765%26sr%3D8-1%26keywords%3Dthe%2Blaws%2Bof%2Bsimplicity%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3D287b1d3357fa799ce7563584e098c5d8\" target=\"_blank\" rel=\"noopener\">“The Laws of Simplicity (Simplicity: Design, Technology, Business, Life)”</a></p>\n</blockquote>\n<p>구글 사전에 따르면 추상화란  “그 연관성, 속성 또는 구체적인 사례와는 독립적인 무언가를 추려내는 과정” 입니다.</p>\n<p>abstraction은 라틴어 동사  <em>abstrahere</em> 에서 왔습니다. 이는 없애 버리다(to draw away)라는 의미 입니다.  전 이러한 깨달음을 좋아합니다.  추상화는 사물을 제거하는 것입니다. 그러나 무엇을 제거하고 무엇을 남겨야 합니까?</p>\n<p>때로는 단어를 다른 언어로 번역 한 다음 영어로 다시 번역하여 우리가 일반적으로 생각하지 않는 다른 연관성을 느끼는 것을 좋아합니다.  &quot;추상화&quot;를 이디시어로 번역하면 그 결과는 &quot;absentminded(무관심한, 넋이 나간)&quot;입니다.  전 이것도 좋아합니다.  무관심한 사람은 자동 조종 장치로 달리고 있는 것이나 마찬가지입니다. 하고있는 일에 대해 적극적으로 생각하지 않고 … 그냥 하고 있습니다.</p>\n<p>추상화를 통해 우리는 자동 조종 장치로 안전하게 달릴 수 있습니다.  모든 소프트웨어는 자동화입니다.  컴퓨터로 할 수 있는 모든 일들은 충분한 시간이 주어지면  종이, 잉크 그리고  비둘기로 할 수 있습니다.  소프트웨어는 수동으로 수행하려면 많은 시간이 소요될 수 있는 작은 세부 사항까지 모두 처리합니다.</p>\n<p>모든 소프트웨어는 추상화의 결과물입니다. 우리가 이러한 혜택을 누리는 동안 모든 힘든 작업들과 세부 사항들을 숨기고 있습니다.</p>\n<p>소프트웨어 프로세스는 반복적입니다.  문제를 분석하는 단계에서 반복되는 내용을 처음부터 다시 구현하려면 불필요한 작업을 많이 해야 합니다. 바보같은 짓이며 비실용적입니다.</p>\n<p>대신에 우리는 여러 종류의 구성 요소(함수, 모듈, 클래스 등)를 만들고 이름 (ID)을 부여하고 원하는 만큼 여러번 재사용함으로써 중복을 제거합니다.</p>\n<p>분해 과정은 추상화 과정입니다.  성공적인 추상화의 결과물은 개별적인 쓰임새가 있는 유용하고 재구성 가능한 요소들의 집합입니다.  이로부터 우리는 소프트웨어 아키텍처의 중요한 원칙을 얻게되었습니다.</p>\n<p>소프트웨어 솔루션은 내부 구성 요소의 구현 세부 사항을 변경하지 않고도 해당 구성 요소로 분해 할 수 있어야 하며 새로운 솔루션으로 재구성 가능해야합니다.</p>\n<h2>추상화는 단순화 작업입니다.</h2>\n<blockquote>\n<p>“단순함이란 명백한 부분을 제거하고 의미있는 부분을 남기는 것 입니다.”- John Maeda,  <a href=\"https://www.amazon.com/Laws-Simplicity-Design-Technology-Business/dp/0262134721/ref%3Das_li_ss_tl%3Fie%3DUTF8%26qid%3D1516330765%26sr%3D8-1%26keywords%3Dthe%2Blaws%2Bof%2Bsimplicity%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3D287b1d3357fa799ce7563584e098c5d8\" target=\"_blank\" rel=\"noopener\">“The Laws of Simplicity (Simplicity: Design, Technology, Business, Life)”</a></p>\n</blockquote>\n<p>추상화 프로세스에는 두 가지 요소가 있습니다.</p>\n<ul>\n<li><strong>일반화</strong><sup>Generalization</sup> 는 반복되는 패턴에서  <em>유사점</em>  (명백함)을 찾고 추상화 뒤에 이를 숨기는 과정입니다.</li>\n<li><strong>전문화</strong><sup>Specialization</sup>  는 각 유스케이스별로  무엇이 근본적으로 다른지  찾아 이를 남기는 과정입니다.</li>\n</ul>\n<p>추상화란 어떤 개념의 에센스를 추출하는 과정입니다.  서로 다른 영역의 서로 다른 문제들 사이의 공통점을 탐구함으로써 우리의 정신은 잠시 바깥으로 나가 다른 관점에서 문제를 바라보는 방법을 배웁니다.  문제의 본질을 파악해서 나온 좋은 해결책은 다른 많은 문제에 적용할 수 있다는 것을 알게됩니다.  솔루션을 잘 코딩하면 소프트웨어의 복잡성을 근본적으로 줄일 수 있습니다.</p>\n<blockquote>\n<p>“깊은 깨달음으로 한 가지를 만지면 모든 것을 만질 수 있습니다.”~ 팃낙한</p>\n</blockquote>\n<p>이 원칙은 애플리케이션을 빌드하기 위해 필요한 코드를 크게 줄이는데 사용할 수 있습니다.</p>\n<h2>소프트웨어 추상화</h2>\n<p>소프트웨어 추상화는 다음과 같은 다양한 형태를 취합니다.</p>\n<ul>\n<li>알고리즘<sup>Algorithm</sup></li>\n<li>자료구조<sup>Data</sup> <sup>Structure</sup></li>\n<li>모듈<sup>Module</sup></li>\n<li>클래스<sup>Class</sup></li>\n<li>프레임 워크<sup>Framework</sup></li>\n</ul>\n<p>그리고 제 개인적 취향인 :</p>\n<blockquote>\n<p>“때때로 우아한 구현은 단지 함수뿐입니다.  메소드가 아닙니다. 클래스도 아닙니다. 프레임워크도 아니고 그저 함수입니다.”~ John Carmack</p>\n</blockquote>\n<p>함수는 추상화에 필요한 훌륭한 특징들을 가지고 있습니다.</p>\n<ul>\n<li><strong>Identity</strong>  - 이름을 붙이고 다른 맥락에서 이를 다시 사용할 수 있는 특징입니다.</li>\n<li><strong>Composition</strong>  -간단한 함수들을 합성해 고차 함수를 만들 수 있습니다.</li>\n</ul>\n<h2>합성을 통한 추상화</h2>\n<p>소프트웨어를 추상화할 때 가장 유용한 함수는 수학 함수의 모듈러 특성을 공유하는  <em>순수 함수</em>  입니다.  수학의 함수는 동일한 입력을 받았을 때 항상 동일한 출력을 반환합니다.  함수를 입력과 출력 사이의 관계로 볼 수 있습니다.  어떤 입력  <code>A</code>가  주어지면 함수  <code>f</code>  는  <code>B</code>를 출력합니다. 이 때  <code>f</code>  가  <code>A</code>  와  <code>B</code> 사이의  관계를 정의한다고 말할 수 있습니다.</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">f</span>: A -&gt;</span> B</span><br></pre></td></tr></table></figure>\n<p>마찬가지로  <code>B</code>  와  <code>C</code>  사이의 관계를 정의하는 또 다른 함수  <code>g</code>  가 있을 때,</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">g</span>: B -&gt;</span> C</span><br></pre></td></tr></table></figure>\n<p>이는  <code>A</code>  에서  <code>C</code>로의 직접적인 관계를 정의하는 또 다른 함수  <code>h</code>가 있음을 의미합니다.</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">h</span>: A -&gt;</span> C</span><br></pre></td></tr></table></figure>\n<p>이러한 관계는 문제공간의 구조를 형성하며 함수를 합성하는 방법이 애플리케이션의 구조를 결정합니다.</p>\n<p>좋은 추상화는 내부 구조를 숨기며 단순화합니다. 마치 <code>h</code> 함수가<code>A -&gt; B -&gt; C</code>를  <code>A -&gt; C</code> 로 단순화하는 것과 비슷합니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uFTKDgI0kT878E97K14V1A.png\" alt=\"\"></p>\n<h2>적은 코드로 더 많은 작업을 수행하는 방법</h2>\n<p>추상화는 적은 코드로 더 많은 일을 할 수있는 열쇠입니다.  예를 들어, 단순히 두 개의 숫자를 더하는 함수가 있다고 가정 해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure>\n<p>그러나 이를 반복적으로 사용하는 패턴이 있을 때 숫자하나를 고정시켜주는게 좋습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = add(<span class=\"number\">1</span>, <span class=\"number\">1</span>);   </span><br><span class=\"line\"><span class=\"keyword\">const</span> b = add(a, <span class=\"number\">1</span>);   </span><br><span class=\"line\"><span class=\"keyword\">const</span> c = add(b, <span class=\"number\">1</span>);   </span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<p>우리는 add 함수를 커링할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> b =&gt; a + b;</span><br></pre></td></tr></table></figure>\n<p>그리고 나서 첫 번째 인수를 받아 새 함수를 반환하는 프로그램을 만듭니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inc = add(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>이제는  <code>1</code> 씩 더해야 할 때  <code>add</code>  대신  <code>inc</code>를 사용할 수 있으므로 필요한 코드의 양이 줄어들었습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = inc(<span class=\"number\">1</span>);   </span><br><span class=\"line\"><span class=\"keyword\">const</span> b = inc(a);   </span><br><span class=\"line\"><span class=\"keyword\">const</span> c = inc(b);   </span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<p>이 경우  <code>inc</code>  는 add의  특수한  버전일 뿐입니다.  모든 커링은 추상화입니다.  사실, 모든 고차 함수는 하나 이상의 인수를 전달하여 특화시킬 수 있는 일반화입니다.</p>\n<p>예를 들어,  <code>Array.prototype.map()</code>은 배열의 각 요소에 함수를 적용하는 아이디어를 추상화한 고차 함수입니다.  보다 명확하게하기 위해  <code>map</code>을 커리된 함수로 작성해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> arr =&gt; arr.map(f);</span><br></pre></td></tr></table></figure>\n<p>이 버전의  <code>map</code>은 특정 함수를 취한 다음 처리 할 배열을 인수로 받는 함수를 리턴합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> doubleAll = map(f);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> doubled = doubleAll([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);  </span><br><span class=\"line\"><span class=\"comment\">// =&gt; [2, 4, 6]</span></span><br></pre></td></tr></table></figure>\n<p><code>doubleAll</code>의 코드가 얼마나 짧은지 보입니까 ? <code>map(f)</code>  - 이게 전부입니다!  이것이 전체 정의입니다.  추상화를 기본 요소로 삼으면 새로운 코드를 거의 만들지 않고도 매우 복잡한 기능들을 구현할 수 있습니다.</p>\n<h2>결론</h2>\n<p>소프트웨어 개발자는 모든 시간을 추상화하는데 사용합니다. 그럼에도 추상화 또는 합성에 대한 기본적인 이해가 거의 없는 경우가 많습니다.</p>\n<p>어떤 것을 추상화할 때는 충분한 시간을 들여 생각해야 합니다. 그리고 <code>map</code>  ,  <code>filter</code>  및  <code>reduce</code>  와 같은 유용한 추상화들을 알고 있어야합니다.  마지막으로 좋은 추상화의 특징을 알아보는 법을 배워야 합니다.</p>\n<ul>\n<li>단순한<sup>Simple</sup></li>\n<li>간결한<sup>Concise</sup></li>\n<li>재사용 가능한<sup>Reusable</sup></li>\n<li>독립적인<sup>Independent</sup></li>\n<li>분해가능한<sup>Decomposable</sup></li>\n<li>재구성가능한<sup>Recomposable</sup></li>\n</ul>\n"},{"title":"함수형 자료구조","catalog":true,"date":"2018-04-14T15:21:45.000Z","subtitle":"Composable Datatypes with Functions","header-img":"bg.jpg","readingTime":5,"catagories":["개발"],"preview":"JavaScript에서 무언가를 합성^compose^하는 가장 쉬운 방법은 함수 합성이며 함수는 객체이기 때문에 메소드가 추가 될 수 있습니다 `t`는 숫자형 인스턴스를 생성하는 팩토리입니다.  그러나 `t`의 인스턴스는 단순한 객체가 아닙니다.  **함수**입니다. 즉, 일반적인 함수와 마찬가지로 합성할 수 있습니다.  기본적으로 멤버를 더하는 함수라고 가정 해 봅시다.  어쩌면 합성될 때 더해지는 것이 합리적 일 수 있습니다. 먼저 몇 가지 규칙을 세우겠습니다. ( `====`는  \"동등한\"을 의미).","_content":"\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/composable-datatypes-with-functions-aec72db3b093)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/)\n\n## 함수형 자료구조\n\nJavaScript에서 무언가를 합성^compose^하는 가장 쉬운 방법은 함수 합성이며 함수는 객체이기 때문에 메소드가 추가 될 수 있습니다 :\n\n```javascript\nconst t = value => {  \n  const fn = () => value;\n\n  fn.toString = () => `t(${ value })`;\n\n  return fn;  \n};  \n  \n\nconst someValue = t(2);\n\nconsole.log(  \n  someValue.toString() // \"t(2)\"  \n);\n```\n\n`t`는 숫자형 인스턴스를 생성하는 팩토리입니다.  그러나 `t`의 인스턴스는 단순한 객체가 아닙니다.  **함수**입니다. 즉, 일반적인 함수와 마찬가지로 합성할 수 있습니다.  기본적으로 멤버를 더하는 함수라고 가정 해 봅시다.  어쩌면 합성될 때 더해지는 것이 합리적 일 수 있습니다.\n\n먼저 몇 가지 규칙을 세우겠습니다. ( `====`는  \"동등한\"을 의미).\n\n-   `t(x)(t(0)) ==== t(x)`\n-   `t(x)(t(1)) ==== t(x + 1)`\n\n`.toString()`  메소드를 사용하면 다음과 같습니다.\n\n-   `t(x)(t(0)).toString() === t(x).toString()`\n-   `t(x)(t(1)).toString() === t(x + 1).toString()`\n\n이 규칙들을 바탕으로 간단한 유닛 테스트를 작성해보겠습니다 :\n\n```javascript\nconst assert = {  \n  same: (actual, expected, msg) => {  \n    if (actual.toString() !== expected.toString()) {  \n      throw new Error(`NOT OK: ${ msg }  \n        Expected: ${ expected }  \n        Actual:   ${ actual }  \n      `);  \n    }\n\n    console.log(`OK: ${ msg }`);  \n  }  \n};  \n  \n\n{  \n  const msg = 'a value t(x) composed with t(0) ==== t(x)';  \n  const x = 20;  \n  const a = t(x)(t(0));  \n  const b = t(x);  \n  assert.same(a, b, msg);  \n}\n\n{  \n  const msg = 'a value t(x) composed with t(1) ==== t(x + 1)';  \n  const x = 20;  \n  const a = t(x)(t(1));  \n  const b = t(x + 1);  \n  assert.same(a, b, msg);  \n}\n```\n처음에는 실패합니다.\n```javascript\n NOT OK: a value t(x) composed with t(0) ==== t(x)   \n\t\t Expected: t(20)   \n\t\t Actual: 20\n```\n\n> 이는 `fn`이 `t` 인스턴스가 아니라 실제 값인 `value`를 리턴하기 때문입니다.  flatten되는 것이지요. 계속되는 논의에서 저자는 이를 monoid 형태로 만들어갑니다 -역자\n\n그러나 다음 세가지 단계를 거쳐 간단하게 통과시킬 수 있습니다.\n\n1.  `fn`  함수를  `t(value + n)`를 리턴하는  `add`  함수로 변경합니다. 여기서  `n`은 전달 된 인수입니다.\n2.  새로운  `add()`함수가  `t()` 인스턴스를 인수로 취할 수 있도록 하겠습니다.   이를 위해 `.valueOf()`메소드가  `t` 타입을 풀어줄 수 있게합니다. 그리고 `+`  연산자는 두 번째 피연산자로  `n.valueOf()`의 결과를 사용합니다.\n3.  `Object.assign()`  을 사용하여  `add()`  함수에 메소드들을 추가합니다.\n\n새로 작성한 코드입니다.\n```javascript\nconst t = value => {  \n  const add = n => t(value + n);\n\n  return Object.assign(add, {  \n    toString: () => `t(${ value })`,  \n    valueOf: () => value  \n  });  \n};\n```\n이번에는 테스트가 통과합니다.\n```javascript\n\"OK: a value t(x) composed with t(0) ==== t(x)\"  \n\"OK: a value t(x) composed with t(1) ==== t(x + 1)\"\n```\n이제  `t()`값을 함수 합성으로 연산할 수 있습니다.\n```javascript\n// Compose functions from top to bottom:  \nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\n\n// Sugar to kick off the pipeline with an initial value:  \nconst sumT = (...fns) => pipe(...fns)(t(0));\n\nsumT(  \n  t(2),  \n  t(4),  \n  t(-1)  \n).valueOf(); // 5\n```\n## 모든 데이터 유형에 대해 가능합니다\n\n합성 자체에 특정한 의미를 부여할 수 있는 한 데이터가 어떤 모양을 하고있는지는 중요하지 않습니다.  배열 또는 문자열의 경우 연결^concatenation^ 일 수 있습니다.  DSP의 경우 신호 합계가 될 수 있습니다.  수많은 예들이 있을 겁니다.  어떤 연산 혹은 작업이 합성이란 개념과 잘 맞는가라는 질문이 핵심이 됩니다. 즉, 어떤 작업이 다음처럼 표현하기 좋을까요?\n```javascript\nconst result = compose(  \n  value1,  \n  value2,  \n  value3  \n);\n```\n## Composable Currency 예제\n\n[Moneysafe](https://github.com/ericelliott/moneysafe)는 함수형 자료구조로 구현된 오픈 소스 라이브러리입니다.  JavaScript의  `Number`는 소숫점 자리의 달러를 정확하게 나타낼 수 없습니다.\n```javascript\n  .1 + .2 === .3 // false \n```\nMoneysafe는 달러를 센트로 변환해 문제를 해결합니다.\n```bash\n $ npm install --save moneysafe\n```\n사용법은 다음과 같습니다:\n```javascript\nimport { $ } from 'moneysafe';\n\n$(.1) + $(.2) === $(.3).cents; // true\n```\n렛저^ledger^(장부)라는 간단한 함수 합성 유틸리티가 있습니다. 렛저 구문은 Moneysafe가 값을 승급^lift^하여 함수처럼 다룰 수 있다는 사실을 이용합니다.  \n```javascript\nimport { $ } from 'moneysafe';  \nimport { $$, subtractPercent, addPercent } from 'moneysafe/ledger';\n\n$$(  \n  $(40),  \n  $(60),  \n  // subtract discount  \n  subtractPercent(20),  \n  // add tax  \n  addPercent(10)  \n).$; // 88\n```\n리턴 값은 처음에 승급된 화폐 값입니다.  내부적으로  부동 소수점 센트 값을 달러로 변환하여 가장 가까운 센트로 반올림하며 이를 `.$`라는 getter를 사용해 받을 수 있습니다.\n\n즉, 장부처럼 금전계산을 할 수있는 직관적인 인터페이스입니다.\n\n### 실습해보기\n\nMoneysafe를 git에서 받아옵니다 :\n\n```bash\n$ git clone git@github.com:ericelliott/moneysafe.git \n```\n\n디펜던시들을 설치 합니다.\n\n```bash\n$ npm install\n```\n\nwatch 콘솔을 사용하여 단위 테스트를 실행하십시오.  모두 통과해야합니다 :\n\n```bash\n$ npm run watch\n```\n\n새 터미널을 열고 구현된 코드들을 삭제하겠습니다.\n\n```bash\n$ rm source/moneysafe.js && touch source/moneysafe.js\n```\n\nwatch 콘솔 테스트를 다시 한 번 살펴보십시오.  이제는 오류가 표시되어야합니다.\n\n여러분의 임무는 unit test와 documentation을 참고해서 `moneysafe.js`를 처음부터 다시 구현하는 것입니다.\n\n회원들을 위해 7개의 파트로 구성된 튜토리얼 시리즈를 녹화했습니다.  여기 첫 번째 에피소드가 있습니다.\n\nMoneysafe 튜토리얼은  [Shotgun 시리즈](https://ericelliottjs.com/premium-content/shotgun-the-moneysafe-series/)에서 볼 수 있습니다.\n\n회원이 아니십니까?  [지금 가입하세요](https://ericelliottjs.com/product/lifetime-access-pass/).\n\n[**다음: JavaScript 모나드 >**](https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/)","source":"_posts/composable-datatype-with-functions.md","raw":"---\ntitle: 함수형 자료구조\ncatalog: true\ndate: 2018-04-15 00:21:45\nsubtitle: Composable Datatypes with Functions\nheader-img: \"bg.jpg\"\nreadingTime: 5\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: JavaScript에서 무언가를 합성^compose^하는 가장 쉬운 방법은 함수 합성이며 함수는 객체이기 때문에 메소드가 추가 될 수 있습니다 `t`는 숫자형 인스턴스를 생성하는 팩토리입니다.  그러나 `t`의 인스턴스는 단순한 객체가 아닙니다.  **함수**입니다. 즉, 일반적인 함수와 마찬가지로 합성할 수 있습니다.  기본적으로 멤버를 더하는 함수라고 가정 해 봅시다.  어쩌면 합성될 때 더해지는 것이 합리적 일 수 있습니다. 먼저 몇 가지 규칙을 세우겠습니다. ( `====`는  \"동등한\"을 의미).\n---\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/composable-datatypes-with-functions-aec72db3b093)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/)\n\n## 함수형 자료구조\n\nJavaScript에서 무언가를 합성^compose^하는 가장 쉬운 방법은 함수 합성이며 함수는 객체이기 때문에 메소드가 추가 될 수 있습니다 :\n\n```javascript\nconst t = value => {  \n  const fn = () => value;\n\n  fn.toString = () => `t(${ value })`;\n\n  return fn;  \n};  \n  \n\nconst someValue = t(2);\n\nconsole.log(  \n  someValue.toString() // \"t(2)\"  \n);\n```\n\n`t`는 숫자형 인스턴스를 생성하는 팩토리입니다.  그러나 `t`의 인스턴스는 단순한 객체가 아닙니다.  **함수**입니다. 즉, 일반적인 함수와 마찬가지로 합성할 수 있습니다.  기본적으로 멤버를 더하는 함수라고 가정 해 봅시다.  어쩌면 합성될 때 더해지는 것이 합리적 일 수 있습니다.\n\n먼저 몇 가지 규칙을 세우겠습니다. ( `====`는  \"동등한\"을 의미).\n\n-   `t(x)(t(0)) ==== t(x)`\n-   `t(x)(t(1)) ==== t(x + 1)`\n\n`.toString()`  메소드를 사용하면 다음과 같습니다.\n\n-   `t(x)(t(0)).toString() === t(x).toString()`\n-   `t(x)(t(1)).toString() === t(x + 1).toString()`\n\n이 규칙들을 바탕으로 간단한 유닛 테스트를 작성해보겠습니다 :\n\n```javascript\nconst assert = {  \n  same: (actual, expected, msg) => {  \n    if (actual.toString() !== expected.toString()) {  \n      throw new Error(`NOT OK: ${ msg }  \n        Expected: ${ expected }  \n        Actual:   ${ actual }  \n      `);  \n    }\n\n    console.log(`OK: ${ msg }`);  \n  }  \n};  \n  \n\n{  \n  const msg = 'a value t(x) composed with t(0) ==== t(x)';  \n  const x = 20;  \n  const a = t(x)(t(0));  \n  const b = t(x);  \n  assert.same(a, b, msg);  \n}\n\n{  \n  const msg = 'a value t(x) composed with t(1) ==== t(x + 1)';  \n  const x = 20;  \n  const a = t(x)(t(1));  \n  const b = t(x + 1);  \n  assert.same(a, b, msg);  \n}\n```\n처음에는 실패합니다.\n```javascript\n NOT OK: a value t(x) composed with t(0) ==== t(x)   \n\t\t Expected: t(20)   \n\t\t Actual: 20\n```\n\n> 이는 `fn`이 `t` 인스턴스가 아니라 실제 값인 `value`를 리턴하기 때문입니다.  flatten되는 것이지요. 계속되는 논의에서 저자는 이를 monoid 형태로 만들어갑니다 -역자\n\n그러나 다음 세가지 단계를 거쳐 간단하게 통과시킬 수 있습니다.\n\n1.  `fn`  함수를  `t(value + n)`를 리턴하는  `add`  함수로 변경합니다. 여기서  `n`은 전달 된 인수입니다.\n2.  새로운  `add()`함수가  `t()` 인스턴스를 인수로 취할 수 있도록 하겠습니다.   이를 위해 `.valueOf()`메소드가  `t` 타입을 풀어줄 수 있게합니다. 그리고 `+`  연산자는 두 번째 피연산자로  `n.valueOf()`의 결과를 사용합니다.\n3.  `Object.assign()`  을 사용하여  `add()`  함수에 메소드들을 추가합니다.\n\n새로 작성한 코드입니다.\n```javascript\nconst t = value => {  \n  const add = n => t(value + n);\n\n  return Object.assign(add, {  \n    toString: () => `t(${ value })`,  \n    valueOf: () => value  \n  });  \n};\n```\n이번에는 테스트가 통과합니다.\n```javascript\n\"OK: a value t(x) composed with t(0) ==== t(x)\"  \n\"OK: a value t(x) composed with t(1) ==== t(x + 1)\"\n```\n이제  `t()`값을 함수 합성으로 연산할 수 있습니다.\n```javascript\n// Compose functions from top to bottom:  \nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\n\n// Sugar to kick off the pipeline with an initial value:  \nconst sumT = (...fns) => pipe(...fns)(t(0));\n\nsumT(  \n  t(2),  \n  t(4),  \n  t(-1)  \n).valueOf(); // 5\n```\n## 모든 데이터 유형에 대해 가능합니다\n\n합성 자체에 특정한 의미를 부여할 수 있는 한 데이터가 어떤 모양을 하고있는지는 중요하지 않습니다.  배열 또는 문자열의 경우 연결^concatenation^ 일 수 있습니다.  DSP의 경우 신호 합계가 될 수 있습니다.  수많은 예들이 있을 겁니다.  어떤 연산 혹은 작업이 합성이란 개념과 잘 맞는가라는 질문이 핵심이 됩니다. 즉, 어떤 작업이 다음처럼 표현하기 좋을까요?\n```javascript\nconst result = compose(  \n  value1,  \n  value2,  \n  value3  \n);\n```\n## Composable Currency 예제\n\n[Moneysafe](https://github.com/ericelliott/moneysafe)는 함수형 자료구조로 구현된 오픈 소스 라이브러리입니다.  JavaScript의  `Number`는 소숫점 자리의 달러를 정확하게 나타낼 수 없습니다.\n```javascript\n  .1 + .2 === .3 // false \n```\nMoneysafe는 달러를 센트로 변환해 문제를 해결합니다.\n```bash\n $ npm install --save moneysafe\n```\n사용법은 다음과 같습니다:\n```javascript\nimport { $ } from 'moneysafe';\n\n$(.1) + $(.2) === $(.3).cents; // true\n```\n렛저^ledger^(장부)라는 간단한 함수 합성 유틸리티가 있습니다. 렛저 구문은 Moneysafe가 값을 승급^lift^하여 함수처럼 다룰 수 있다는 사실을 이용합니다.  \n```javascript\nimport { $ } from 'moneysafe';  \nimport { $$, subtractPercent, addPercent } from 'moneysafe/ledger';\n\n$$(  \n  $(40),  \n  $(60),  \n  // subtract discount  \n  subtractPercent(20),  \n  // add tax  \n  addPercent(10)  \n).$; // 88\n```\n리턴 값은 처음에 승급된 화폐 값입니다.  내부적으로  부동 소수점 센트 값을 달러로 변환하여 가장 가까운 센트로 반올림하며 이를 `.$`라는 getter를 사용해 받을 수 있습니다.\n\n즉, 장부처럼 금전계산을 할 수있는 직관적인 인터페이스입니다.\n\n### 실습해보기\n\nMoneysafe를 git에서 받아옵니다 :\n\n```bash\n$ git clone git@github.com:ericelliott/moneysafe.git \n```\n\n디펜던시들을 설치 합니다.\n\n```bash\n$ npm install\n```\n\nwatch 콘솔을 사용하여 단위 테스트를 실행하십시오.  모두 통과해야합니다 :\n\n```bash\n$ npm run watch\n```\n\n새 터미널을 열고 구현된 코드들을 삭제하겠습니다.\n\n```bash\n$ rm source/moneysafe.js && touch source/moneysafe.js\n```\n\nwatch 콘솔 테스트를 다시 한 번 살펴보십시오.  이제는 오류가 표시되어야합니다.\n\n여러분의 임무는 unit test와 documentation을 참고해서 `moneysafe.js`를 처음부터 다시 구현하는 것입니다.\n\n회원들을 위해 7개의 파트로 구성된 튜토리얼 시리즈를 녹화했습니다.  여기 첫 번째 에피소드가 있습니다.\n\nMoneysafe 튜토리얼은  [Shotgun 시리즈](https://ericelliottjs.com/premium-content/shotgun-the-moneysafe-series/)에서 볼 수 있습니다.\n\n회원이 아니십니까?  [지금 가입하세요](https://ericelliottjs.com/product/lifetime-access-pass/).\n\n[**다음: JavaScript 모나드 >**](https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/)","slug":"composable-datatype-with-functions","published":1,"updated":"2018-04-28T13:38:21.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83cn0008ifp6yt02c4o1","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/composable-datatypes-with-functions-aec72db3b093\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/\">다음&gt;</a></p>\n</blockquote>\n<h2 id=\"함수형-자료구조\">함수형 자료구조</h2>\n<p>JavaScript에서 무언가를 합성<sup>compose</sup>하는 가장 쉬운 방법은 함수 합성이며 함수는 객체이기 때문에 메소드가 추가 될 수 있습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> t = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn.toString = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`t(<span class=\"subst\">$&#123; value &#125;</span>)`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> someValue = t(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  someValue.toString() <span class=\"comment\">// \"t(2)\"  </span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>t</code>는 숫자형 인스턴스를 생성하는 팩토리입니다.  그러나 <code>t</code>의 인스턴스는 단순한 객체가 아닙니다.  <strong>함수</strong>입니다. 즉, 일반적인 함수와 마찬가지로 합성할 수 있습니다.  기본적으로 멤버를 더하는 함수라고 가정 해 봅시다.  어쩌면 합성될 때 더해지는 것이 합리적 일 수 있습니다.</p>\n<p>먼저 몇 가지 규칙을 세우겠습니다. ( <code>====</code>는  &quot;동등한&quot;을 의미).</p>\n<ul>\n<li><code>t(x)(t(0)) ==== t(x)</code></li>\n<li><code>t(x)(t(1)) ==== t(x + 1)</code></li>\n</ul>\n<p><code>.toString()</code>  메소드를 사용하면 다음과 같습니다.</p>\n<ul>\n<li><code>t(x)(t(0)).toString() === t(x).toString()</code></li>\n<li><code>t(x)(t(1)).toString() === t(x + 1).toString()</code></li>\n</ul>\n<p>이 규칙들을 바탕으로 간단한 유닛 테스트를 작성해보겠습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> assert = &#123;  </span><br><span class=\"line\">  same: <span class=\"function\">(<span class=\"params\">actual, expected, msg</span>) =&gt;</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (actual.toString() !== expected.toString()) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`NOT OK: <span class=\"subst\">$&#123; msg &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">        Expected: <span class=\"subst\">$&#123; expected &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">        Actual:   <span class=\"subst\">$&#123; actual &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">      `</span>);  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`OK: <span class=\"subst\">$&#123; msg &#125;</span>`</span>);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> msg = <span class=\"string\">'a value t(x) composed with t(0) ==== t(x)'</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = t(x)(t(<span class=\"number\">0</span>));  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = t(x);  </span><br><span class=\"line\">  assert.same(a, b, msg);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> msg = <span class=\"string\">'a value t(x) composed with t(1) ==== t(x + 1)'</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = t(x)(t(<span class=\"number\">1</span>));  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = t(x + <span class=\"number\">1</span>);  </span><br><span class=\"line\">  assert.same(a, b, msg);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>처음에는 실패합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NOT OK: a value t(x) composed <span class=\"keyword\">with</span> t(<span class=\"number\">0</span>) ==== t(x)   </span><br><span class=\"line\">\t Expected: t(<span class=\"number\">20</span>)   </span><br><span class=\"line\">\t Actual: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>이는 <code>fn</code>이 <code>t</code> 인스턴스가 아니라 실제 값인 <code>value</code>를 리턴하기 때문입니다.  flatten되는 것이지요. 계속되는 논의에서 저자는 이를 monoid 형태로 만들어갑니다 -역자</p>\n</blockquote>\n<p>그러나 다음 세가지 단계를 거쳐 간단하게 통과시킬 수 있습니다.</p>\n<ol>\n<li><code>fn</code>  함수를  <code>t(value + n)</code>를 리턴하는  <code>add</code>  함수로 변경합니다. 여기서  <code>n</code>은 전달 된 인수입니다.</li>\n<li>새로운  <code>add()</code>함수가  <code>t()</code> 인스턴스를 인수로 취할 수 있도록 하겠습니다.   이를 위해 <code>.valueOf()</code>메소드가  <code>t</code> 타입을 풀어줄 수 있게합니다. 그리고 <code>+</code>  연산자는 두 번째 피연산자로  <code>n.valueOf()</code>의 결과를 사용합니다.</li>\n<li><code>Object.assign()</code>  을 사용하여  <code>add()</code>  함수에 메소드들을 추가합니다.</li>\n</ol>\n<p>새로 작성한 코드입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> t = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> add = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> t(value + n);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(add, &#123;  </span><br><span class=\"line\">    toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`t(<span class=\"subst\">$&#123; value &#125;</span>)`</span>,  </span><br><span class=\"line\">    valueOf: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> value  </span><br><span class=\"line\">  &#125;);  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>이번에는 테스트가 통과합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"OK: a value t(x) composed with t(0) ==== t(x)\"</span>  </span><br><span class=\"line\"><span class=\"string\">\"OK: a value t(x) composed with t(1) ==== t(x + 1)\"</span></span><br></pre></td></tr></table></figure>\n<p>이제  <code>t()</code>값을 함수 합성으로 연산할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Compose functions from top to bottom:  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Sugar to kick off the pipeline with an initial value:  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sumT = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> pipe(...fns)(t(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">sumT(  </span><br><span class=\"line\">  t(<span class=\"number\">2</span>),  </span><br><span class=\"line\">  t(<span class=\"number\">4</span>),  </span><br><span class=\"line\">  t(<span class=\"number\">-1</span>)  </span><br><span class=\"line\">).valueOf(); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"모든-데이터-유형에-대해-가능합니다\">모든 데이터 유형에 대해 가능합니다</h2>\n<p>합성 자체에 특정한 의미를 부여할 수 있는 한 데이터가 어떤 모양을 하고있는지는 중요하지 않습니다.  배열 또는 문자열의 경우 연결<sup>concatenation</sup> 일 수 있습니다.  DSP의 경우 신호 합계가 될 수 있습니다.  수많은 예들이 있을 겁니다.  어떤 연산 혹은 작업이 합성이란 개념과 잘 맞는가라는 질문이 핵심이 됩니다. 즉, 어떤 작업이 다음처럼 표현하기 좋을까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result = compose(  </span><br><span class=\"line\">  value1,  </span><br><span class=\"line\">  value2,  </span><br><span class=\"line\">  value3  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"composable-currency-예제\">Composable Currency 예제</h2>\n<p><a href=\"https://github.com/ericelliott/moneysafe\" target=\"_blank\" rel=\"noopener\">Moneysafe</a>는 함수형 자료구조로 구현된 오픈 소스 라이브러리입니다.  JavaScript의  <code>Number</code>는 소숫점 자리의 달러를 정확하게 나타낼 수 없습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">.1</span> + <span class=\"number\">.2</span> === <span class=\"number\">.3</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>Moneysafe는 달러를 센트로 변환해 문제를 해결합니다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save moneysafe</span><br></pre></td></tr></table></figure>\n<p>사용법은 다음과 같습니다:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; $ &#125; <span class=\"keyword\">from</span> <span class=\"string\">'moneysafe'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"number\">.1</span>) + $(<span class=\"number\">.2</span>) === $(<span class=\"number\">.3</span>).cents; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>렛저<sup>ledger</sup>(장부)라는 간단한 함수 합성 유틸리티가 있습니다. 렛저 구문은 Moneysafe가 값을 승급<sup>lift</sup>하여 함수처럼 다룰 수 있다는 사실을 이용합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; $ &#125; <span class=\"keyword\">from</span> <span class=\"string\">'moneysafe'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; $$, subtractPercent, addPercent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'moneysafe/ledger'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$$(  </span><br><span class=\"line\">  $(<span class=\"number\">40</span>),  </span><br><span class=\"line\">  $(<span class=\"number\">60</span>),  </span><br><span class=\"line\">  <span class=\"comment\">// subtract discount  </span></span><br><span class=\"line\">  subtractPercent(<span class=\"number\">20</span>),  </span><br><span class=\"line\">  <span class=\"comment\">// add tax  </span></span><br><span class=\"line\">  addPercent(<span class=\"number\">10</span>)  </span><br><span class=\"line\">).$; <span class=\"comment\">// 88</span></span><br></pre></td></tr></table></figure>\n<p>리턴 값은 처음에 승급된 화폐 값입니다.  내부적으로  부동 소수점 센트 값을 달러로 변환하여 가장 가까운 센트로 반올림하며 이를 <code>.$</code>라는 getter를 사용해 받을 수 있습니다.</p>\n<p>즉, 장부처럼 금전계산을 할 수있는 직관적인 인터페이스입니다.</p>\n<h3 id=\"실습해보기\">실습해보기</h3>\n<p>Moneysafe를 git에서 받아옵니다 :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:ericelliott/moneysafe.git</span><br></pre></td></tr></table></figure>\n<p>디펜던시들을 설치 합니다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>watch 콘솔을 사용하여 단위 테스트를 실행하십시오.  모두 통과해야합니다 :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run watch</span><br></pre></td></tr></table></figure>\n<p>새 터미널을 열고 구현된 코드들을 삭제하겠습니다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm <span class=\"built_in\">source</span>/moneysafe.js &amp;&amp; touch <span class=\"built_in\">source</span>/moneysafe.js</span><br></pre></td></tr></table></figure>\n<p>watch 콘솔 테스트를 다시 한 번 살펴보십시오.  이제는 오류가 표시되어야합니다.</p>\n<p>여러분의 임무는 unit test와 documentation을 참고해서 <code>moneysafe.js</code>를 처음부터 다시 구현하는 것입니다.</p>\n<p>회원들을 위해 7개의 파트로 구성된 튜토리얼 시리즈를 녹화했습니다.  여기 첫 번째 에피소드가 있습니다.</p>\n<p>Moneysafe 튜토리얼은  <a href=\"https://ericelliottjs.com/premium-content/shotgun-the-moneysafe-series/\" target=\"_blank\" rel=\"noopener\">Shotgun 시리즈</a>에서 볼 수 있습니다.</p>\n<p>회원이 아니십니까?  <a href=\"https://ericelliottjs.com/product/lifetime-access-pass/\" target=\"_blank\" rel=\"noopener\">지금 가입하세요</a>.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/\"><strong>다음: JavaScript 모나드 &gt;</strong></a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/composable-datatypes-with-functions-aec72db3b093\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/\">다음&gt;</a></p>\n</blockquote>\n<h2>함수형 자료구조</h2>\n<p>JavaScript에서 무언가를 합성<sup>compose</sup>하는 가장 쉬운 방법은 함수 합성이며 함수는 객체이기 때문에 메소드가 추가 될 수 있습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> t = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">  fn.toString = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`t(<span class=\"subst\">$&#123; value &#125;</span>)`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> someValue = t(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  someValue.toString() <span class=\"comment\">// \"t(2)\"  </span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>t</code>는 숫자형 인스턴스를 생성하는 팩토리입니다.  그러나 <code>t</code>의 인스턴스는 단순한 객체가 아닙니다.  <strong>함수</strong>입니다. 즉, 일반적인 함수와 마찬가지로 합성할 수 있습니다.  기본적으로 멤버를 더하는 함수라고 가정 해 봅시다.  어쩌면 합성될 때 더해지는 것이 합리적 일 수 있습니다.</p>\n<p>먼저 몇 가지 규칙을 세우겠습니다. ( <code>====</code>는  &quot;동등한&quot;을 의미).</p>\n<ul>\n<li><code>t(x)(t(0)) ==== t(x)</code></li>\n<li><code>t(x)(t(1)) ==== t(x + 1)</code></li>\n</ul>\n<p><code>.toString()</code>  메소드를 사용하면 다음과 같습니다.</p>\n<ul>\n<li><code>t(x)(t(0)).toString() === t(x).toString()</code></li>\n<li><code>t(x)(t(1)).toString() === t(x + 1).toString()</code></li>\n</ul>\n<p>이 규칙들을 바탕으로 간단한 유닛 테스트를 작성해보겠습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> assert = &#123;  </span><br><span class=\"line\">  same: <span class=\"function\">(<span class=\"params\">actual, expected, msg</span>) =&gt;</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (actual.toString() !== expected.toString()) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`NOT OK: <span class=\"subst\">$&#123; msg &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">        Expected: <span class=\"subst\">$&#123; expected &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">        Actual:   <span class=\"subst\">$&#123; actual &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">      `</span>);  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`OK: <span class=\"subst\">$&#123; msg &#125;</span>`</span>);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> msg = <span class=\"string\">'a value t(x) composed with t(0) ==== t(x)'</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = t(x)(t(<span class=\"number\">0</span>));  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = t(x);  </span><br><span class=\"line\">  assert.same(a, b, msg);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> msg = <span class=\"string\">'a value t(x) composed with t(1) ==== t(x + 1)'</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = t(x)(t(<span class=\"number\">1</span>));  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = t(x + <span class=\"number\">1</span>);  </span><br><span class=\"line\">  assert.same(a, b, msg);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>처음에는 실패합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NOT OK: a value t(x) composed <span class=\"keyword\">with</span> t(<span class=\"number\">0</span>) ==== t(x)   </span><br><span class=\"line\">\t Expected: t(<span class=\"number\">20</span>)   </span><br><span class=\"line\">\t Actual: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>이는 <code>fn</code>이 <code>t</code> 인스턴스가 아니라 실제 값인 <code>value</code>를 리턴하기 때문입니다.  flatten되는 것이지요. 계속되는 논의에서 저자는 이를 monoid 형태로 만들어갑니다 -역자</p>\n</blockquote>\n<p>그러나 다음 세가지 단계를 거쳐 간단하게 통과시킬 수 있습니다.</p>\n<ol>\n<li><code>fn</code>  함수를  <code>t(value + n)</code>를 리턴하는  <code>add</code>  함수로 변경합니다. 여기서  <code>n</code>은 전달 된 인수입니다.</li>\n<li>새로운  <code>add()</code>함수가  <code>t()</code> 인스턴스를 인수로 취할 수 있도록 하겠습니다.   이를 위해 <code>.valueOf()</code>메소드가  <code>t</code> 타입을 풀어줄 수 있게합니다. 그리고 <code>+</code>  연산자는 두 번째 피연산자로  <code>n.valueOf()</code>의 결과를 사용합니다.</li>\n<li><code>Object.assign()</code>  을 사용하여  <code>add()</code>  함수에 메소드들을 추가합니다.</li>\n</ol>\n<p>새로 작성한 코드입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> t = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> add = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> t(value + n);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(add, &#123;  </span><br><span class=\"line\">    toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`t(<span class=\"subst\">$&#123; value &#125;</span>)`</span>,  </span><br><span class=\"line\">    valueOf: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> value  </span><br><span class=\"line\">  &#125;);  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>이번에는 테스트가 통과합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"OK: a value t(x) composed with t(0) ==== t(x)\"</span>  </span><br><span class=\"line\"><span class=\"string\">\"OK: a value t(x) composed with t(1) ==== t(x + 1)\"</span></span><br></pre></td></tr></table></figure>\n<p>이제  <code>t()</code>값을 함수 합성으로 연산할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Compose functions from top to bottom:  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Sugar to kick off the pipeline with an initial value:  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sumT = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> pipe(...fns)(t(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">sumT(  </span><br><span class=\"line\">  t(<span class=\"number\">2</span>),  </span><br><span class=\"line\">  t(<span class=\"number\">4</span>),  </span><br><span class=\"line\">  t(<span class=\"number\">-1</span>)  </span><br><span class=\"line\">).valueOf(); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<h2>모든 데이터 유형에 대해 가능합니다</h2>\n<p>합성 자체에 특정한 의미를 부여할 수 있는 한 데이터가 어떤 모양을 하고있는지는 중요하지 않습니다.  배열 또는 문자열의 경우 연결<sup>concatenation</sup> 일 수 있습니다.  DSP의 경우 신호 합계가 될 수 있습니다.  수많은 예들이 있을 겁니다.  어떤 연산 혹은 작업이 합성이란 개념과 잘 맞는가라는 질문이 핵심이 됩니다. 즉, 어떤 작업이 다음처럼 표현하기 좋을까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result = compose(  </span><br><span class=\"line\">  value1,  </span><br><span class=\"line\">  value2,  </span><br><span class=\"line\">  value3  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2>Composable Currency 예제</h2>\n<p><a href=\"https://github.com/ericelliott/moneysafe\" target=\"_blank\" rel=\"noopener\">Moneysafe</a>는 함수형 자료구조로 구현된 오픈 소스 라이브러리입니다.  JavaScript의  <code>Number</code>는 소숫점 자리의 달러를 정확하게 나타낼 수 없습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">.1</span> + <span class=\"number\">.2</span> === <span class=\"number\">.3</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>Moneysafe는 달러를 센트로 변환해 문제를 해결합니다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save moneysafe</span><br></pre></td></tr></table></figure>\n<p>사용법은 다음과 같습니다:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; $ &#125; <span class=\"keyword\">from</span> <span class=\"string\">'moneysafe'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"number\">.1</span>) + $(<span class=\"number\">.2</span>) === $(<span class=\"number\">.3</span>).cents; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>렛저<sup>ledger</sup>(장부)라는 간단한 함수 합성 유틸리티가 있습니다. 렛저 구문은 Moneysafe가 값을 승급<sup>lift</sup>하여 함수처럼 다룰 수 있다는 사실을 이용합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; $ &#125; <span class=\"keyword\">from</span> <span class=\"string\">'moneysafe'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; $$, subtractPercent, addPercent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'moneysafe/ledger'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$$(  </span><br><span class=\"line\">  $(<span class=\"number\">40</span>),  </span><br><span class=\"line\">  $(<span class=\"number\">60</span>),  </span><br><span class=\"line\">  <span class=\"comment\">// subtract discount  </span></span><br><span class=\"line\">  subtractPercent(<span class=\"number\">20</span>),  </span><br><span class=\"line\">  <span class=\"comment\">// add tax  </span></span><br><span class=\"line\">  addPercent(<span class=\"number\">10</span>)  </span><br><span class=\"line\">).$; <span class=\"comment\">// 88</span></span><br></pre></td></tr></table></figure>\n<p>리턴 값은 처음에 승급된 화폐 값입니다.  내부적으로  부동 소수점 센트 값을 달러로 변환하여 가장 가까운 센트로 반올림하며 이를 <code>.$</code>라는 getter를 사용해 받을 수 있습니다.</p>\n<p>즉, 장부처럼 금전계산을 할 수있는 직관적인 인터페이스입니다.</p>\n<h3>실습해보기</h3>\n<p>Moneysafe를 git에서 받아옵니다 :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:ericelliott/moneysafe.git</span><br></pre></td></tr></table></figure>\n<p>디펜던시들을 설치 합니다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>watch 콘솔을 사용하여 단위 테스트를 실행하십시오.  모두 통과해야합니다 :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run watch</span><br></pre></td></tr></table></figure>\n<p>새 터미널을 열고 구현된 코드들을 삭제하겠습니다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm <span class=\"built_in\">source</span>/moneysafe.js &amp;&amp; touch <span class=\"built_in\">source</span>/moneysafe.js</span><br></pre></td></tr></table></figure>\n<p>watch 콘솔 테스트를 다시 한 번 살펴보십시오.  이제는 오류가 표시되어야합니다.</p>\n<p>여러분의 임무는 unit test와 documentation을 참고해서 <code>moneysafe.js</code>를 처음부터 다시 구현하는 것입니다.</p>\n<p>회원들을 위해 7개의 파트로 구성된 튜토리얼 시리즈를 녹화했습니다.  여기 첫 번째 에피소드가 있습니다.</p>\n<p>Moneysafe 튜토리얼은  <a href=\"https://ericelliottjs.com/premium-content/shotgun-the-moneysafe-series/\" target=\"_blank\" rel=\"noopener\">Shotgun 시리즈</a>에서 볼 수 있습니다.</p>\n<p>회원이 아니십니까?  <a href=\"https://ericelliottjs.com/product/lifetime-access-pass/\" target=\"_blank\" rel=\"noopener\">지금 가입하세요</a>.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/\"><strong>다음: JavaScript 모나드 &gt;</strong></a></p>\n"},{"title":"소프트웨어 합성: 개요","catalog":true,"date":"2018-03-16T05:13:44.000Z","subtitle":"composing software: introduction","header-img":"bg.jpg","readingTime":12,"catagories":["개발"],"preview":"첫 고등학교 프로그래밍 수업 시간에 소프트웨어 개발이란 복잡한 문제를 작은 문제들로 분해하고 작은 문제들의 해법들을 다시 조합해 복잡한 문제를 해결 할 수 있는 솔루션을 만드는 행위라고 배웠습니다. 전 그 말의 중요성을 너무 늦게 깨달았다는 것이 매우 후회됩니다. 너무 늦게 소프트웨어 설계의 본질을 깨달은 것 입니다. 수백 명의 개발자들을 인터뷰하며 나만 그런 것이 아님을 알게됐습니다.  아주 소수의 개발자만이 소프트웨어 개발의 본질에 대해 잘 알고 있었습니다.  대부분의 경우에는 우리가 활용해야 하는 가장 중요한 개념과 그것을 잘 적용하는 방법을 몰랐습니다.  다음은 소프트웨어 개발에서 가장 중요한 두가지 질문입니다.","_content":"\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  [[원문보기]](https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea)\n> \n![main image](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈에 대한 소개입니다.  앞으로 계속하여 연재될 것입니다.\n[_다음편 >_](https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/)\n\n\n> 합성 : 전체를 구성하기 위해 부분이나 요소를 결합하는 행위 \n>  Dictionary .com\n\n첫 고등학교 프로그래밍 수업 시간에 소프트웨어 개발이란 복잡한 문제를 작은 문제들로 분해하고 작은 문제들의 해법들을 다시 조합해 복잡한 문제를 해결 할 수 있는 솔루션을 만드는 행위라고 배웠습니다.\n\n전 그 말의 중요성을 너무 늦게 깨달았다는 것이 매우 후회됩니다. 너무 늦게 소프트웨어 설계의 본질을 깨달은 것 입니다.\n\n수백 명의 개발자들을 인터뷰하며 나만 그런 것이 아님을 알게됐습니다.  아주 소수의 개발자만이 소프트웨어 개발의 본질에 대해 잘 알고 있었습니다.  대부분의 경우에는 우리가 활용해야 하는 가장 중요한 개념과 그것을 잘 적용하는 방법을 몰랐습니다.  다음은 소프트웨어 개발에서 가장 중요한 두가지 질문입니다.\n\n-   함수 합성 ^function^ ^composition^ 이란 무엇인가?\n-   객체 합성 ^object^ ^composition^이란 무엇인가?\n\n문제는 당신이 단지 잘 모른다고해서 객체 및 함수 합성을 하지 않을 수는 없다는 것입니다.  당신은 여전히 의식하지않고 (나쁘게)합성을 합니다. 그렇기에 버그가 넘쳐나고 다른 개발자가 이해하기 어려운 코드가 나옵니다.  이는 큰 문제이며 적지않은 대가를 지불하고 있습니다.  소프트웨어는 만드는 것보다 유지 보수하는 데 더 많은 시간이 들고, 버그는 전 세계 수십억 명의 사람들에게 영향을줍니다.\n\n오늘날 소프트웨어는 모든 곳에 존재합니다.  모든 자동차는 바퀴가 달린 미니 수퍼 컴퓨터이며 소프트웨어 설계 문제로 인해 사고가 발생하고 사람이 목숨을 잃습니다.  2013년, 배심원단은 사고를 조사하는 과정에서 Toyota의 소프트웨어 개발팀이 10,000 개의 글로벌 변수가있는 스파게티 코드를 작성한 것을 발견했습니다.  \n\n[해커 및 정부](https://www.technologyreview.com/s/607875/should-the-government-keep-stockpiling-software-bugs/)는  버그를 활용해 사람들을 감시하고, 신용 카드를 훔치고, DDoS 공격을 하고 , 암호를 해독하고,  심지어 [선거를 조작](https://www.technologyreview.com/s/604138/the-fbi-shut-down-a-huge-botnet-but-there-are-plenty-more-left/)  합니다.\n\n우리가 더 잘해야합니다.\n\n## 사실 당신은 매일 소프트웨어를 합성합니다\n모든 소프트웨어 개발자는 의식하든 하지 못하든 매일 매일 함수와 데이터 구조를 합성합니다.  조금만 신경을 써서 더 잘 할 수 있지만, 그렇지 않고 덕트 테이프와 순간 접착제로 모든걸 망쳐버릴 수도 있습니다.\n\n소프트웨어 개발 프로세스란 큰 문제를 작은 문제로 분해하여 작은 문제를 해결하는 요소를 만들고 이러한 구성 요소들을 합성하여 완전한 응용 프로그램을애플리케이션 구성하는 것입니다.\n\n## 함수 합성\n함수 합성이란 한 함수의 출력에 다른 함수를 결합시키는 과정입니다.  대수학에서  `f`  와  `g` 두 함수, 그리고 합성 함수   `(f ∘ g)(x) = f(g(x))` 를 본적 있을 겁니다.  조그마한 원 기호는 합성 연산자입니다.  일반적으로 \"composed with\"또는 \"after\"로 발음^[한국에서는 보통 ~와 ~를 합성한다고 하거나 ~에 ~ 처럼생략합니다 ]됩니다.    `f` 와 `g`를 합성하는 것은  `f`에  `g`에 `x` 와 같이 부를 수 있습니다 . 이 때  `g`  가 먼저 평가되기 때문에  `g`  를 계산하고  그 결과를  `f`의  인수로 전달합니다.\n\n다음과 같은 방식의 코드를 작성할 때마다 함수를 합성하고 있는 것입니다.\n```javascript\nconst g = n => n + 1;   \nconst f = n => n * 2; \n\nconst doStuff = x => {   \n\tconst afterG = g (x);   \n\tconst afterF = f (afterG);   \n\treturn afterF;   \n}; \n\ndoStuff (20);  // 42\n```\nES6의 promise chain은  합성함수입니다.\n\n```javascript\nconst g = n => n + 1;  \nconst f = n => n * 2;\n\nconst wait = time => new Promise(  \n  (resolve, reject) => setTimeout(  \n    resolve,  \n    time  \n  )  \n);\n\nwait(300)  \n  .then(() => 20)  \n  .then(g)  \n  .then(f)  \n  .then(value => console.log(value)) // 42\n```\n마찬가지로 배열 메소드 호출하거나 lodash 메소드, observables (RxJS, etc ...)를 체인 할 때마다 함수를 합성하게 됩니다.  체이닝은 합성입니다.  반환 값을 다른 함수에 전달하는 것도 합성입니다.  `this`를  입력으로하여 두 개의 메소드를 순차적으로 호출하는 것 역시 합성입니다.\n\n>당신이 체이닝을 한다면 합성중입니다.\n\n함수를 합성하고있다는 사실을 알고 있어야 합니다.\n\n다음은 함수를 합성하여  `doStuff()`  함수를 한줄로 고치는 코드입니다.\n\n```javascript\nconst g = n => n + 1;   \nconst f = n => n * 2; \n\nconst doStuffBetter = x => f (g (x)); \n\ndoStuffBetter (20);  // 42\n```\n  이러한 방법은 종종 디버깅이 어렵다는 얘기를 듣습니다.  그렇다면 디버깅 로직이 담긴 아래 코드를 함수 합성방식으로 재작성 해보겠습니다.\n```javascript\nconst doStuff = x => {  \n  const afterG = g(x);  \n  console.log(`after g: ${ afterG }`);  \n  const afterF = f(afterG);  \n  console.log(`after f: ${ afterF }`);  \n  return afterF;  \n};\n\ndoStuff(20); // =>  \n/*  \n\"after g: 21\"  \n\"after f: 42\"  \n*/\n```\n먼저, `afterF`,  `afterG`를 추상화할 수 있는 `trace()` 라는 간단한 로거^logger^함수를 만들어 보겠습니다.\n\n```javascript\nconst trace = label => value => {  \n  console.log(`${ label }: ${ value }`);  \n  return value;  \n};\n```\n이제 다음과 같이 사용할 수 있습니다.\n```javascript\nconst doStuff = x => {  \n  const afterG = g(x);  \n  trace('after g')(afterG);  \n  const afterF = f(afterG);  \n  trace('after f')(afterF);  \n  return afterF;  \n};\n\ndoStuff(20); // =>  \n/*  \n\"after g: 21\"  \n\"after f: 42\"  \n*/\n```\nLodash 및 Ramda와 같은 인기있는 함수 프로그래밍 라이브러리에는 함수를 쉽게 구성 할 수있는 유틸리티가 포함되어 있습니다.  위의 함수를 다음과 같이 다시 작성할 수 있습니다.\n\n```javascript\nimport pipe from 'lodash/fp/flow';\n\nconst doStuffBetter = pipe(  \n  g,  \n  trace('after g'),  \n  f,  \n  trace('after f')  \n);\n\ndoStuffBetter(20); // =>  \n/*  \n\"after g: 21\"  \n\"after f: 42\"  \n*/\n```\n라이브러리를 사용하지 않고 다음과 같이 pipe를 직접 정의 할 수도 있습니다.\n```javascript\n// pipe(...fns: [...Function]) => x => y  \nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\n```\n아직은 어떻게 작동하는지 몰라도 괜찮습니다.  나중에 훨씬 더 자세하게 알아볼 것입니다.  사실 매우 중요한 코드이기 때문에 문서 전체에 걸쳐 반복해서 정의되고 시연 될 겁니다.  중요한 건 당신이 그 의미와 사용법을 자동적으로 떠올릴 수 있을 만큼 익숙해지는 것입니다.  **합성**^composition^과 한 몸이 되어야 합니다.\n\n`pipe()` 유틸리티는 한 함수의 출력을 다른 함수의 입력으로 전달하여 함수 파이프 라인을 생성합니다.  `pipe()`  (그리고 쌍둥이라고 할 수 있는  `compose()`  )를 사용하면 중간 변수^intermediary^ ^variables^가 필요 없습니다.  인수를 언급하지 않고 함수를 작성하는 것을  **포인트없는 스타일**^point-free^ ^style^ 혹은 **무인수 방식**이라고  **합니다.**  이를 위해 함수를 명시적으로 선언하는 대신 다른 함수를 반환하는 함수를 호출합니다.  즉,  `function`  키워드 나 화살표 구문 (  `=>`  )이 필요하지 않습니다.\n\n무인수 방식으로 전체 로직을 구성할 수도 있지만, 중간 변수들이 여러분의 기능에 불필요한 복잡성^complexity^을 더하기 때문에 여기 저기 조금씩 사용하는 것도 좋습니다.\n\n복잡성 감소에는 몇 가지 이점이 있습니다.\n\n## 단기 기억\n\n인간 두뇌의  [단기 기억력](http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html)은 서로 다른 항목을 저장하기 위한 공간이 한정되어있으며, 함수의 인자와 변수는 잠재적으로 그 공간 중 하나를 소비합니다.  변수가 늘어날 수록 각 변수의 의미를 기억하기 힘들어 집니다. 단기 기억 모형에 따르면 우리의 두뇌는 일반적으로 4-7 개의 항목을 단기 기억 공간에 저장할 수 있으며 이 보다 크면 오류율이 급격히 증가합니다.\n\n우리는 함수 파이프라이닝을 사용해 변수 3개를 소거하였고 다른 변수를 기억하는데 사용할 수  있게 됐습니다.  단기 기억 공간의 거의 절반을 확보한 것입니다. 이는 인지 부하를 상당히 줄여줍니다.  소프트웨어 개발자는 데이터를 묶어 기억하는 경향이 있지만 그렇다고 이 개념의 중요성이 약해지는 것은 아닙니다.\n\n## 신호 대 잡음비\n간결함은 코드의 신호 대 잡음 비율^Signal^ ^to^ ^Noise^ ^Ratio^을 향상시킵니다.  라디오를 듣는 것과 같습니다. 라디오의 주파수가 제대로 맞춰져 있지 않으면 소음이 발생하며 음악을 듣기가 어려워집니다.  방송국 주파수로 정확하게 튜닝하면 소음이 사라지고 음악 신호가 강해집니다.\n\n코드도 마찬가지입니다.  간결한 표현은 이해력을 향상시킵니다. 일부 코드는 유용한 정보를 제공하고 일부 코드는 공간을 차지합니다.  전달되어야 할 의미를 변화시키지 않는 선에서 코드의 양을 줄이면 코드를 읽고 이해해야하는 다른 사람들이 더 쉽게 이해할 수 있습니다.^[개발자가 코드를 작성하고 다른 개발자가 이를 이해한다는 것을 라디오의 방송국과 청취자들의 관계에 비유했 습니다. 이 때 신호란 전달되어야하는 의미이고 잡음이란 공간만 차지하는 코드입니다. 즉 더 적은 코드로 같은 의미를 전달하는 것이 좋다는 말이 됩니다.]\n\n## 코드의 면적과 버그\n\n함수형으로 작성된 코드를 살펴보면 마치 코드가 살을 빼 다이어트 한 것처럼 보입니다. 이 비유가 중요한 이유는 여분의 코드가 버그를 숨길 수있는 추가 표면적을 의미하기 때문입니다 . 즉 더 많은 버그가 숨어 버릴 수 있음을 의미합니다.\n\n> _적은 코드 = 버그가 적은 표면 = 버그가 적습니다._\n\n## 객체 합성\n> \"클래스 상속보다는 객체 합성을 우선해라\", Gang of Four,  [\"디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소\"](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&qid=1494993475&sr=8-1&keywords=design+patterns&linkCode=ll1&tag=eejs-20&linkId=6c553f16325f3939e5abadd4ee04e8b4)\n\n> \"컴퓨터 과학에서 복합 자료형^composite^ ^datatype^이란 프로그래밍 언어의 원시형 및 기타 복합 자료형 사용하여 프로그램에서 조합 할 수있는 모든 자료형입니다.  \\[...\\] 복합 자료형을 만드는 행위는 합성^composition^으로 알려져 있습니다. \"~ Wikipedia\n\n\n다음은 원시형입니다.\n```javascript\nconst firstName = 'Claude';  \nconst lastName = 'Debussy';\n```\n그리고 이것은 복합체입니다.\n```javascript\nconst fullName = {  \n  firstName,  \n  lastName  \n};\n```\n마찬가지로 모든 array, set, map, weak map, typed array 등은 복합 자료형입니다.  비 원시형 구조를 작성할 때마다 우리는 객체를 합성합니다.\n\nGang of Four의 **컴포지트 패턴**^composite^ ^pattern^은 객체들의 관계를 재귀적으로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 정의합니다. 일부 개발자는 컴포지트 패턴이 _객체 합성의 유일한 형태_  라고 생각하면서 혼란스러워 합니다.  혼동하지 마십시오.  객체 합성에는 여러 가지 종류가 있습니다.\n\nGang of Four는 계속해서 \"객체합성은 여러 디자인 패턴에 다양하게 적용될 것 입니다\"라고 말한 다음 객체가 합성될때 두 객체의 관계를 정의하기 위한 세가지 표현을 정의했습니다.\n1.  **위임**^delegation^  (state, strategy 및 visitor 패턴에서 사용 됨) \n2.  **인지**^acquaintance^  (객체가 참조로 다른 객체를 알고있을 때 일반적으로 매개 변수로 전달됨 : 네트워크 요청 처리기가 로거에 대한 참조를 전달하여 요청을 기록 \\- 요청 처리기가 로거를 사용함) \n3.  **집합**^aggregation^  (자식 객체가 부모 객체의 일부를 형성하는 경우 : has - a 관계, 예를 들어 자식 DOM은 부모 노드의 구성 요소 - DOM 노드는 자식을 가짐).\n\n클래스 상속은 복합 객체를 구성하는 데 사용할 수 있지만 제한적이고 취약한 방법입니다.  Gang of Four는 \"클래스 상속보다는 객체 합성을 우선해라\"라고 말하면서 객체를 합성하기 위해 클래스 상속이란 강고하고 단단히 결합 된 접근 방식보다는  유연한 접근 방식을 사용하도록 조언합니다.\n\n[\"Categorical Methods in Computer Science: With Aspects from Topology\"](https://www.amazon.com/Categorical-Methods-Computer-Science-Topology/dp/0387517227/ref=as_li_ss_tl?ie=UTF8&qid=1495077930&sr=8-3&keywords=Categorical+Methods+in+Computer+Science:+With+Aspects+from+Topology&linkCode=ll1&tag=eejs-20&linkId=095afed5272832b74357f63b41410cb7) (1989)에서 나오는 개체 합성에 대한보다 넓은 정의를 사용하겠습니다.\n\n> \"복합 객체는 객체들이 합쳐져 만들어 지는데, 각각의 latter는 former의 일부분이된다.\"\n\n또 다른 좋은 참고 자료는 \"Reliable Software Through Composite Design\"(Glenford J Myers, 1975)입니다. 두 책 모두 절판되었지만 여러분이 객체 합성이라는 주제에 대해 심도있게 알아보고 싶으면 Amazon이나 이베이에서 여전히 책을 찾을 수 있습니다.\n\n_클래스 상속은 복합 객체 생성의 한 종류에 불과합니다._ 모든 클래스는 복합 객체를 생성하지만 모든 복합 객체가 클래스 또는 클래스 상속에 의해 생성되는 것은 아닙니다.  \"클래스 상속보다는 객체 합성을 우선해라\"라는 말은 클래스 계층의 조상 (ancestor)에서 모든 속성을 상속하지 않고 작은 구성 요소 부분에서 복합 객체를 형성해야한다는 것을 의미합니다.  전자는 객체 지향 설계에서 잘 알려진 다양한  문제를 일으 킵니다.\n\n-   **단단한 결합 문제** ^The^ ^tight^ ^coupling^ ^problem^ :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.\n-   **깨지기 쉬운 기초 클래스 문제**^The^ ^fragile^ ^base^ ^class^ ^problem^  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.\n-   **경직된 계층 구조 문제**^The^ ^inflexible^ ^hierarchy^ ^problem^ :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.\n-   **중복 필요성 문제**^The^ ^duplication^ ^by^ ^necessity^ ^problem^ : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.\n-   **고릴라 / 바나나 문제**^The^ ^gorilla/banana^ ^problem^ :  \"... 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. \"~ Joe Armstrong,  [\"Coders at Work \"](http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN)\n\nJavaScript에서 객체 합성의 가장 일반적인 형태는  **객체 연결**  (mixin composition이라고도 함)이라고합니다.  마치 아이스크림처럼 작동합니다. 먼저 바닐라 아이스크림과 같은 객체로 시작한 다음 원하는 기능을 믹스합니다.  견과류, 캐러멜, 초콜릿 소용돌이를 추가하면 너트 카라멜 초콜릿 소용돌이 아이스크림이 됩니다.\n\n클래스 상속을 사용하여 복합 객체 만들기 :\n\n```javascript\nclass Foo {  \n  constructor () {  \n    this.a = 'a'  \n  }  \n}\n\nclass Bar extends Foo {  \n  constructor (options) {  \n    super(options);  \n    this.b = 'b'  \n  }  \n}\n\nconst myBar = new Bar(); // {a: 'a', b: 'b'}\n```\n믹스 인 성분으로 복합 객체 만들기 :\n```javascript\nconst a = {  \n  a: 'a'  \n};\n\nconst b = {  \n  b: 'b'  \n};\n\nconst c = {...a, ...b}; // {a: 'a', b: 'b'}\n```\n\n앞으로 객체를 합성하는 다양한 방법에 대해 알아볼 것입니다.  지금까지의 논의를 정리하자면 다음과 같습니다.\n\n1.  어떤 것을 수행하는 데는 한 가지 이상의 방법이 있습니다.\n2.  어떤 방법은 다른 방법보다 낫습니다.\n3.  당장의 작업을 위해 가장 단순하고 유연한 솔루션을 선택하려고 합니다.\n\n## 결론\n\n이 글은 FP (Functional Programming)와 OOP (Object-Oriented Programming) 또는 프로그래밍 언어에 대한 글이 아닙니다.  소프트웨어를 합성하기 위한 컴포넌트는 함수, 자료 구조, 클래스 등의 형태를 취할 수 있습니다. 프로그래밍 언어마다 컴포넌트에 대해 서로 다른 접근방식을 취합니다. 자바는 클래스를 제공하고, 하스켈은 함수를 제공합니다. 그러나 어떤 언어, 어떤 패러다임을 선호하든 관계없이 함수와 자료구조를 합성할 수 밖에 없습니다.  결국, 모두 뒤죽박죽이 될지라도 말이지요.\n\n우리는 지금까지 대부분의 논의를 함수형 프로그래밍에 관하여 했습니다.  그 이유는 함수야 말로 JavaScript에서 가장 합성을 하기 쉬운 요소이고, 함수 프로그래밍 커뮤니티가 함수 합성 테크닉을 공식화하는 데 많은 시간과 노력을 투자했기 때문입니다.\n\n이 글은 함수형 프로그래밍이 객체 지향 프로그래밍보다 낫다는 논의를 하려는게 아닙니다. 만약 그렇다면 두 패러다임중 하나를 선택하라 할테지요.  OOP 대 FP는 잘못된 이분법입니다.  최근 몇 년 동안 본 모든 Javascript 애플리케이션은 FP와 OOP를 광범위하게 혼합합니다.\n\n객체를 합성하여 FP에서 사용될 자료구조를 만들고 함수형 프로그래밍으로 OOP에서 객체를 만들어볼 것 입니다.\n\n_소프트웨어를 작성하는 방법에 상관없이 훌륭한 합성을 해야합니다_\n\n> 소프트웨어 개발의 핵심은 합성입니다.\n\n합성을 이해하지 못하는 소프트웨어 개발자는 볼트나 못에 대해 모르는 주택 건설업자와 같습니다.  어떻게 합성될지 신경쓰지 않고 소프트웨어를 제작하는 것은 집을 건설할 때 덕트 테이프와 순간 접착제로 벽을 붙이는 것과 같습니다.\n\n이제는 단순하게 생각할 때입니다. 어떤 것을 단순화하는 가장 좋은 방법은 본질에 도달하는 것입니다.  문제는, 소프트웨어 산업에 있는 대부분의 사람들이 본질에 대해 무관심하다는 것입니다.  우리 업계는 소프트웨어 개발자인 당신을 제대로 가르치지 못했습니다.  업계는 개발자를 더 잘 훈련시켜야할 책임이 있습니다. 우리는 이를 고쳐야 합니다.  우리가 책임을 져야합니다.  경제에서 의료 장비에 이르기까지 모든 것에서 소프트웨어가 실행됩니다.  이 행성의 모든 인간의 삶은 소프트웨어 품질에 영향을받고 있습니다.  우리가 뭘 하고있는지 알아야합니다.\n\n지금부터 소프트웨어 합성 방법을 배우면 됩니다.\n\n[다음: 함수형 프로그래밍 패러다임의 역사>](https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/)","source":"_posts/composing-software-intro.md","raw":"---\ntitle: \"소프트웨어 합성: 개요\"\ncatalog: true\ndate: 2018-03-16 14:13:44\nsubtitle: \"composing software: introduction\"\nheader-img: \"bg.jpg\"\nreadingTime: 12\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 첫 고등학교 프로그래밍 수업 시간에 소프트웨어 개발이란 복잡한 문제를 작은 문제들로 분해하고 작은 문제들의 해법들을 다시 조합해 복잡한 문제를 해결 할 수 있는 솔루션을 만드는 행위라고 배웠습니다. 전 그 말의 중요성을 너무 늦게 깨달았다는 것이 매우 후회됩니다. 너무 늦게 소프트웨어 설계의 본질을 깨달은 것 입니다. 수백 명의 개발자들을 인터뷰하며 나만 그런 것이 아님을 알게됐습니다.  아주 소수의 개발자만이 소프트웨어 개발의 본질에 대해 잘 알고 있었습니다.  대부분의 경우에는 우리가 활용해야 하는 가장 중요한 개념과 그것을 잘 적용하는 방법을 몰랐습니다.  다음은 소프트웨어 개발에서 가장 중요한 두가지 질문입니다.\n---\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  [[원문보기]](https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea)\n> \n![main image](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈에 대한 소개입니다.  앞으로 계속하여 연재될 것입니다.\n[_다음편 >_](https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/)\n\n\n> 합성 : 전체를 구성하기 위해 부분이나 요소를 결합하는 행위 \n>  Dictionary .com\n\n첫 고등학교 프로그래밍 수업 시간에 소프트웨어 개발이란 복잡한 문제를 작은 문제들로 분해하고 작은 문제들의 해법들을 다시 조합해 복잡한 문제를 해결 할 수 있는 솔루션을 만드는 행위라고 배웠습니다.\n\n전 그 말의 중요성을 너무 늦게 깨달았다는 것이 매우 후회됩니다. 너무 늦게 소프트웨어 설계의 본질을 깨달은 것 입니다.\n\n수백 명의 개발자들을 인터뷰하며 나만 그런 것이 아님을 알게됐습니다.  아주 소수의 개발자만이 소프트웨어 개발의 본질에 대해 잘 알고 있었습니다.  대부분의 경우에는 우리가 활용해야 하는 가장 중요한 개념과 그것을 잘 적용하는 방법을 몰랐습니다.  다음은 소프트웨어 개발에서 가장 중요한 두가지 질문입니다.\n\n-   함수 합성 ^function^ ^composition^ 이란 무엇인가?\n-   객체 합성 ^object^ ^composition^이란 무엇인가?\n\n문제는 당신이 단지 잘 모른다고해서 객체 및 함수 합성을 하지 않을 수는 없다는 것입니다.  당신은 여전히 의식하지않고 (나쁘게)합성을 합니다. 그렇기에 버그가 넘쳐나고 다른 개발자가 이해하기 어려운 코드가 나옵니다.  이는 큰 문제이며 적지않은 대가를 지불하고 있습니다.  소프트웨어는 만드는 것보다 유지 보수하는 데 더 많은 시간이 들고, 버그는 전 세계 수십억 명의 사람들에게 영향을줍니다.\n\n오늘날 소프트웨어는 모든 곳에 존재합니다.  모든 자동차는 바퀴가 달린 미니 수퍼 컴퓨터이며 소프트웨어 설계 문제로 인해 사고가 발생하고 사람이 목숨을 잃습니다.  2013년, 배심원단은 사고를 조사하는 과정에서 Toyota의 소프트웨어 개발팀이 10,000 개의 글로벌 변수가있는 스파게티 코드를 작성한 것을 발견했습니다.  \n\n[해커 및 정부](https://www.technologyreview.com/s/607875/should-the-government-keep-stockpiling-software-bugs/)는  버그를 활용해 사람들을 감시하고, 신용 카드를 훔치고, DDoS 공격을 하고 , 암호를 해독하고,  심지어 [선거를 조작](https://www.technologyreview.com/s/604138/the-fbi-shut-down-a-huge-botnet-but-there-are-plenty-more-left/)  합니다.\n\n우리가 더 잘해야합니다.\n\n## 사실 당신은 매일 소프트웨어를 합성합니다\n모든 소프트웨어 개발자는 의식하든 하지 못하든 매일 매일 함수와 데이터 구조를 합성합니다.  조금만 신경을 써서 더 잘 할 수 있지만, 그렇지 않고 덕트 테이프와 순간 접착제로 모든걸 망쳐버릴 수도 있습니다.\n\n소프트웨어 개발 프로세스란 큰 문제를 작은 문제로 분해하여 작은 문제를 해결하는 요소를 만들고 이러한 구성 요소들을 합성하여 완전한 응용 프로그램을애플리케이션 구성하는 것입니다.\n\n## 함수 합성\n함수 합성이란 한 함수의 출력에 다른 함수를 결합시키는 과정입니다.  대수학에서  `f`  와  `g` 두 함수, 그리고 합성 함수   `(f ∘ g)(x) = f(g(x))` 를 본적 있을 겁니다.  조그마한 원 기호는 합성 연산자입니다.  일반적으로 \"composed with\"또는 \"after\"로 발음^[한국에서는 보통 ~와 ~를 합성한다고 하거나 ~에 ~ 처럼생략합니다 ]됩니다.    `f` 와 `g`를 합성하는 것은  `f`에  `g`에 `x` 와 같이 부를 수 있습니다 . 이 때  `g`  가 먼저 평가되기 때문에  `g`  를 계산하고  그 결과를  `f`의  인수로 전달합니다.\n\n다음과 같은 방식의 코드를 작성할 때마다 함수를 합성하고 있는 것입니다.\n```javascript\nconst g = n => n + 1;   \nconst f = n => n * 2; \n\nconst doStuff = x => {   \n\tconst afterG = g (x);   \n\tconst afterF = f (afterG);   \n\treturn afterF;   \n}; \n\ndoStuff (20);  // 42\n```\nES6의 promise chain은  합성함수입니다.\n\n```javascript\nconst g = n => n + 1;  \nconst f = n => n * 2;\n\nconst wait = time => new Promise(  \n  (resolve, reject) => setTimeout(  \n    resolve,  \n    time  \n  )  \n);\n\nwait(300)  \n  .then(() => 20)  \n  .then(g)  \n  .then(f)  \n  .then(value => console.log(value)) // 42\n```\n마찬가지로 배열 메소드 호출하거나 lodash 메소드, observables (RxJS, etc ...)를 체인 할 때마다 함수를 합성하게 됩니다.  체이닝은 합성입니다.  반환 값을 다른 함수에 전달하는 것도 합성입니다.  `this`를  입력으로하여 두 개의 메소드를 순차적으로 호출하는 것 역시 합성입니다.\n\n>당신이 체이닝을 한다면 합성중입니다.\n\n함수를 합성하고있다는 사실을 알고 있어야 합니다.\n\n다음은 함수를 합성하여  `doStuff()`  함수를 한줄로 고치는 코드입니다.\n\n```javascript\nconst g = n => n + 1;   \nconst f = n => n * 2; \n\nconst doStuffBetter = x => f (g (x)); \n\ndoStuffBetter (20);  // 42\n```\n  이러한 방법은 종종 디버깅이 어렵다는 얘기를 듣습니다.  그렇다면 디버깅 로직이 담긴 아래 코드를 함수 합성방식으로 재작성 해보겠습니다.\n```javascript\nconst doStuff = x => {  \n  const afterG = g(x);  \n  console.log(`after g: ${ afterG }`);  \n  const afterF = f(afterG);  \n  console.log(`after f: ${ afterF }`);  \n  return afterF;  \n};\n\ndoStuff(20); // =>  \n/*  \n\"after g: 21\"  \n\"after f: 42\"  \n*/\n```\n먼저, `afterF`,  `afterG`를 추상화할 수 있는 `trace()` 라는 간단한 로거^logger^함수를 만들어 보겠습니다.\n\n```javascript\nconst trace = label => value => {  \n  console.log(`${ label }: ${ value }`);  \n  return value;  \n};\n```\n이제 다음과 같이 사용할 수 있습니다.\n```javascript\nconst doStuff = x => {  \n  const afterG = g(x);  \n  trace('after g')(afterG);  \n  const afterF = f(afterG);  \n  trace('after f')(afterF);  \n  return afterF;  \n};\n\ndoStuff(20); // =>  \n/*  \n\"after g: 21\"  \n\"after f: 42\"  \n*/\n```\nLodash 및 Ramda와 같은 인기있는 함수 프로그래밍 라이브러리에는 함수를 쉽게 구성 할 수있는 유틸리티가 포함되어 있습니다.  위의 함수를 다음과 같이 다시 작성할 수 있습니다.\n\n```javascript\nimport pipe from 'lodash/fp/flow';\n\nconst doStuffBetter = pipe(  \n  g,  \n  trace('after g'),  \n  f,  \n  trace('after f')  \n);\n\ndoStuffBetter(20); // =>  \n/*  \n\"after g: 21\"  \n\"after f: 42\"  \n*/\n```\n라이브러리를 사용하지 않고 다음과 같이 pipe를 직접 정의 할 수도 있습니다.\n```javascript\n// pipe(...fns: [...Function]) => x => y  \nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\n```\n아직은 어떻게 작동하는지 몰라도 괜찮습니다.  나중에 훨씬 더 자세하게 알아볼 것입니다.  사실 매우 중요한 코드이기 때문에 문서 전체에 걸쳐 반복해서 정의되고 시연 될 겁니다.  중요한 건 당신이 그 의미와 사용법을 자동적으로 떠올릴 수 있을 만큼 익숙해지는 것입니다.  **합성**^composition^과 한 몸이 되어야 합니다.\n\n`pipe()` 유틸리티는 한 함수의 출력을 다른 함수의 입력으로 전달하여 함수 파이프 라인을 생성합니다.  `pipe()`  (그리고 쌍둥이라고 할 수 있는  `compose()`  )를 사용하면 중간 변수^intermediary^ ^variables^가 필요 없습니다.  인수를 언급하지 않고 함수를 작성하는 것을  **포인트없는 스타일**^point-free^ ^style^ 혹은 **무인수 방식**이라고  **합니다.**  이를 위해 함수를 명시적으로 선언하는 대신 다른 함수를 반환하는 함수를 호출합니다.  즉,  `function`  키워드 나 화살표 구문 (  `=>`  )이 필요하지 않습니다.\n\n무인수 방식으로 전체 로직을 구성할 수도 있지만, 중간 변수들이 여러분의 기능에 불필요한 복잡성^complexity^을 더하기 때문에 여기 저기 조금씩 사용하는 것도 좋습니다.\n\n복잡성 감소에는 몇 가지 이점이 있습니다.\n\n## 단기 기억\n\n인간 두뇌의  [단기 기억력](http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html)은 서로 다른 항목을 저장하기 위한 공간이 한정되어있으며, 함수의 인자와 변수는 잠재적으로 그 공간 중 하나를 소비합니다.  변수가 늘어날 수록 각 변수의 의미를 기억하기 힘들어 집니다. 단기 기억 모형에 따르면 우리의 두뇌는 일반적으로 4-7 개의 항목을 단기 기억 공간에 저장할 수 있으며 이 보다 크면 오류율이 급격히 증가합니다.\n\n우리는 함수 파이프라이닝을 사용해 변수 3개를 소거하였고 다른 변수를 기억하는데 사용할 수  있게 됐습니다.  단기 기억 공간의 거의 절반을 확보한 것입니다. 이는 인지 부하를 상당히 줄여줍니다.  소프트웨어 개발자는 데이터를 묶어 기억하는 경향이 있지만 그렇다고 이 개념의 중요성이 약해지는 것은 아닙니다.\n\n## 신호 대 잡음비\n간결함은 코드의 신호 대 잡음 비율^Signal^ ^to^ ^Noise^ ^Ratio^을 향상시킵니다.  라디오를 듣는 것과 같습니다. 라디오의 주파수가 제대로 맞춰져 있지 않으면 소음이 발생하며 음악을 듣기가 어려워집니다.  방송국 주파수로 정확하게 튜닝하면 소음이 사라지고 음악 신호가 강해집니다.\n\n코드도 마찬가지입니다.  간결한 표현은 이해력을 향상시킵니다. 일부 코드는 유용한 정보를 제공하고 일부 코드는 공간을 차지합니다.  전달되어야 할 의미를 변화시키지 않는 선에서 코드의 양을 줄이면 코드를 읽고 이해해야하는 다른 사람들이 더 쉽게 이해할 수 있습니다.^[개발자가 코드를 작성하고 다른 개발자가 이를 이해한다는 것을 라디오의 방송국과 청취자들의 관계에 비유했 습니다. 이 때 신호란 전달되어야하는 의미이고 잡음이란 공간만 차지하는 코드입니다. 즉 더 적은 코드로 같은 의미를 전달하는 것이 좋다는 말이 됩니다.]\n\n## 코드의 면적과 버그\n\n함수형으로 작성된 코드를 살펴보면 마치 코드가 살을 빼 다이어트 한 것처럼 보입니다. 이 비유가 중요한 이유는 여분의 코드가 버그를 숨길 수있는 추가 표면적을 의미하기 때문입니다 . 즉 더 많은 버그가 숨어 버릴 수 있음을 의미합니다.\n\n> _적은 코드 = 버그가 적은 표면 = 버그가 적습니다._\n\n## 객체 합성\n> \"클래스 상속보다는 객체 합성을 우선해라\", Gang of Four,  [\"디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소\"](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&qid=1494993475&sr=8-1&keywords=design+patterns&linkCode=ll1&tag=eejs-20&linkId=6c553f16325f3939e5abadd4ee04e8b4)\n\n> \"컴퓨터 과학에서 복합 자료형^composite^ ^datatype^이란 프로그래밍 언어의 원시형 및 기타 복합 자료형 사용하여 프로그램에서 조합 할 수있는 모든 자료형입니다.  \\[...\\] 복합 자료형을 만드는 행위는 합성^composition^으로 알려져 있습니다. \"~ Wikipedia\n\n\n다음은 원시형입니다.\n```javascript\nconst firstName = 'Claude';  \nconst lastName = 'Debussy';\n```\n그리고 이것은 복합체입니다.\n```javascript\nconst fullName = {  \n  firstName,  \n  lastName  \n};\n```\n마찬가지로 모든 array, set, map, weak map, typed array 등은 복합 자료형입니다.  비 원시형 구조를 작성할 때마다 우리는 객체를 합성합니다.\n\nGang of Four의 **컴포지트 패턴**^composite^ ^pattern^은 객체들의 관계를 재귀적으로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 정의합니다. 일부 개발자는 컴포지트 패턴이 _객체 합성의 유일한 형태_  라고 생각하면서 혼란스러워 합니다.  혼동하지 마십시오.  객체 합성에는 여러 가지 종류가 있습니다.\n\nGang of Four는 계속해서 \"객체합성은 여러 디자인 패턴에 다양하게 적용될 것 입니다\"라고 말한 다음 객체가 합성될때 두 객체의 관계를 정의하기 위한 세가지 표현을 정의했습니다.\n1.  **위임**^delegation^  (state, strategy 및 visitor 패턴에서 사용 됨) \n2.  **인지**^acquaintance^  (객체가 참조로 다른 객체를 알고있을 때 일반적으로 매개 변수로 전달됨 : 네트워크 요청 처리기가 로거에 대한 참조를 전달하여 요청을 기록 \\- 요청 처리기가 로거를 사용함) \n3.  **집합**^aggregation^  (자식 객체가 부모 객체의 일부를 형성하는 경우 : has - a 관계, 예를 들어 자식 DOM은 부모 노드의 구성 요소 - DOM 노드는 자식을 가짐).\n\n클래스 상속은 복합 객체를 구성하는 데 사용할 수 있지만 제한적이고 취약한 방법입니다.  Gang of Four는 \"클래스 상속보다는 객체 합성을 우선해라\"라고 말하면서 객체를 합성하기 위해 클래스 상속이란 강고하고 단단히 결합 된 접근 방식보다는  유연한 접근 방식을 사용하도록 조언합니다.\n\n[\"Categorical Methods in Computer Science: With Aspects from Topology\"](https://www.amazon.com/Categorical-Methods-Computer-Science-Topology/dp/0387517227/ref=as_li_ss_tl?ie=UTF8&qid=1495077930&sr=8-3&keywords=Categorical+Methods+in+Computer+Science:+With+Aspects+from+Topology&linkCode=ll1&tag=eejs-20&linkId=095afed5272832b74357f63b41410cb7) (1989)에서 나오는 개체 합성에 대한보다 넓은 정의를 사용하겠습니다.\n\n> \"복합 객체는 객체들이 합쳐져 만들어 지는데, 각각의 latter는 former의 일부분이된다.\"\n\n또 다른 좋은 참고 자료는 \"Reliable Software Through Composite Design\"(Glenford J Myers, 1975)입니다. 두 책 모두 절판되었지만 여러분이 객체 합성이라는 주제에 대해 심도있게 알아보고 싶으면 Amazon이나 이베이에서 여전히 책을 찾을 수 있습니다.\n\n_클래스 상속은 복합 객체 생성의 한 종류에 불과합니다._ 모든 클래스는 복합 객체를 생성하지만 모든 복합 객체가 클래스 또는 클래스 상속에 의해 생성되는 것은 아닙니다.  \"클래스 상속보다는 객체 합성을 우선해라\"라는 말은 클래스 계층의 조상 (ancestor)에서 모든 속성을 상속하지 않고 작은 구성 요소 부분에서 복합 객체를 형성해야한다는 것을 의미합니다.  전자는 객체 지향 설계에서 잘 알려진 다양한  문제를 일으 킵니다.\n\n-   **단단한 결합 문제** ^The^ ^tight^ ^coupling^ ^problem^ :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.\n-   **깨지기 쉬운 기초 클래스 문제**^The^ ^fragile^ ^base^ ^class^ ^problem^  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.\n-   **경직된 계층 구조 문제**^The^ ^inflexible^ ^hierarchy^ ^problem^ :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.\n-   **중복 필요성 문제**^The^ ^duplication^ ^by^ ^necessity^ ^problem^ : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.\n-   **고릴라 / 바나나 문제**^The^ ^gorilla/banana^ ^problem^ :  \"... 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. \"~ Joe Armstrong,  [\"Coders at Work \"](http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN)\n\nJavaScript에서 객체 합성의 가장 일반적인 형태는  **객체 연결**  (mixin composition이라고도 함)이라고합니다.  마치 아이스크림처럼 작동합니다. 먼저 바닐라 아이스크림과 같은 객체로 시작한 다음 원하는 기능을 믹스합니다.  견과류, 캐러멜, 초콜릿 소용돌이를 추가하면 너트 카라멜 초콜릿 소용돌이 아이스크림이 됩니다.\n\n클래스 상속을 사용하여 복합 객체 만들기 :\n\n```javascript\nclass Foo {  \n  constructor () {  \n    this.a = 'a'  \n  }  \n}\n\nclass Bar extends Foo {  \n  constructor (options) {  \n    super(options);  \n    this.b = 'b'  \n  }  \n}\n\nconst myBar = new Bar(); // {a: 'a', b: 'b'}\n```\n믹스 인 성분으로 복합 객체 만들기 :\n```javascript\nconst a = {  \n  a: 'a'  \n};\n\nconst b = {  \n  b: 'b'  \n};\n\nconst c = {...a, ...b}; // {a: 'a', b: 'b'}\n```\n\n앞으로 객체를 합성하는 다양한 방법에 대해 알아볼 것입니다.  지금까지의 논의를 정리하자면 다음과 같습니다.\n\n1.  어떤 것을 수행하는 데는 한 가지 이상의 방법이 있습니다.\n2.  어떤 방법은 다른 방법보다 낫습니다.\n3.  당장의 작업을 위해 가장 단순하고 유연한 솔루션을 선택하려고 합니다.\n\n## 결론\n\n이 글은 FP (Functional Programming)와 OOP (Object-Oriented Programming) 또는 프로그래밍 언어에 대한 글이 아닙니다.  소프트웨어를 합성하기 위한 컴포넌트는 함수, 자료 구조, 클래스 등의 형태를 취할 수 있습니다. 프로그래밍 언어마다 컴포넌트에 대해 서로 다른 접근방식을 취합니다. 자바는 클래스를 제공하고, 하스켈은 함수를 제공합니다. 그러나 어떤 언어, 어떤 패러다임을 선호하든 관계없이 함수와 자료구조를 합성할 수 밖에 없습니다.  결국, 모두 뒤죽박죽이 될지라도 말이지요.\n\n우리는 지금까지 대부분의 논의를 함수형 프로그래밍에 관하여 했습니다.  그 이유는 함수야 말로 JavaScript에서 가장 합성을 하기 쉬운 요소이고, 함수 프로그래밍 커뮤니티가 함수 합성 테크닉을 공식화하는 데 많은 시간과 노력을 투자했기 때문입니다.\n\n이 글은 함수형 프로그래밍이 객체 지향 프로그래밍보다 낫다는 논의를 하려는게 아닙니다. 만약 그렇다면 두 패러다임중 하나를 선택하라 할테지요.  OOP 대 FP는 잘못된 이분법입니다.  최근 몇 년 동안 본 모든 Javascript 애플리케이션은 FP와 OOP를 광범위하게 혼합합니다.\n\n객체를 합성하여 FP에서 사용될 자료구조를 만들고 함수형 프로그래밍으로 OOP에서 객체를 만들어볼 것 입니다.\n\n_소프트웨어를 작성하는 방법에 상관없이 훌륭한 합성을 해야합니다_\n\n> 소프트웨어 개발의 핵심은 합성입니다.\n\n합성을 이해하지 못하는 소프트웨어 개발자는 볼트나 못에 대해 모르는 주택 건설업자와 같습니다.  어떻게 합성될지 신경쓰지 않고 소프트웨어를 제작하는 것은 집을 건설할 때 덕트 테이프와 순간 접착제로 벽을 붙이는 것과 같습니다.\n\n이제는 단순하게 생각할 때입니다. 어떤 것을 단순화하는 가장 좋은 방법은 본질에 도달하는 것입니다.  문제는, 소프트웨어 산업에 있는 대부분의 사람들이 본질에 대해 무관심하다는 것입니다.  우리 업계는 소프트웨어 개발자인 당신을 제대로 가르치지 못했습니다.  업계는 개발자를 더 잘 훈련시켜야할 책임이 있습니다. 우리는 이를 고쳐야 합니다.  우리가 책임을 져야합니다.  경제에서 의료 장비에 이르기까지 모든 것에서 소프트웨어가 실행됩니다.  이 행성의 모든 인간의 삶은 소프트웨어 품질에 영향을받고 있습니다.  우리가 뭘 하고있는지 알아야합니다.\n\n지금부터 소프트웨어 합성 방법을 배우면 됩니다.\n\n[다음: 함수형 프로그래밍 패러다임의 역사>](https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/)","slug":"composing-software-intro","published":1,"updated":"2018-05-05T14:47:03.261Z","_id":"cjgjh83ct0009ifp63u10tt0s","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  <a href=\"https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"main image\"><br>\n<em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈에 대한 소개입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/\"><em>다음편 &gt;</em></a></p>\n</blockquote>\n<blockquote>\n<p>합성 : 전체를 구성하기 위해 부분이나 요소를 결합하는 행위<br>\nDictionary .com</p>\n</blockquote>\n<p>첫 고등학교 프로그래밍 수업 시간에 소프트웨어 개발이란 복잡한 문제를 작은 문제들로 분해하고 작은 문제들의 해법들을 다시 조합해 복잡한 문제를 해결 할 수 있는 솔루션을 만드는 행위라고 배웠습니다.</p>\n<p>전 그 말의 중요성을 너무 늦게 깨달았다는 것이 매우 후회됩니다. 너무 늦게 소프트웨어 설계의 본질을 깨달은 것 입니다.</p>\n<p>수백 명의 개발자들을 인터뷰하며 나만 그런 것이 아님을 알게됐습니다.  아주 소수의 개발자만이 소프트웨어 개발의 본질에 대해 잘 알고 있었습니다.  대부분의 경우에는 우리가 활용해야 하는 가장 중요한 개념과 그것을 잘 적용하는 방법을 몰랐습니다.  다음은 소프트웨어 개발에서 가장 중요한 두가지 질문입니다.</p>\n<ul>\n<li>함수 합성 <sup>function</sup> <sup>composition</sup> 이란 무엇인가?</li>\n<li>객체 합성 <sup>object</sup> <sup>composition</sup>이란 무엇인가?</li>\n</ul>\n<p>문제는 당신이 단지 잘 모른다고해서 객체 및 함수 합성을 하지 않을 수는 없다는 것입니다.  당신은 여전히 의식하지않고 (나쁘게)합성을 합니다. 그렇기에 버그가 넘쳐나고 다른 개발자가 이해하기 어려운 코드가 나옵니다.  이는 큰 문제이며 적지않은 대가를 지불하고 있습니다.  소프트웨어는 만드는 것보다 유지 보수하는 데 더 많은 시간이 들고, 버그는 전 세계 수십억 명의 사람들에게 영향을줍니다.</p>\n<p>오늘날 소프트웨어는 모든 곳에 존재합니다.  모든 자동차는 바퀴가 달린 미니 수퍼 컴퓨터이며 소프트웨어 설계 문제로 인해 사고가 발생하고 사람이 목숨을 잃습니다.  2013년, 배심원단은 사고를 조사하는 과정에서 Toyota의 소프트웨어 개발팀이 10,000 개의 글로벌 변수가있는 스파게티 코드를 작성한 것을 발견했습니다.</p>\n<p><a href=\"https://www.technologyreview.com/s/607875/should-the-government-keep-stockpiling-software-bugs/\" target=\"_blank\" rel=\"noopener\">해커 및 정부</a>는  버그를 활용해 사람들을 감시하고, 신용 카드를 훔치고, DDoS 공격을 하고 , 암호를 해독하고,  심지어 <a href=\"https://www.technologyreview.com/s/604138/the-fbi-shut-down-a-huge-botnet-but-there-are-plenty-more-left/\" target=\"_blank\" rel=\"noopener\">선거를 조작</a>  합니다.</p>\n<p>우리가 더 잘해야합니다.</p>\n<h2 id=\"사실-당신은-매일-소프트웨어를-합성합니다\">사실 당신은 매일 소프트웨어를 합성합니다</h2>\n<p>모든 소프트웨어 개발자는 의식하든 하지 못하든 매일 매일 함수와 데이터 구조를 합성합니다.  조금만 신경을 써서 더 잘 할 수 있지만, 그렇지 않고 덕트 테이프와 순간 접착제로 모든걸 망쳐버릴 수도 있습니다.</p>\n<p>소프트웨어 개발 프로세스란 큰 문제를 작은 문제로 분해하여 작은 문제를 해결하는 요소를 만들고 이러한 구성 요소들을 합성하여 완전한 응용 프로그램을애플리케이션 구성하는 것입니다.</p>\n<h2 id=\"함수-합성\">함수 합성</h2>\n<p>함수 합성이란 한 함수의 출력에 다른 함수를 결합시키는 과정입니다.  대수학에서  <code>f</code>  와  <code>g</code> 두 함수, 그리고 합성 함수   <code>(f ∘ g)(x) = f(g(x))</code> 를 본적 있을 겁니다.  조그마한 원 기호는 합성 연산자입니다.  일반적으로 &quot;composed with&quot;또는 &quot;after&quot;로 발음<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>됩니다.    <code>f</code> 와 <code>g</code>를 합성하는 것은  <code>f</code>에  <code>g</code>에 <code>x</code> 와 같이 부를 수 있습니다 . 이 때  <code>g</code>  가 먼저 평가되기 때문에  <code>g</code>  를 계산하고  그 결과를  <code>f</code>의  인수로 전달합니다.</p>\n<p>다음과 같은 방식의 코드를 작성할 때마다 함수를 합성하고 있는 것입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;   </span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> doStuff = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;   </span><br><span class=\"line\">\t<span class=\"keyword\">const</span> afterG = g (x);   </span><br><span class=\"line\">\t<span class=\"keyword\">const</span> afterF = f (afterG);   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> afterF;   </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">doStuff (<span class=\"number\">20</span>);  <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<p>ES6의 promise chain은  합성함수입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> wait = <span class=\"function\"><span class=\"params\">time</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(  </span><br><span class=\"line\">  (resolve, reject) =&gt; setTimeout(  </span><br><span class=\"line\">    resolve,  </span><br><span class=\"line\">    time  </span><br><span class=\"line\">  )  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">wait(<span class=\"number\">300</span>)  </span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">20</span>)  </span><br><span class=\"line\">  .then(g)  </span><br><span class=\"line\">  .then(f)  </span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"built_in\">console</span>.log(value)) <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<p>마찬가지로 배열 메소드 호출하거나 lodash 메소드, observables (RxJS, etc …)를 체인 할 때마다 함수를 합성하게 됩니다.  체이닝은 합성입니다.  반환 값을 다른 함수에 전달하는 것도 합성입니다.  <code>this</code>를  입력으로하여 두 개의 메소드를 순차적으로 호출하는 것 역시 합성입니다.</p>\n<blockquote>\n<p>당신이 체이닝을 한다면 합성중입니다.</p>\n</blockquote>\n<p>함수를 합성하고있다는 사실을 알고 있어야 합니다.</p>\n<p>다음은 함수를 합성하여  <code>doStuff()</code>  함수를 한줄로 고치는 코드입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;   </span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> doStuffBetter = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> f (g (x)); </span><br><span class=\"line\"></span><br><span class=\"line\">doStuffBetter (<span class=\"number\">20</span>);  <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<p>이러한 방법은 종종 디버깅이 어렵다는 얘기를 듣습니다.  그렇다면 디버깅 로직이 담긴 아래 코드를 함수 합성방식으로 재작성 해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doStuff = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterG = g(x);  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`after g: <span class=\"subst\">$&#123; afterG &#125;</span>`</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterF = f(afterG);  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`after f: <span class=\"subst\">$&#123; afterF &#125;</span>`</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> afterF;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">doStuff(<span class=\"number\">20</span>); <span class=\"comment\">// =&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">\"after g: 21\"  </span></span><br><span class=\"line\"><span class=\"comment\">\"after f: 42\"  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>먼저, <code>afterF</code>,  <code>afterG</code>를 추상화할 수 있는 <code>trace()</code> 라는 간단한 로거<sup>logger</sup>함수를 만들어 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> trace = <span class=\"function\"><span class=\"params\">label</span> =&gt;</span> value =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123; label &#125;</span>: <span class=\"subst\">$&#123; value &#125;</span>`</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>이제 다음과 같이 사용할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doStuff = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterG = g(x);  </span><br><span class=\"line\">  trace(<span class=\"string\">'after g'</span>)(afterG);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterF = f(afterG);  </span><br><span class=\"line\">  trace(<span class=\"string\">'after f'</span>)(afterF);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> afterF;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">doStuff(<span class=\"number\">20</span>); <span class=\"comment\">// =&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">\"after g: 21\"  </span></span><br><span class=\"line\"><span class=\"comment\">\"after f: 42\"  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>Lodash 및 Ramda와 같은 인기있는 함수 프로그래밍 라이브러리에는 함수를 쉽게 구성 할 수있는 유틸리티가 포함되어 있습니다.  위의 함수를 다음과 같이 다시 작성할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pipe <span class=\"keyword\">from</span> <span class=\"string\">'lodash/fp/flow'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> doStuffBetter = pipe(  </span><br><span class=\"line\">  g,  </span><br><span class=\"line\">  trace(<span class=\"string\">'after g'</span>),  </span><br><span class=\"line\">  f,  </span><br><span class=\"line\">  trace(<span class=\"string\">'after f'</span>)  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">doStuffBetter(<span class=\"number\">20</span>); <span class=\"comment\">// =&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">\"after g: 21\"  </span></span><br><span class=\"line\"><span class=\"comment\">\"after f: 42\"  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>라이브러리를 사용하지 않고 다음과 같이 pipe를 직접 정의 할 수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pipe(...fns: [...Function]) =&gt; x =&gt; y  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);</span><br></pre></td></tr></table></figure>\n<p>아직은 어떻게 작동하는지 몰라도 괜찮습니다.  나중에 훨씬 더 자세하게 알아볼 것입니다.  사실 매우 중요한 코드이기 때문에 문서 전체에 걸쳐 반복해서 정의되고 시연 될 겁니다.  중요한 건 당신이 그 의미와 사용법을 자동적으로 떠올릴 수 있을 만큼 익숙해지는 것입니다.  <strong>합성</strong><sup>composition</sup>과 한 몸이 되어야 합니다.</p>\n<p><code>pipe()</code> 유틸리티는 한 함수의 출력을 다른 함수의 입력으로 전달하여 함수 파이프 라인을 생성합니다.  <code>pipe()</code>  (그리고 쌍둥이라고 할 수 있는  <code>compose()</code>  )를 사용하면 중간 변수<sup>intermediary</sup> <sup>variables</sup>가 필요 없습니다.  인수를 언급하지 않고 함수를 작성하는 것을  <strong>포인트없는 스타일</strong><sup>point-free</sup> <sup>style</sup> 혹은 <strong>무인수 방식</strong>이라고  <strong>합니다.</strong>  이를 위해 함수를 명시적으로 선언하는 대신 다른 함수를 반환하는 함수를 호출합니다.  즉,  <code>function</code>  키워드 나 화살표 구문 (  <code>=&gt;</code>  )이 필요하지 않습니다.</p>\n<p>무인수 방식으로 전체 로직을 구성할 수도 있지만, 중간 변수들이 여러분의 기능에 불필요한 복잡성<sup>complexity</sup>을 더하기 때문에 여기 저기 조금씩 사용하는 것도 좋습니다.</p>\n<p>복잡성 감소에는 몇 가지 이점이 있습니다.</p>\n<h2 id=\"단기-기억\">단기 기억</h2>\n<p>인간 두뇌의  <a href=\"http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html\" target=\"_blank\" rel=\"noopener\">단기 기억력</a>은 서로 다른 항목을 저장하기 위한 공간이 한정되어있으며, 함수의 인자와 변수는 잠재적으로 그 공간 중 하나를 소비합니다.  변수가 늘어날 수록 각 변수의 의미를 기억하기 힘들어 집니다. 단기 기억 모형에 따르면 우리의 두뇌는 일반적으로 4-7 개의 항목을 단기 기억 공간에 저장할 수 있으며 이 보다 크면 오류율이 급격히 증가합니다.</p>\n<p>우리는 함수 파이프라이닝을 사용해 변수 3개를 소거하였고 다른 변수를 기억하는데 사용할 수  있게 됐습니다.  단기 기억 공간의 거의 절반을 확보한 것입니다. 이는 인지 부하를 상당히 줄여줍니다.  소프트웨어 개발자는 데이터를 묶어 기억하는 경향이 있지만 그렇다고 이 개념의 중요성이 약해지는 것은 아닙니다.</p>\n<h2 id=\"신호-대-잡음비\">신호 대 잡음비</h2>\n<p>간결함은 코드의 신호 대 잡음 비율<sup>Signal</sup> <sup>to</sup> <sup>Noise</sup> <sup>Ratio</sup>을 향상시킵니다.  라디오를 듣는 것과 같습니다. 라디오의 주파수가 제대로 맞춰져 있지 않으면 소음이 발생하며 음악을 듣기가 어려워집니다.  방송국 주파수로 정확하게 튜닝하면 소음이 사라지고 음악 신호가 강해집니다.</p>\n<p>코드도 마찬가지입니다.  간결한 표현은 이해력을 향상시킵니다. 일부 코드는 유용한 정보를 제공하고 일부 코드는 공간을 차지합니다.  전달되어야 할 의미를 변화시키지 않는 선에서 코드의 양을 줄이면 코드를 읽고 이해해야하는 다른 사람들이 더 쉽게 이해할 수 있습니다.<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n<h2 id=\"코드의-면적과-버그\">코드의 면적과 버그</h2>\n<p>함수형으로 작성된 코드를 살펴보면 마치 코드가 살을 빼 다이어트 한 것처럼 보입니다. 이 비유가 중요한 이유는 여분의 코드가 버그를 숨길 수있는 추가 표면적을 의미하기 때문입니다 . 즉 더 많은 버그가 숨어 버릴 수 있음을 의미합니다.</p>\n<blockquote>\n<p><em>적은 코드 = 버그가 적은 표면 = 버그가 적습니다.</em></p>\n</blockquote>\n<h2 id=\"객체-합성\">객체 합성</h2>\n<blockquote>\n<p>“클래스 상속보다는 객체 합성을 우선해라”, Gang of Four,  <a href=\"https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;qid=1494993475&amp;sr=8-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6c553f16325f3939e5abadd4ee04e8b4\" target=\"_blank\" rel=\"noopener\">“디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소”</a></p>\n</blockquote>\n<blockquote>\n<p>&quot;컴퓨터 과학에서 복합 자료형<sup>composite</sup> <sup>datatype</sup>이란 프로그래밍 언어의 원시형 및 기타 복합 자료형 사용하여 프로그램에서 조합 할 수있는 모든 자료형입니다.  […] 복합 자료형을 만드는 행위는 합성<sup>composition</sup>으로 알려져 있습니다. &quot;~ Wikipedia</p>\n</blockquote>\n<p>다음은 원시형입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> firstName = <span class=\"string\">'Claude'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> lastName = <span class=\"string\">'Debussy'</span>;</span><br></pre></td></tr></table></figure>\n<p>그리고 이것은 복합체입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fullName = &#123;  </span><br><span class=\"line\">  firstName,  </span><br><span class=\"line\">  lastName  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>마찬가지로 모든 array, set, map, weak map, typed array 등은 복합 자료형입니다.  비 원시형 구조를 작성할 때마다 우리는 객체를 합성합니다.</p>\n<p>Gang of Four의 <strong>컴포지트 패턴</strong><sup>composite</sup> <sup>pattern</sup>은 객체들의 관계를 재귀적으로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 정의합니다. 일부 개발자는 컴포지트 패턴이 <em>객체 합성의 유일한 형태</em>  라고 생각하면서 혼란스러워 합니다.  혼동하지 마십시오.  객체 합성에는 여러 가지 종류가 있습니다.</p>\n<p>Gang of Four는 계속해서 &quot;객체합성은 여러 디자인 패턴에 다양하게 적용될 것 입니다&quot;라고 말한 다음 객체가 합성될때 두 객체의 관계를 정의하기 위한 세가지 표현을 정의했습니다.</p>\n<ol>\n<li><strong>위임</strong><sup>delegation</sup>  (state, strategy 및 visitor 패턴에서 사용 됨)</li>\n<li><strong>인지</strong><sup>acquaintance</sup>  (객체가 참조로 다른 객체를 알고있을 때 일반적으로 매개 변수로 전달됨 : 네트워크 요청 처리기가 로거에 대한 참조를 전달하여 요청을 기록 - 요청 처리기가 로거를 사용함)</li>\n<li><strong>집합</strong><sup>aggregation</sup>  (자식 객체가 부모 객체의 일부를 형성하는 경우 : has - a 관계, 예를 들어 자식 DOM은 부모 노드의 구성 요소 - DOM 노드는 자식을 가짐).</li>\n</ol>\n<p>클래스 상속은 복합 객체를 구성하는 데 사용할 수 있지만 제한적이고 취약한 방법입니다.  Gang of Four는 &quot;클래스 상속보다는 객체 합성을 우선해라&quot;라고 말하면서 객체를 합성하기 위해 클래스 상속이란 강고하고 단단히 결합 된 접근 방식보다는  유연한 접근 방식을 사용하도록 조언합니다.</p>\n<p><a href=\"https://www.amazon.com/Categorical-Methods-Computer-Science-Topology/dp/0387517227/ref=as_li_ss_tl?ie=UTF8&amp;qid=1495077930&amp;sr=8-3&amp;keywords=Categorical+Methods+in+Computer+Science:+With+Aspects+from+Topology&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=095afed5272832b74357f63b41410cb7\" target=\"_blank\" rel=\"noopener\">“Categorical Methods in Computer Science: With Aspects from Topology”</a> (1989)에서 나오는 개체 합성에 대한보다 넓은 정의를 사용하겠습니다.</p>\n<blockquote>\n<p>“복합 객체는 객체들이 합쳐져 만들어 지는데, 각각의 latter는 former의 일부분이된다.”</p>\n</blockquote>\n<p>또 다른 좋은 참고 자료는 “Reliable Software Through Composite Design”(Glenford J Myers, 1975)입니다. 두 책 모두 절판되었지만 여러분이 객체 합성이라는 주제에 대해 심도있게 알아보고 싶으면 Amazon이나 이베이에서 여전히 책을 찾을 수 있습니다.</p>\n<p><em>클래스 상속은 복합 객체 생성의 한 종류에 불과합니다.</em> 모든 클래스는 복합 객체를 생성하지만 모든 복합 객체가 클래스 또는 클래스 상속에 의해 생성되는 것은 아닙니다.  &quot;클래스 상속보다는 객체 합성을 우선해라&quot;라는 말은 클래스 계층의 조상 (ancestor)에서 모든 속성을 상속하지 않고 작은 구성 요소 부분에서 복합 객체를 형성해야한다는 것을 의미합니다.  전자는 객체 지향 설계에서 잘 알려진 다양한  문제를 일으 킵니다.</p>\n<ul>\n<li><strong>단단한 결합 문제</strong> <sup>The</sup> <sup>tight</sup> <sup>coupling</sup> <sup>problem</sup> :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.</li>\n<li><strong>깨지기 쉬운 기초 클래스 문제</strong><sup>The</sup> <sup>fragile</sup> <sup>base</sup> <sup>class</sup> <sup>problem</sup>  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.</li>\n<li><strong>경직된 계층 구조 문제</strong><sup>The</sup> <sup>inflexible</sup> <sup>hierarchy</sup> <sup>problem</sup> :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.</li>\n<li><strong>중복 필요성 문제</strong><sup>The</sup> <sup>duplication</sup> <sup>by</sup> <sup>necessity</sup> <sup>problem</sup> : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.</li>\n<li><strong>고릴라 / 바나나 문제</strong><sup>The</sup> <sup>gorilla/banana</sup> <sup>problem</sup> :  &quot;… 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. &quot;~ Joe Armstrong,  <a href=\"http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN\" target=\"_blank\" rel=\"noopener\">&quot;Coders at Work &quot;</a></li>\n</ul>\n<p>JavaScript에서 객체 합성의 가장 일반적인 형태는  <strong>객체 연결</strong>  (mixin composition이라고도 함)이라고합니다.  마치 아이스크림처럼 작동합니다. 먼저 바닐라 아이스크림과 같은 객체로 시작한 다음 원하는 기능을 믹스합니다.  견과류, 캐러멜, 초콜릿 소용돌이를 추가하면 너트 카라멜 초콜릿 소용돌이 아이스크림이 됩니다.</p>\n<p>클래스 상속을 사용하여 복합 객체 만들기 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = <span class=\"string\">'a'</span>  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Foo</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (options) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">super</span>(options);  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = <span class=\"string\">'b'</span>  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myBar = <span class=\"keyword\">new</span> Bar(); <span class=\"comment\">// &#123;a: 'a', b: 'b'&#125;</span></span><br></pre></td></tr></table></figure>\n<p>믹스 인 성분으로 복합 객체 만들기 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;  </span><br><span class=\"line\">  a: <span class=\"string\">'a'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;  </span><br><span class=\"line\">  b: <span class=\"string\">'b'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> c = &#123;...a, ...b&#125;; <span class=\"comment\">// &#123;a: 'a', b: 'b'&#125;</span></span><br></pre></td></tr></table></figure>\n<p>앞으로 객체를 합성하는 다양한 방법에 대해 알아볼 것입니다.  지금까지의 논의를 정리하자면 다음과 같습니다.</p>\n<ol>\n<li>어떤 것을 수행하는 데는 한 가지 이상의 방법이 있습니다.</li>\n<li>어떤 방법은 다른 방법보다 낫습니다.</li>\n<li>당장의 작업을 위해 가장 단순하고 유연한 솔루션을 선택하려고 합니다.</li>\n</ol>\n<h2 id=\"결론\">결론</h2>\n<p>이 글은 FP (Functional Programming)와 OOP (Object-Oriented Programming) 또는 프로그래밍 언어에 대한 글이 아닙니다.  소프트웨어를 합성하기 위한 컴포넌트는 함수, 자료 구조, 클래스 등의 형태를 취할 수 있습니다. 프로그래밍 언어마다 컴포넌트에 대해 서로 다른 접근방식을 취합니다. 자바는 클래스를 제공하고, 하스켈은 함수를 제공합니다. 그러나 어떤 언어, 어떤 패러다임을 선호하든 관계없이 함수와 자료구조를 합성할 수 밖에 없습니다.  결국, 모두 뒤죽박죽이 될지라도 말이지요.</p>\n<p>우리는 지금까지 대부분의 논의를 함수형 프로그래밍에 관하여 했습니다.  그 이유는 함수야 말로 JavaScript에서 가장 합성을 하기 쉬운 요소이고, 함수 프로그래밍 커뮤니티가 함수 합성 테크닉을 공식화하는 데 많은 시간과 노력을 투자했기 때문입니다.</p>\n<p>이 글은 함수형 프로그래밍이 객체 지향 프로그래밍보다 낫다는 논의를 하려는게 아닙니다. 만약 그렇다면 두 패러다임중 하나를 선택하라 할테지요.  OOP 대 FP는 잘못된 이분법입니다.  최근 몇 년 동안 본 모든 Javascript 애플리케이션은 FP와 OOP를 광범위하게 혼합합니다.</p>\n<p>객체를 합성하여 FP에서 사용될 자료구조를 만들고 함수형 프로그래밍으로 OOP에서 객체를 만들어볼 것 입니다.</p>\n<p><em>소프트웨어를 작성하는 방법에 상관없이 훌륭한 합성을 해야합니다</em></p>\n<blockquote>\n<p>소프트웨어 개발의 핵심은 합성입니다.</p>\n</blockquote>\n<p>합성을 이해하지 못하는 소프트웨어 개발자는 볼트나 못에 대해 모르는 주택 건설업자와 같습니다.  어떻게 합성될지 신경쓰지 않고 소프트웨어를 제작하는 것은 집을 건설할 때 덕트 테이프와 순간 접착제로 벽을 붙이는 것과 같습니다.</p>\n<p>이제는 단순하게 생각할 때입니다. 어떤 것을 단순화하는 가장 좋은 방법은 본질에 도달하는 것입니다.  문제는, 소프트웨어 산업에 있는 대부분의 사람들이 본질에 대해 무관심하다는 것입니다.  우리 업계는 소프트웨어 개발자인 당신을 제대로 가르치지 못했습니다.  업계는 개발자를 더 잘 훈련시켜야할 책임이 있습니다. 우리는 이를 고쳐야 합니다.  우리가 책임을 져야합니다.  경제에서 의료 장비에 이르기까지 모든 것에서 소프트웨어가 실행됩니다.  이 행성의 모든 인간의 삶은 소프트웨어 품질에 영향을받고 있습니다.  우리가 뭘 하고있는지 알아야합니다.</p>\n<p>지금부터 소프트웨어 합성 방법을 배우면 됩니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/\">다음: 함수형 프로그래밍 패러다임의 역사&gt;</a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>한국에서는 보통 ~와 ~를 합성한다고 하거나 ~에 ~ 처럼생략합니다  <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>개발자가 코드를 작성하고 다른 개발자가 이를 이해한다는 것을 라디오의 방송국과 청취자들의 관계에 비유했 습니다. 이 때 신호란 전달되어야하는 의미이고 잡음이란 공간만 차지하는 코드입니다. 즉 더 적은 코드로 같은 의미를 전달하는 것이 좋다는 말이 됩니다. <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  <a href=\"https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"main image\"><br>\n<em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈에 대한 소개입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/\"><em>다음편 &gt;</em></a></p>\n</blockquote>\n<blockquote>\n<p>합성 : 전체를 구성하기 위해 부분이나 요소를 결합하는 행위<br>\nDictionary .com</p>\n</blockquote>\n<p>첫 고등학교 프로그래밍 수업 시간에 소프트웨어 개발이란 복잡한 문제를 작은 문제들로 분해하고 작은 문제들의 해법들을 다시 조합해 복잡한 문제를 해결 할 수 있는 솔루션을 만드는 행위라고 배웠습니다.</p>\n<p>전 그 말의 중요성을 너무 늦게 깨달았다는 것이 매우 후회됩니다. 너무 늦게 소프트웨어 설계의 본질을 깨달은 것 입니다.</p>\n<p>수백 명의 개발자들을 인터뷰하며 나만 그런 것이 아님을 알게됐습니다.  아주 소수의 개발자만이 소프트웨어 개발의 본질에 대해 잘 알고 있었습니다.  대부분의 경우에는 우리가 활용해야 하는 가장 중요한 개념과 그것을 잘 적용하는 방법을 몰랐습니다.  다음은 소프트웨어 개발에서 가장 중요한 두가지 질문입니다.</p>\n<ul>\n<li>함수 합성 <sup>function</sup> <sup>composition</sup> 이란 무엇인가?</li>\n<li>객체 합성 <sup>object</sup> <sup>composition</sup>이란 무엇인가?</li>\n</ul>\n<p>문제는 당신이 단지 잘 모른다고해서 객체 및 함수 합성을 하지 않을 수는 없다는 것입니다.  당신은 여전히 의식하지않고 (나쁘게)합성을 합니다. 그렇기에 버그가 넘쳐나고 다른 개발자가 이해하기 어려운 코드가 나옵니다.  이는 큰 문제이며 적지않은 대가를 지불하고 있습니다.  소프트웨어는 만드는 것보다 유지 보수하는 데 더 많은 시간이 들고, 버그는 전 세계 수십억 명의 사람들에게 영향을줍니다.</p>\n<p>오늘날 소프트웨어는 모든 곳에 존재합니다.  모든 자동차는 바퀴가 달린 미니 수퍼 컴퓨터이며 소프트웨어 설계 문제로 인해 사고가 발생하고 사람이 목숨을 잃습니다.  2013년, 배심원단은 사고를 조사하는 과정에서 Toyota의 소프트웨어 개발팀이 10,000 개의 글로벌 변수가있는 스파게티 코드를 작성한 것을 발견했습니다.</p>\n<p><a href=\"https://www.technologyreview.com/s/607875/should-the-government-keep-stockpiling-software-bugs/\" target=\"_blank\" rel=\"noopener\">해커 및 정부</a>는  버그를 활용해 사람들을 감시하고, 신용 카드를 훔치고, DDoS 공격을 하고 , 암호를 해독하고,  심지어 <a href=\"https://www.technologyreview.com/s/604138/the-fbi-shut-down-a-huge-botnet-but-there-are-plenty-more-left/\" target=\"_blank\" rel=\"noopener\">선거를 조작</a>  합니다.</p>\n<p>우리가 더 잘해야합니다.</p>\n<h2>사실 당신은 매일 소프트웨어를 합성합니다</h2>\n<p>모든 소프트웨어 개발자는 의식하든 하지 못하든 매일 매일 함수와 데이터 구조를 합성합니다.  조금만 신경을 써서 더 잘 할 수 있지만, 그렇지 않고 덕트 테이프와 순간 접착제로 모든걸 망쳐버릴 수도 있습니다.</p>\n<p>소프트웨어 개발 프로세스란 큰 문제를 작은 문제로 분해하여 작은 문제를 해결하는 요소를 만들고 이러한 구성 요소들을 합성하여 완전한 응용 프로그램을애플리케이션 구성하는 것입니다.</p>\n<h2>함수 합성</h2>\n<p>함수 합성이란 한 함수의 출력에 다른 함수를 결합시키는 과정입니다.  대수학에서  <code>f</code>  와  <code>g</code> 두 함수, 그리고 합성 함수   <code>(f ∘ g)(x) = f(g(x))</code> 를 본적 있을 겁니다.  조그마한 원 기호는 합성 연산자입니다.  일반적으로 &quot;composed with&quot;또는 &quot;after&quot;로 발음<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>됩니다.    <code>f</code> 와 <code>g</code>를 합성하는 것은  <code>f</code>에  <code>g</code>에 <code>x</code> 와 같이 부를 수 있습니다 . 이 때  <code>g</code>  가 먼저 평가되기 때문에  <code>g</code>  를 계산하고  그 결과를  <code>f</code>의  인수로 전달합니다.</p>\n<p>다음과 같은 방식의 코드를 작성할 때마다 함수를 합성하고 있는 것입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;   </span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> doStuff = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;   </span><br><span class=\"line\">\t<span class=\"keyword\">const</span> afterG = g (x);   </span><br><span class=\"line\">\t<span class=\"keyword\">const</span> afterF = f (afterG);   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> afterF;   </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">doStuff (<span class=\"number\">20</span>);  <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<p>ES6의 promise chain은  합성함수입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> wait = <span class=\"function\"><span class=\"params\">time</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(  </span><br><span class=\"line\">  (resolve, reject) =&gt; setTimeout(  </span><br><span class=\"line\">    resolve,  </span><br><span class=\"line\">    time  </span><br><span class=\"line\">  )  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">wait(<span class=\"number\">300</span>)  </span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">20</span>)  </span><br><span class=\"line\">  .then(g)  </span><br><span class=\"line\">  .then(f)  </span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"built_in\">console</span>.log(value)) <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<p>마찬가지로 배열 메소드 호출하거나 lodash 메소드, observables (RxJS, etc …)를 체인 할 때마다 함수를 합성하게 됩니다.  체이닝은 합성입니다.  반환 값을 다른 함수에 전달하는 것도 합성입니다.  <code>this</code>를  입력으로하여 두 개의 메소드를 순차적으로 호출하는 것 역시 합성입니다.</p>\n<blockquote>\n<p>당신이 체이닝을 한다면 합성중입니다.</p>\n</blockquote>\n<p>함수를 합성하고있다는 사실을 알고 있어야 합니다.</p>\n<p>다음은 함수를 합성하여  <code>doStuff()</code>  함수를 한줄로 고치는 코드입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;   </span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> doStuffBetter = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> f (g (x)); </span><br><span class=\"line\"></span><br><span class=\"line\">doStuffBetter (<span class=\"number\">20</span>);  <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<p>이러한 방법은 종종 디버깅이 어렵다는 얘기를 듣습니다.  그렇다면 디버깅 로직이 담긴 아래 코드를 함수 합성방식으로 재작성 해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doStuff = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterG = g(x);  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`after g: <span class=\"subst\">$&#123; afterG &#125;</span>`</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterF = f(afterG);  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`after f: <span class=\"subst\">$&#123; afterF &#125;</span>`</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> afterF;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">doStuff(<span class=\"number\">20</span>); <span class=\"comment\">// =&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">\"after g: 21\"  </span></span><br><span class=\"line\"><span class=\"comment\">\"after f: 42\"  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>먼저, <code>afterF</code>,  <code>afterG</code>를 추상화할 수 있는 <code>trace()</code> 라는 간단한 로거<sup>logger</sup>함수를 만들어 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> trace = <span class=\"function\"><span class=\"params\">label</span> =&gt;</span> value =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123; label &#125;</span>: <span class=\"subst\">$&#123; value &#125;</span>`</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>이제 다음과 같이 사용할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doStuff = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterG = g(x);  </span><br><span class=\"line\">  trace(<span class=\"string\">'after g'</span>)(afterG);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterF = f(afterG);  </span><br><span class=\"line\">  trace(<span class=\"string\">'after f'</span>)(afterF);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> afterF;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">doStuff(<span class=\"number\">20</span>); <span class=\"comment\">// =&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">\"after g: 21\"  </span></span><br><span class=\"line\"><span class=\"comment\">\"after f: 42\"  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>Lodash 및 Ramda와 같은 인기있는 함수 프로그래밍 라이브러리에는 함수를 쉽게 구성 할 수있는 유틸리티가 포함되어 있습니다.  위의 함수를 다음과 같이 다시 작성할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pipe <span class=\"keyword\">from</span> <span class=\"string\">'lodash/fp/flow'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> doStuffBetter = pipe(  </span><br><span class=\"line\">  g,  </span><br><span class=\"line\">  trace(<span class=\"string\">'after g'</span>),  </span><br><span class=\"line\">  f,  </span><br><span class=\"line\">  trace(<span class=\"string\">'after f'</span>)  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">doStuffBetter(<span class=\"number\">20</span>); <span class=\"comment\">// =&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">\"after g: 21\"  </span></span><br><span class=\"line\"><span class=\"comment\">\"after f: 42\"  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>라이브러리를 사용하지 않고 다음과 같이 pipe를 직접 정의 할 수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pipe(...fns: [...Function]) =&gt; x =&gt; y  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);</span><br></pre></td></tr></table></figure>\n<p>아직은 어떻게 작동하는지 몰라도 괜찮습니다.  나중에 훨씬 더 자세하게 알아볼 것입니다.  사실 매우 중요한 코드이기 때문에 문서 전체에 걸쳐 반복해서 정의되고 시연 될 겁니다.  중요한 건 당신이 그 의미와 사용법을 자동적으로 떠올릴 수 있을 만큼 익숙해지는 것입니다.  <strong>합성</strong><sup>composition</sup>과 한 몸이 되어야 합니다.</p>\n<p><code>pipe()</code> 유틸리티는 한 함수의 출력을 다른 함수의 입력으로 전달하여 함수 파이프 라인을 생성합니다.  <code>pipe()</code>  (그리고 쌍둥이라고 할 수 있는  <code>compose()</code>  )를 사용하면 중간 변수<sup>intermediary</sup> <sup>variables</sup>가 필요 없습니다.  인수를 언급하지 않고 함수를 작성하는 것을  <strong>포인트없는 스타일</strong><sup>point-free</sup> <sup>style</sup> 혹은 <strong>무인수 방식</strong>이라고  <strong>합니다.</strong>  이를 위해 함수를 명시적으로 선언하는 대신 다른 함수를 반환하는 함수를 호출합니다.  즉,  <code>function</code>  키워드 나 화살표 구문 (  <code>=&gt;</code>  )이 필요하지 않습니다.</p>\n<p>무인수 방식으로 전체 로직을 구성할 수도 있지만, 중간 변수들이 여러분의 기능에 불필요한 복잡성<sup>complexity</sup>을 더하기 때문에 여기 저기 조금씩 사용하는 것도 좋습니다.</p>\n<p>복잡성 감소에는 몇 가지 이점이 있습니다.</p>\n<h2>단기 기억</h2>\n<p>인간 두뇌의  <a href=\"http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html\" target=\"_blank\" rel=\"noopener\">단기 기억력</a>은 서로 다른 항목을 저장하기 위한 공간이 한정되어있으며, 함수의 인자와 변수는 잠재적으로 그 공간 중 하나를 소비합니다.  변수가 늘어날 수록 각 변수의 의미를 기억하기 힘들어 집니다. 단기 기억 모형에 따르면 우리의 두뇌는 일반적으로 4-7 개의 항목을 단기 기억 공간에 저장할 수 있으며 이 보다 크면 오류율이 급격히 증가합니다.</p>\n<p>우리는 함수 파이프라이닝을 사용해 변수 3개를 소거하였고 다른 변수를 기억하는데 사용할 수  있게 됐습니다.  단기 기억 공간의 거의 절반을 확보한 것입니다. 이는 인지 부하를 상당히 줄여줍니다.  소프트웨어 개발자는 데이터를 묶어 기억하는 경향이 있지만 그렇다고 이 개념의 중요성이 약해지는 것은 아닙니다.</p>\n<h2>신호 대 잡음비</h2>\n<p>간결함은 코드의 신호 대 잡음 비율<sup>Signal</sup> <sup>to</sup> <sup>Noise</sup> <sup>Ratio</sup>을 향상시킵니다.  라디오를 듣는 것과 같습니다. 라디오의 주파수가 제대로 맞춰져 있지 않으면 소음이 발생하며 음악을 듣기가 어려워집니다.  방송국 주파수로 정확하게 튜닝하면 소음이 사라지고 음악 신호가 강해집니다.</p>\n<p>코드도 마찬가지입니다.  간결한 표현은 이해력을 향상시킵니다. 일부 코드는 유용한 정보를 제공하고 일부 코드는 공간을 차지합니다.  전달되어야 할 의미를 변화시키지 않는 선에서 코드의 양을 줄이면 코드를 읽고 이해해야하는 다른 사람들이 더 쉽게 이해할 수 있습니다.<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n<h2>코드의 면적과 버그</h2>\n<p>함수형으로 작성된 코드를 살펴보면 마치 코드가 살을 빼 다이어트 한 것처럼 보입니다. 이 비유가 중요한 이유는 여분의 코드가 버그를 숨길 수있는 추가 표면적을 의미하기 때문입니다 . 즉 더 많은 버그가 숨어 버릴 수 있음을 의미합니다.</p>\n<blockquote>\n<p><em>적은 코드 = 버그가 적은 표면 = 버그가 적습니다.</em></p>\n</blockquote>\n<h2>객체 합성</h2>\n<blockquote>\n<p>“클래스 상속보다는 객체 합성을 우선해라”, Gang of Four,  <a href=\"https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;qid=1494993475&amp;sr=8-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6c553f16325f3939e5abadd4ee04e8b4\" target=\"_blank\" rel=\"noopener\">“디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소”</a></p>\n</blockquote>\n<blockquote>\n<p>&quot;컴퓨터 과학에서 복합 자료형<sup>composite</sup> <sup>datatype</sup>이란 프로그래밍 언어의 원시형 및 기타 복합 자료형 사용하여 프로그램에서 조합 할 수있는 모든 자료형입니다.  […] 복합 자료형을 만드는 행위는 합성<sup>composition</sup>으로 알려져 있습니다. &quot;~ Wikipedia</p>\n</blockquote>\n<p>다음은 원시형입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> firstName = <span class=\"string\">'Claude'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> lastName = <span class=\"string\">'Debussy'</span>;</span><br></pre></td></tr></table></figure>\n<p>그리고 이것은 복합체입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fullName = &#123;  </span><br><span class=\"line\">  firstName,  </span><br><span class=\"line\">  lastName  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>마찬가지로 모든 array, set, map, weak map, typed array 등은 복합 자료형입니다.  비 원시형 구조를 작성할 때마다 우리는 객체를 합성합니다.</p>\n<p>Gang of Four의 <strong>컴포지트 패턴</strong><sup>composite</sup> <sup>pattern</sup>은 객체들의 관계를 재귀적으로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 정의합니다. 일부 개발자는 컴포지트 패턴이 <em>객체 합성의 유일한 형태</em>  라고 생각하면서 혼란스러워 합니다.  혼동하지 마십시오.  객체 합성에는 여러 가지 종류가 있습니다.</p>\n<p>Gang of Four는 계속해서 &quot;객체합성은 여러 디자인 패턴에 다양하게 적용될 것 입니다&quot;라고 말한 다음 객체가 합성될때 두 객체의 관계를 정의하기 위한 세가지 표현을 정의했습니다.</p>\n<ol>\n<li><strong>위임</strong><sup>delegation</sup>  (state, strategy 및 visitor 패턴에서 사용 됨)</li>\n<li><strong>인지</strong><sup>acquaintance</sup>  (객체가 참조로 다른 객체를 알고있을 때 일반적으로 매개 변수로 전달됨 : 네트워크 요청 처리기가 로거에 대한 참조를 전달하여 요청을 기록 - 요청 처리기가 로거를 사용함)</li>\n<li><strong>집합</strong><sup>aggregation</sup>  (자식 객체가 부모 객체의 일부를 형성하는 경우 : has - a 관계, 예를 들어 자식 DOM은 부모 노드의 구성 요소 - DOM 노드는 자식을 가짐).</li>\n</ol>\n<p>클래스 상속은 복합 객체를 구성하는 데 사용할 수 있지만 제한적이고 취약한 방법입니다.  Gang of Four는 &quot;클래스 상속보다는 객체 합성을 우선해라&quot;라고 말하면서 객체를 합성하기 위해 클래스 상속이란 강고하고 단단히 결합 된 접근 방식보다는  유연한 접근 방식을 사용하도록 조언합니다.</p>\n<p><a href=\"https://www.amazon.com/Categorical-Methods-Computer-Science-Topology/dp/0387517227/ref=as_li_ss_tl?ie=UTF8&amp;qid=1495077930&amp;sr=8-3&amp;keywords=Categorical+Methods+in+Computer+Science:+With+Aspects+from+Topology&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=095afed5272832b74357f63b41410cb7\" target=\"_blank\" rel=\"noopener\">“Categorical Methods in Computer Science: With Aspects from Topology”</a> (1989)에서 나오는 개체 합성에 대한보다 넓은 정의를 사용하겠습니다.</p>\n<blockquote>\n<p>“복합 객체는 객체들이 합쳐져 만들어 지는데, 각각의 latter는 former의 일부분이된다.”</p>\n</blockquote>\n<p>또 다른 좋은 참고 자료는 “Reliable Software Through Composite Design”(Glenford J Myers, 1975)입니다. 두 책 모두 절판되었지만 여러분이 객체 합성이라는 주제에 대해 심도있게 알아보고 싶으면 Amazon이나 이베이에서 여전히 책을 찾을 수 있습니다.</p>\n<p><em>클래스 상속은 복합 객체 생성의 한 종류에 불과합니다.</em> 모든 클래스는 복합 객체를 생성하지만 모든 복합 객체가 클래스 또는 클래스 상속에 의해 생성되는 것은 아닙니다.  &quot;클래스 상속보다는 객체 합성을 우선해라&quot;라는 말은 클래스 계층의 조상 (ancestor)에서 모든 속성을 상속하지 않고 작은 구성 요소 부분에서 복합 객체를 형성해야한다는 것을 의미합니다.  전자는 객체 지향 설계에서 잘 알려진 다양한  문제를 일으 킵니다.</p>\n<ul>\n<li><strong>단단한 결합 문제</strong> <sup>The</sup> <sup>tight</sup> <sup>coupling</sup> <sup>problem</sup> :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.</li>\n<li><strong>깨지기 쉬운 기초 클래스 문제</strong><sup>The</sup> <sup>fragile</sup> <sup>base</sup> <sup>class</sup> <sup>problem</sup>  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.</li>\n<li><strong>경직된 계층 구조 문제</strong><sup>The</sup> <sup>inflexible</sup> <sup>hierarchy</sup> <sup>problem</sup> :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.</li>\n<li><strong>중복 필요성 문제</strong><sup>The</sup> <sup>duplication</sup> <sup>by</sup> <sup>necessity</sup> <sup>problem</sup> : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.</li>\n<li><strong>고릴라 / 바나나 문제</strong><sup>The</sup> <sup>gorilla/banana</sup> <sup>problem</sup> :  &quot;… 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. &quot;~ Joe Armstrong,  <a href=\"http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN\" target=\"_blank\" rel=\"noopener\">&quot;Coders at Work &quot;</a></li>\n</ul>\n<p>JavaScript에서 객체 합성의 가장 일반적인 형태는  <strong>객체 연결</strong>  (mixin composition이라고도 함)이라고합니다.  마치 아이스크림처럼 작동합니다. 먼저 바닐라 아이스크림과 같은 객체로 시작한 다음 원하는 기능을 믹스합니다.  견과류, 캐러멜, 초콜릿 소용돌이를 추가하면 너트 카라멜 초콜릿 소용돌이 아이스크림이 됩니다.</p>\n<p>클래스 상속을 사용하여 복합 객체 만들기 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = <span class=\"string\">'a'</span>  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Foo</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (options) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">super</span>(options);  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = <span class=\"string\">'b'</span>  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myBar = <span class=\"keyword\">new</span> Bar(); <span class=\"comment\">// &#123;a: 'a', b: 'b'&#125;</span></span><br></pre></td></tr></table></figure>\n<p>믹스 인 성분으로 복합 객체 만들기 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;  </span><br><span class=\"line\">  a: <span class=\"string\">'a'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;  </span><br><span class=\"line\">  b: <span class=\"string\">'b'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> c = &#123;...a, ...b&#125;; <span class=\"comment\">// &#123;a: 'a', b: 'b'&#125;</span></span><br></pre></td></tr></table></figure>\n<p>앞으로 객체를 합성하는 다양한 방법에 대해 알아볼 것입니다.  지금까지의 논의를 정리하자면 다음과 같습니다.</p>\n<ol>\n<li>어떤 것을 수행하는 데는 한 가지 이상의 방법이 있습니다.</li>\n<li>어떤 방법은 다른 방법보다 낫습니다.</li>\n<li>당장의 작업을 위해 가장 단순하고 유연한 솔루션을 선택하려고 합니다.</li>\n</ol>\n<h2>결론</h2>\n<p>이 글은 FP (Functional Programming)와 OOP (Object-Oriented Programming) 또는 프로그래밍 언어에 대한 글이 아닙니다.  소프트웨어를 합성하기 위한 컴포넌트는 함수, 자료 구조, 클래스 등의 형태를 취할 수 있습니다. 프로그래밍 언어마다 컴포넌트에 대해 서로 다른 접근방식을 취합니다. 자바는 클래스를 제공하고, 하스켈은 함수를 제공합니다. 그러나 어떤 언어, 어떤 패러다임을 선호하든 관계없이 함수와 자료구조를 합성할 수 밖에 없습니다.  결국, 모두 뒤죽박죽이 될지라도 말이지요.</p>\n<p>우리는 지금까지 대부분의 논의를 함수형 프로그래밍에 관하여 했습니다.  그 이유는 함수야 말로 JavaScript에서 가장 합성을 하기 쉬운 요소이고, 함수 프로그래밍 커뮤니티가 함수 합성 테크닉을 공식화하는 데 많은 시간과 노력을 투자했기 때문입니다.</p>\n<p>이 글은 함수형 프로그래밍이 객체 지향 프로그래밍보다 낫다는 논의를 하려는게 아닙니다. 만약 그렇다면 두 패러다임중 하나를 선택하라 할테지요.  OOP 대 FP는 잘못된 이분법입니다.  최근 몇 년 동안 본 모든 Javascript 애플리케이션은 FP와 OOP를 광범위하게 혼합합니다.</p>\n<p>객체를 합성하여 FP에서 사용될 자료구조를 만들고 함수형 프로그래밍으로 OOP에서 객체를 만들어볼 것 입니다.</p>\n<p><em>소프트웨어를 작성하는 방법에 상관없이 훌륭한 합성을 해야합니다</em></p>\n<blockquote>\n<p>소프트웨어 개발의 핵심은 합성입니다.</p>\n</blockquote>\n<p>합성을 이해하지 못하는 소프트웨어 개발자는 볼트나 못에 대해 모르는 주택 건설업자와 같습니다.  어떻게 합성될지 신경쓰지 않고 소프트웨어를 제작하는 것은 집을 건설할 때 덕트 테이프와 순간 접착제로 벽을 붙이는 것과 같습니다.</p>\n<p>이제는 단순하게 생각할 때입니다. 어떤 것을 단순화하는 가장 좋은 방법은 본질에 도달하는 것입니다.  문제는, 소프트웨어 산업에 있는 대부분의 사람들이 본질에 대해 무관심하다는 것입니다.  우리 업계는 소프트웨어 개발자인 당신을 제대로 가르치지 못했습니다.  업계는 개발자를 더 잘 훈련시켜야할 책임이 있습니다. 우리는 이를 고쳐야 합니다.  우리가 책임을 져야합니다.  경제에서 의료 장비에 이르기까지 모든 것에서 소프트웨어가 실행됩니다.  이 행성의 모든 인간의 삶은 소프트웨어 품질에 영향을받고 있습니다.  우리가 뭘 하고있는지 알아야합니다.</p>\n<p>지금부터 소프트웨어 합성 방법을 배우면 됩니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/\">다음: 함수형 프로그래밍 패러다임의 역사&gt;</a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>한국에서는 보통 ~와 ~를 합성한다고 하거나 ~에 ~ 처럼생략합니다  <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>개발자가 코드를 작성하고 다른 개발자가 이를 이해한다는 것을 라디오의 방송국과 청취자들의 관계에 비유했 습니다. 이 때 신호란 전달되어야하는 의미이고 잡음이란 공간만 차지하는 코드입니다. 즉 더 적은 코드로 같은 의미를 전달하는 것이 좋다는 말이 됩니다. <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n"},{"title":"함수형 믹스인","catalog":true,"date":"2018-04-07T17:10:13.000Z","subtitle":"functional-mixins","header-img":"bg.jpg","readingTime":12,"catagories":["개발"],"preview":"함수형 믹스인은 합성될 수 있는 팩토리함수입니다. 파이프라이닝되어 객체를 찍어내는 공장입니다. 각 함수는 조립 라인의 인력처럼 객체의 속성 또는 동작을 추가합니다. 함수형 믹스인은 기본 팩토리 또는 생성자가 필요하지 않습니다. 임의의 객체를 믹스인으로 전달하기만 하면 해당 객체의 향상된 버전이 반환됩니다. 실제로 현대의 모든 소프트웨어 개발은 합성으로 이루어집니다. 우리는 크고 복잡한 문제를 작고 단순한 문제로 분해 한 다음 솔루션을 조합하여 애플리케이션을 구성합니다.","_content":"\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/functional-mixins-composing-software-ffb66d5e731c)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/07/functors-and-categories/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/)\n\n**함수형 믹스인**은 합성될 수 있는 팩토리함수입니다. 파이프라이닝되어 객체를 찍어내는 공장입니다. 각 함수는 조립 라인의 인력처럼 객체의 속성 또는 동작을 추가합니다. 함수형 믹스인은 기본 팩토리 또는 생성자가 필요하지 않습니다. 임의의 객체를 믹스인으로 전달하기만 하면 해당 객체의 향상된 버전이 반환됩니다.\n\n함수형 믹스인의 특징 :\n\n-   데이터 보안/캡슐화\n-   private 상태를 상속\n-   여러 소스에서 상속\n-   다이아몬드 문제(namespace충돌) 없음 - 마지막으로 상속된 것이 이김\n-   베이스 클래스가 필요하지 않음\n\n## 동기부여\n\n실제로 현대의 모든 소프트웨어 개발은 합성으로 이루어집니다. 우리는 크고 복잡한 문제를 작고 단순한 문제로 분해 한 다음 솔루션을 조합하여 애플리케이션을 구성합니다.\n\n합성의 재료로 쓰이는 원자 단위는 다음과 같습니다.\n\n-   함수\n-   데이터 구조\n\n애플리케이션의 구조는 이러한 원자들이 조합되는 방식으로 정의됩니다. 많은 곳에서 클래스 상속을 사용하여 복합 객체를 만듭니다. 클래스는 상위 클래스의 기능들 대부분을 상속하고 이를 확장^extend^ 또는 오버라이딩합니다.  이 접근 방식은 **\"~는 ~이다(is-a) \"** 라는 사고를 강요한다는 문제가 있습니다. 예를 들어 \"관리자는 직원\" 같은 방식으로 관계를 정의하며 이런 접근방식에서 많은 디자인 문제가 발생합니다.\n\n-   **단단한 결합 문제** ^The^ ^tight^ ^coupling^ ^problem^ :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.\n-   **깨지기 쉬운 기초 클래스 문제**^The^ ^fragile^ ^base^ ^class^ ^problem^  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.\n-   **경직된 계층 구조 문제**^The^ ^inflexible^ ^hierarchy^ ^problem^ :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.\n-   **중복 필요성 문제**^The^ ^duplication^ ^by^ ^necessity^ ^problem^ : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.\n-   **고릴라 / 바나나 문제**^The^ ^gorilla/banana^ ^problem^ :  \"... 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. \"~ Joe Armstrong,  [\"Coders at Work \"](http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN)\n\n관리자가 직원이라고 정의했을 때 일시적으로 관리 업무를 수행하기 위해 외부 컨설턴트를 고용하는 상황을 어떻게 처리합니까?  모든 요구사항을 미리 알고 있다면 클래스 상속이 가능할 수도 있지만 그건 불가능합니다. 애플리케이션이 충분히 사용되다 보면 새로운 문제와 보다 효율적인 프로세스가 발견되고 애플리케이션의 기능과 요구 사항은 필연적으로 증가하고 발전합니다.\n\n이런 상황에서 믹스인은 보다 유연한 접근 방식을 제공합니다.\n\n## 믹스인이란 무엇입니까?\n\n> \"클래스 상속보다는 객체 합성을 우선해라\", Gang of Four,  [\"디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소\"](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&qid=1494993475&sr=8-1&keywords=design+patterns&linkCode=ll1&tag=eejs-20&linkId=6c553f16325f3939e5abadd4ee04e8b4)\n\n**믹스인**은  **객체 합성**의 한 종류로, 구성 요소의 속성들이 혼합되어 복합 객체의 속성들을 구성합니다.\n\nOOP에서 \"믹스인\"이란 용어는 믹스인 아이스크림 가게에서 등장합니다. 미리 만들어진 많은 양의 아이스크림들이 있는 대신 바닐라 아이스크림과 각 고객별로 맞춤식 맛을 내기 위해 혼합될 수 있는 여러가지 재료가 있습니다.\n\n오브젝트 믹스인도 비슷합니다. 빈 오브젝트로 시작해 기능을 믹스하고 확장합니다.  JavaScript는 클래스가 없이 객체를 생성하고 동적 객체 확장을 지원하기 때문에 오브젝트 믹스인을 쉽게 사용할 수 있습니다. JavaScript에서 가장 일반적인 상속 방법인 만큼 다른 것들과 큰 차이가 있습니다.  예제를 살펴 보겠습니다.\n\n```javascript\nconst chocolate = {  \n  hasChocolate: () => true  \n};\n\nconst caramelSwirl = {  \n  hasCaramelSwirl: () => true  \n};\n\nconst pecans = {  \n  hasPecans: () => true  \n};\n\nconst iceCream = Object.assign({}, chocolate, caramelSwirl, pecans);\n\n/*  \n// or, if your environment supports object spread...  \nconst iceCream = {...chocolate, ...caramelSwirl, ...pecans};  \n*/\n\nconsole.log(`  \n  hasChocolate: ${ iceCream.hasChocolate() }  \n  hasCaramelSwirl: ${ iceCream.hasCaramelSwirl() }  \n  hasPecans: ${ iceCream.hasPecans() }  \n`);\n```\n\n이는 다음과 같은 로그를 남깁니다 :\n\n```javascript\nhasChocolate: true\nhasCaramelSwirl: true\nhasPecans: true\n```\n\n## 함수형 상속이란 무엇입니까?\n\n함수형 상속은 오브젝트 인스턴스에 함수를 적용하여 기능을 상속하는 프로세스입니다.  이 함수는 클로저를 사용해 일부 데이터를 비공개로 유지하며 동적으로 오브젝트를 확장해 새로운 속성 및 메소드를 가진 인스턴스를 만듭니다.\n\nDouglas Crockford가 작성한 코드를 보자.\n\n```javascript\n// Base object factory  \nfunction base(spec) {  \n    var that = {}; // Create an empty object  \n    that.name = spec.name; // Add it a \"name\" property  \n    return that; // Return the object  \n}\n\n// Construct a child object, inheriting from \"base\"  \nfunction child(spec) {  \n    // Create the object through the \"base\" constructor  \n    var that = base(spec);   \n    that.sayHello = function() { // Augment that object  \n        return 'Hello, I\\'m ' + that.name;  \n    };  \n    return that; // Return it  \n}\n\n// Usage  \nvar result = child({ name: 'a functional object' });  \nconsole.log(result.sayHello()); // \"Hello, I'm a functional object\"\n```\n\n그러나 `child()`가  `base()`에  단단하게 결합되어 있으므로 `grandchild()`,  `greatGrandchild()`등을 추가하려고 할 때면 클래스 상속의 일반적인 문제를 다시 마주치게 됩니다.\n\n## 함수형 믹스인이란 무엇입니까?\n\n함수형 믹스인은 새로운 속성이나 동작을 주어진 개체의 속성과 혼합하는 **합성가능한 함수**입니다.  함수형 믹스인은 기본 팩토리 또는 생성자가 필요하지 않고 이들에 의존하지도 않습니다. 확장을 하기 위해서 임의의 객체를 믹스인으로 전달하기만 하면 됩니다.\n\n예제를 살펴 보겠습니다.\n\n```javascript\nconst flying = o => {  \n  let isFlying = false;\n\n  return Object.assign({}, o, {  \n    fly () {  \n      isFlying = true;  \n      return this;  \n    },\n\n    isFlying: () => isFlying,\n\n    land () {  \n      isFlying = false;  \n      return this;  \n    }  \n  });  \n};\n\nconst bird = flying({});  \nconsole.log( bird.isFlying() ); // false  \nconsole.log( bird.fly().isFlying() ); // true\n```\n\n`flying()`을 호출 할 때, 객체를 전달해야 합니다.  함수형 믹스인은 **합성 함수**를 사용하도록 설계되었습니다.  더 많은 예제를 알아보겠습니다.\n\n```javascript\nconst quacking = quack => o => Object.assign({}, o, {  \n  quack: () => quack  \n});\n\nconst quacker = quacking('Quack!')({});  \nconsole.log( quacker.quack() ); // 'Quack!'\n```\n## 함수형 믹스인을 합성하기\n\n함수형 믹스인은 함수 합성으로 간단하게 구현 할 수 있습니다.\n```javascript\nconst createDuck = quack => quacking(quack)(flying({}));\n\nconst duck = createDuck('Quack!');\n\nconsole.log(duck.fly().quack());\n```\n조금 어색해 보입니다.  또한 디버깅하거나 합성 순서를 바꾸는 것이 약간 까다로울 수 있습니다.\n\n물론 이것은 기초적인 함수 합성이며  `compose()` 또는 `pipe()`를 사용하는 더 나은 방법을 이미 알고 있습니다.  `pipe()`를 사용하면 순서가 거꾸로 바뀌고 컴포지션은 동일한 우선 순위를 유지하면서  `Object.assign({}, ...)` 또는  `{...object, ...spread}` 처럼 읽을 수 있게 됩니다. 이름이 충돌하는 경우, 마지막으로 합성된 객체, 속성, 메소드가 승리합니다.\n\n```javascript\nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\n// OR...\n// import pipe from `lodash/fp/flow`;\n\nconst createDuck = quack => pipe(\n  flying,\n  quacking(quack)\n)({});\n\nconst duck = createDuck('Quack!');\n\nconsole.log(duck.fly().quack());\n```\n\n## 함수형 믹스인을 사용해야 하는 경우\n\n항상 문제를 해결하기 위한 가장 단순한 추상화를 사용해야합니다. 처음에는 **순수 함수**로 시작하십시오.  상태가 존재하는 객체가 필요하면 **팩토리 함수**를 사용해보십시오. 보다 복잡한 객체를 작성해야 할 경우 **함수형 믹스인**을 사용하십시오.\n\n다음은 함수형 믹스인을 사용한 좋은 예들 입니다.\n\n-   애플리케이션 상태 관리 (예 : Redux 저장소).\n-   centralized logger와 같은 특정 문제 및 서비스.\n-   합성 가능한 함수형 자료구조 (예 : JavaScript의  `Array`를 사용해서 `Semigroup`  ,  `Functor`  ,  `Foldable`을 구현할 수 있습니다.  일부 대수 구조^algebraic^ ^structure^는 다른 대수 구조에서 파생 될 수 있습니다. 즉,  커스터마이징하지 않고도 특정 근원에서 새로운 데이터 유형으로 합성 될 수 있음을 의미합니다.\n\n**React 사용자 :**   `class`를 사용해도 괜찮습니다. 그 이유는 프레임워크 디자인 차원에서 caller가 `new`를 사용하지 않도록 되어있고 React가 기본적으로 제공하는 base 컴포넌트 외에 다른 컴포넌트를 상속하지 않도록  문서화된 모범 사례^best-practice^들을 제공하기 때문입니다.\n\n저는 React의 UI 컴포넌트를 구성할 때 함수 합성을 사용하여 HOC (Higher Order Components)를 사용할 것을 권장합니다.\n\n## 주의 사항\n\n대부분의 문제는 순수 함수를 사용하여 우아하게 해결할 수 있습니다. 그러나 함수형 믹스인의 경우에는 아닙니다.  클래스 상속과 마찬가지로 함수형 믹스인은 자체적으로 문제를 일으킬 수 있습니다.  실제로 함수형 믹스인을 사용하여 클래스 상속의 모든 기능과 문제점을 충실히 재현 할 수 있습니다.\n\n이를 피하기 위해 다음 조언을 따르면 됩니다:\n\n-   가장 간단한 구현방법을 택하세요. 왼쪽에서 시작해 필요에 따라 오른쪽으로 이동하십시오 : 순수 함수 > 팩토리 > 함수형 믹스인 > 클래스.\n-   객체, 믹스인 또는 데이터 유형간  **is-a**  관계가 생성되는걸 피하십시오.\n-   믹스인사이의 암묵적인 의존성을 제거하십시오 — 가능하다면 함수형 믹스인은 자체로 만족적이어야 하고 다른 믹스인에 대한 참조가 없어야 합니다.\n-   \"함수형 믹스인\"은 \"함수형 프로그래밍\"을 의미하지 않습니다.\n-   `Object.assign()` 또는 객체 스프레드 구문 (  `{...}` )을 사용하여 속성에 액세스 할 때 부수효과가 발생할 수 있습니다.  또한 열거되지 않는 속성은 건너 뛴다는 것을 주의해야 합니다..  ES2017은 이 문제를 해결하기 위해  [`Object.getOwnPropertyDescriptors()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors)를 추가했습니다.\n\n자신의 사이드 프로젝트가 아닌 큰 프로젝트에서 함수형 믹스인을 사용하려고 한다면,  [stamps](https://github.com/stampit-org/stamp-specification)를 참고하십시오. Stamp Specification은 속성 설명자, 프로토 타입 위임 등을 다루며 표준 JS 기능들을 사용하여 합성 가능한 팩토리 함수를 공유하고 재사용하는 표준입니다.\n\n필자는 주로 애플리케이션의 구조 및 동작을 구성하기 위해 함수 합성을 사용하는데 이 때 함수형 믹스인이나 _stamp_ 는 거의 필요하지 않습니다.  그리고 클래스 상속은 절대 사용하지 않는데 한가지 예외가 있다면 `React.Class`같은 서드파티의 기본 클래스를 최소한의 루트로 상속해서 사용하는 것 입니다. 저는 절대로 직접 상속 계층 구조를 만들지 않습니다.\n\n## 클래스\n\n클래스 상속이 JavaScript에서 괜찮은 접근법인 경우는 거의(아마 절대로) 없습니다. 그러나 본인이 직접 구현하지 않은 라이브러리나 프레임 워크에서 `class`를 사용하는 경우는 많이 있습니다.  이 경우  `class`를 실용적으로 사용할 수 있습니다. 다만 다음과 같은 특징을 가진 라이브러리에서 제공되는 `class`로 제한됩니다:\n\n1.  직접 클래스를 확장 할 필요가 없어야 합니다(즉, 다중 레벨의 클래스 상속 구조를 만들 필요가 없습니다).\n2.  `new`  키워드를 직접 사용할 필요가 없습니다. 즉, 프레임 워크가 인스턴스화를 처리합니다.\n\nAngular 2+와 React 모두 이러한 요구 사항을 충족하므로 클래스를 확장하지 않는 한 클래스를 안전하게 사용할 수 있습니다.  React는 여러분이 원하지 않는 경우 클래스를 사용하지 않아도 됩니다(선택사항입니다). 그러나 React의 기본 클래스에 내장 된 최적화 기능을 사용하지 못하고 여러분의 컴포넌트가 예제 문서에 나오는 컴포넌트처럼 보이지 않을 수 있습니다. 어쨌든 React 컴포넌트도 마찬가지로 가능하다면 순수 함수 형식을 항상 선호해야합니다.\n\n### 클래스와 퍼포먼스\n\n일부 브라우저의 JavaScript 엔진에서는 클래스에 특화된 최적화를 제공합니다. 대부분의 경우 이러한 최적화는 앱의 성능에 큰 영향을 미치지 않습니다.  실제로,  `class`  성능 차이에 대해 걱정할 필요없이 오랜 기간동안 프로젝트를 진행할 수 있습니다.  객체를 생성하고 속성에 접근하는 것은 객체를 만드는 방법에 관계없이 항상 매우 빠릅니다(초당 수백만번의 연산이 가능).\n\n그러나, RxJS, Lodash 등과 같은 범용 유틸리티 라이브러리를 만들 때는  `class`  를 사용하여 객체 인스턴스를 만들었을 때 얻을 수 있는 성능상의 이점을 조사해야합니다.  `class` 사용해서 해결할 수 있는 성능상의 병목현상이 없다면 (그리고 그 것을 증명할 수 있는게 아니라면)  성능에 대해 걱정하기 보다는 깨끗하고 유연한 코드 작성하는 방식으로 최적화해야합니다.\n\n## 암시적인 종속성\n\n당신은 함수형 믹스인으로 여러 기능들을 욱여넣고 싶은 유혹을 느낍니다.  당신이 설정 관리자^configuration^ ^manager^를 만들려고 합니다. 이 관리자는 존재하지 않는 설정 속성에 액세스하려고 할 때 경고 로그를 띄웁니다.\n\n다음과 같이 빌드 할 수 있습니다.\n\n```javascript\n// in its own module...  \nconst withLogging = logger => o => Object.assign({}, o, {  \n  log (text) {  \n    logger(text)  \n  }  \n});  \n  \n\n// in a different module with no explicit mention of  \n// withLogging -- we just assume it's there...  \nconst withConfig = config => (o = {  \n  log: (text = '') => console.log(text)  \n}) => Object.assign({}, o, {  \n  get (key) {  \n    return config[key] == undefined ?\n\n      // vvv implicit dependency here... oops! vvv  \n      this.log(`Missing config key: ${ key }`) :  \n      // ^^^ implicit dependency here... oops! ^^^\n\n      config[key]  \n    ;  \n  }  \n});\n\n// in yet another module that imports withLogging and  \n// withConfig...  \nconst createConfig = ({ initialConfig, logger }) =>  \n  pipe(  \n    withLogging(logger),  \n    withConfig(initialConfig)  \n  )({})  \n;\n\n// elsewhere...  \nconst initialConfig = {  \n  host: 'localhost'  \n};\n\nconst logger = console.log.bind(console);\n\nconst config = createConfig({initialConfig, logger});\n\nconsole.log(config.get('host')); // 'localhost'  \nconfig.get('notThere'); // 'Missing config key: notThere'\n```\n\n그러나 다음과 같이 빌드 할 수도 있습니다.\n\n```javascript\n// import withLogging() explicitly in withConfig module  \nimport withLogging from './with-logging';\n\nconst addConfig = config => o => Object.assign({}, o, {  \n  get (key) {  \n    return config[key] == undefined ?   \n      this.log(`Missing config key: ${ key }`) :  \n      config[key]  \n    ;  \n  }  \n});\n\nconst withConfig = ({ initialConfig, logger }) => o =>  \n  pipe(\n\n    // vvv compose explicit dependency in here vvv  \n    withLogging(logger),  \n    // ^^^ compose explicit dependency in here ^^^\n\n    addConfig(initialConfig)  \n  )(o)  \n;\n\n// The factory only needs to know about withConfig now...  \nconst createConfig = ({ initialConfig, logger }) =>  \n  withConfig({ initialConfig, logger })({})  \n;  \n  \n\n// elsewhere, in a different module...  \nconst initialConfig = {  \n  host: 'localhost'  \n};\n\nconst logger = console.log.bind(console);\n\nconst config = createConfig({initialConfig, logger});\n\nconsole.log(config.get('host')); // 'localhost'  \nconfig.get('notThere'); // 'Missing config key: notThere'\n```\n\n우리는 다양한 요소들을 고려해서 올바른 디자인을 선택해야 합니다.  함수형 믹스인을 사용하기 위해 래핑된 데이터 유형을 요구하는 것은 타당하지만, 그렇다면 이를 함수 서명 및 API 문서에 명시해야합니다.\n\n그렇기에 암시적인 버전의 함수 서명에는  `o`  에 대한 기본값이 존재해야합니다. JavaScript에는 타입 주석 기능이 없기 때문에 기본값을 제공하여 모방할 수 있습니다.\n```javascript\n const withConfig = config => (o = {   \n log: (text = '') => console.log(text)   \n }) => Object.assign({}, o, {   \n // ...\n```\nTypeScript 또는 Flow를 사용하는 경우 명시적으로 인터페이스를 선언해 객체 요구 사항으로 사용하는 것이 좋습니다.\n\n## 함수형 믹스인 및 함수형 프로그래밍\n\n함수형 믹스인에서 \"함수형\"은 \"함수형 프로그래밍\"과 같은 뜻을 지니지 않습니다.  함수형 믹스인은 일반적으로 부수작용들이 있는 OOP 스타일로 사용됩니다.  이는 인자로 전달받은 객체를 변경합니다. 주의하십시오.\n\n마찬가지로 함수형 프로그래밍 스타일을 선호는 일부 개발자들은 전달받은 객체의 주소를 계속 가지고 있지 않습니다.  여러분은 두 스타일을 적절히 혼합하여 사용하는 방식으로 코딩해야합니다.\n\n즉, 객체 인스턴스를 리턴해야하는 경우 클로저에 있는 인스턴스 대신 항상 `this`를 리턴하십시오.  이 말은 즉, 그 둘이 동일한 객체가 아닐 가능성이 있다는 것 입니다.  또한  `Object.assign()` 나  `{...object, ...spread}`  구문을 사용해서 인스턴스를 복사, 할당한다고 가정할 경우 열거되지 않는 속성이 있으면 최종 객체에서 작동하지 않을 것입니다.\n```javascript\nconst a = Object.defineProperty({}, 'a', {  \n  enumerable: false,  \n  value: 'a'  \n});\n\nconst b = {  \n  b: 'b'  \n};\n\nconsole.log({...a, ...b}); // { b: 'b' }\n```\n마지막으로, 함수형 코드에서 작성하지 않은 함수 믹스인을 사용하는 경우 코드가 순수하다고 가정하지 마십시오. 기본 객체가 변형 될 수 있고 부수작용이 있으며 참조 투명성이 확보되지 않는다고 가정해야 합니다. 즉, 함수형 믹스인으로 구성된 팩토리는 메모이제이션하기 힘듭니다.\n\n## 결론\n\n함수형 믹스인는 조립 라인의 스테이션처럼 객체에 속성 및 동작을 추가하는 합성 가능한 팩토리 함수입니다.  고전적인 클래스(  **is-a**  )처럼 모든 기능을 상속하는 것과는 대조적으로 여러 관계(  **has-a, uses-a, can-do**  )와 기능으로 동작을 정의하는 좋은 방법입니다.\n\n\"함수형 믹스인\"은 \"함수형 프로그래밍\"을 의미하는 것이 아니라 단순히 \"함수에 기초한 믹스인\"을 의미합니다.  함수형 믹스인은 함수형 프로그래밍 스타일을 사용하여 부수효과를 없애고 참조 투명성을 유지하면서 작성 될 수 있지만 보장되지는 않습니다.  서드파티의 믹스인에는 부수작용과 비결정적인 위험 요소들이 있을 수 있습니다.\n\n-   단순한 오브젝트 믹스인와 달리 함수형 믹스인는 비공개 데이터를 상속하는 등 실제 데이터 프라이버시 (캡슐화)를 지원합니다.\n-   단일 조상 클래스 상속과는 달리, 함수형 믹스인은 클래스 데코레이터, 특성^trait^ 또는 다중 상속과 마찬가지로 다양한 조상으로부터 기능을 상속받는데 적합합니다.\n-   C ++의 다중 상속과는 달리, JavaScript에서는 다이아몬드 문제가 거의 발생하지 않습니다. 충돌이 발생할 때 간단한 규칙이 있기 때문입니다. 마지막으로 추가 된 믹스인이 승리합니다.\n-   클래스 데코레이터, 특성 또는 다중 상속과 달리 기본 클래스를 필요로 하지 않습니다.\n\n가장 간단한 구현으로 시작하여 필요한 경우에만보다 복잡한 구현으로 이동하십시오.\n\n >**함수 > 객체 > 팩토리 함수 > 함수형 믹스인 > 클래스**\n> Functions > objects > factory functions > functional mixins > classe\n\n[**다음: ES6+와 팩토리 함수 >**](https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/)","source":"_posts/functional-mixins.md","raw":"---\ntitle: 함수형 믹스인\ncatalog: true\ndate: 2018-04-08 02:10:13\nsubtitle: functional-mixins\nheader-img: \"bg.jpg\"\nreadingTime: 12\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 함수형 믹스인은 합성될 수 있는 팩토리함수입니다. 파이프라이닝되어 객체를 찍어내는 공장입니다. 각 함수는 조립 라인의 인력처럼 객체의 속성 또는 동작을 추가합니다. 함수형 믹스인은 기본 팩토리 또는 생성자가 필요하지 않습니다. 임의의 객체를 믹스인으로 전달하기만 하면 해당 객체의 향상된 버전이 반환됩니다. 실제로 현대의 모든 소프트웨어 개발은 합성으로 이루어집니다. 우리는 크고 복잡한 문제를 작고 단순한 문제로 분해 한 다음 솔루션을 조합하여 애플리케이션을 구성합니다.\n---\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/functional-mixins-composing-software-ffb66d5e731c)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/07/functors-and-categories/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/)\n\n**함수형 믹스인**은 합성될 수 있는 팩토리함수입니다. 파이프라이닝되어 객체를 찍어내는 공장입니다. 각 함수는 조립 라인의 인력처럼 객체의 속성 또는 동작을 추가합니다. 함수형 믹스인은 기본 팩토리 또는 생성자가 필요하지 않습니다. 임의의 객체를 믹스인으로 전달하기만 하면 해당 객체의 향상된 버전이 반환됩니다.\n\n함수형 믹스인의 특징 :\n\n-   데이터 보안/캡슐화\n-   private 상태를 상속\n-   여러 소스에서 상속\n-   다이아몬드 문제(namespace충돌) 없음 - 마지막으로 상속된 것이 이김\n-   베이스 클래스가 필요하지 않음\n\n## 동기부여\n\n실제로 현대의 모든 소프트웨어 개발은 합성으로 이루어집니다. 우리는 크고 복잡한 문제를 작고 단순한 문제로 분해 한 다음 솔루션을 조합하여 애플리케이션을 구성합니다.\n\n합성의 재료로 쓰이는 원자 단위는 다음과 같습니다.\n\n-   함수\n-   데이터 구조\n\n애플리케이션의 구조는 이러한 원자들이 조합되는 방식으로 정의됩니다. 많은 곳에서 클래스 상속을 사용하여 복합 객체를 만듭니다. 클래스는 상위 클래스의 기능들 대부분을 상속하고 이를 확장^extend^ 또는 오버라이딩합니다.  이 접근 방식은 **\"~는 ~이다(is-a) \"** 라는 사고를 강요한다는 문제가 있습니다. 예를 들어 \"관리자는 직원\" 같은 방식으로 관계를 정의하며 이런 접근방식에서 많은 디자인 문제가 발생합니다.\n\n-   **단단한 결합 문제** ^The^ ^tight^ ^coupling^ ^problem^ :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.\n-   **깨지기 쉬운 기초 클래스 문제**^The^ ^fragile^ ^base^ ^class^ ^problem^  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.\n-   **경직된 계층 구조 문제**^The^ ^inflexible^ ^hierarchy^ ^problem^ :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.\n-   **중복 필요성 문제**^The^ ^duplication^ ^by^ ^necessity^ ^problem^ : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.\n-   **고릴라 / 바나나 문제**^The^ ^gorilla/banana^ ^problem^ :  \"... 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. \"~ Joe Armstrong,  [\"Coders at Work \"](http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN)\n\n관리자가 직원이라고 정의했을 때 일시적으로 관리 업무를 수행하기 위해 외부 컨설턴트를 고용하는 상황을 어떻게 처리합니까?  모든 요구사항을 미리 알고 있다면 클래스 상속이 가능할 수도 있지만 그건 불가능합니다. 애플리케이션이 충분히 사용되다 보면 새로운 문제와 보다 효율적인 프로세스가 발견되고 애플리케이션의 기능과 요구 사항은 필연적으로 증가하고 발전합니다.\n\n이런 상황에서 믹스인은 보다 유연한 접근 방식을 제공합니다.\n\n## 믹스인이란 무엇입니까?\n\n> \"클래스 상속보다는 객체 합성을 우선해라\", Gang of Four,  [\"디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소\"](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&qid=1494993475&sr=8-1&keywords=design+patterns&linkCode=ll1&tag=eejs-20&linkId=6c553f16325f3939e5abadd4ee04e8b4)\n\n**믹스인**은  **객체 합성**의 한 종류로, 구성 요소의 속성들이 혼합되어 복합 객체의 속성들을 구성합니다.\n\nOOP에서 \"믹스인\"이란 용어는 믹스인 아이스크림 가게에서 등장합니다. 미리 만들어진 많은 양의 아이스크림들이 있는 대신 바닐라 아이스크림과 각 고객별로 맞춤식 맛을 내기 위해 혼합될 수 있는 여러가지 재료가 있습니다.\n\n오브젝트 믹스인도 비슷합니다. 빈 오브젝트로 시작해 기능을 믹스하고 확장합니다.  JavaScript는 클래스가 없이 객체를 생성하고 동적 객체 확장을 지원하기 때문에 오브젝트 믹스인을 쉽게 사용할 수 있습니다. JavaScript에서 가장 일반적인 상속 방법인 만큼 다른 것들과 큰 차이가 있습니다.  예제를 살펴 보겠습니다.\n\n```javascript\nconst chocolate = {  \n  hasChocolate: () => true  \n};\n\nconst caramelSwirl = {  \n  hasCaramelSwirl: () => true  \n};\n\nconst pecans = {  \n  hasPecans: () => true  \n};\n\nconst iceCream = Object.assign({}, chocolate, caramelSwirl, pecans);\n\n/*  \n// or, if your environment supports object spread...  \nconst iceCream = {...chocolate, ...caramelSwirl, ...pecans};  \n*/\n\nconsole.log(`  \n  hasChocolate: ${ iceCream.hasChocolate() }  \n  hasCaramelSwirl: ${ iceCream.hasCaramelSwirl() }  \n  hasPecans: ${ iceCream.hasPecans() }  \n`);\n```\n\n이는 다음과 같은 로그를 남깁니다 :\n\n```javascript\nhasChocolate: true\nhasCaramelSwirl: true\nhasPecans: true\n```\n\n## 함수형 상속이란 무엇입니까?\n\n함수형 상속은 오브젝트 인스턴스에 함수를 적용하여 기능을 상속하는 프로세스입니다.  이 함수는 클로저를 사용해 일부 데이터를 비공개로 유지하며 동적으로 오브젝트를 확장해 새로운 속성 및 메소드를 가진 인스턴스를 만듭니다.\n\nDouglas Crockford가 작성한 코드를 보자.\n\n```javascript\n// Base object factory  \nfunction base(spec) {  \n    var that = {}; // Create an empty object  \n    that.name = spec.name; // Add it a \"name\" property  \n    return that; // Return the object  \n}\n\n// Construct a child object, inheriting from \"base\"  \nfunction child(spec) {  \n    // Create the object through the \"base\" constructor  \n    var that = base(spec);   \n    that.sayHello = function() { // Augment that object  \n        return 'Hello, I\\'m ' + that.name;  \n    };  \n    return that; // Return it  \n}\n\n// Usage  \nvar result = child({ name: 'a functional object' });  \nconsole.log(result.sayHello()); // \"Hello, I'm a functional object\"\n```\n\n그러나 `child()`가  `base()`에  단단하게 결합되어 있으므로 `grandchild()`,  `greatGrandchild()`등을 추가하려고 할 때면 클래스 상속의 일반적인 문제를 다시 마주치게 됩니다.\n\n## 함수형 믹스인이란 무엇입니까?\n\n함수형 믹스인은 새로운 속성이나 동작을 주어진 개체의 속성과 혼합하는 **합성가능한 함수**입니다.  함수형 믹스인은 기본 팩토리 또는 생성자가 필요하지 않고 이들에 의존하지도 않습니다. 확장을 하기 위해서 임의의 객체를 믹스인으로 전달하기만 하면 됩니다.\n\n예제를 살펴 보겠습니다.\n\n```javascript\nconst flying = o => {  \n  let isFlying = false;\n\n  return Object.assign({}, o, {  \n    fly () {  \n      isFlying = true;  \n      return this;  \n    },\n\n    isFlying: () => isFlying,\n\n    land () {  \n      isFlying = false;  \n      return this;  \n    }  \n  });  \n};\n\nconst bird = flying({});  \nconsole.log( bird.isFlying() ); // false  \nconsole.log( bird.fly().isFlying() ); // true\n```\n\n`flying()`을 호출 할 때, 객체를 전달해야 합니다.  함수형 믹스인은 **합성 함수**를 사용하도록 설계되었습니다.  더 많은 예제를 알아보겠습니다.\n\n```javascript\nconst quacking = quack => o => Object.assign({}, o, {  \n  quack: () => quack  \n});\n\nconst quacker = quacking('Quack!')({});  \nconsole.log( quacker.quack() ); // 'Quack!'\n```\n## 함수형 믹스인을 합성하기\n\n함수형 믹스인은 함수 합성으로 간단하게 구현 할 수 있습니다.\n```javascript\nconst createDuck = quack => quacking(quack)(flying({}));\n\nconst duck = createDuck('Quack!');\n\nconsole.log(duck.fly().quack());\n```\n조금 어색해 보입니다.  또한 디버깅하거나 합성 순서를 바꾸는 것이 약간 까다로울 수 있습니다.\n\n물론 이것은 기초적인 함수 합성이며  `compose()` 또는 `pipe()`를 사용하는 더 나은 방법을 이미 알고 있습니다.  `pipe()`를 사용하면 순서가 거꾸로 바뀌고 컴포지션은 동일한 우선 순위를 유지하면서  `Object.assign({}, ...)` 또는  `{...object, ...spread}` 처럼 읽을 수 있게 됩니다. 이름이 충돌하는 경우, 마지막으로 합성된 객체, 속성, 메소드가 승리합니다.\n\n```javascript\nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\n// OR...\n// import pipe from `lodash/fp/flow`;\n\nconst createDuck = quack => pipe(\n  flying,\n  quacking(quack)\n)({});\n\nconst duck = createDuck('Quack!');\n\nconsole.log(duck.fly().quack());\n```\n\n## 함수형 믹스인을 사용해야 하는 경우\n\n항상 문제를 해결하기 위한 가장 단순한 추상화를 사용해야합니다. 처음에는 **순수 함수**로 시작하십시오.  상태가 존재하는 객체가 필요하면 **팩토리 함수**를 사용해보십시오. 보다 복잡한 객체를 작성해야 할 경우 **함수형 믹스인**을 사용하십시오.\n\n다음은 함수형 믹스인을 사용한 좋은 예들 입니다.\n\n-   애플리케이션 상태 관리 (예 : Redux 저장소).\n-   centralized logger와 같은 특정 문제 및 서비스.\n-   합성 가능한 함수형 자료구조 (예 : JavaScript의  `Array`를 사용해서 `Semigroup`  ,  `Functor`  ,  `Foldable`을 구현할 수 있습니다.  일부 대수 구조^algebraic^ ^structure^는 다른 대수 구조에서 파생 될 수 있습니다. 즉,  커스터마이징하지 않고도 특정 근원에서 새로운 데이터 유형으로 합성 될 수 있음을 의미합니다.\n\n**React 사용자 :**   `class`를 사용해도 괜찮습니다. 그 이유는 프레임워크 디자인 차원에서 caller가 `new`를 사용하지 않도록 되어있고 React가 기본적으로 제공하는 base 컴포넌트 외에 다른 컴포넌트를 상속하지 않도록  문서화된 모범 사례^best-practice^들을 제공하기 때문입니다.\n\n저는 React의 UI 컴포넌트를 구성할 때 함수 합성을 사용하여 HOC (Higher Order Components)를 사용할 것을 권장합니다.\n\n## 주의 사항\n\n대부분의 문제는 순수 함수를 사용하여 우아하게 해결할 수 있습니다. 그러나 함수형 믹스인의 경우에는 아닙니다.  클래스 상속과 마찬가지로 함수형 믹스인은 자체적으로 문제를 일으킬 수 있습니다.  실제로 함수형 믹스인을 사용하여 클래스 상속의 모든 기능과 문제점을 충실히 재현 할 수 있습니다.\n\n이를 피하기 위해 다음 조언을 따르면 됩니다:\n\n-   가장 간단한 구현방법을 택하세요. 왼쪽에서 시작해 필요에 따라 오른쪽으로 이동하십시오 : 순수 함수 > 팩토리 > 함수형 믹스인 > 클래스.\n-   객체, 믹스인 또는 데이터 유형간  **is-a**  관계가 생성되는걸 피하십시오.\n-   믹스인사이의 암묵적인 의존성을 제거하십시오 — 가능하다면 함수형 믹스인은 자체로 만족적이어야 하고 다른 믹스인에 대한 참조가 없어야 합니다.\n-   \"함수형 믹스인\"은 \"함수형 프로그래밍\"을 의미하지 않습니다.\n-   `Object.assign()` 또는 객체 스프레드 구문 (  `{...}` )을 사용하여 속성에 액세스 할 때 부수효과가 발생할 수 있습니다.  또한 열거되지 않는 속성은 건너 뛴다는 것을 주의해야 합니다..  ES2017은 이 문제를 해결하기 위해  [`Object.getOwnPropertyDescriptors()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors)를 추가했습니다.\n\n자신의 사이드 프로젝트가 아닌 큰 프로젝트에서 함수형 믹스인을 사용하려고 한다면,  [stamps](https://github.com/stampit-org/stamp-specification)를 참고하십시오. Stamp Specification은 속성 설명자, 프로토 타입 위임 등을 다루며 표준 JS 기능들을 사용하여 합성 가능한 팩토리 함수를 공유하고 재사용하는 표준입니다.\n\n필자는 주로 애플리케이션의 구조 및 동작을 구성하기 위해 함수 합성을 사용하는데 이 때 함수형 믹스인이나 _stamp_ 는 거의 필요하지 않습니다.  그리고 클래스 상속은 절대 사용하지 않는데 한가지 예외가 있다면 `React.Class`같은 서드파티의 기본 클래스를 최소한의 루트로 상속해서 사용하는 것 입니다. 저는 절대로 직접 상속 계층 구조를 만들지 않습니다.\n\n## 클래스\n\n클래스 상속이 JavaScript에서 괜찮은 접근법인 경우는 거의(아마 절대로) 없습니다. 그러나 본인이 직접 구현하지 않은 라이브러리나 프레임 워크에서 `class`를 사용하는 경우는 많이 있습니다.  이 경우  `class`를 실용적으로 사용할 수 있습니다. 다만 다음과 같은 특징을 가진 라이브러리에서 제공되는 `class`로 제한됩니다:\n\n1.  직접 클래스를 확장 할 필요가 없어야 합니다(즉, 다중 레벨의 클래스 상속 구조를 만들 필요가 없습니다).\n2.  `new`  키워드를 직접 사용할 필요가 없습니다. 즉, 프레임 워크가 인스턴스화를 처리합니다.\n\nAngular 2+와 React 모두 이러한 요구 사항을 충족하므로 클래스를 확장하지 않는 한 클래스를 안전하게 사용할 수 있습니다.  React는 여러분이 원하지 않는 경우 클래스를 사용하지 않아도 됩니다(선택사항입니다). 그러나 React의 기본 클래스에 내장 된 최적화 기능을 사용하지 못하고 여러분의 컴포넌트가 예제 문서에 나오는 컴포넌트처럼 보이지 않을 수 있습니다. 어쨌든 React 컴포넌트도 마찬가지로 가능하다면 순수 함수 형식을 항상 선호해야합니다.\n\n### 클래스와 퍼포먼스\n\n일부 브라우저의 JavaScript 엔진에서는 클래스에 특화된 최적화를 제공합니다. 대부분의 경우 이러한 최적화는 앱의 성능에 큰 영향을 미치지 않습니다.  실제로,  `class`  성능 차이에 대해 걱정할 필요없이 오랜 기간동안 프로젝트를 진행할 수 있습니다.  객체를 생성하고 속성에 접근하는 것은 객체를 만드는 방법에 관계없이 항상 매우 빠릅니다(초당 수백만번의 연산이 가능).\n\n그러나, RxJS, Lodash 등과 같은 범용 유틸리티 라이브러리를 만들 때는  `class`  를 사용하여 객체 인스턴스를 만들었을 때 얻을 수 있는 성능상의 이점을 조사해야합니다.  `class` 사용해서 해결할 수 있는 성능상의 병목현상이 없다면 (그리고 그 것을 증명할 수 있는게 아니라면)  성능에 대해 걱정하기 보다는 깨끗하고 유연한 코드 작성하는 방식으로 최적화해야합니다.\n\n## 암시적인 종속성\n\n당신은 함수형 믹스인으로 여러 기능들을 욱여넣고 싶은 유혹을 느낍니다.  당신이 설정 관리자^configuration^ ^manager^를 만들려고 합니다. 이 관리자는 존재하지 않는 설정 속성에 액세스하려고 할 때 경고 로그를 띄웁니다.\n\n다음과 같이 빌드 할 수 있습니다.\n\n```javascript\n// in its own module...  \nconst withLogging = logger => o => Object.assign({}, o, {  \n  log (text) {  \n    logger(text)  \n  }  \n});  \n  \n\n// in a different module with no explicit mention of  \n// withLogging -- we just assume it's there...  \nconst withConfig = config => (o = {  \n  log: (text = '') => console.log(text)  \n}) => Object.assign({}, o, {  \n  get (key) {  \n    return config[key] == undefined ?\n\n      // vvv implicit dependency here... oops! vvv  \n      this.log(`Missing config key: ${ key }`) :  \n      // ^^^ implicit dependency here... oops! ^^^\n\n      config[key]  \n    ;  \n  }  \n});\n\n// in yet another module that imports withLogging and  \n// withConfig...  \nconst createConfig = ({ initialConfig, logger }) =>  \n  pipe(  \n    withLogging(logger),  \n    withConfig(initialConfig)  \n  )({})  \n;\n\n// elsewhere...  \nconst initialConfig = {  \n  host: 'localhost'  \n};\n\nconst logger = console.log.bind(console);\n\nconst config = createConfig({initialConfig, logger});\n\nconsole.log(config.get('host')); // 'localhost'  \nconfig.get('notThere'); // 'Missing config key: notThere'\n```\n\n그러나 다음과 같이 빌드 할 수도 있습니다.\n\n```javascript\n// import withLogging() explicitly in withConfig module  \nimport withLogging from './with-logging';\n\nconst addConfig = config => o => Object.assign({}, o, {  \n  get (key) {  \n    return config[key] == undefined ?   \n      this.log(`Missing config key: ${ key }`) :  \n      config[key]  \n    ;  \n  }  \n});\n\nconst withConfig = ({ initialConfig, logger }) => o =>  \n  pipe(\n\n    // vvv compose explicit dependency in here vvv  \n    withLogging(logger),  \n    // ^^^ compose explicit dependency in here ^^^\n\n    addConfig(initialConfig)  \n  )(o)  \n;\n\n// The factory only needs to know about withConfig now...  \nconst createConfig = ({ initialConfig, logger }) =>  \n  withConfig({ initialConfig, logger })({})  \n;  \n  \n\n// elsewhere, in a different module...  \nconst initialConfig = {  \n  host: 'localhost'  \n};\n\nconst logger = console.log.bind(console);\n\nconst config = createConfig({initialConfig, logger});\n\nconsole.log(config.get('host')); // 'localhost'  \nconfig.get('notThere'); // 'Missing config key: notThere'\n```\n\n우리는 다양한 요소들을 고려해서 올바른 디자인을 선택해야 합니다.  함수형 믹스인을 사용하기 위해 래핑된 데이터 유형을 요구하는 것은 타당하지만, 그렇다면 이를 함수 서명 및 API 문서에 명시해야합니다.\n\n그렇기에 암시적인 버전의 함수 서명에는  `o`  에 대한 기본값이 존재해야합니다. JavaScript에는 타입 주석 기능이 없기 때문에 기본값을 제공하여 모방할 수 있습니다.\n```javascript\n const withConfig = config => (o = {   \n log: (text = '') => console.log(text)   \n }) => Object.assign({}, o, {   \n // ...\n```\nTypeScript 또는 Flow를 사용하는 경우 명시적으로 인터페이스를 선언해 객체 요구 사항으로 사용하는 것이 좋습니다.\n\n## 함수형 믹스인 및 함수형 프로그래밍\n\n함수형 믹스인에서 \"함수형\"은 \"함수형 프로그래밍\"과 같은 뜻을 지니지 않습니다.  함수형 믹스인은 일반적으로 부수작용들이 있는 OOP 스타일로 사용됩니다.  이는 인자로 전달받은 객체를 변경합니다. 주의하십시오.\n\n마찬가지로 함수형 프로그래밍 스타일을 선호는 일부 개발자들은 전달받은 객체의 주소를 계속 가지고 있지 않습니다.  여러분은 두 스타일을 적절히 혼합하여 사용하는 방식으로 코딩해야합니다.\n\n즉, 객체 인스턴스를 리턴해야하는 경우 클로저에 있는 인스턴스 대신 항상 `this`를 리턴하십시오.  이 말은 즉, 그 둘이 동일한 객체가 아닐 가능성이 있다는 것 입니다.  또한  `Object.assign()` 나  `{...object, ...spread}`  구문을 사용해서 인스턴스를 복사, 할당한다고 가정할 경우 열거되지 않는 속성이 있으면 최종 객체에서 작동하지 않을 것입니다.\n```javascript\nconst a = Object.defineProperty({}, 'a', {  \n  enumerable: false,  \n  value: 'a'  \n});\n\nconst b = {  \n  b: 'b'  \n};\n\nconsole.log({...a, ...b}); // { b: 'b' }\n```\n마지막으로, 함수형 코드에서 작성하지 않은 함수 믹스인을 사용하는 경우 코드가 순수하다고 가정하지 마십시오. 기본 객체가 변형 될 수 있고 부수작용이 있으며 참조 투명성이 확보되지 않는다고 가정해야 합니다. 즉, 함수형 믹스인으로 구성된 팩토리는 메모이제이션하기 힘듭니다.\n\n## 결론\n\n함수형 믹스인는 조립 라인의 스테이션처럼 객체에 속성 및 동작을 추가하는 합성 가능한 팩토리 함수입니다.  고전적인 클래스(  **is-a**  )처럼 모든 기능을 상속하는 것과는 대조적으로 여러 관계(  **has-a, uses-a, can-do**  )와 기능으로 동작을 정의하는 좋은 방법입니다.\n\n\"함수형 믹스인\"은 \"함수형 프로그래밍\"을 의미하는 것이 아니라 단순히 \"함수에 기초한 믹스인\"을 의미합니다.  함수형 믹스인은 함수형 프로그래밍 스타일을 사용하여 부수효과를 없애고 참조 투명성을 유지하면서 작성 될 수 있지만 보장되지는 않습니다.  서드파티의 믹스인에는 부수작용과 비결정적인 위험 요소들이 있을 수 있습니다.\n\n-   단순한 오브젝트 믹스인와 달리 함수형 믹스인는 비공개 데이터를 상속하는 등 실제 데이터 프라이버시 (캡슐화)를 지원합니다.\n-   단일 조상 클래스 상속과는 달리, 함수형 믹스인은 클래스 데코레이터, 특성^trait^ 또는 다중 상속과 마찬가지로 다양한 조상으로부터 기능을 상속받는데 적합합니다.\n-   C ++의 다중 상속과는 달리, JavaScript에서는 다이아몬드 문제가 거의 발생하지 않습니다. 충돌이 발생할 때 간단한 규칙이 있기 때문입니다. 마지막으로 추가 된 믹스인이 승리합니다.\n-   클래스 데코레이터, 특성 또는 다중 상속과 달리 기본 클래스를 필요로 하지 않습니다.\n\n가장 간단한 구현으로 시작하여 필요한 경우에만보다 복잡한 구현으로 이동하십시오.\n\n >**함수 > 객체 > 팩토리 함수 > 함수형 믹스인 > 클래스**\n> Functions > objects > factory functions > functional mixins > classe\n\n[**다음: ES6+와 팩토리 함수 >**](https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/)","slug":"functional-mixins","published":1,"updated":"2018-04-28T13:35:59.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83d2000bifp6djenm1k2","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/functional-mixins-composing-software-ffb66d5e731c\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/07/functors-and-categories/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/\">다음&gt;</a></p>\n</blockquote>\n<p><strong>함수형 믹스인</strong>은 합성될 수 있는 팩토리함수입니다. 파이프라이닝되어 객체를 찍어내는 공장입니다. 각 함수는 조립 라인의 인력처럼 객체의 속성 또는 동작을 추가합니다. 함수형 믹스인은 기본 팩토리 또는 생성자가 필요하지 않습니다. 임의의 객체를 믹스인으로 전달하기만 하면 해당 객체의 향상된 버전이 반환됩니다.</p>\n<p>함수형 믹스인의 특징 :</p>\n<ul>\n<li>데이터 보안/캡슐화</li>\n<li>private 상태를 상속</li>\n<li>여러 소스에서 상속</li>\n<li>다이아몬드 문제(namespace충돌) 없음 - 마지막으로 상속된 것이 이김</li>\n<li>베이스 클래스가 필요하지 않음</li>\n</ul>\n<h2 id=\"동기부여\">동기부여</h2>\n<p>실제로 현대의 모든 소프트웨어 개발은 합성으로 이루어집니다. 우리는 크고 복잡한 문제를 작고 단순한 문제로 분해 한 다음 솔루션을 조합하여 애플리케이션을 구성합니다.</p>\n<p>합성의 재료로 쓰이는 원자 단위는 다음과 같습니다.</p>\n<ul>\n<li>함수</li>\n<li>데이터 구조</li>\n</ul>\n<p>애플리케이션의 구조는 이러한 원자들이 조합되는 방식으로 정의됩니다. 많은 곳에서 클래스 상속을 사용하여 복합 객체를 만듭니다. 클래스는 상위 클래스의 기능들 대부분을 상속하고 이를 확장<sup>extend</sup> 또는 오버라이딩합니다.  이 접근 방식은 <strong>&quot;~는 ~이다(is-a) &quot;</strong> 라는 사고를 강요한다는 문제가 있습니다. 예를 들어 “관리자는 직원” 같은 방식으로 관계를 정의하며 이런 접근방식에서 많은 디자인 문제가 발생합니다.</p>\n<ul>\n<li><strong>단단한 결합 문제</strong> <sup>The</sup> <sup>tight</sup> <sup>coupling</sup> <sup>problem</sup> :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.</li>\n<li><strong>깨지기 쉬운 기초 클래스 문제</strong><sup>The</sup> <sup>fragile</sup> <sup>base</sup> <sup>class</sup> <sup>problem</sup>  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.</li>\n<li><strong>경직된 계층 구조 문제</strong><sup>The</sup> <sup>inflexible</sup> <sup>hierarchy</sup> <sup>problem</sup> :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.</li>\n<li><strong>중복 필요성 문제</strong><sup>The</sup> <sup>duplication</sup> <sup>by</sup> <sup>necessity</sup> <sup>problem</sup> : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.</li>\n<li><strong>고릴라 / 바나나 문제</strong><sup>The</sup> <sup>gorilla/banana</sup> <sup>problem</sup> :  &quot;… 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. &quot;~ Joe Armstrong,  <a href=\"http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN\" target=\"_blank\" rel=\"noopener\">&quot;Coders at Work &quot;</a></li>\n</ul>\n<p>관리자가 직원이라고 정의했을 때 일시적으로 관리 업무를 수행하기 위해 외부 컨설턴트를 고용하는 상황을 어떻게 처리합니까?  모든 요구사항을 미리 알고 있다면 클래스 상속이 가능할 수도 있지만 그건 불가능합니다. 애플리케이션이 충분히 사용되다 보면 새로운 문제와 보다 효율적인 프로세스가 발견되고 애플리케이션의 기능과 요구 사항은 필연적으로 증가하고 발전합니다.</p>\n<p>이런 상황에서 믹스인은 보다 유연한 접근 방식을 제공합니다.</p>\n<h2 id=\"믹스인이란-무엇입니까\">믹스인이란 무엇입니까?</h2>\n<blockquote>\n<p>“클래스 상속보다는 객체 합성을 우선해라”, Gang of Four,  <a href=\"https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;qid=1494993475&amp;sr=8-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6c553f16325f3939e5abadd4ee04e8b4\" target=\"_blank\" rel=\"noopener\">“디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소”</a></p>\n</blockquote>\n<p><strong>믹스인</strong>은  <strong>객체 합성</strong>의 한 종류로, 구성 요소의 속성들이 혼합되어 복합 객체의 속성들을 구성합니다.</p>\n<p>OOP에서 &quot;믹스인&quot;이란 용어는 믹스인 아이스크림 가게에서 등장합니다. 미리 만들어진 많은 양의 아이스크림들이 있는 대신 바닐라 아이스크림과 각 고객별로 맞춤식 맛을 내기 위해 혼합될 수 있는 여러가지 재료가 있습니다.</p>\n<p>오브젝트 믹스인도 비슷합니다. 빈 오브젝트로 시작해 기능을 믹스하고 확장합니다.  JavaScript는 클래스가 없이 객체를 생성하고 동적 객체 확장을 지원하기 때문에 오브젝트 믹스인을 쉽게 사용할 수 있습니다. JavaScript에서 가장 일반적인 상속 방법인 만큼 다른 것들과 큰 차이가 있습니다.  예제를 살펴 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> chocolate = &#123;  </span><br><span class=\"line\">  hasChocolate: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"literal\">true</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> caramelSwirl = &#123;  </span><br><span class=\"line\">  hasCaramelSwirl: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"literal\">true</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pecans = &#123;  </span><br><span class=\"line\">  hasPecans: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"literal\">true</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> iceCream = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, chocolate, caramelSwirl, pecans);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">// or, if your environment supports object spread...  </span></span><br><span class=\"line\"><span class=\"comment\">const iceCream = &#123;...chocolate, ...caramelSwirl, ...pecans&#125;;  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">  hasChocolate: <span class=\"subst\">$&#123; iceCream.hasChocolate() &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">  hasCaramelSwirl: <span class=\"subst\">$&#123; iceCream.hasCaramelSwirl() &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">  hasPecans: <span class=\"subst\">$&#123; iceCream.hasPecans() &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">`</span>);</span><br></pre></td></tr></table></figure>\n<p>이는 다음과 같은 로그를 남깁니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hasChocolate: <span class=\"literal\">true</span></span><br><span class=\"line\">hasCaramelSwirl: <span class=\"literal\">true</span></span><br><span class=\"line\">hasPecans: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"함수형-상속이란-무엇입니까\">함수형 상속이란 무엇입니까?</h2>\n<p>함수형 상속은 오브젝트 인스턴스에 함수를 적용하여 기능을 상속하는 프로세스입니다.  이 함수는 클로저를 사용해 일부 데이터를 비공개로 유지하며 동적으로 오브젝트를 확장해 새로운 속성 및 메소드를 가진 인스턴스를 만듭니다.</p>\n<p>Douglas Crockford가 작성한 코드를 보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Base object factory  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">base</span>(<span class=\"params\">spec</span>) </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = &#123;&#125;; <span class=\"comment\">// Create an empty object  </span></span><br><span class=\"line\">    that.name = spec.name; <span class=\"comment\">// Add it a \"name\" property  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> that; <span class=\"comment\">// Return the object  </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Construct a child object, inheriting from \"base\"  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child</span>(<span class=\"params\">spec</span>) </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// Create the object through the \"base\" constructor  </span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = base(spec);   </span><br><span class=\"line\">    that.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// Augment that object  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Hello, I\\'m '</span> + that.name;  </span><br><span class=\"line\">    &#125;;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> that; <span class=\"comment\">// Return it  </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Usage  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = child(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'a functional object'</span> &#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.sayHello()); <span class=\"comment\">// \"Hello, I'm a functional object\"</span></span><br></pre></td></tr></table></figure>\n<p>그러나 <code>child()</code>가  <code>base()</code>에  단단하게 결합되어 있으므로 <code>grandchild()</code>,  <code>greatGrandchild()</code>등을 추가하려고 할 때면 클래스 상속의 일반적인 문제를 다시 마주치게 됩니다.</p>\n<h2 id=\"함수형-믹스인이란-무엇입니까\">함수형 믹스인이란 무엇입니까?</h2>\n<p>함수형 믹스인은 새로운 속성이나 동작을 주어진 개체의 속성과 혼합하는 <strong>합성가능한 함수</strong>입니다.  함수형 믹스인은 기본 팩토리 또는 생성자가 필요하지 않고 이들에 의존하지도 않습니다. 확장을 하기 위해서 임의의 객체를 믹스인으로 전달하기만 하면 됩니다.</p>\n<p>예제를 살펴 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> flying = <span class=\"function\"><span class=\"params\">o</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> isFlying = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;  </span><br><span class=\"line\">    fly () &#123;  </span><br><span class=\"line\">      isFlying = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    isFlying: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> isFlying,</span><br><span class=\"line\"></span><br><span class=\"line\">    land () &#123;  </span><br><span class=\"line\">      isFlying = <span class=\"literal\">false</span>;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;);  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> bird = flying(&#123;&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bird.isFlying() ); <span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bird.fly().isFlying() ); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>flying()</code>을 호출 할 때, 객체를 전달해야 합니다.  함수형 믹스인은 <strong>합성 함수</strong>를 사용하도록 설계되었습니다.  더 많은 예제를 알아보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> quacking = <span class=\"function\"><span class=\"params\">quack</span> =&gt;</span> o =&gt; <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;  </span><br><span class=\"line\">  quack: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> quack  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> quacker = quacking(<span class=\"string\">'Quack!'</span>)(&#123;&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( quacker.quack() ); <span class=\"comment\">// 'Quack!'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"함수형-믹스인을-합성하기\">함수형 믹스인을 합성하기</h2>\n<p>함수형 믹스인은 함수 합성으로 간단하게 구현 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createDuck = <span class=\"function\"><span class=\"params\">quack</span> =&gt;</span> quacking(quack)(flying(&#123;&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> duck = createDuck(<span class=\"string\">'Quack!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(duck.fly().quack());</span><br></pre></td></tr></table></figure>\n<p>조금 어색해 보입니다.  또한 디버깅하거나 합성 순서를 바꾸는 것이 약간 까다로울 수 있습니다.</p>\n<p>물론 이것은 기초적인 함수 합성이며  <code>compose()</code> 또는 <code>pipe()</code>를 사용하는 더 나은 방법을 이미 알고 있습니다.  <code>pipe()</code>를 사용하면 순서가 거꾸로 바뀌고 컴포지션은 동일한 우선 순위를 유지하면서  <code>Object.assign({}, ...)</code> 또는  <code>{...object, ...spread}</code> 처럼 읽을 수 있게 됩니다. 이름이 충돌하는 경우, 마지막으로 합성된 객체, 속성, 메소드가 승리합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);</span><br><span class=\"line\"><span class=\"comment\">// OR...</span></span><br><span class=\"line\"><span class=\"comment\">// import pipe from `lodash/fp/flow`;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createDuck = <span class=\"function\"><span class=\"params\">quack</span> =&gt;</span> pipe(</span><br><span class=\"line\">  flying,</span><br><span class=\"line\">  quacking(quack)</span><br><span class=\"line\">)(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> duck = createDuck(<span class=\"string\">'Quack!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(duck.fly().quack());</span><br></pre></td></tr></table></figure>\n<h2 id=\"함수형-믹스인을-사용해야-하는-경우\">함수형 믹스인을 사용해야 하는 경우</h2>\n<p>항상 문제를 해결하기 위한 가장 단순한 추상화를 사용해야합니다. 처음에는 <strong>순수 함수</strong>로 시작하십시오.  상태가 존재하는 객체가 필요하면 <strong>팩토리 함수</strong>를 사용해보십시오. 보다 복잡한 객체를 작성해야 할 경우 <strong>함수형 믹스인</strong>을 사용하십시오.</p>\n<p>다음은 함수형 믹스인을 사용한 좋은 예들 입니다.</p>\n<ul>\n<li>애플리케이션 상태 관리 (예 : Redux 저장소).</li>\n<li>centralized logger와 같은 특정 문제 및 서비스.</li>\n<li>합성 가능한 함수형 자료구조 (예 : JavaScript의  <code>Array</code>를 사용해서 <code>Semigroup</code>  ,  <code>Functor</code>  ,  <code>Foldable</code>을 구현할 수 있습니다.  일부 대수 구조<sup>algebraic</sup> <sup>structure</sup>는 다른 대수 구조에서 파생 될 수 있습니다. 즉,  커스터마이징하지 않고도 특정 근원에서 새로운 데이터 유형으로 합성 될 수 있음을 의미합니다.</li>\n</ul>\n<p><strong>React 사용자 :</strong>   <code>class</code>를 사용해도 괜찮습니다. 그 이유는 프레임워크 디자인 차원에서 caller가 <code>new</code>를 사용하지 않도록 되어있고 React가 기본적으로 제공하는 base 컴포넌트 외에 다른 컴포넌트를 상속하지 않도록  문서화된 모범 사례<sup>best-practice</sup>들을 제공하기 때문입니다.</p>\n<p>저는 React의 UI 컴포넌트를 구성할 때 함수 합성을 사용하여 HOC (Higher Order Components)를 사용할 것을 권장합니다.</p>\n<h2 id=\"주의-사항\">주의 사항</h2>\n<p>대부분의 문제는 순수 함수를 사용하여 우아하게 해결할 수 있습니다. 그러나 함수형 믹스인의 경우에는 아닙니다.  클래스 상속과 마찬가지로 함수형 믹스인은 자체적으로 문제를 일으킬 수 있습니다.  실제로 함수형 믹스인을 사용하여 클래스 상속의 모든 기능과 문제점을 충실히 재현 할 수 있습니다.</p>\n<p>이를 피하기 위해 다음 조언을 따르면 됩니다:</p>\n<ul>\n<li>가장 간단한 구현방법을 택하세요. 왼쪽에서 시작해 필요에 따라 오른쪽으로 이동하십시오 : 순수 함수 &gt; 팩토리 &gt; 함수형 믹스인 &gt; 클래스.</li>\n<li>객체, 믹스인 또는 데이터 유형간  <strong>is-a</strong>  관계가 생성되는걸 피하십시오.</li>\n<li>믹스인사이의 암묵적인 의존성을 제거하십시오 — 가능하다면 함수형 믹스인은 자체로 만족적이어야 하고 다른 믹스인에 대한 참조가 없어야 합니다.</li>\n<li>&quot;함수형 믹스인&quot;은 &quot;함수형 프로그래밍&quot;을 의미하지 않습니다.</li>\n<li><code>Object.assign()</code> 또는 객체 스프레드 구문 (  <code>{...}</code> )을 사용하여 속성에 액세스 할 때 부수효과가 발생할 수 있습니다.  또한 열거되지 않는 속성은 건너 뛴다는 것을 주의해야 합니다…  ES2017은 이 문제를 해결하기 위해  <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\" target=\"_blank\" rel=\"noopener\"><code>Object.getOwnPropertyDescriptors()</code></a>를 추가했습니다.</li>\n</ul>\n<p>자신의 사이드 프로젝트가 아닌 큰 프로젝트에서 함수형 믹스인을 사용하려고 한다면,  <a href=\"https://github.com/stampit-org/stamp-specification\" target=\"_blank\" rel=\"noopener\">stamps</a>를 참고하십시오. Stamp Specification은 속성 설명자, 프로토 타입 위임 등을 다루며 표준 JS 기능들을 사용하여 합성 가능한 팩토리 함수를 공유하고 재사용하는 표준입니다.</p>\n<p>필자는 주로 애플리케이션의 구조 및 동작을 구성하기 위해 함수 합성을 사용하는데 이 때 함수형 믹스인이나 <em>stamp</em> 는 거의 필요하지 않습니다.  그리고 클래스 상속은 절대 사용하지 않는데 한가지 예외가 있다면 <code>React.Class</code>같은 서드파티의 기본 클래스를 최소한의 루트로 상속해서 사용하는 것 입니다. 저는 절대로 직접 상속 계층 구조를 만들지 않습니다.</p>\n<h2 id=\"클래스\">클래스</h2>\n<p>클래스 상속이 JavaScript에서 괜찮은 접근법인 경우는 거의(아마 절대로) 없습니다. 그러나 본인이 직접 구현하지 않은 라이브러리나 프레임 워크에서 <code>class</code>를 사용하는 경우는 많이 있습니다.  이 경우  <code>class</code>를 실용적으로 사용할 수 있습니다. 다만 다음과 같은 특징을 가진 라이브러리에서 제공되는 <code>class</code>로 제한됩니다:</p>\n<ol>\n<li>직접 클래스를 확장 할 필요가 없어야 합니다(즉, 다중 레벨의 클래스 상속 구조를 만들 필요가 없습니다).</li>\n<li><code>new</code>  키워드를 직접 사용할 필요가 없습니다. 즉, 프레임 워크가 인스턴스화를 처리합니다.</li>\n</ol>\n<p>Angular 2+와 React 모두 이러한 요구 사항을 충족하므로 클래스를 확장하지 않는 한 클래스를 안전하게 사용할 수 있습니다.  React는 여러분이 원하지 않는 경우 클래스를 사용하지 않아도 됩니다(선택사항입니다). 그러나 React의 기본 클래스에 내장 된 최적화 기능을 사용하지 못하고 여러분의 컴포넌트가 예제 문서에 나오는 컴포넌트처럼 보이지 않을 수 있습니다. 어쨌든 React 컴포넌트도 마찬가지로 가능하다면 순수 함수 형식을 항상 선호해야합니다.</p>\n<h3 id=\"클래스와-퍼포먼스\">클래스와 퍼포먼스</h3>\n<p>일부 브라우저의 JavaScript 엔진에서는 클래스에 특화된 최적화를 제공합니다. 대부분의 경우 이러한 최적화는 앱의 성능에 큰 영향을 미치지 않습니다.  실제로,  <code>class</code>  성능 차이에 대해 걱정할 필요없이 오랜 기간동안 프로젝트를 진행할 수 있습니다.  객체를 생성하고 속성에 접근하는 것은 객체를 만드는 방법에 관계없이 항상 매우 빠릅니다(초당 수백만번의 연산이 가능).</p>\n<p>그러나, RxJS, Lodash 등과 같은 범용 유틸리티 라이브러리를 만들 때는  <code>class</code>  를 사용하여 객체 인스턴스를 만들었을 때 얻을 수 있는 성능상의 이점을 조사해야합니다.  <code>class</code> 사용해서 해결할 수 있는 성능상의 병목현상이 없다면 (그리고 그 것을 증명할 수 있는게 아니라면)  성능에 대해 걱정하기 보다는 깨끗하고 유연한 코드 작성하는 방식으로 최적화해야합니다.</p>\n<h2 id=\"암시적인-종속성\">암시적인 종속성</h2>\n<p>당신은 함수형 믹스인으로 여러 기능들을 욱여넣고 싶은 유혹을 느낍니다.  당신이 설정 관리자<sup>configuration</sup> <sup>manager</sup>를 만들려고 합니다. 이 관리자는 존재하지 않는 설정 속성에 액세스하려고 할 때 경고 로그를 띄웁니다.</p>\n<p>다음과 같이 빌드 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in its own module...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withLogging = <span class=\"function\"><span class=\"params\">logger</span> =&gt;</span> o =&gt; <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;  </span><br><span class=\"line\">  log (text) &#123;  </span><br><span class=\"line\">    logger(text)  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// in a different module with no explicit mention of  </span></span><br><span class=\"line\"><span class=\"comment\">// withLogging -- we just assume it's there...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withConfig = <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> (o = &#123;  </span><br><span class=\"line\">  log: <span class=\"function\">(<span class=\"params\">text = <span class=\"string\">''</span></span>) =&gt;</span> <span class=\"built_in\">console</span>.log(text)  </span><br><span class=\"line\">&#125;) =&gt; <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;  </span><br><span class=\"line\">  get (key) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> config[key] == <span class=\"literal\">undefined</span> ?</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// vvv implicit dependency here... oops! vvv  </span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.log(<span class=\"string\">`Missing config key: <span class=\"subst\">$&#123; key &#125;</span>`</span>) :  </span><br><span class=\"line\">      <span class=\"comment\">// ^^^ implicit dependency here... oops! ^^^</span></span><br><span class=\"line\"></span><br><span class=\"line\">      config[key]  </span><br><span class=\"line\">    ;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// in yet another module that imports withLogging and  </span></span><br><span class=\"line\"><span class=\"comment\">// withConfig...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> createConfig = <span class=\"function\">(<span class=\"params\">&#123; initialConfig, logger &#125;</span>) =&gt;</span>  </span><br><span class=\"line\">  pipe(  </span><br><span class=\"line\">    withLogging(logger),  </span><br><span class=\"line\">    withConfig(initialConfig)  </span><br><span class=\"line\">  )(&#123;&#125;)  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// elsewhere...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialConfig = &#123;  </span><br><span class=\"line\">  host: <span class=\"string\">'localhost'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"built_in\">console</span>.log.bind(<span class=\"built_in\">console</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = createConfig(&#123;initialConfig, logger&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(config.get(<span class=\"string\">'host'</span>)); <span class=\"comment\">// 'localhost'  </span></span><br><span class=\"line\">config.get(<span class=\"string\">'notThere'</span>); <span class=\"comment\">// 'Missing config key: notThere'</span></span><br></pre></td></tr></table></figure>\n<p>그러나 다음과 같이 빌드 할 수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import withLogging() explicitly in withConfig module  </span></span><br><span class=\"line\"><span class=\"keyword\">import</span> withLogging <span class=\"keyword\">from</span> <span class=\"string\">'./with-logging'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> addConfig = <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> o =&gt; <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;  </span><br><span class=\"line\">  get (key) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> config[key] == <span class=\"literal\">undefined</span> ?   </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.log(<span class=\"string\">`Missing config key: <span class=\"subst\">$&#123; key &#125;</span>`</span>) :  </span><br><span class=\"line\">      config[key]  </span><br><span class=\"line\">    ;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> withConfig = <span class=\"function\">(<span class=\"params\">&#123; initialConfig, logger &#125;</span>) =&gt;</span> o =&gt;  </span><br><span class=\"line\">  pipe(</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// vvv compose explicit dependency in here vvv  </span></span><br><span class=\"line\">    withLogging(logger),  </span><br><span class=\"line\">    <span class=\"comment\">// ^^^ compose explicit dependency in here ^^^</span></span><br><span class=\"line\"></span><br><span class=\"line\">    addConfig(initialConfig)  </span><br><span class=\"line\">  )(o)  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The factory only needs to know about withConfig now...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> createConfig = <span class=\"function\">(<span class=\"params\">&#123; initialConfig, logger &#125;</span>) =&gt;</span>  </span><br><span class=\"line\">  withConfig(&#123; initialConfig, logger &#125;)(&#123;&#125;)  </span><br><span class=\"line\">;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// elsewhere, in a different module...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialConfig = &#123;  </span><br><span class=\"line\">  host: <span class=\"string\">'localhost'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"built_in\">console</span>.log.bind(<span class=\"built_in\">console</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = createConfig(&#123;initialConfig, logger&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(config.get(<span class=\"string\">'host'</span>)); <span class=\"comment\">// 'localhost'  </span></span><br><span class=\"line\">config.get(<span class=\"string\">'notThere'</span>); <span class=\"comment\">// 'Missing config key: notThere'</span></span><br></pre></td></tr></table></figure>\n<p>우리는 다양한 요소들을 고려해서 올바른 디자인을 선택해야 합니다.  함수형 믹스인을 사용하기 위해 래핑된 데이터 유형을 요구하는 것은 타당하지만, 그렇다면 이를 함수 서명 및 API 문서에 명시해야합니다.</p>\n<p>그렇기에 암시적인 버전의 함수 서명에는  <code>o</code>  에 대한 기본값이 존재해야합니다. JavaScript에는 타입 주석 기능이 없기 때문에 기본값을 제공하여 모방할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withConfig = <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> (o = &#123;   </span><br><span class=\"line\">log: <span class=\"function\">(<span class=\"params\">text = <span class=\"string\">''</span></span>) =&gt;</span> <span class=\"built_in\">console</span>.log(text)   </span><br><span class=\"line\">&#125;) =&gt; <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;   </span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript 또는 Flow를 사용하는 경우 명시적으로 인터페이스를 선언해 객체 요구 사항으로 사용하는 것이 좋습니다.</p>\n<h2 id=\"함수형-믹스인-및-함수형-프로그래밍\">함수형 믹스인 및 함수형 프로그래밍</h2>\n<p>함수형 믹스인에서 &quot;함수형&quot;은 &quot;함수형 프로그래밍&quot;과 같은 뜻을 지니지 않습니다.  함수형 믹스인은 일반적으로 부수작용들이 있는 OOP 스타일로 사용됩니다.  이는 인자로 전달받은 객체를 변경합니다. 주의하십시오.</p>\n<p>마찬가지로 함수형 프로그래밍 스타일을 선호는 일부 개발자들은 전달받은 객체의 주소를 계속 가지고 있지 않습니다.  여러분은 두 스타일을 적절히 혼합하여 사용하는 방식으로 코딩해야합니다.</p>\n<p>즉, 객체 인스턴스를 리턴해야하는 경우 클로저에 있는 인스턴스 대신 항상 <code>this</code>를 리턴하십시오.  이 말은 즉, 그 둘이 동일한 객체가 아닐 가능성이 있다는 것 입니다.  또한  <code>Object.assign()</code> 나  <code>{...object, ...spread}</code>  구문을 사용해서 인스턴스를 복사, 할당한다고 가정할 경우 열거되지 않는 속성이 있으면 최종 객체에서 작동하지 않을 것입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"built_in\">Object</span>.defineProperty(&#123;&#125;, <span class=\"string\">'a'</span>, &#123;  </span><br><span class=\"line\">  enumerable: <span class=\"literal\">false</span>,  </span><br><span class=\"line\">  value: <span class=\"string\">'a'</span>  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;  </span><br><span class=\"line\">  b: <span class=\"string\">'b'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(&#123;...a, ...b&#125;); <span class=\"comment\">// &#123; b: 'b' &#125;</span></span><br></pre></td></tr></table></figure>\n<p>마지막으로, 함수형 코드에서 작성하지 않은 함수 믹스인을 사용하는 경우 코드가 순수하다고 가정하지 마십시오. 기본 객체가 변형 될 수 있고 부수작용이 있으며 참조 투명성이 확보되지 않는다고 가정해야 합니다. 즉, 함수형 믹스인으로 구성된 팩토리는 메모이제이션하기 힘듭니다.</p>\n<h2 id=\"결론\">결론</h2>\n<p>함수형 믹스인는 조립 라인의 스테이션처럼 객체에 속성 및 동작을 추가하는 합성 가능한 팩토리 함수입니다.  고전적인 클래스(  <strong>is-a</strong>  )처럼 모든 기능을 상속하는 것과는 대조적으로 여러 관계(  <strong>has-a, uses-a, can-do</strong>  )와 기능으로 동작을 정의하는 좋은 방법입니다.</p>\n<p>&quot;함수형 믹스인&quot;은 &quot;함수형 프로그래밍&quot;을 의미하는 것이 아니라 단순히 &quot;함수에 기초한 믹스인&quot;을 의미합니다.  함수형 믹스인은 함수형 프로그래밍 스타일을 사용하여 부수효과를 없애고 참조 투명성을 유지하면서 작성 될 수 있지만 보장되지는 않습니다.  서드파티의 믹스인에는 부수작용과 비결정적인 위험 요소들이 있을 수 있습니다.</p>\n<ul>\n<li>단순한 오브젝트 믹스인와 달리 함수형 믹스인는 비공개 데이터를 상속하는 등 실제 데이터 프라이버시 (캡슐화)를 지원합니다.</li>\n<li>단일 조상 클래스 상속과는 달리, 함수형 믹스인은 클래스 데코레이터, 특성<sup>trait</sup> 또는 다중 상속과 마찬가지로 다양한 조상으로부터 기능을 상속받는데 적합합니다.</li>\n<li>C ++의 다중 상속과는 달리, JavaScript에서는 다이아몬드 문제가 거의 발생하지 않습니다. 충돌이 발생할 때 간단한 규칙이 있기 때문입니다. 마지막으로 추가 된 믹스인이 승리합니다.</li>\n<li>클래스 데코레이터, 특성 또는 다중 상속과 달리 기본 클래스를 필요로 하지 않습니다.</li>\n</ul>\n<p>가장 간단한 구현으로 시작하여 필요한 경우에만보다 복잡한 구현으로 이동하십시오.</p>\n<blockquote>\n<p><strong>함수 &gt; 객체 &gt; 팩토리 함수 &gt; 함수형 믹스인 &gt; 클래스</strong><br>\nFunctions &gt; objects &gt; factory functions &gt; functional mixins &gt; classe</p>\n</blockquote>\n<p><a href=\"https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/\"><strong>다음: ES6+와 팩토리 함수 &gt;</strong></a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/functional-mixins-composing-software-ffb66d5e731c\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/07/functors-and-categories/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/\">다음&gt;</a></p>\n</blockquote>\n<p><strong>함수형 믹스인</strong>은 합성될 수 있는 팩토리함수입니다. 파이프라이닝되어 객체를 찍어내는 공장입니다. 각 함수는 조립 라인의 인력처럼 객체의 속성 또는 동작을 추가합니다. 함수형 믹스인은 기본 팩토리 또는 생성자가 필요하지 않습니다. 임의의 객체를 믹스인으로 전달하기만 하면 해당 객체의 향상된 버전이 반환됩니다.</p>\n<p>함수형 믹스인의 특징 :</p>\n<ul>\n<li>데이터 보안/캡슐화</li>\n<li>private 상태를 상속</li>\n<li>여러 소스에서 상속</li>\n<li>다이아몬드 문제(namespace충돌) 없음 - 마지막으로 상속된 것이 이김</li>\n<li>베이스 클래스가 필요하지 않음</li>\n</ul>\n<h2>동기부여</h2>\n<p>실제로 현대의 모든 소프트웨어 개발은 합성으로 이루어집니다. 우리는 크고 복잡한 문제를 작고 단순한 문제로 분해 한 다음 솔루션을 조합하여 애플리케이션을 구성합니다.</p>\n<p>합성의 재료로 쓰이는 원자 단위는 다음과 같습니다.</p>\n<ul>\n<li>함수</li>\n<li>데이터 구조</li>\n</ul>\n<p>애플리케이션의 구조는 이러한 원자들이 조합되는 방식으로 정의됩니다. 많은 곳에서 클래스 상속을 사용하여 복합 객체를 만듭니다. 클래스는 상위 클래스의 기능들 대부분을 상속하고 이를 확장<sup>extend</sup> 또는 오버라이딩합니다.  이 접근 방식은 <strong>&quot;~는 ~이다(is-a) &quot;</strong> 라는 사고를 강요한다는 문제가 있습니다. 예를 들어 “관리자는 직원” 같은 방식으로 관계를 정의하며 이런 접근방식에서 많은 디자인 문제가 발생합니다.</p>\n<ul>\n<li><strong>단단한 결합 문제</strong> <sup>The</sup> <sup>tight</sup> <sup>coupling</sup> <sup>problem</sup> :  자식 클래스는 부모 클래스의 구현에 의존하기 때문에 클래스 상속은 객체 지향 디자인에서 사용할 수있는 가장 조밀한 결합입니다.</li>\n<li><strong>깨지기 쉬운 기초 클래스 문제</strong><sup>The</sup> <sup>fragile</sup> <sup>base</sup> <sup>class</sup> <sup>problem</sup>  : 긴밀한 결합으로 인해  기초 클래스가  변경되면 잠재적으로 제 3자가 관리하는 코드에서 많은 수의 클래스가 손상 될 수 있습니다.  작성자는 알지 못하는 코드를 깨뜨릴 수 있습니다.</li>\n<li><strong>경직된 계층 구조 문제</strong><sup>The</sup> <sup>inflexible</sup> <sup>hierarchy</sup> <sup>problem</sup> :  단일 조상으로 시작해 충분한 시간과 진화가 이루어진 후에는 사실상 새로운 유스 케이스에 대해  잘못된 클래스 이름을 가지게 될 것입니다.</li>\n<li><strong>중복 필요성 문제</strong><sup>The</sup> <sup>duplication</sup> <sup>by</sup> <sup>necessity</sup> <sup>problem</sup> : 경직된 계층 구조로 인해 새로운 유스 케이스가 종종 확장이 아닌 복제에 의해 구현되고 이로 인해 불필요한 유사한 클래스들이 나타나게 됩니다. 유사한 클래스들이 존재하면 상속의 기준을 무엇으로 잡을지 불투명해 집니다.</li>\n<li><strong>고릴라 / 바나나 문제</strong><sup>The</sup> <sup>gorilla/banana</sup> <sup>problem</sup> :  &quot;… 객체 지향 언어의 문제점은 객체가 모든 암묵적인 환경을 함께 가질 수 있다는 것입니다.  당신은 바나나를 원했지만 바나나와 정글 전체를 들고있는 고릴라가있었습니다. &quot;~ Joe Armstrong,  <a href=\"http://www.amazon.com/gp/product/1430219483%3Fie%3DUTF8%26camp%3D213733%26creative%3D393185%26creativeASIN%3D1430219483%26linkCode%3Dshr%26tag%3Deejs-20%26linkId%3D3MNWRRZU3C4Q4BDN\" target=\"_blank\" rel=\"noopener\">&quot;Coders at Work &quot;</a></li>\n</ul>\n<p>관리자가 직원이라고 정의했을 때 일시적으로 관리 업무를 수행하기 위해 외부 컨설턴트를 고용하는 상황을 어떻게 처리합니까?  모든 요구사항을 미리 알고 있다면 클래스 상속이 가능할 수도 있지만 그건 불가능합니다. 애플리케이션이 충분히 사용되다 보면 새로운 문제와 보다 효율적인 프로세스가 발견되고 애플리케이션의 기능과 요구 사항은 필연적으로 증가하고 발전합니다.</p>\n<p>이런 상황에서 믹스인은 보다 유연한 접근 방식을 제공합니다.</p>\n<h2>믹스인이란 무엇입니까?</h2>\n<blockquote>\n<p>“클래스 상속보다는 객체 합성을 우선해라”, Gang of Four,  <a href=\"https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;qid=1494993475&amp;sr=8-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6c553f16325f3939e5abadd4ee04e8b4\" target=\"_blank\" rel=\"noopener\">“디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소”</a></p>\n</blockquote>\n<p><strong>믹스인</strong>은  <strong>객체 합성</strong>의 한 종류로, 구성 요소의 속성들이 혼합되어 복합 객체의 속성들을 구성합니다.</p>\n<p>OOP에서 &quot;믹스인&quot;이란 용어는 믹스인 아이스크림 가게에서 등장합니다. 미리 만들어진 많은 양의 아이스크림들이 있는 대신 바닐라 아이스크림과 각 고객별로 맞춤식 맛을 내기 위해 혼합될 수 있는 여러가지 재료가 있습니다.</p>\n<p>오브젝트 믹스인도 비슷합니다. 빈 오브젝트로 시작해 기능을 믹스하고 확장합니다.  JavaScript는 클래스가 없이 객체를 생성하고 동적 객체 확장을 지원하기 때문에 오브젝트 믹스인을 쉽게 사용할 수 있습니다. JavaScript에서 가장 일반적인 상속 방법인 만큼 다른 것들과 큰 차이가 있습니다.  예제를 살펴 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> chocolate = &#123;  </span><br><span class=\"line\">  hasChocolate: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"literal\">true</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> caramelSwirl = &#123;  </span><br><span class=\"line\">  hasCaramelSwirl: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"literal\">true</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pecans = &#123;  </span><br><span class=\"line\">  hasPecans: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"literal\">true</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> iceCream = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, chocolate, caramelSwirl, pecans);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">// or, if your environment supports object spread...  </span></span><br><span class=\"line\"><span class=\"comment\">const iceCream = &#123;...chocolate, ...caramelSwirl, ...pecans&#125;;  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">  hasChocolate: <span class=\"subst\">$&#123; iceCream.hasChocolate() &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">  hasCaramelSwirl: <span class=\"subst\">$&#123; iceCream.hasCaramelSwirl() &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">  hasPecans: <span class=\"subst\">$&#123; iceCream.hasPecans() &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">`</span>);</span><br></pre></td></tr></table></figure>\n<p>이는 다음과 같은 로그를 남깁니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hasChocolate: <span class=\"literal\">true</span></span><br><span class=\"line\">hasCaramelSwirl: <span class=\"literal\">true</span></span><br><span class=\"line\">hasPecans: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h2>함수형 상속이란 무엇입니까?</h2>\n<p>함수형 상속은 오브젝트 인스턴스에 함수를 적용하여 기능을 상속하는 프로세스입니다.  이 함수는 클로저를 사용해 일부 데이터를 비공개로 유지하며 동적으로 오브젝트를 확장해 새로운 속성 및 메소드를 가진 인스턴스를 만듭니다.</p>\n<p>Douglas Crockford가 작성한 코드를 보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Base object factory  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">base</span>(<span class=\"params\">spec</span>) </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = &#123;&#125;; <span class=\"comment\">// Create an empty object  </span></span><br><span class=\"line\">    that.name = spec.name; <span class=\"comment\">// Add it a \"name\" property  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> that; <span class=\"comment\">// Return the object  </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Construct a child object, inheriting from \"base\"  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child</span>(<span class=\"params\">spec</span>) </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// Create the object through the \"base\" constructor  </span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = base(spec);   </span><br><span class=\"line\">    that.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// Augment that object  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Hello, I\\'m '</span> + that.name;  </span><br><span class=\"line\">    &#125;;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> that; <span class=\"comment\">// Return it  </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Usage  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = child(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'a functional object'</span> &#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.sayHello()); <span class=\"comment\">// \"Hello, I'm a functional object\"</span></span><br></pre></td></tr></table></figure>\n<p>그러나 <code>child()</code>가  <code>base()</code>에  단단하게 결합되어 있으므로 <code>grandchild()</code>,  <code>greatGrandchild()</code>등을 추가하려고 할 때면 클래스 상속의 일반적인 문제를 다시 마주치게 됩니다.</p>\n<h2>함수형 믹스인이란 무엇입니까?</h2>\n<p>함수형 믹스인은 새로운 속성이나 동작을 주어진 개체의 속성과 혼합하는 <strong>합성가능한 함수</strong>입니다.  함수형 믹스인은 기본 팩토리 또는 생성자가 필요하지 않고 이들에 의존하지도 않습니다. 확장을 하기 위해서 임의의 객체를 믹스인으로 전달하기만 하면 됩니다.</p>\n<p>예제를 살펴 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> flying = <span class=\"function\"><span class=\"params\">o</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> isFlying = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;  </span><br><span class=\"line\">    fly () &#123;  </span><br><span class=\"line\">      isFlying = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    isFlying: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> isFlying,</span><br><span class=\"line\"></span><br><span class=\"line\">    land () &#123;  </span><br><span class=\"line\">      isFlying = <span class=\"literal\">false</span>;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;);  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> bird = flying(&#123;&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bird.isFlying() ); <span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bird.fly().isFlying() ); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>flying()</code>을 호출 할 때, 객체를 전달해야 합니다.  함수형 믹스인은 <strong>합성 함수</strong>를 사용하도록 설계되었습니다.  더 많은 예제를 알아보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> quacking = <span class=\"function\"><span class=\"params\">quack</span> =&gt;</span> o =&gt; <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;  </span><br><span class=\"line\">  quack: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> quack  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> quacker = quacking(<span class=\"string\">'Quack!'</span>)(&#123;&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( quacker.quack() ); <span class=\"comment\">// 'Quack!'</span></span><br></pre></td></tr></table></figure>\n<h2>함수형 믹스인을 합성하기</h2>\n<p>함수형 믹스인은 함수 합성으로 간단하게 구현 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createDuck = <span class=\"function\"><span class=\"params\">quack</span> =&gt;</span> quacking(quack)(flying(&#123;&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> duck = createDuck(<span class=\"string\">'Quack!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(duck.fly().quack());</span><br></pre></td></tr></table></figure>\n<p>조금 어색해 보입니다.  또한 디버깅하거나 합성 순서를 바꾸는 것이 약간 까다로울 수 있습니다.</p>\n<p>물론 이것은 기초적인 함수 합성이며  <code>compose()</code> 또는 <code>pipe()</code>를 사용하는 더 나은 방법을 이미 알고 있습니다.  <code>pipe()</code>를 사용하면 순서가 거꾸로 바뀌고 컴포지션은 동일한 우선 순위를 유지하면서  <code>Object.assign({}, ...)</code> 또는  <code>{...object, ...spread}</code> 처럼 읽을 수 있게 됩니다. 이름이 충돌하는 경우, 마지막으로 합성된 객체, 속성, 메소드가 승리합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);</span><br><span class=\"line\"><span class=\"comment\">// OR...</span></span><br><span class=\"line\"><span class=\"comment\">// import pipe from `lodash/fp/flow`;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createDuck = <span class=\"function\"><span class=\"params\">quack</span> =&gt;</span> pipe(</span><br><span class=\"line\">  flying,</span><br><span class=\"line\">  quacking(quack)</span><br><span class=\"line\">)(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> duck = createDuck(<span class=\"string\">'Quack!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(duck.fly().quack());</span><br></pre></td></tr></table></figure>\n<h2>함수형 믹스인을 사용해야 하는 경우</h2>\n<p>항상 문제를 해결하기 위한 가장 단순한 추상화를 사용해야합니다. 처음에는 <strong>순수 함수</strong>로 시작하십시오.  상태가 존재하는 객체가 필요하면 <strong>팩토리 함수</strong>를 사용해보십시오. 보다 복잡한 객체를 작성해야 할 경우 <strong>함수형 믹스인</strong>을 사용하십시오.</p>\n<p>다음은 함수형 믹스인을 사용한 좋은 예들 입니다.</p>\n<ul>\n<li>애플리케이션 상태 관리 (예 : Redux 저장소).</li>\n<li>centralized logger와 같은 특정 문제 및 서비스.</li>\n<li>합성 가능한 함수형 자료구조 (예 : JavaScript의  <code>Array</code>를 사용해서 <code>Semigroup</code>  ,  <code>Functor</code>  ,  <code>Foldable</code>을 구현할 수 있습니다.  일부 대수 구조<sup>algebraic</sup> <sup>structure</sup>는 다른 대수 구조에서 파생 될 수 있습니다. 즉,  커스터마이징하지 않고도 특정 근원에서 새로운 데이터 유형으로 합성 될 수 있음을 의미합니다.</li>\n</ul>\n<p><strong>React 사용자 :</strong>   <code>class</code>를 사용해도 괜찮습니다. 그 이유는 프레임워크 디자인 차원에서 caller가 <code>new</code>를 사용하지 않도록 되어있고 React가 기본적으로 제공하는 base 컴포넌트 외에 다른 컴포넌트를 상속하지 않도록  문서화된 모범 사례<sup>best-practice</sup>들을 제공하기 때문입니다.</p>\n<p>저는 React의 UI 컴포넌트를 구성할 때 함수 합성을 사용하여 HOC (Higher Order Components)를 사용할 것을 권장합니다.</p>\n<h2>주의 사항</h2>\n<p>대부분의 문제는 순수 함수를 사용하여 우아하게 해결할 수 있습니다. 그러나 함수형 믹스인의 경우에는 아닙니다.  클래스 상속과 마찬가지로 함수형 믹스인은 자체적으로 문제를 일으킬 수 있습니다.  실제로 함수형 믹스인을 사용하여 클래스 상속의 모든 기능과 문제점을 충실히 재현 할 수 있습니다.</p>\n<p>이를 피하기 위해 다음 조언을 따르면 됩니다:</p>\n<ul>\n<li>가장 간단한 구현방법을 택하세요. 왼쪽에서 시작해 필요에 따라 오른쪽으로 이동하십시오 : 순수 함수 &gt; 팩토리 &gt; 함수형 믹스인 &gt; 클래스.</li>\n<li>객체, 믹스인 또는 데이터 유형간  <strong>is-a</strong>  관계가 생성되는걸 피하십시오.</li>\n<li>믹스인사이의 암묵적인 의존성을 제거하십시오 — 가능하다면 함수형 믹스인은 자체로 만족적이어야 하고 다른 믹스인에 대한 참조가 없어야 합니다.</li>\n<li>&quot;함수형 믹스인&quot;은 &quot;함수형 프로그래밍&quot;을 의미하지 않습니다.</li>\n<li><code>Object.assign()</code> 또는 객체 스프레드 구문 (  <code>{...}</code> )을 사용하여 속성에 액세스 할 때 부수효과가 발생할 수 있습니다.  또한 열거되지 않는 속성은 건너 뛴다는 것을 주의해야 합니다…  ES2017은 이 문제를 해결하기 위해  <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\" target=\"_blank\" rel=\"noopener\"><code>Object.getOwnPropertyDescriptors()</code></a>를 추가했습니다.</li>\n</ul>\n<p>자신의 사이드 프로젝트가 아닌 큰 프로젝트에서 함수형 믹스인을 사용하려고 한다면,  <a href=\"https://github.com/stampit-org/stamp-specification\" target=\"_blank\" rel=\"noopener\">stamps</a>를 참고하십시오. Stamp Specification은 속성 설명자, 프로토 타입 위임 등을 다루며 표준 JS 기능들을 사용하여 합성 가능한 팩토리 함수를 공유하고 재사용하는 표준입니다.</p>\n<p>필자는 주로 애플리케이션의 구조 및 동작을 구성하기 위해 함수 합성을 사용하는데 이 때 함수형 믹스인이나 <em>stamp</em> 는 거의 필요하지 않습니다.  그리고 클래스 상속은 절대 사용하지 않는데 한가지 예외가 있다면 <code>React.Class</code>같은 서드파티의 기본 클래스를 최소한의 루트로 상속해서 사용하는 것 입니다. 저는 절대로 직접 상속 계층 구조를 만들지 않습니다.</p>\n<h2>클래스</h2>\n<p>클래스 상속이 JavaScript에서 괜찮은 접근법인 경우는 거의(아마 절대로) 없습니다. 그러나 본인이 직접 구현하지 않은 라이브러리나 프레임 워크에서 <code>class</code>를 사용하는 경우는 많이 있습니다.  이 경우  <code>class</code>를 실용적으로 사용할 수 있습니다. 다만 다음과 같은 특징을 가진 라이브러리에서 제공되는 <code>class</code>로 제한됩니다:</p>\n<ol>\n<li>직접 클래스를 확장 할 필요가 없어야 합니다(즉, 다중 레벨의 클래스 상속 구조를 만들 필요가 없습니다).</li>\n<li><code>new</code>  키워드를 직접 사용할 필요가 없습니다. 즉, 프레임 워크가 인스턴스화를 처리합니다.</li>\n</ol>\n<p>Angular 2+와 React 모두 이러한 요구 사항을 충족하므로 클래스를 확장하지 않는 한 클래스를 안전하게 사용할 수 있습니다.  React는 여러분이 원하지 않는 경우 클래스를 사용하지 않아도 됩니다(선택사항입니다). 그러나 React의 기본 클래스에 내장 된 최적화 기능을 사용하지 못하고 여러분의 컴포넌트가 예제 문서에 나오는 컴포넌트처럼 보이지 않을 수 있습니다. 어쨌든 React 컴포넌트도 마찬가지로 가능하다면 순수 함수 형식을 항상 선호해야합니다.</p>\n<h3>클래스와 퍼포먼스</h3>\n<p>일부 브라우저의 JavaScript 엔진에서는 클래스에 특화된 최적화를 제공합니다. 대부분의 경우 이러한 최적화는 앱의 성능에 큰 영향을 미치지 않습니다.  실제로,  <code>class</code>  성능 차이에 대해 걱정할 필요없이 오랜 기간동안 프로젝트를 진행할 수 있습니다.  객체를 생성하고 속성에 접근하는 것은 객체를 만드는 방법에 관계없이 항상 매우 빠릅니다(초당 수백만번의 연산이 가능).</p>\n<p>그러나, RxJS, Lodash 등과 같은 범용 유틸리티 라이브러리를 만들 때는  <code>class</code>  를 사용하여 객체 인스턴스를 만들었을 때 얻을 수 있는 성능상의 이점을 조사해야합니다.  <code>class</code> 사용해서 해결할 수 있는 성능상의 병목현상이 없다면 (그리고 그 것을 증명할 수 있는게 아니라면)  성능에 대해 걱정하기 보다는 깨끗하고 유연한 코드 작성하는 방식으로 최적화해야합니다.</p>\n<h2>암시적인 종속성</h2>\n<p>당신은 함수형 믹스인으로 여러 기능들을 욱여넣고 싶은 유혹을 느낍니다.  당신이 설정 관리자<sup>configuration</sup> <sup>manager</sup>를 만들려고 합니다. 이 관리자는 존재하지 않는 설정 속성에 액세스하려고 할 때 경고 로그를 띄웁니다.</p>\n<p>다음과 같이 빌드 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in its own module...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withLogging = <span class=\"function\"><span class=\"params\">logger</span> =&gt;</span> o =&gt; <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;  </span><br><span class=\"line\">  log (text) &#123;  </span><br><span class=\"line\">    logger(text)  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// in a different module with no explicit mention of  </span></span><br><span class=\"line\"><span class=\"comment\">// withLogging -- we just assume it's there...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withConfig = <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> (o = &#123;  </span><br><span class=\"line\">  log: <span class=\"function\">(<span class=\"params\">text = <span class=\"string\">''</span></span>) =&gt;</span> <span class=\"built_in\">console</span>.log(text)  </span><br><span class=\"line\">&#125;) =&gt; <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;  </span><br><span class=\"line\">  get (key) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> config[key] == <span class=\"literal\">undefined</span> ?</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// vvv implicit dependency here... oops! vvv  </span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.log(<span class=\"string\">`Missing config key: <span class=\"subst\">$&#123; key &#125;</span>`</span>) :  </span><br><span class=\"line\">      <span class=\"comment\">// ^^^ implicit dependency here... oops! ^^^</span></span><br><span class=\"line\"></span><br><span class=\"line\">      config[key]  </span><br><span class=\"line\">    ;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// in yet another module that imports withLogging and  </span></span><br><span class=\"line\"><span class=\"comment\">// withConfig...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> createConfig = <span class=\"function\">(<span class=\"params\">&#123; initialConfig, logger &#125;</span>) =&gt;</span>  </span><br><span class=\"line\">  pipe(  </span><br><span class=\"line\">    withLogging(logger),  </span><br><span class=\"line\">    withConfig(initialConfig)  </span><br><span class=\"line\">  )(&#123;&#125;)  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// elsewhere...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialConfig = &#123;  </span><br><span class=\"line\">  host: <span class=\"string\">'localhost'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"built_in\">console</span>.log.bind(<span class=\"built_in\">console</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = createConfig(&#123;initialConfig, logger&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(config.get(<span class=\"string\">'host'</span>)); <span class=\"comment\">// 'localhost'  </span></span><br><span class=\"line\">config.get(<span class=\"string\">'notThere'</span>); <span class=\"comment\">// 'Missing config key: notThere'</span></span><br></pre></td></tr></table></figure>\n<p>그러나 다음과 같이 빌드 할 수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import withLogging() explicitly in withConfig module  </span></span><br><span class=\"line\"><span class=\"keyword\">import</span> withLogging <span class=\"keyword\">from</span> <span class=\"string\">'./with-logging'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> addConfig = <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> o =&gt; <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;  </span><br><span class=\"line\">  get (key) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> config[key] == <span class=\"literal\">undefined</span> ?   </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.log(<span class=\"string\">`Missing config key: <span class=\"subst\">$&#123; key &#125;</span>`</span>) :  </span><br><span class=\"line\">      config[key]  </span><br><span class=\"line\">    ;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> withConfig = <span class=\"function\">(<span class=\"params\">&#123; initialConfig, logger &#125;</span>) =&gt;</span> o =&gt;  </span><br><span class=\"line\">  pipe(</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// vvv compose explicit dependency in here vvv  </span></span><br><span class=\"line\">    withLogging(logger),  </span><br><span class=\"line\">    <span class=\"comment\">// ^^^ compose explicit dependency in here ^^^</span></span><br><span class=\"line\"></span><br><span class=\"line\">    addConfig(initialConfig)  </span><br><span class=\"line\">  )(o)  </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The factory only needs to know about withConfig now...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> createConfig = <span class=\"function\">(<span class=\"params\">&#123; initialConfig, logger &#125;</span>) =&gt;</span>  </span><br><span class=\"line\">  withConfig(&#123; initialConfig, logger &#125;)(&#123;&#125;)  </span><br><span class=\"line\">;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// elsewhere, in a different module...  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialConfig = &#123;  </span><br><span class=\"line\">  host: <span class=\"string\">'localhost'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"built_in\">console</span>.log.bind(<span class=\"built_in\">console</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = createConfig(&#123;initialConfig, logger&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(config.get(<span class=\"string\">'host'</span>)); <span class=\"comment\">// 'localhost'  </span></span><br><span class=\"line\">config.get(<span class=\"string\">'notThere'</span>); <span class=\"comment\">// 'Missing config key: notThere'</span></span><br></pre></td></tr></table></figure>\n<p>우리는 다양한 요소들을 고려해서 올바른 디자인을 선택해야 합니다.  함수형 믹스인을 사용하기 위해 래핑된 데이터 유형을 요구하는 것은 타당하지만, 그렇다면 이를 함수 서명 및 API 문서에 명시해야합니다.</p>\n<p>그렇기에 암시적인 버전의 함수 서명에는  <code>o</code>  에 대한 기본값이 존재해야합니다. JavaScript에는 타입 주석 기능이 없기 때문에 기본값을 제공하여 모방할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withConfig = <span class=\"function\"><span class=\"params\">config</span> =&gt;</span> (o = &#123;   </span><br><span class=\"line\">log: <span class=\"function\">(<span class=\"params\">text = <span class=\"string\">''</span></span>) =&gt;</span> <span class=\"built_in\">console</span>.log(text)   </span><br><span class=\"line\">&#125;) =&gt; <span class=\"built_in\">Object</span>.assign(&#123;&#125;, o, &#123;   </span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript 또는 Flow를 사용하는 경우 명시적으로 인터페이스를 선언해 객체 요구 사항으로 사용하는 것이 좋습니다.</p>\n<h2>함수형 믹스인 및 함수형 프로그래밍</h2>\n<p>함수형 믹스인에서 &quot;함수형&quot;은 &quot;함수형 프로그래밍&quot;과 같은 뜻을 지니지 않습니다.  함수형 믹스인은 일반적으로 부수작용들이 있는 OOP 스타일로 사용됩니다.  이는 인자로 전달받은 객체를 변경합니다. 주의하십시오.</p>\n<p>마찬가지로 함수형 프로그래밍 스타일을 선호는 일부 개발자들은 전달받은 객체의 주소를 계속 가지고 있지 않습니다.  여러분은 두 스타일을 적절히 혼합하여 사용하는 방식으로 코딩해야합니다.</p>\n<p>즉, 객체 인스턴스를 리턴해야하는 경우 클로저에 있는 인스턴스 대신 항상 <code>this</code>를 리턴하십시오.  이 말은 즉, 그 둘이 동일한 객체가 아닐 가능성이 있다는 것 입니다.  또한  <code>Object.assign()</code> 나  <code>{...object, ...spread}</code>  구문을 사용해서 인스턴스를 복사, 할당한다고 가정할 경우 열거되지 않는 속성이 있으면 최종 객체에서 작동하지 않을 것입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"built_in\">Object</span>.defineProperty(&#123;&#125;, <span class=\"string\">'a'</span>, &#123;  </span><br><span class=\"line\">  enumerable: <span class=\"literal\">false</span>,  </span><br><span class=\"line\">  value: <span class=\"string\">'a'</span>  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;  </span><br><span class=\"line\">  b: <span class=\"string\">'b'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(&#123;...a, ...b&#125;); <span class=\"comment\">// &#123; b: 'b' &#125;</span></span><br></pre></td></tr></table></figure>\n<p>마지막으로, 함수형 코드에서 작성하지 않은 함수 믹스인을 사용하는 경우 코드가 순수하다고 가정하지 마십시오. 기본 객체가 변형 될 수 있고 부수작용이 있으며 참조 투명성이 확보되지 않는다고 가정해야 합니다. 즉, 함수형 믹스인으로 구성된 팩토리는 메모이제이션하기 힘듭니다.</p>\n<h2>결론</h2>\n<p>함수형 믹스인는 조립 라인의 스테이션처럼 객체에 속성 및 동작을 추가하는 합성 가능한 팩토리 함수입니다.  고전적인 클래스(  <strong>is-a</strong>  )처럼 모든 기능을 상속하는 것과는 대조적으로 여러 관계(  <strong>has-a, uses-a, can-do</strong>  )와 기능으로 동작을 정의하는 좋은 방법입니다.</p>\n<p>&quot;함수형 믹스인&quot;은 &quot;함수형 프로그래밍&quot;을 의미하는 것이 아니라 단순히 &quot;함수에 기초한 믹스인&quot;을 의미합니다.  함수형 믹스인은 함수형 프로그래밍 스타일을 사용하여 부수효과를 없애고 참조 투명성을 유지하면서 작성 될 수 있지만 보장되지는 않습니다.  서드파티의 믹스인에는 부수작용과 비결정적인 위험 요소들이 있을 수 있습니다.</p>\n<ul>\n<li>단순한 오브젝트 믹스인와 달리 함수형 믹스인는 비공개 데이터를 상속하는 등 실제 데이터 프라이버시 (캡슐화)를 지원합니다.</li>\n<li>단일 조상 클래스 상속과는 달리, 함수형 믹스인은 클래스 데코레이터, 특성<sup>trait</sup> 또는 다중 상속과 마찬가지로 다양한 조상으로부터 기능을 상속받는데 적합합니다.</li>\n<li>C ++의 다중 상속과는 달리, JavaScript에서는 다이아몬드 문제가 거의 발생하지 않습니다. 충돌이 발생할 때 간단한 규칙이 있기 때문입니다. 마지막으로 추가 된 믹스인이 승리합니다.</li>\n<li>클래스 데코레이터, 특성 또는 다중 상속과 달리 기본 클래스를 필요로 하지 않습니다.</li>\n</ul>\n<p>가장 간단한 구현으로 시작하여 필요한 경우에만보다 복잡한 구현으로 이동하십시오.</p>\n<blockquote>\n<p><strong>함수 &gt; 객체 &gt; 팩토리 함수 &gt; 함수형 믹스인 &gt; 클래스</strong><br>\nFunctions &gt; objects &gt; factory functions &gt; functional mixins &gt; classe</p>\n</blockquote>\n<p><a href=\"https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/\"><strong>다음: ES6+와 팩토리 함수 &gt;</strong></a></p>\n"},{"title":"Functors와 카테고리","catalog":true,"date":"2018-04-07T05:43:48.000Z","subtitle":"Functors and categories","header-img":"bg.jpg","readingTime":8,"catagories":["개발"],"preview":"Functor는 사용자가 맵핑 할 수있는 데이터 타입입니다.  내부의 값에 함수를 적용하는 인터페이스가 있는 컨테이너입니다.  functor를 발견하면  \"mappable\" 한 무언가라고 생각하면 됩니다. functor 타입은 일반적으로 객체처럼 구현되며 구조를 유지한채 입력에서 출력으로 맵핑하는  `.map()`  메소드를 가집니다.  이 때 \"구조 유지\"란 동일한 유형의 functor를 리턴한다는 것을 의미합니다 (컨테이너 내부의 값은 다른 유형 일 수 있음).functor는 무언가를 담을 수 있는 상자^box^와 맵핑^mapping^ 인터페이스를 제공합니다.  배열^Array^은 functor의 좋은 예이며 promise, 스트림, 트리 등 다양한 종류의 객체 또한 _\"mappable\"_ 한 것들입니다. JavaScript에 내장 된 배열 및 promise 객체는 functor처럼 작동합니다. 콜렉션(배열, 스트림 등)은 일반적으로  `.map()`을 사용해서 콜렉션을 순회하며 주어진 함수를 각 값에 적용하지만 모든 functor가 콜렉션처럼 순회하지는 않습니다. 사실 functor는 특정 문맥^context^에서 함수를 적용하는 것에 관한 것입니다.","_content":"\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/functors-categories-61e031bac53f)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/03/31/reduce/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/07/functional-mixins/)\n\n**Functor는**^[펑터라고 발음합니다. 함수자 혹은 함자로 번역이 되는데 그보다는 단어를 그대로 사용하기로 결정했습니다 - 역자] 사용자가 맵핑 할 수있는 **데이터 타입**입니다.  내부의 값에 함수를 적용하는 인터페이스가 있는 **컨테이너**입니다.  functor를 발견하면  _\"mappable\"_ 한 무언가라고 생각하면 됩니다. functor 타입은 일반적으로 객체처럼 구현되며 구조를 유지한채 입력에서 출력으로 맵핑하는  `.map()`  메소드를 가집니다.  이 때 \"구조 유지\"란 동일한 유형의 functor를 리턴한다는 것을 의미합니다 (컨테이너 내부의 값은 다른 유형 일 수 있음).\n\nfunctor는 무언가를 담을 수 있는 상자^box^와 맵핑^mapping^ 인터페이스를 제공합니다.  배열^Array^은 functor의 좋은 예이며 promise, 스트림, 트리 등 다양한 종류의 객체 또한 _\"mappable\"_ 한 것들입니다. JavaScript에 내장 된 배열 및 promise 객체는 functor처럼 작동합니다. 콜렉션(배열, 스트림 등)은 일반적으로  `.map()`을 사용해서 원소들을 순회하며 주어진 함수를 각 값에 적용하지만 모든 functor가 콜렉션처럼 순회하지는 않습니다. 사실 functor란 특정 문맥^context^에서 함수를 적용하는 것에 관한 개념입니다.\n\nPromise는  `.map()`  대신  `.then()`을 사용합니다.  일반적으로  `.then()`을 비동기식  `.map()`메서드로 생각할 수 있습니다. 단, 중첩된 promise가 있는 경우는 예외이며, 자동으로 외부 promise를 처리하지 않습니다.  다시 말하자면 promise가 아닌 값에 대해서  `.then()`은 비동기 `.map()`과 같은 역할을 합니다. 반면에 promise값의 경우  `.then()`은 모나드의 `.chain()` 메서드(`.bind()`  또는  `.flatMap()`이라고도 함)처럼 동작합니다.   따라서 promise은 functor가 아니고 모나드도 아닙니다. 그러나 실제로는 그 둘 중 하나로 취급 할 수 있습니다. 모나드가 무엇인지 몰라도 걱정하지 마십시오. 모나드는 일종의 functor이며, 우리는 먼저 functor에 대해 알아볼 것입니다.\n\n다양한 것들을 functor로 만들어주는 라이브러리들이 있습니다.\n\nHaskell에서 functor 타입은 다음과 같이 정의됩니다.\n```\n fmap :: (a -> b) -> fa -> fb\n```\na를 받아 b를 리턴하는 함수를 인자로 받습니다. 그리고 a가 담긴 functor를 받아 b가 담긴 functor를 리턴합니다.  `fa`  와  `fb`는  \"a의 functor\",  \"b의 functor\"로 읽을 수 있습니다. 즉,  `fa`에는 `a`가 담긴 상자가 있고  `fb`에는 `b`가 담긴 상자가 있습니다.\n\nfunctor를 사용하는 것은 간단합니다.  `map()`을 호출하면 됩니다.\n```javascript\n  const f = [1, 2, 3];   \n  f.map(double);  //[2, 4, 6] \n```\n## Functor's Law\n\n카테고리^[수학의 범주론에 나오는 개념입니다. 이에 대해 [Eugenia Cheng](https://www.amazon.com/s/ref=dp_byline_sr_book_1?ie=UTF8&text=Eugenia+Cheng&search-alias=books&field-author=Eugenia+Cheng&sort=relevancerank)의 How To Bake PI라는 비교적 쉽게 쓰인 입문서가 있습니다. -역자] 에는 두 가지 중요한 속성이 있습니다.\n\n1.  항등^identity^\n2.  합성^composition^\n\nfunctor는 카테고리들 사이의 맵핑이기 때문에, functor는 항등과 합성을 지원해야 합니다. 이 두가지는 functor의 법칙으로 알려져 있습니다.\n\n### 항등Identity\n\n임의의 functor `f`에 항등함수(`x => x`)를 맵핑시키면 동일한 `f`가 리턴되어야 합니다: \n```javascript\n  const f = [1, 2, 3];   \n  f.map(x => x);  // [1, 2, 3] \n```\n### 합성Composition\n\nfunctor는 합성이 가능해야 합니다.  `F.map(x => f(g(x)))`  는  `F.map(g).map(f)`  와 동일합니다.\n\n```\nFunctor.map( f . g ) === Functor.map(g).map(f)\n```\n\n함수 합성이란 어떤 함수의 출력을 다른 함수에 넣는 것입니다. 예를 들어,  인수로 `x`를 가지는 함수 `f`와 `g`가 합성된 `(f ∘ g)(x)`는 `f(g(x))`를 의미합니다.   \n\n함수형 프로그래밍에 나오는 용어는 대부분 범주론^category^ ^theory^에서 왔습니다. 범주론의 핵심은 합성입니다.  범주론이 처음에는 무서워보일 수 있지만 알고보면 쉽습니다. 다이빙 보드에서 뛰어 내리거나 롤러 코스터를 타는 것과 같습니다.  다음은 범주론의 몇 가지 중요한 핵심과 이론적 기초입니다.\n\n-   카테고리는 객체와 객체들간의 화살표의 모음입니다. ( \"객체\"은 문자 그대로 객체^object^ 입니다)^[이때 객체란 어떤 실행 프로세스 내부의 추상화된 인스턴스가 아니라 사물, 어떤 것이라고 이해하면 됩니다. -역자]\n-   화살표는 사상^morphism^입니다^[맵핑과 동일합니다. -역자]. 사상은 코드에서 함수로 구현됩니다.\n-   객체들이 `a -> b -> c`처럼 연결됐을 때  합성을 통해 `a -> c`로 직접 맵핑시킬 수 있어야 합니다.\n-   모든 화살표는 컴포지션으로 나타낼 수 있습니다 (단지 객체 자신을 가리키는 항등 화살표일지라도).  카테고리의 모든 객체에는 항등 화살표가 있습니다.\n\n`a`를 취하여  `b` 를 리턴하는 함수  `g`  가 있고  `b`를 취하여  `c`리턴하는 또 다른 함수  `f`가 있을 때  `f`  와  `g`의 합성을 나타내는 함수  `h`도 있어야합니다.  그러므로  `a -> c`는  `f ∘ g`라는 합성 (`f`  _after_  `g`)이며 `h(x) = f(g(x))`와 같습니다.  함수는 왼쪽에서 오른쪽으로 합성되지 않고 오른쪽에서 왼쪽으로 되기 때문에  `f ∘ g`  는 종종  `f`  _after_  `g`라고 읽습니다.\n\n합성은 **결합법칙**^associative^ ^law^이 적용됩니다.  간단하게 말하자면 함수를 합성할 때 기본적으로 괄호가 필요 없다는 뜻 입니다.\n```\n h∘(g∘f) = (h∘g)∘f = h∘g∘f\n```\n JavaScript 코드로 합성을 다시 한 번 살펴 보겠습니다.\n\n`F`라는 functor가 있을 때:\n\n```javascript\n  const F = [1, 2, 3]; \n```\n다음 두 줄의 코드는 같은 표현입니다.\n```javascript\nF.map(x => f(g(x)));\n\n// is equivalent to...\n\nF.map(g).map(f);\n```\n## Endofunctors^[functor에 붙은 접두사 endo-는 \"inside, within, internal,\"라는 뜻을 가지고 있습니다. 즉, 닫힌계라고 생각하시면 됩니다. 엔도펑터라고 발음합니다. -역자]\n\nendofunctor는 카테고리에서 다시 같은 카테고리로 맵핑되는 functor입니다.\n\nFunctor는 카테고리에서 카테고리로 맵핑 할 수 있습니다.  `X -> Y`\n\nendofunctor는 동일한 카테고리로 맵핑합니다.  `X -> X`\n\n모나드는 endofunctor입니다.  기억나십니까^[전 글 [왜 자바스크립트로 함수형 프로그래밍을 배우는가](https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/)에 나옵니다]:\n\n> _\"모나드는 endofunctor라는 카테고리에 속한 한 monoid에 불과해. 뭐가 문제야?\"_\n> _“A monad is just a monoid in the category of endofunctors. What’s the problem?”_\n\n그 말이 조금 더 이해되었기를 바랍니다. monoid와 monads에 대해선 나중에 알아볼 것입니다.\n\n## Functor 구현하기\n\n여기 간단한 functor가 하나 있습니다 :\n\n```javascript\nconst Identity = value => ({  map: fn => Identity(fn(value))});\n```\n아래 코드를 보면 `Identity`가 functor 법칙을 만족시키는걸 알 수 있습니다 :\n```javascript\n// trace() is a utility to let you easily inspect  \n// the contents.  \nconst trace = x => {  \n  console.log(x);  \n  return x;  \n};\n\nconst u = Identity(2);\n\n// Identity law  \nu.map(trace);             // 2  \nu.map(x => x).map(trace); // 2\n\nconst f = n => n + 1;  \nconst g = n => n * 2;\n\n// Composition law  \nconst r1 = u.map(x => f(g(x)));  \nconst r2 = u.map(g).map(f);\n\nr1.map(trace); // 5  \nr2.map(trace); // 5\n```\n이제 배열을 맵핑하는 것처럼 어떤 데이터 타입이라도 맵핑 할 수 있습니다. 좋군요!\n\n이는 JavaScript로 구현한 **가장** 단순한 functor입니다. 그러나 JavaScript의 데이터 타입들이 지원하는 몇 가지 기능이 빠져 있습니다. 그것들을 추가합시다.  `+`  연산자가 숫자와 문자열 값을 둘 다 처리 할 수 ​​있다면 멋지지 않겠습니까?\n\n따라서 우리가해야 할 일은  `.valueOf()`  구현하는 것이며  `.valueOf()`는 또한 functor에서 값을 푸는^unwrap^ 편리한 방법처럼 보입니다 :\n```javascript\nconst Identity = value => ({  \n  map: fn => Identity(fn(value)),\n\n  valueOf: () => value,  \n});\n\nconst ints = (Identity(2) + Identity(4));  \ntrace(ints); // 6\n\nconst hi = (Identity('h') + Identity('i'));  \ntrace(hi); // \"hi\"\n```\n> _valueOf 메소드는 식이 평가될 때 자동으로 호출됩니다. -역자_\n\n좋습니다.  그러나 콘솔에서  `Identity` 인스턴스를 검사하려면 어떻게해야할까요? `> \"Identity(value)\"`이라고 프린트되면 멋질 것입니다.  `.toString()`  메소드를 추가해봅시다.\n```javascript\ntoString: () => `Identity(${value})`,\n```\n괜찮네요. 이제 JS의 표준 순회 프로토콜을 구현하겠습니다.  커스텀 반복자를 추가하면됩니다 :\n```javascript\n[Symbol.iterator]: function* () {  \n  yield value;  \n}\n```\n\n이제 다음과 같은 작업을 수행 할 수 있습니다.\n\n```javascript\n// [Symbol.iterator] enables standard JS iterations:  \nconst arr = [6, 7, ...Identity(8)];  \ntrace(arr); // [6, 7, 8]\n```\n만약 `Identity(n)`을 받아  `n + 1`  ,  `n + 2`등을 포함하는 `Identity` 배열을 리턴하려면 어떻게 해야 합니까? 참 쉽죠 ?\n```javascript\nconst fRange = (  \n  start,  \n  end  \n) => Array.from(  \n  { length: end - start + 1 },  \n  (x, i) => Identity(i + start)  \n);\n```\n> _Array.from은 첫번째 인자로 유사배열( length속성이 있는 객체)를 받고 두번째 인자(옵션)로 생성시 맵핑할 함수를 받습니다. -역자_\n\n자 이제, 만약 `fRange`가 임의의 functor에 대해 기능하게 하고싶습니다.  데이터 타입의 각 인스턴스가 생성자`constructor`에 대한 참조를 가져야 한다는 스펙이 있다면 어떨까요?  바꿔봅시다 :\n```javascript\nconst fRange = (  \n  start,  \n  end  \n) => Array.from(  \n  { length: end - start + 1 },  \n    \n  // change `Identity` to `start.constructor`  \n  (x, i) => start.constructor(i + start)  \n);\n\nconst range = fRange(Identity(2), 4);  \nrange.map(x => x.map(trace)); // 2, 3, 4\n```\n값이 functor인지 테스트 하려면 어떻게해야할까요?  이를 위해  `Identity`에 `is(x)`라는 정적 메소드와 `.toString()` 정적 메소드를 하나 추가해줍니다.\n```javascript\nObject.assign(Identity, {  \n  toString: () => 'Identity',  \n  is: x => typeof x.map === 'function'  \n});\n```\n```javascript\nconst a = Identity(5);\nIdentity.is(a) // true;\n```\n\n이 모든 것들을 하나로 합쳐보겠습니다.\n\n```javascript\nconst Identity = value => ({  \n  map: fn => Identity(fn(value)),  \n  valueOf: () => value,  \n  toString: () => `Identity(${value})`,  \n  [Symbol.iterator]: function* () {  \n    yield value;  \n  },  \n  constructor: Identity  \n});\n\nObject.assign(Identity, {  \n  toString: () => 'Identity',  \n  is: x => typeof x.map === 'function'  \n});\n```\nfunctor 나 endofunctor에 속하기 위해 위 코드들이 전부 필요하지는 않습니다. 편의성을 위해 추가한 것들일 뿐입니다.  functor가 되기 위해서는 functor법칙 두가지를 충족 시키는 `.map()` 인터페이스만 있으면 됩니다.\n\n## 왜 Functors를 사용할까요?\n\nFunctor를 사용하는데는 여러 이유가 있습니다. 무엇보다 중요한 것은 다양한 데이터 유형에 대해 작동하는 공통 인터페이스를 구현하는 것입니다.  예를 들어, functor내의 값이  `undefined`거나  `null`이 아닌 경우에만 연산이 되게 하려면 어떡해야 할까요?\n```javascript\n// Create the predicate  \nconst exists = x => (x.valueOf() !== undefined \n                  && x.valueOf() !== null);\n\nconst ifExists = x => ({  \n  map: fn => exists(x) ? x.map(fn) : x  \n});\n\nconst add1 = n => n + 1;  \nconst double = n => n * 2;\n\n// Nothing happens...  \nifExists(Identity(undefined)).map(trace);  \n// Still nothing...  \nifExists(Identity(null)).map(trace);\n\n// 42  \nifExists(Identity(20))  \n  .map(add1)  \n  .map(double)  \n  .map(trace)  \n;\n```\n마지막으로 함수형 프로그래밍의 주요 관심사는 작은 함수들을 조합하여 높은 수준으로 추상화된 코드를 작성하는 것입니다.  따라서 어떤 functor에서도 작동하는 _generic_ `map`을 만들어 보겠습니다. `fn` 함수를 인수로 부분적용해서 functor를 받는 새 함수를 리턴하게 하면 됩니다.\n\n쉽습니다. 좋아하는 `auto-curry`라이브러리를 가져오거나 이전에 사용했던 마법을 쓰면 됩니다.\n```javascript\nconst curry = (  \n  f, arr = []  \n) => (...args) => (  \n  a => a.length === f.length ?  \n    f(...a) :  \n    curry(f, a)  \n)([...arr, ...args]);\n```\n이제 `map`을 우리가 원하는데로 다룰 수 있습니다.\n```javascript\n const map = curry((fn, F) => F.map(fn));\n\n const double = n => n * 2;\n\n const mdouble = map(double);   \n mdouble(Identity(4)).map(trace); // 8\n```\n### 결론\n\nFunctor는 우리가 맵핑할 수 있는 것들 입니다. 형식적으로 말하자면, functor는 카테고리에서 카테고리로의 맵핑입니다.  어떤 functor는 카테고리에서 다시 같은 카테고리로 맵핑 될 수 있습니다. (_endofunctor_)\n\n카테고리는 객체의 집합이며 객체를 연결하는 화살표가 있습니다.  화살표는 morphisms(혹은 함수 또는 조합^[composition을 여기서는 조합이라 번역했습니다])을 뜻합니다. 카테고리의 각 객체는 항등 morphism(`x => x`)을 가집니다.  `A -> B -> C`로 객체가 사상될 경우,  `A -> C`로의 연결이 있어야합니다.\n\nfunctor는 모든 데이터 유형에서 작동하는 다양한 공용 함수를 만들 수있는 훌륭한 고차원 추상화입니다.\n\n[**다음: 함수형 믹스인 >**](https://midojeong.github.io/2018/04/07/functional-mixins/)","source":"_posts/functors-and-categories.md","raw":"---\ntitle: Functors와 카테고리\ncatalog: true\ndate: 2018-04-07 14:43:48\nsubtitle: Functors and categories\nheader-img: \"bg.jpg\"\nreadingTime: 8\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: Functor는 사용자가 맵핑 할 수있는 데이터 타입입니다.  내부의 값에 함수를 적용하는 인터페이스가 있는 컨테이너입니다.  functor를 발견하면  \"mappable\" 한 무언가라고 생각하면 됩니다. functor 타입은 일반적으로 객체처럼 구현되며 구조를 유지한채 입력에서 출력으로 맵핑하는  `.map()`  메소드를 가집니다.  이 때 \"구조 유지\"란 동일한 유형의 functor를 리턴한다는 것을 의미합니다 (컨테이너 내부의 값은 다른 유형 일 수 있음).functor는 무언가를 담을 수 있는 상자^box^와 맵핑^mapping^ 인터페이스를 제공합니다.  배열^Array^은 functor의 좋은 예이며 promise, 스트림, 트리 등 다양한 종류의 객체 또한 _\"mappable\"_ 한 것들입니다. JavaScript에 내장 된 배열 및 promise 객체는 functor처럼 작동합니다. 콜렉션(배열, 스트림 등)은 일반적으로  `.map()`을 사용해서 콜렉션을 순회하며 주어진 함수를 각 값에 적용하지만 모든 functor가 콜렉션처럼 순회하지는 않습니다. 사실 functor는 특정 문맥^context^에서 함수를 적용하는 것에 관한 것입니다.\n---\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/functors-categories-61e031bac53f)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/03/31/reduce/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/07/functional-mixins/)\n\n**Functor는**^[펑터라고 발음합니다. 함수자 혹은 함자로 번역이 되는데 그보다는 단어를 그대로 사용하기로 결정했습니다 - 역자] 사용자가 맵핑 할 수있는 **데이터 타입**입니다.  내부의 값에 함수를 적용하는 인터페이스가 있는 **컨테이너**입니다.  functor를 발견하면  _\"mappable\"_ 한 무언가라고 생각하면 됩니다. functor 타입은 일반적으로 객체처럼 구현되며 구조를 유지한채 입력에서 출력으로 맵핑하는  `.map()`  메소드를 가집니다.  이 때 \"구조 유지\"란 동일한 유형의 functor를 리턴한다는 것을 의미합니다 (컨테이너 내부의 값은 다른 유형 일 수 있음).\n\nfunctor는 무언가를 담을 수 있는 상자^box^와 맵핑^mapping^ 인터페이스를 제공합니다.  배열^Array^은 functor의 좋은 예이며 promise, 스트림, 트리 등 다양한 종류의 객체 또한 _\"mappable\"_ 한 것들입니다. JavaScript에 내장 된 배열 및 promise 객체는 functor처럼 작동합니다. 콜렉션(배열, 스트림 등)은 일반적으로  `.map()`을 사용해서 원소들을 순회하며 주어진 함수를 각 값에 적용하지만 모든 functor가 콜렉션처럼 순회하지는 않습니다. 사실 functor란 특정 문맥^context^에서 함수를 적용하는 것에 관한 개념입니다.\n\nPromise는  `.map()`  대신  `.then()`을 사용합니다.  일반적으로  `.then()`을 비동기식  `.map()`메서드로 생각할 수 있습니다. 단, 중첩된 promise가 있는 경우는 예외이며, 자동으로 외부 promise를 처리하지 않습니다.  다시 말하자면 promise가 아닌 값에 대해서  `.then()`은 비동기 `.map()`과 같은 역할을 합니다. 반면에 promise값의 경우  `.then()`은 모나드의 `.chain()` 메서드(`.bind()`  또는  `.flatMap()`이라고도 함)처럼 동작합니다.   따라서 promise은 functor가 아니고 모나드도 아닙니다. 그러나 실제로는 그 둘 중 하나로 취급 할 수 있습니다. 모나드가 무엇인지 몰라도 걱정하지 마십시오. 모나드는 일종의 functor이며, 우리는 먼저 functor에 대해 알아볼 것입니다.\n\n다양한 것들을 functor로 만들어주는 라이브러리들이 있습니다.\n\nHaskell에서 functor 타입은 다음과 같이 정의됩니다.\n```\n fmap :: (a -> b) -> fa -> fb\n```\na를 받아 b를 리턴하는 함수를 인자로 받습니다. 그리고 a가 담긴 functor를 받아 b가 담긴 functor를 리턴합니다.  `fa`  와  `fb`는  \"a의 functor\",  \"b의 functor\"로 읽을 수 있습니다. 즉,  `fa`에는 `a`가 담긴 상자가 있고  `fb`에는 `b`가 담긴 상자가 있습니다.\n\nfunctor를 사용하는 것은 간단합니다.  `map()`을 호출하면 됩니다.\n```javascript\n  const f = [1, 2, 3];   \n  f.map(double);  //[2, 4, 6] \n```\n## Functor's Law\n\n카테고리^[수학의 범주론에 나오는 개념입니다. 이에 대해 [Eugenia Cheng](https://www.amazon.com/s/ref=dp_byline_sr_book_1?ie=UTF8&text=Eugenia+Cheng&search-alias=books&field-author=Eugenia+Cheng&sort=relevancerank)의 How To Bake PI라는 비교적 쉽게 쓰인 입문서가 있습니다. -역자] 에는 두 가지 중요한 속성이 있습니다.\n\n1.  항등^identity^\n2.  합성^composition^\n\nfunctor는 카테고리들 사이의 맵핑이기 때문에, functor는 항등과 합성을 지원해야 합니다. 이 두가지는 functor의 법칙으로 알려져 있습니다.\n\n### 항등Identity\n\n임의의 functor `f`에 항등함수(`x => x`)를 맵핑시키면 동일한 `f`가 리턴되어야 합니다: \n```javascript\n  const f = [1, 2, 3];   \n  f.map(x => x);  // [1, 2, 3] \n```\n### 합성Composition\n\nfunctor는 합성이 가능해야 합니다.  `F.map(x => f(g(x)))`  는  `F.map(g).map(f)`  와 동일합니다.\n\n```\nFunctor.map( f . g ) === Functor.map(g).map(f)\n```\n\n함수 합성이란 어떤 함수의 출력을 다른 함수에 넣는 것입니다. 예를 들어,  인수로 `x`를 가지는 함수 `f`와 `g`가 합성된 `(f ∘ g)(x)`는 `f(g(x))`를 의미합니다.   \n\n함수형 프로그래밍에 나오는 용어는 대부분 범주론^category^ ^theory^에서 왔습니다. 범주론의 핵심은 합성입니다.  범주론이 처음에는 무서워보일 수 있지만 알고보면 쉽습니다. 다이빙 보드에서 뛰어 내리거나 롤러 코스터를 타는 것과 같습니다.  다음은 범주론의 몇 가지 중요한 핵심과 이론적 기초입니다.\n\n-   카테고리는 객체와 객체들간의 화살표의 모음입니다. ( \"객체\"은 문자 그대로 객체^object^ 입니다)^[이때 객체란 어떤 실행 프로세스 내부의 추상화된 인스턴스가 아니라 사물, 어떤 것이라고 이해하면 됩니다. -역자]\n-   화살표는 사상^morphism^입니다^[맵핑과 동일합니다. -역자]. 사상은 코드에서 함수로 구현됩니다.\n-   객체들이 `a -> b -> c`처럼 연결됐을 때  합성을 통해 `a -> c`로 직접 맵핑시킬 수 있어야 합니다.\n-   모든 화살표는 컴포지션으로 나타낼 수 있습니다 (단지 객체 자신을 가리키는 항등 화살표일지라도).  카테고리의 모든 객체에는 항등 화살표가 있습니다.\n\n`a`를 취하여  `b` 를 리턴하는 함수  `g`  가 있고  `b`를 취하여  `c`리턴하는 또 다른 함수  `f`가 있을 때  `f`  와  `g`의 합성을 나타내는 함수  `h`도 있어야합니다.  그러므로  `a -> c`는  `f ∘ g`라는 합성 (`f`  _after_  `g`)이며 `h(x) = f(g(x))`와 같습니다.  함수는 왼쪽에서 오른쪽으로 합성되지 않고 오른쪽에서 왼쪽으로 되기 때문에  `f ∘ g`  는 종종  `f`  _after_  `g`라고 읽습니다.\n\n합성은 **결합법칙**^associative^ ^law^이 적용됩니다.  간단하게 말하자면 함수를 합성할 때 기본적으로 괄호가 필요 없다는 뜻 입니다.\n```\n h∘(g∘f) = (h∘g)∘f = h∘g∘f\n```\n JavaScript 코드로 합성을 다시 한 번 살펴 보겠습니다.\n\n`F`라는 functor가 있을 때:\n\n```javascript\n  const F = [1, 2, 3]; \n```\n다음 두 줄의 코드는 같은 표현입니다.\n```javascript\nF.map(x => f(g(x)));\n\n// is equivalent to...\n\nF.map(g).map(f);\n```\n## Endofunctors^[functor에 붙은 접두사 endo-는 \"inside, within, internal,\"라는 뜻을 가지고 있습니다. 즉, 닫힌계라고 생각하시면 됩니다. 엔도펑터라고 발음합니다. -역자]\n\nendofunctor는 카테고리에서 다시 같은 카테고리로 맵핑되는 functor입니다.\n\nFunctor는 카테고리에서 카테고리로 맵핑 할 수 있습니다.  `X -> Y`\n\nendofunctor는 동일한 카테고리로 맵핑합니다.  `X -> X`\n\n모나드는 endofunctor입니다.  기억나십니까^[전 글 [왜 자바스크립트로 함수형 프로그래밍을 배우는가](https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/)에 나옵니다]:\n\n> _\"모나드는 endofunctor라는 카테고리에 속한 한 monoid에 불과해. 뭐가 문제야?\"_\n> _“A monad is just a monoid in the category of endofunctors. What’s the problem?”_\n\n그 말이 조금 더 이해되었기를 바랍니다. monoid와 monads에 대해선 나중에 알아볼 것입니다.\n\n## Functor 구현하기\n\n여기 간단한 functor가 하나 있습니다 :\n\n```javascript\nconst Identity = value => ({  map: fn => Identity(fn(value))});\n```\n아래 코드를 보면 `Identity`가 functor 법칙을 만족시키는걸 알 수 있습니다 :\n```javascript\n// trace() is a utility to let you easily inspect  \n// the contents.  \nconst trace = x => {  \n  console.log(x);  \n  return x;  \n};\n\nconst u = Identity(2);\n\n// Identity law  \nu.map(trace);             // 2  \nu.map(x => x).map(trace); // 2\n\nconst f = n => n + 1;  \nconst g = n => n * 2;\n\n// Composition law  \nconst r1 = u.map(x => f(g(x)));  \nconst r2 = u.map(g).map(f);\n\nr1.map(trace); // 5  \nr2.map(trace); // 5\n```\n이제 배열을 맵핑하는 것처럼 어떤 데이터 타입이라도 맵핑 할 수 있습니다. 좋군요!\n\n이는 JavaScript로 구현한 **가장** 단순한 functor입니다. 그러나 JavaScript의 데이터 타입들이 지원하는 몇 가지 기능이 빠져 있습니다. 그것들을 추가합시다.  `+`  연산자가 숫자와 문자열 값을 둘 다 처리 할 수 ​​있다면 멋지지 않겠습니까?\n\n따라서 우리가해야 할 일은  `.valueOf()`  구현하는 것이며  `.valueOf()`는 또한 functor에서 값을 푸는^unwrap^ 편리한 방법처럼 보입니다 :\n```javascript\nconst Identity = value => ({  \n  map: fn => Identity(fn(value)),\n\n  valueOf: () => value,  \n});\n\nconst ints = (Identity(2) + Identity(4));  \ntrace(ints); // 6\n\nconst hi = (Identity('h') + Identity('i'));  \ntrace(hi); // \"hi\"\n```\n> _valueOf 메소드는 식이 평가될 때 자동으로 호출됩니다. -역자_\n\n좋습니다.  그러나 콘솔에서  `Identity` 인스턴스를 검사하려면 어떻게해야할까요? `> \"Identity(value)\"`이라고 프린트되면 멋질 것입니다.  `.toString()`  메소드를 추가해봅시다.\n```javascript\ntoString: () => `Identity(${value})`,\n```\n괜찮네요. 이제 JS의 표준 순회 프로토콜을 구현하겠습니다.  커스텀 반복자를 추가하면됩니다 :\n```javascript\n[Symbol.iterator]: function* () {  \n  yield value;  \n}\n```\n\n이제 다음과 같은 작업을 수행 할 수 있습니다.\n\n```javascript\n// [Symbol.iterator] enables standard JS iterations:  \nconst arr = [6, 7, ...Identity(8)];  \ntrace(arr); // [6, 7, 8]\n```\n만약 `Identity(n)`을 받아  `n + 1`  ,  `n + 2`등을 포함하는 `Identity` 배열을 리턴하려면 어떻게 해야 합니까? 참 쉽죠 ?\n```javascript\nconst fRange = (  \n  start,  \n  end  \n) => Array.from(  \n  { length: end - start + 1 },  \n  (x, i) => Identity(i + start)  \n);\n```\n> _Array.from은 첫번째 인자로 유사배열( length속성이 있는 객체)를 받고 두번째 인자(옵션)로 생성시 맵핑할 함수를 받습니다. -역자_\n\n자 이제, 만약 `fRange`가 임의의 functor에 대해 기능하게 하고싶습니다.  데이터 타입의 각 인스턴스가 생성자`constructor`에 대한 참조를 가져야 한다는 스펙이 있다면 어떨까요?  바꿔봅시다 :\n```javascript\nconst fRange = (  \n  start,  \n  end  \n) => Array.from(  \n  { length: end - start + 1 },  \n    \n  // change `Identity` to `start.constructor`  \n  (x, i) => start.constructor(i + start)  \n);\n\nconst range = fRange(Identity(2), 4);  \nrange.map(x => x.map(trace)); // 2, 3, 4\n```\n값이 functor인지 테스트 하려면 어떻게해야할까요?  이를 위해  `Identity`에 `is(x)`라는 정적 메소드와 `.toString()` 정적 메소드를 하나 추가해줍니다.\n```javascript\nObject.assign(Identity, {  \n  toString: () => 'Identity',  \n  is: x => typeof x.map === 'function'  \n});\n```\n```javascript\nconst a = Identity(5);\nIdentity.is(a) // true;\n```\n\n이 모든 것들을 하나로 합쳐보겠습니다.\n\n```javascript\nconst Identity = value => ({  \n  map: fn => Identity(fn(value)),  \n  valueOf: () => value,  \n  toString: () => `Identity(${value})`,  \n  [Symbol.iterator]: function* () {  \n    yield value;  \n  },  \n  constructor: Identity  \n});\n\nObject.assign(Identity, {  \n  toString: () => 'Identity',  \n  is: x => typeof x.map === 'function'  \n});\n```\nfunctor 나 endofunctor에 속하기 위해 위 코드들이 전부 필요하지는 않습니다. 편의성을 위해 추가한 것들일 뿐입니다.  functor가 되기 위해서는 functor법칙 두가지를 충족 시키는 `.map()` 인터페이스만 있으면 됩니다.\n\n## 왜 Functors를 사용할까요?\n\nFunctor를 사용하는데는 여러 이유가 있습니다. 무엇보다 중요한 것은 다양한 데이터 유형에 대해 작동하는 공통 인터페이스를 구현하는 것입니다.  예를 들어, functor내의 값이  `undefined`거나  `null`이 아닌 경우에만 연산이 되게 하려면 어떡해야 할까요?\n```javascript\n// Create the predicate  \nconst exists = x => (x.valueOf() !== undefined \n                  && x.valueOf() !== null);\n\nconst ifExists = x => ({  \n  map: fn => exists(x) ? x.map(fn) : x  \n});\n\nconst add1 = n => n + 1;  \nconst double = n => n * 2;\n\n// Nothing happens...  \nifExists(Identity(undefined)).map(trace);  \n// Still nothing...  \nifExists(Identity(null)).map(trace);\n\n// 42  \nifExists(Identity(20))  \n  .map(add1)  \n  .map(double)  \n  .map(trace)  \n;\n```\n마지막으로 함수형 프로그래밍의 주요 관심사는 작은 함수들을 조합하여 높은 수준으로 추상화된 코드를 작성하는 것입니다.  따라서 어떤 functor에서도 작동하는 _generic_ `map`을 만들어 보겠습니다. `fn` 함수를 인수로 부분적용해서 functor를 받는 새 함수를 리턴하게 하면 됩니다.\n\n쉽습니다. 좋아하는 `auto-curry`라이브러리를 가져오거나 이전에 사용했던 마법을 쓰면 됩니다.\n```javascript\nconst curry = (  \n  f, arr = []  \n) => (...args) => (  \n  a => a.length === f.length ?  \n    f(...a) :  \n    curry(f, a)  \n)([...arr, ...args]);\n```\n이제 `map`을 우리가 원하는데로 다룰 수 있습니다.\n```javascript\n const map = curry((fn, F) => F.map(fn));\n\n const double = n => n * 2;\n\n const mdouble = map(double);   \n mdouble(Identity(4)).map(trace); // 8\n```\n### 결론\n\nFunctor는 우리가 맵핑할 수 있는 것들 입니다. 형식적으로 말하자면, functor는 카테고리에서 카테고리로의 맵핑입니다.  어떤 functor는 카테고리에서 다시 같은 카테고리로 맵핑 될 수 있습니다. (_endofunctor_)\n\n카테고리는 객체의 집합이며 객체를 연결하는 화살표가 있습니다.  화살표는 morphisms(혹은 함수 또는 조합^[composition을 여기서는 조합이라 번역했습니다])을 뜻합니다. 카테고리의 각 객체는 항등 morphism(`x => x`)을 가집니다.  `A -> B -> C`로 객체가 사상될 경우,  `A -> C`로의 연결이 있어야합니다.\n\nfunctor는 모든 데이터 유형에서 작동하는 다양한 공용 함수를 만들 수있는 훌륭한 고차원 추상화입니다.\n\n[**다음: 함수형 믹스인 >**](https://midojeong.github.io/2018/04/07/functional-mixins/)","slug":"functors-and-categories","published":1,"updated":"2018-04-28T13:35:13.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83d7000cifp6r0u9xkw4","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/functors-categories-61e031bac53f\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/31/reduce/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/07/functional-mixins/\">다음&gt;</a></p>\n</blockquote>\n<p><strong>Functor는</strong><sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> 사용자가 맵핑 할 수있는 <strong>데이터 타입</strong>입니다.  내부의 값에 함수를 적용하는 인터페이스가 있는 <strong>컨테이너</strong>입니다.  functor를 발견하면  <em>“mappable”</em> 한 무언가라고 생각하면 됩니다. functor 타입은 일반적으로 객체처럼 구현되며 구조를 유지한채 입력에서 출력으로 맵핑하는  <code>.map()</code>  메소드를 가집니다.  이 때 &quot;구조 유지&quot;란 동일한 유형의 functor를 리턴한다는 것을 의미합니다 (컨테이너 내부의 값은 다른 유형 일 수 있음).</p>\n<p>functor는 무언가를 담을 수 있는 상자<sup>box</sup>와 맵핑<sup>mapping</sup> 인터페이스를 제공합니다.  배열<sup>Array</sup>은 functor의 좋은 예이며 promise, 스트림, 트리 등 다양한 종류의 객체 또한 <em>“mappable”</em> 한 것들입니다. JavaScript에 내장 된 배열 및 promise 객체는 functor처럼 작동합니다. 콜렉션(배열, 스트림 등)은 일반적으로  <code>.map()</code>을 사용해서 원소들을 순회하며 주어진 함수를 각 값에 적용하지만 모든 functor가 콜렉션처럼 순회하지는 않습니다. 사실 functor란 특정 문맥<sup>context</sup>에서 함수를 적용하는 것에 관한 개념입니다.</p>\n<p>Promise는  <code>.map()</code>  대신  <code>.then()</code>을 사용합니다.  일반적으로  <code>.then()</code>을 비동기식  <code>.map()</code>메서드로 생각할 수 있습니다. 단, 중첩된 promise가 있는 경우는 예외이며, 자동으로 외부 promise를 처리하지 않습니다.  다시 말하자면 promise가 아닌 값에 대해서  <code>.then()</code>은 비동기 <code>.map()</code>과 같은 역할을 합니다. 반면에 promise값의 경우  <code>.then()</code>은 모나드의 <code>.chain()</code> 메서드(<code>.bind()</code>  또는  <code>.flatMap()</code>이라고도 함)처럼 동작합니다.   따라서 promise은 functor가 아니고 모나드도 아닙니다. 그러나 실제로는 그 둘 중 하나로 취급 할 수 있습니다. 모나드가 무엇인지 몰라도 걱정하지 마십시오. 모나드는 일종의 functor이며, 우리는 먼저 functor에 대해 알아볼 것입니다.</p>\n<p>다양한 것들을 functor로 만들어주는 라이브러리들이 있습니다.</p>\n<p>Haskell에서 functor 타입은 다음과 같이 정의됩니다.</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">fmap</span> :: (a -&gt;</span> <span class=\"function\"><span class=\"title\">b</span>) -&gt;</span> <span class=\"function\"><span class=\"title\">fa</span> -&gt;</span> fb</span><br></pre></td></tr></table></figure>\n<p>a를 받아 b를 리턴하는 함수를 인자로 받습니다. 그리고 a가 담긴 functor를 받아 b가 담긴 functor를 리턴합니다.  <code>fa</code>  와  <code>fb</code>는  “a의 functor”,  &quot;b의 functor&quot;로 읽을 수 있습니다. 즉,  <code>fa</code>에는 <code>a</code>가 담긴 상자가 있고  <code>fb</code>에는 <code>b</code>가 담긴 상자가 있습니다.</p>\n<p>functor를 사용하는 것은 간단합니다.  <code>map()</code>을 호출하면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];   </span><br><span class=\"line\">f.map(double);  <span class=\"comment\">//[2, 4, 6]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"functors-law\">Functor’s Law</h2>\n<p>카테고리<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup> 에는 두 가지 중요한 속성이 있습니다.</p>\n<ol>\n<li>항등<sup>identity</sup></li>\n<li>합성<sup>composition</sup></li>\n</ol>\n<p>functor는 카테고리들 사이의 맵핑이기 때문에, functor는 항등과 합성을 지원해야 합니다. 이 두가지는 functor의 법칙으로 알려져 있습니다.</p>\n<h3 id=\"항등identity\">항등Identity</h3>\n<p>임의의 functor <code>f</code>에 항등함수(<code>x =&gt; x</code>)를 맵핑시키면 동일한 <code>f</code>가 리턴되어야 합니다:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];   </span><br><span class=\"line\">f.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x);  <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"합성composition\">합성Composition</h3>\n<p>functor는 합성이 가능해야 합니다.  <code>F.map(x =&gt; f(g(x)))</code>  는  <code>F.map(g).map(f)</code>  와 동일합니다.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Functor.<span class=\"built_in\">map</span>( f . g ) === Functor.<span class=\"built_in\">map</span>(g).<span class=\"built_in\">map</span>(f)</span><br></pre></td></tr></table></figure>\n<p>함수 합성이란 어떤 함수의 출력을 다른 함수에 넣는 것입니다. 예를 들어,  인수로 <code>x</code>를 가지는 함수 <code>f</code>와 <code>g</code>가 합성된 <code>(f ∘ g)(x)</code>는 <code>f(g(x))</code>를 의미합니다.</p>\n<p>함수형 프로그래밍에 나오는 용어는 대부분 범주론<sup>category</sup> <sup>theory</sup>에서 왔습니다. 범주론의 핵심은 합성입니다.  범주론이 처음에는 무서워보일 수 있지만 알고보면 쉽습니다. 다이빙 보드에서 뛰어 내리거나 롤러 코스터를 타는 것과 같습니다.  다음은 범주론의 몇 가지 중요한 핵심과 이론적 기초입니다.</p>\n<ul>\n<li>카테고리는 객체와 객체들간의 화살표의 모음입니다. ( &quot;객체&quot;은 문자 그대로 객체<sup>object</sup> 입니다)<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup></li>\n<li>화살표는 사상<sup>morphism</sup>입니다<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>. 사상은 코드에서 함수로 구현됩니다.</li>\n<li>객체들이 <code>a -&gt; b -&gt; c</code>처럼 연결됐을 때  합성을 통해 <code>a -&gt; c</code>로 직접 맵핑시킬 수 있어야 합니다.</li>\n<li>모든 화살표는 컴포지션으로 나타낼 수 있습니다 (단지 객체 자신을 가리키는 항등 화살표일지라도).  카테고리의 모든 객체에는 항등 화살표가 있습니다.</li>\n</ul>\n<p><code>a</code>를 취하여  <code>b</code> 를 리턴하는 함수  <code>g</code>  가 있고  <code>b</code>를 취하여  <code>c</code>리턴하는 또 다른 함수  <code>f</code>가 있을 때  <code>f</code>  와  <code>g</code>의 합성을 나타내는 함수  <code>h</code>도 있어야합니다.  그러므로  <code>a -&gt; c</code>는  <code>f ∘ g</code>라는 합성 (<code>f</code>  <em>after</em>  <code>g</code>)이며 <code>h(x) = f(g(x))</code>와 같습니다.  함수는 왼쪽에서 오른쪽으로 합성되지 않고 오른쪽에서 왼쪽으로 되기 때문에  <code>f ∘ g</code>  는 종종  <code>f</code>  <em>after</em>  <code>g</code>라고 읽습니다.</p>\n<p>합성은 <strong>결합법칙</strong><sup>associative</sup> <sup>law</sup>이 적용됩니다.  간단하게 말하자면 함수를 합성할 때 기본적으로 괄호가 필요 없다는 뜻 입니다.</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h∘<span class=\"comment\">(g∘f)</span> = <span class=\"comment\">(h∘g)</span>∘f = h∘g∘f</span><br></pre></td></tr></table></figure>\n<p>JavaScript 코드로 합성을 다시 한 번 살펴 보겠습니다.</p>\n<p><code>F</code>라는 functor가 있을 때:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> F = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>다음 두 줄의 코드는 같은 표현입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> f(g(x)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// is equivalent to...</span></span><br><span class=\"line\"></span><br><span class=\"line\">F.map(g).map(f);</span><br></pre></td></tr></table></figure>\n<h2 id=\"endofunctors5\">Endofunctors<sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup></h2>\n<p>endofunctor는 카테고리에서 다시 같은 카테고리로 맵핑되는 functor입니다.</p>\n<p>Functor는 카테고리에서 카테고리로 맵핑 할 수 있습니다.  <code>X -&gt; Y</code></p>\n<p>endofunctor는 동일한 카테고리로 맵핑합니다.  <code>X -&gt; X</code></p>\n<p>모나드는 endofunctor입니다.  기억나십니까<sup class=\"footnote-ref\"><a href=\"#fn6\" id=\"fnref6\">[6]</a></sup>:</p>\n<blockquote>\n<p><em>“모나드는 endofunctor라는 카테고리에 속한 한 monoid에 불과해. 뭐가 문제야?”</em><br>\n<em>“A monad is just a monoid in the category of endofunctors. What’s the problem?”</em></p>\n</blockquote>\n<p>그 말이 조금 더 이해되었기를 바랍니다. monoid와 monads에 대해선 나중에 알아볼 것입니다.</p>\n<h2 id=\"functor-구현하기\">Functor 구현하기</h2>\n<p>여기 간단한 functor가 하나 있습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Identity = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  <span class=\"attr\">map</span>: <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> Identity(fn(value))&#125;);</span><br></pre></td></tr></table></figure>\n<p>아래 코드를 보면 <code>Identity</code>가 functor 법칙을 만족시키는걸 알 수 있습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// trace() is a utility to let you easily inspect  </span></span><br><span class=\"line\"><span class=\"comment\">// the contents.  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> trace = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> u = Identity(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Identity law  </span></span><br><span class=\"line\">u.map(trace);             <span class=\"comment\">// 2  </span></span><br><span class=\"line\">u.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x).map(trace); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Composition law  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> r1 = u.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> f(g(x)));  </span><br><span class=\"line\"><span class=\"keyword\">const</span> r2 = u.map(g).map(f);</span><br><span class=\"line\"></span><br><span class=\"line\">r1.map(trace); <span class=\"comment\">// 5  </span></span><br><span class=\"line\">r2.map(trace); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>이제 배열을 맵핑하는 것처럼 어떤 데이터 타입이라도 맵핑 할 수 있습니다. 좋군요!</p>\n<p>이는 JavaScript로 구현한 <strong>가장</strong> 단순한 functor입니다. 그러나 JavaScript의 데이터 타입들이 지원하는 몇 가지 기능이 빠져 있습니다. 그것들을 추가합시다.  <code>+</code>  연산자가 숫자와 문자열 값을 둘 다 처리 할 수 ​​있다면 멋지지 않겠습니까?</p>\n<p>따라서 우리가해야 할 일은  <code>.valueOf()</code>  구현하는 것이며  <code>.valueOf()</code>는 또한 functor에서 값을 푸는<sup>unwrap</sup> 편리한 방법처럼 보입니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Identity = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  map: <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> Identity(fn(value)),</span><br><span class=\"line\"></span><br><span class=\"line\">  valueOf: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> value,  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ints = (Identity(<span class=\"number\">2</span>) + Identity(<span class=\"number\">4</span>));  </span><br><span class=\"line\">trace(ints); <span class=\"comment\">// 6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hi = (Identity(<span class=\"string\">'h'</span>) + Identity(<span class=\"string\">'i'</span>));  </span><br><span class=\"line\">trace(hi); <span class=\"comment\">// \"hi\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><em>valueOf 메소드는 식이 평가될 때 자동으로 호출됩니다. -역자</em></p>\n</blockquote>\n<p>좋습니다.  그러나 콘솔에서  <code>Identity</code> 인스턴스를 검사하려면 어떻게해야할까요? <code>&gt; &quot;Identity(value)&quot;</code>이라고 프린트되면 멋질 것입니다.  <code>.toString()</code>  메소드를 추가해봅시다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`Identity(<span class=\"subst\">$&#123;value&#125;</span>)`</span>,</span><br></pre></td></tr></table></figure>\n<p>괜찮네요. 이제 JS의 표준 순회 프로토콜을 구현하겠습니다.  커스텀 반복자를 추가하면됩니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">Symbol</span>.iterator]: <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">yield</span> value;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 다음과 같은 작업을 수행 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [Symbol.iterator] enables standard JS iterations:  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">6</span>, <span class=\"number\">7</span>, ...Identity(<span class=\"number\">8</span>)];  </span><br><span class=\"line\">trace(arr); <span class=\"comment\">// [6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p>만약 <code>Identity(n)</code>을 받아  <code>n + 1</code>  ,  <code>n + 2</code>등을 포함하는 <code>Identity</code> 배열을 리턴하려면 어떻게 해야 합니까? 참 쉽죠 ?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fRange = (  </span><br><span class=\"line\">  start,  </span><br><span class=\"line\">  end  </span><br><span class=\"line\">) =&gt; <span class=\"built_in\">Array</span>.from(  </span><br><span class=\"line\">  &#123; <span class=\"attr\">length</span>: end - start + <span class=\"number\">1</span> &#125;,  </span><br><span class=\"line\">  (x, i) =&gt; Identity(i + start)  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><em>Array.from은 첫번째 인자로 유사배열( length속성이 있는 객체)를 받고 두번째 인자(옵션)로 생성시 맵핑할 함수를 받습니다. -역자</em></p>\n</blockquote>\n<p>자 이제, 만약 <code>fRange</code>가 임의의 functor에 대해 기능하게 하고싶습니다.  데이터 타입의 각 인스턴스가 생성자<code>constructor</code>에 대한 참조를 가져야 한다는 스펙이 있다면 어떨까요?  바꿔봅시다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fRange = (  </span><br><span class=\"line\">  start,  </span><br><span class=\"line\">  end  </span><br><span class=\"line\">) =&gt; <span class=\"built_in\">Array</span>.from(  </span><br><span class=\"line\">  &#123; <span class=\"attr\">length</span>: end - start + <span class=\"number\">1</span> &#125;,  </span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">// change `Identity` to `start.constructor`  </span></span><br><span class=\"line\">  (x, i) =&gt; start.constructor(i + start)  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> range = fRange(Identity(<span class=\"number\">2</span>), <span class=\"number\">4</span>);  </span><br><span class=\"line\">range.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x.map(trace)); <span class=\"comment\">// 2, 3, 4</span></span><br></pre></td></tr></table></figure>\n<p>값이 functor인지 테스트 하려면 어떻게해야할까요?  이를 위해  <code>Identity</code>에 <code>is(x)</code>라는 정적 메소드와 <code>.toString()</code> 정적 메소드를 하나 추가해줍니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.assign(Identity, &#123;  </span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">'Identity'</span>,  </span><br><span class=\"line\">  is: <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"keyword\">typeof</span> x.map === <span class=\"string\">'function'</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = Identity(<span class=\"number\">5</span>);</span><br><span class=\"line\">Identity.is(a) <span class=\"comment\">// true;</span></span><br></pre></td></tr></table></figure>\n<p>이 모든 것들을 하나로 합쳐보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Identity = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  map: <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> Identity(fn(value)),  </span><br><span class=\"line\">  valueOf: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> value,  </span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`Identity(<span class=\"subst\">$&#123;value&#125;</span>)`</span>,  </span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.iterator]: <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">yield</span> value;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>: Identity  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Object.assign(Identity, &#123;  </span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">'Identity'</span>,  </span><br><span class=\"line\">  is: <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"keyword\">typeof</span> x.map === <span class=\"string\">'function'</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>functor 나 endofunctor에 속하기 위해 위 코드들이 전부 필요하지는 않습니다. 편의성을 위해 추가한 것들일 뿐입니다.  functor가 되기 위해서는 functor법칙 두가지를 충족 시키는 <code>.map()</code> 인터페이스만 있으면 됩니다.</p>\n<h2 id=\"왜-functors를-사용할까요\">왜 Functors를 사용할까요?</h2>\n<p>Functor를 사용하는데는 여러 이유가 있습니다. 무엇보다 중요한 것은 다양한 데이터 유형에 대해 작동하는 공통 인터페이스를 구현하는 것입니다.  예를 들어, functor내의 값이  <code>undefined</code>거나  <code>null</code>이 아닌 경우에만 연산이 되게 하려면 어떡해야 할까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create the predicate  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> exists = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (x.valueOf() !== <span class=\"literal\">undefined</span> </span><br><span class=\"line\">                  &amp;&amp; x.valueOf() !== <span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ifExists = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  map: <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> exists(x) ? x.map(fn) : x  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> add1 = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Nothing happens...  </span></span><br><span class=\"line\">ifExists(Identity(<span class=\"literal\">undefined</span>)).map(trace);  </span><br><span class=\"line\"><span class=\"comment\">// Still nothing...  </span></span><br><span class=\"line\">ifExists(Identity(<span class=\"literal\">null</span>)).map(trace);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 42  </span></span><br><span class=\"line\">ifExists(Identity(<span class=\"number\">20</span>))  </span><br><span class=\"line\">  .map(add1)  </span><br><span class=\"line\">  .map(double)  </span><br><span class=\"line\">  .map(trace)  </span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<p>마지막으로 함수형 프로그래밍의 주요 관심사는 작은 함수들을 조합하여 높은 수준으로 추상화된 코드를 작성하는 것입니다.  따라서 어떤 functor에서도 작동하는 <em>generic</em> <code>map</code>을 만들어 보겠습니다. <code>fn</code> 함수를 인수로 부분적용해서 functor를 받는 새 함수를 리턴하게 하면 됩니다.</p>\n<p>쉽습니다. 좋아하는 <code>auto-curry</code>라이브러리를 가져오거나 이전에 사용했던 마법을 쓰면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> curry = (  </span><br><span class=\"line\">  f, arr = []  </span><br><span class=\"line\">) =&gt; <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> (  </span><br><span class=\"line\">  a =&gt; a.length === f.length ?  </span><br><span class=\"line\">    f(...a) :  </span><br><span class=\"line\">    curry(f, a)  </span><br><span class=\"line\">)([...arr, ...args]);</span><br></pre></td></tr></table></figure>\n<p>이제 <code>map</code>을 우리가 원하는데로 다룰 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = curry(<span class=\"function\">(<span class=\"params\">fn, F</span>) =&gt;</span> F.map(fn));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mdouble = map(double);   </span><br><span class=\"line\">mdouble(Identity(<span class=\"number\">4</span>)).map(trace); <span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"결론\">결론</h3>\n<p>Functor는 우리가 맵핑할 수 있는 것들 입니다. 형식적으로 말하자면, functor는 카테고리에서 카테고리로의 맵핑입니다.  어떤 functor는 카테고리에서 다시 같은 카테고리로 맵핑 될 수 있습니다. (<em>endofunctor</em>)</p>\n<p>카테고리는 객체의 집합이며 객체를 연결하는 화살표가 있습니다.  화살표는 morphisms(혹은 함수 또는 조합<sup class=\"footnote-ref\"><a href=\"#fn7\" id=\"fnref7\">[7]</a></sup>)을 뜻합니다. 카테고리의 각 객체는 항등 morphism(<code>x =&gt; x</code>)을 가집니다.  <code>A -&gt; B -&gt; C</code>로 객체가 사상될 경우,  <code>A -&gt; C</code>로의 연결이 있어야합니다.</p>\n<p>functor는 모든 데이터 유형에서 작동하는 다양한 공용 함수를 만들 수있는 훌륭한 고차원 추상화입니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/07/functional-mixins/\"><strong>다음: 함수형 믹스인 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>펑터라고 발음합니다. 함수자 혹은 함자로 번역이 되는데 그보다는 단어를 그대로 사용하기로 결정했습니다 - 역자 <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>수학의 범주론에 나오는 개념입니다. 이에 대해 <a href=\"https://www.amazon.com/s/ref=dp_byline_sr_book_1?ie=UTF8&amp;text=Eugenia+Cheng&amp;search-alias=books&amp;field-author=Eugenia+Cheng&amp;sort=relevancerank\" target=\"_blank\" rel=\"noopener\">Eugenia Cheng</a>의 How To Bake PI라는 비교적 쉽게 쓰인 입문서가 있습니다. -역자 <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>이때 객체란 어떤 실행 프로세스 내부의 추상화된 인스턴스가 아니라 사물, 어떤 것이라고 이해하면 됩니다. -역자 <a href=\"#fnref3\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p>맵핑과 동일합니다. -역자 <a href=\"#fnref4\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p>functor에 붙은 접두사 endo-는 &quot;inside, within, internal,&quot;라는 뜻을 가지고 있습니다. 즉, 닫힌계라고 생각하시면 됩니다. 엔도펑터라고 발음합니다. -역자 <a href=\"#fnref5\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn6\" class=\"footnote-item\"><p>전 글 <a href=\"https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/\">왜 자바스크립트로 함수형 프로그래밍을 배우는가</a>에 나옵니다 <a href=\"#fnref6\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn7\" class=\"footnote-item\"><p>composition을 여기서는 조합이라 번역했습니다 <a href=\"#fnref7\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/functors-categories-61e031bac53f\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/31/reduce/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/07/functional-mixins/\">다음&gt;</a></p>\n</blockquote>\n<p><strong>Functor는</strong><sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> 사용자가 맵핑 할 수있는 <strong>데이터 타입</strong>입니다.  내부의 값에 함수를 적용하는 인터페이스가 있는 <strong>컨테이너</strong>입니다.  functor를 발견하면  <em>“mappable”</em> 한 무언가라고 생각하면 됩니다. functor 타입은 일반적으로 객체처럼 구현되며 구조를 유지한채 입력에서 출력으로 맵핑하는  <code>.map()</code>  메소드를 가집니다.  이 때 &quot;구조 유지&quot;란 동일한 유형의 functor를 리턴한다는 것을 의미합니다 (컨테이너 내부의 값은 다른 유형 일 수 있음).</p>\n<p>functor는 무언가를 담을 수 있는 상자<sup>box</sup>와 맵핑<sup>mapping</sup> 인터페이스를 제공합니다.  배열<sup>Array</sup>은 functor의 좋은 예이며 promise, 스트림, 트리 등 다양한 종류의 객체 또한 <em>“mappable”</em> 한 것들입니다. JavaScript에 내장 된 배열 및 promise 객체는 functor처럼 작동합니다. 콜렉션(배열, 스트림 등)은 일반적으로  <code>.map()</code>을 사용해서 원소들을 순회하며 주어진 함수를 각 값에 적용하지만 모든 functor가 콜렉션처럼 순회하지는 않습니다. 사실 functor란 특정 문맥<sup>context</sup>에서 함수를 적용하는 것에 관한 개념입니다.</p>\n<p>Promise는  <code>.map()</code>  대신  <code>.then()</code>을 사용합니다.  일반적으로  <code>.then()</code>을 비동기식  <code>.map()</code>메서드로 생각할 수 있습니다. 단, 중첩된 promise가 있는 경우는 예외이며, 자동으로 외부 promise를 처리하지 않습니다.  다시 말하자면 promise가 아닌 값에 대해서  <code>.then()</code>은 비동기 <code>.map()</code>과 같은 역할을 합니다. 반면에 promise값의 경우  <code>.then()</code>은 모나드의 <code>.chain()</code> 메서드(<code>.bind()</code>  또는  <code>.flatMap()</code>이라고도 함)처럼 동작합니다.   따라서 promise은 functor가 아니고 모나드도 아닙니다. 그러나 실제로는 그 둘 중 하나로 취급 할 수 있습니다. 모나드가 무엇인지 몰라도 걱정하지 마십시오. 모나드는 일종의 functor이며, 우리는 먼저 functor에 대해 알아볼 것입니다.</p>\n<p>다양한 것들을 functor로 만들어주는 라이브러리들이 있습니다.</p>\n<p>Haskell에서 functor 타입은 다음과 같이 정의됩니다.</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">fmap</span> :: (a -&gt;</span> <span class=\"function\"><span class=\"title\">b</span>) -&gt;</span> <span class=\"function\"><span class=\"title\">fa</span> -&gt;</span> fb</span><br></pre></td></tr></table></figure>\n<p>a를 받아 b를 리턴하는 함수를 인자로 받습니다. 그리고 a가 담긴 functor를 받아 b가 담긴 functor를 리턴합니다.  <code>fa</code>  와  <code>fb</code>는  “a의 functor”,  &quot;b의 functor&quot;로 읽을 수 있습니다. 즉,  <code>fa</code>에는 <code>a</code>가 담긴 상자가 있고  <code>fb</code>에는 <code>b</code>가 담긴 상자가 있습니다.</p>\n<p>functor를 사용하는 것은 간단합니다.  <code>map()</code>을 호출하면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];   </span><br><span class=\"line\">f.map(double);  <span class=\"comment\">//[2, 4, 6]</span></span><br></pre></td></tr></table></figure>\n<h2>Functor’s Law</h2>\n<p>카테고리<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup> 에는 두 가지 중요한 속성이 있습니다.</p>\n<ol>\n<li>항등<sup>identity</sup></li>\n<li>합성<sup>composition</sup></li>\n</ol>\n<p>functor는 카테고리들 사이의 맵핑이기 때문에, functor는 항등과 합성을 지원해야 합니다. 이 두가지는 functor의 법칙으로 알려져 있습니다.</p>\n<h3>항등Identity</h3>\n<p>임의의 functor <code>f</code>에 항등함수(<code>x =&gt; x</code>)를 맵핑시키면 동일한 <code>f</code>가 리턴되어야 합니다:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];   </span><br><span class=\"line\">f.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x);  <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<h3>합성Composition</h3>\n<p>functor는 합성이 가능해야 합니다.  <code>F.map(x =&gt; f(g(x)))</code>  는  <code>F.map(g).map(f)</code>  와 동일합니다.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Functor.<span class=\"built_in\">map</span>( f . g ) === Functor.<span class=\"built_in\">map</span>(g).<span class=\"built_in\">map</span>(f)</span><br></pre></td></tr></table></figure>\n<p>함수 합성이란 어떤 함수의 출력을 다른 함수에 넣는 것입니다. 예를 들어,  인수로 <code>x</code>를 가지는 함수 <code>f</code>와 <code>g</code>가 합성된 <code>(f ∘ g)(x)</code>는 <code>f(g(x))</code>를 의미합니다.</p>\n<p>함수형 프로그래밍에 나오는 용어는 대부분 범주론<sup>category</sup> <sup>theory</sup>에서 왔습니다. 범주론의 핵심은 합성입니다.  범주론이 처음에는 무서워보일 수 있지만 알고보면 쉽습니다. 다이빙 보드에서 뛰어 내리거나 롤러 코스터를 타는 것과 같습니다.  다음은 범주론의 몇 가지 중요한 핵심과 이론적 기초입니다.</p>\n<ul>\n<li>카테고리는 객체와 객체들간의 화살표의 모음입니다. ( &quot;객체&quot;은 문자 그대로 객체<sup>object</sup> 입니다)<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup></li>\n<li>화살표는 사상<sup>morphism</sup>입니다<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>. 사상은 코드에서 함수로 구현됩니다.</li>\n<li>객체들이 <code>a -&gt; b -&gt; c</code>처럼 연결됐을 때  합성을 통해 <code>a -&gt; c</code>로 직접 맵핑시킬 수 있어야 합니다.</li>\n<li>모든 화살표는 컴포지션으로 나타낼 수 있습니다 (단지 객체 자신을 가리키는 항등 화살표일지라도).  카테고리의 모든 객체에는 항등 화살표가 있습니다.</li>\n</ul>\n<p><code>a</code>를 취하여  <code>b</code> 를 리턴하는 함수  <code>g</code>  가 있고  <code>b</code>를 취하여  <code>c</code>리턴하는 또 다른 함수  <code>f</code>가 있을 때  <code>f</code>  와  <code>g</code>의 합성을 나타내는 함수  <code>h</code>도 있어야합니다.  그러므로  <code>a -&gt; c</code>는  <code>f ∘ g</code>라는 합성 (<code>f</code>  <em>after</em>  <code>g</code>)이며 <code>h(x) = f(g(x))</code>와 같습니다.  함수는 왼쪽에서 오른쪽으로 합성되지 않고 오른쪽에서 왼쪽으로 되기 때문에  <code>f ∘ g</code>  는 종종  <code>f</code>  <em>after</em>  <code>g</code>라고 읽습니다.</p>\n<p>합성은 <strong>결합법칙</strong><sup>associative</sup> <sup>law</sup>이 적용됩니다.  간단하게 말하자면 함수를 합성할 때 기본적으로 괄호가 필요 없다는 뜻 입니다.</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h∘<span class=\"comment\">(g∘f)</span> = <span class=\"comment\">(h∘g)</span>∘f = h∘g∘f</span><br></pre></td></tr></table></figure>\n<p>JavaScript 코드로 합성을 다시 한 번 살펴 보겠습니다.</p>\n<p><code>F</code>라는 functor가 있을 때:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> F = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>다음 두 줄의 코드는 같은 표현입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> f(g(x)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// is equivalent to...</span></span><br><span class=\"line\"></span><br><span class=\"line\">F.map(g).map(f);</span><br></pre></td></tr></table></figure>\n<h2>Endofunctors<sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup></h2>\n<p>endofunctor는 카테고리에서 다시 같은 카테고리로 맵핑되는 functor입니다.</p>\n<p>Functor는 카테고리에서 카테고리로 맵핑 할 수 있습니다.  <code>X -&gt; Y</code></p>\n<p>endofunctor는 동일한 카테고리로 맵핑합니다.  <code>X -&gt; X</code></p>\n<p>모나드는 endofunctor입니다.  기억나십니까<sup class=\"footnote-ref\"><a href=\"#fn6\" id=\"fnref6\">[6]</a></sup>:</p>\n<blockquote>\n<p><em>“모나드는 endofunctor라는 카테고리에 속한 한 monoid에 불과해. 뭐가 문제야?”</em><br>\n<em>“A monad is just a monoid in the category of endofunctors. What’s the problem?”</em></p>\n</blockquote>\n<p>그 말이 조금 더 이해되었기를 바랍니다. monoid와 monads에 대해선 나중에 알아볼 것입니다.</p>\n<h2>Functor 구현하기</h2>\n<p>여기 간단한 functor가 하나 있습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Identity = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  <span class=\"attr\">map</span>: <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> Identity(fn(value))&#125;);</span><br></pre></td></tr></table></figure>\n<p>아래 코드를 보면 <code>Identity</code>가 functor 법칙을 만족시키는걸 알 수 있습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// trace() is a utility to let you easily inspect  </span></span><br><span class=\"line\"><span class=\"comment\">// the contents.  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> trace = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> u = Identity(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Identity law  </span></span><br><span class=\"line\">u.map(trace);             <span class=\"comment\">// 2  </span></span><br><span class=\"line\">u.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x).map(trace); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Composition law  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> r1 = u.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> f(g(x)));  </span><br><span class=\"line\"><span class=\"keyword\">const</span> r2 = u.map(g).map(f);</span><br><span class=\"line\"></span><br><span class=\"line\">r1.map(trace); <span class=\"comment\">// 5  </span></span><br><span class=\"line\">r2.map(trace); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>이제 배열을 맵핑하는 것처럼 어떤 데이터 타입이라도 맵핑 할 수 있습니다. 좋군요!</p>\n<p>이는 JavaScript로 구현한 <strong>가장</strong> 단순한 functor입니다. 그러나 JavaScript의 데이터 타입들이 지원하는 몇 가지 기능이 빠져 있습니다. 그것들을 추가합시다.  <code>+</code>  연산자가 숫자와 문자열 값을 둘 다 처리 할 수 ​​있다면 멋지지 않겠습니까?</p>\n<p>따라서 우리가해야 할 일은  <code>.valueOf()</code>  구현하는 것이며  <code>.valueOf()</code>는 또한 functor에서 값을 푸는<sup>unwrap</sup> 편리한 방법처럼 보입니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Identity = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  map: <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> Identity(fn(value)),</span><br><span class=\"line\"></span><br><span class=\"line\">  valueOf: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> value,  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ints = (Identity(<span class=\"number\">2</span>) + Identity(<span class=\"number\">4</span>));  </span><br><span class=\"line\">trace(ints); <span class=\"comment\">// 6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hi = (Identity(<span class=\"string\">'h'</span>) + Identity(<span class=\"string\">'i'</span>));  </span><br><span class=\"line\">trace(hi); <span class=\"comment\">// \"hi\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><em>valueOf 메소드는 식이 평가될 때 자동으로 호출됩니다. -역자</em></p>\n</blockquote>\n<p>좋습니다.  그러나 콘솔에서  <code>Identity</code> 인스턴스를 검사하려면 어떻게해야할까요? <code>&gt; &quot;Identity(value)&quot;</code>이라고 프린트되면 멋질 것입니다.  <code>.toString()</code>  메소드를 추가해봅시다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`Identity(<span class=\"subst\">$&#123;value&#125;</span>)`</span>,</span><br></pre></td></tr></table></figure>\n<p>괜찮네요. 이제 JS의 표준 순회 프로토콜을 구현하겠습니다.  커스텀 반복자를 추가하면됩니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">Symbol</span>.iterator]: <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">yield</span> value;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 다음과 같은 작업을 수행 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [Symbol.iterator] enables standard JS iterations:  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">6</span>, <span class=\"number\">7</span>, ...Identity(<span class=\"number\">8</span>)];  </span><br><span class=\"line\">trace(arr); <span class=\"comment\">// [6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p>만약 <code>Identity(n)</code>을 받아  <code>n + 1</code>  ,  <code>n + 2</code>등을 포함하는 <code>Identity</code> 배열을 리턴하려면 어떻게 해야 합니까? 참 쉽죠 ?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fRange = (  </span><br><span class=\"line\">  start,  </span><br><span class=\"line\">  end  </span><br><span class=\"line\">) =&gt; <span class=\"built_in\">Array</span>.from(  </span><br><span class=\"line\">  &#123; <span class=\"attr\">length</span>: end - start + <span class=\"number\">1</span> &#125;,  </span><br><span class=\"line\">  (x, i) =&gt; Identity(i + start)  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><em>Array.from은 첫번째 인자로 유사배열( length속성이 있는 객체)를 받고 두번째 인자(옵션)로 생성시 맵핑할 함수를 받습니다. -역자</em></p>\n</blockquote>\n<p>자 이제, 만약 <code>fRange</code>가 임의의 functor에 대해 기능하게 하고싶습니다.  데이터 타입의 각 인스턴스가 생성자<code>constructor</code>에 대한 참조를 가져야 한다는 스펙이 있다면 어떨까요?  바꿔봅시다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fRange = (  </span><br><span class=\"line\">  start,  </span><br><span class=\"line\">  end  </span><br><span class=\"line\">) =&gt; <span class=\"built_in\">Array</span>.from(  </span><br><span class=\"line\">  &#123; <span class=\"attr\">length</span>: end - start + <span class=\"number\">1</span> &#125;,  </span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">// change `Identity` to `start.constructor`  </span></span><br><span class=\"line\">  (x, i) =&gt; start.constructor(i + start)  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> range = fRange(Identity(<span class=\"number\">2</span>), <span class=\"number\">4</span>);  </span><br><span class=\"line\">range.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x.map(trace)); <span class=\"comment\">// 2, 3, 4</span></span><br></pre></td></tr></table></figure>\n<p>값이 functor인지 테스트 하려면 어떻게해야할까요?  이를 위해  <code>Identity</code>에 <code>is(x)</code>라는 정적 메소드와 <code>.toString()</code> 정적 메소드를 하나 추가해줍니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.assign(Identity, &#123;  </span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">'Identity'</span>,  </span><br><span class=\"line\">  is: <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"keyword\">typeof</span> x.map === <span class=\"string\">'function'</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = Identity(<span class=\"number\">5</span>);</span><br><span class=\"line\">Identity.is(a) <span class=\"comment\">// true;</span></span><br></pre></td></tr></table></figure>\n<p>이 모든 것들을 하나로 합쳐보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Identity = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  map: <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> Identity(fn(value)),  </span><br><span class=\"line\">  valueOf: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> value,  </span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`Identity(<span class=\"subst\">$&#123;value&#125;</span>)`</span>,  </span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.iterator]: <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">yield</span> value;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>: Identity  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Object.assign(Identity, &#123;  </span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">'Identity'</span>,  </span><br><span class=\"line\">  is: <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"keyword\">typeof</span> x.map === <span class=\"string\">'function'</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>functor 나 endofunctor에 속하기 위해 위 코드들이 전부 필요하지는 않습니다. 편의성을 위해 추가한 것들일 뿐입니다.  functor가 되기 위해서는 functor법칙 두가지를 충족 시키는 <code>.map()</code> 인터페이스만 있으면 됩니다.</p>\n<h2>왜 Functors를 사용할까요?</h2>\n<p>Functor를 사용하는데는 여러 이유가 있습니다. 무엇보다 중요한 것은 다양한 데이터 유형에 대해 작동하는 공통 인터페이스를 구현하는 것입니다.  예를 들어, functor내의 값이  <code>undefined</code>거나  <code>null</code>이 아닌 경우에만 연산이 되게 하려면 어떡해야 할까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create the predicate  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> exists = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (x.valueOf() !== <span class=\"literal\">undefined</span> </span><br><span class=\"line\">                  &amp;&amp; x.valueOf() !== <span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ifExists = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  map: <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> exists(x) ? x.map(fn) : x  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> add1 = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Nothing happens...  </span></span><br><span class=\"line\">ifExists(Identity(<span class=\"literal\">undefined</span>)).map(trace);  </span><br><span class=\"line\"><span class=\"comment\">// Still nothing...  </span></span><br><span class=\"line\">ifExists(Identity(<span class=\"literal\">null</span>)).map(trace);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 42  </span></span><br><span class=\"line\">ifExists(Identity(<span class=\"number\">20</span>))  </span><br><span class=\"line\">  .map(add1)  </span><br><span class=\"line\">  .map(double)  </span><br><span class=\"line\">  .map(trace)  </span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<p>마지막으로 함수형 프로그래밍의 주요 관심사는 작은 함수들을 조합하여 높은 수준으로 추상화된 코드를 작성하는 것입니다.  따라서 어떤 functor에서도 작동하는 <em>generic</em> <code>map</code>을 만들어 보겠습니다. <code>fn</code> 함수를 인수로 부분적용해서 functor를 받는 새 함수를 리턴하게 하면 됩니다.</p>\n<p>쉽습니다. 좋아하는 <code>auto-curry</code>라이브러리를 가져오거나 이전에 사용했던 마법을 쓰면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> curry = (  </span><br><span class=\"line\">  f, arr = []  </span><br><span class=\"line\">) =&gt; <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> (  </span><br><span class=\"line\">  a =&gt; a.length === f.length ?  </span><br><span class=\"line\">    f(...a) :  </span><br><span class=\"line\">    curry(f, a)  </span><br><span class=\"line\">)([...arr, ...args]);</span><br></pre></td></tr></table></figure>\n<p>이제 <code>map</code>을 우리가 원하는데로 다룰 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = curry(<span class=\"function\">(<span class=\"params\">fn, F</span>) =&gt;</span> F.map(fn));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mdouble = map(double);   </span><br><span class=\"line\">mdouble(Identity(<span class=\"number\">4</span>)).map(trace); <span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n<h3>결론</h3>\n<p>Functor는 우리가 맵핑할 수 있는 것들 입니다. 형식적으로 말하자면, functor는 카테고리에서 카테고리로의 맵핑입니다.  어떤 functor는 카테고리에서 다시 같은 카테고리로 맵핑 될 수 있습니다. (<em>endofunctor</em>)</p>\n<p>카테고리는 객체의 집합이며 객체를 연결하는 화살표가 있습니다.  화살표는 morphisms(혹은 함수 또는 조합<sup class=\"footnote-ref\"><a href=\"#fn7\" id=\"fnref7\">[7]</a></sup>)을 뜻합니다. 카테고리의 각 객체는 항등 morphism(<code>x =&gt; x</code>)을 가집니다.  <code>A -&gt; B -&gt; C</code>로 객체가 사상될 경우,  <code>A -&gt; C</code>로의 연결이 있어야합니다.</p>\n<p>functor는 모든 데이터 유형에서 작동하는 다양한 공용 함수를 만들 수있는 훌륭한 고차원 추상화입니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/07/functional-mixins/\"><strong>다음: 함수형 믹스인 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>펑터라고 발음합니다. 함수자 혹은 함자로 번역이 되는데 그보다는 단어를 그대로 사용하기로 결정했습니다 - 역자 <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>수학의 범주론에 나오는 개념입니다. 이에 대해 <a href=\"https://www.amazon.com/s/ref=dp_byline_sr_book_1?ie=UTF8&amp;text=Eugenia+Cheng&amp;search-alias=books&amp;field-author=Eugenia+Cheng&amp;sort=relevancerank\" target=\"_blank\" rel=\"noopener\">Eugenia Cheng</a>의 How To Bake PI라는 비교적 쉽게 쓰인 입문서가 있습니다. -역자 <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>이때 객체란 어떤 실행 프로세스 내부의 추상화된 인스턴스가 아니라 사물, 어떤 것이라고 이해하면 됩니다. -역자 <a href=\"#fnref3\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p>맵핑과 동일합니다. -역자 <a href=\"#fnref4\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p>functor에 붙은 접두사 endo-는 &quot;inside, within, internal,&quot;라는 뜻을 가지고 있습니다. 즉, 닫힌계라고 생각하시면 됩니다. 엔도펑터라고 발음합니다. -역자 <a href=\"#fnref5\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn6\" class=\"footnote-item\"><p>전 글 <a href=\"https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/\">왜 자바스크립트로 함수형 프로그래밍을 배우는가</a>에 나옵니다 <a href=\"#fnref6\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn7\" class=\"footnote-item\"><p>composition을 여기서는 조합이라 번역했습니다 <a href=\"#fnref7\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n"},{"title":"고차 함수","catalog":true,"date":"2018-03-29T04:48:39.000Z","subtitle":"Higher Order Functions","header-img":"bg.jpg","readingTime":13,"catagories":["개발"],"preview":"고차 함수는 함수를 인수로 받거나 함수를 리턴하는 함수입니다.  반면에 1차 함수는 함수를 인수로 사용하거나 함수를 출력으로 리턴하지 않습니다. 이전 글에서 우리는  .map()  과  .filter() 예제를 보았습니다.  둘 다 인수로 함수를 사용합니다.  즉, 둘 다 고차 함수입니다. 단어 목록에서 네 글자로 이루어진 단어를 선택하는 1차 함수의 예를 살펴 보겠습니다. 이제 's'로 시작하는 모든 단어를 선택하려면 어떻게 해야 할까요? 또 다른 함수를 만들면 됩니다 딱봐도 두 함수가 동일한 코드를 많이 반복하고 있습니다. 코드를 더 일반화된 해결책으로 추상화하는 패턴이 있습니다.  두 함수는 공통점이 많습니다.  둘 다 목록을 순회^iterate^하고 주어진 조건으로 필터링합니다.","_content":"\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99)\n\n\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/03/31/reduce/)\n\n\n**고차 함수^higher^ ^order^ ^function^**  는 함수를 인수로 받거나 함수를 리턴하는 함수입니다.  반면에 1차 함수^first^ ^order^ ^function^는 함수를 인수로 사용하거나 함수를 출력으로 리턴하지 않습니다.\n\n이전 글에서 우리는  `.map()`  과  `.filter()` 예제를 보았습니다.  둘 다 인수로 함수를 사용합니다.  즉, 둘 다 고차 함수입니다.\n\n단어 목록에서 네 글자로 이루어진 단어를 선택하는 1차 함수의 예를 살펴 보겠습니다.\n\n```javascript\nconst censor = words => {  \n  const filtered = [];  \n  for (let i = 0, { length } = words; i < length; i++) {  \n    const word = words[i];  \n    if (word.length !== 4) filtered.push(word);  \n  }  \n  return filtered;  \n};\n\ncensor(['oops', 'gasp', 'shout', 'sun']);  \n// [ 'shout', 'sun' ]\n```\n이제 's'로 시작하는 모든 단어를 선택하려면 어떻게 해야 할까요? 또 다른 함수를 만들면 됩니다 :\n\n```javascript\nconst startsWithS = words => {  \n  const filtered = [];  \n  for (let i = 0, { length } = words; i < length; i++) {  \n    const word = words[i];  \n    if (word.startsWith('s')) filtered.push(word);  \n  }  \n  return filtered;  \n};\n\nstartsWithS(['oops', 'gasp', 'shout', 'sun']);  \n// [ 'shout', 'sun' ]\n```\n딱봐도 두 함수가 동일한 코드를 많이 반복하고 있습니다. 코드를 더 일반화된 해결책으로 추상화하는 패턴이 있습니다.  두 함수는 공통점이 많습니다.  둘 다 목록을 순회^iterate^하고 주어진 조건으로 필터링합니다.\n\n순회와 필터링을 위한 코드가 자기들을 추상화 해달라고 구걸하고 있습니다.  모든 종류의 유사한 함수들을 작성할 때 공유하고 재사용해달라고 말합니다. 사실 어떤 목록에서 물건을 선택하는 것은 매우 일반적인 작업입니다.\n\n다행스럽게도 JavaScript의 함수는 일급^first^ ^class^입니다.  그게 무슨 뜻이냐구요? 숫자, 문자열 또는 객체와 마찬가지로 함수는 다음과 같은 일을 할 수 있습니다.\n\n-   식별자 (변수)값으로 할당\n-   객체 속성 값에 할당 \n-   인수로 전달\n-   함수에서 리턴됨\n\n기본적으로 프로그램에 있는 다른 데이터들처럼 함수를 사용할 수 있으므로 추상화하기가 훨씬 쉬워졌습니다.  예를 들어 목록을 순회하는 과정을 추상화하고  데이터를  처리하는 함수인 **reducer**를 전달하여 리턴 값을 누적하는 함수를 만들 수 있습니다.  이 함수를 **reduce**  라고 부릅니다.\n\n```javascript\nconst reduce = (reducer, initial, arr) => {  \n  // shared stuff  \n  let acc = initial;  \n  for (let i = 0, { length } = arr; i < length; i++) {\n\n    // unique stuff in reducer() call  \n    acc = reducer(acc, arr[i]);\n\n  // more shared stuff  \n  }  \n  return acc;  \n};\n\nreduce((acc, curr) => acc + curr, 0, [1,2,3]); // 6\n```\n`reduce()`함수는 reducer 함수, 누적값^accumulator^의 초기값 그리고 순회할 배열을 인자로 받습니다. 배열의 각 항목마다 reducer가 호출되어 누적값과 현재 배열 요소를 전달합니다.  누적값에는 계속해서 값이 누적되며 배열의 모든 요소에 대해 순회한 이후 최종적인 누적값이 리턴됩니다.\n\n맨 아래줄에서는 reducer함수로 `(acc, curr) => acc + curr`를 전달하는데 이는 배열 요소를 계속하여 누적하는 프로세스가 됩니다. 다음으로 초기 값인  `0`  과 순회할 데이터 배열을 전달합니다.\n\n반복과 누적^accumulation^이 추상화되면서 이제는 좀 더 일반화 된  `filter()`  함수를 구현할 수 있습니다.\n\n```javascript\nconst filter = (  \n  fn, arr  \n) => reduce((acc, curr) => fn(curr) ?  \n  acc.concat([curr]) :  \n  acc, [], arr  \n);\n```\n`filter()`에서는 인수로 전달 된  `fn()`함수를 제외한 모든 것이 다른 곳에서 재사용될 수 있는 것들입니다.  이 때 `fn()`은 술어^predicate^라고합니다.  **술어**  는 부울 값을 리턴하는 함수입니다.\n\n전달받은 배열에서 값을 하나씩 순회하며 `fn()`을 적용합니다.  `fn(curr)`  테스트가  `true`  리턴하면  `curr`  값을 빈 배열에 계속하여 연결합니다.  테스트가 실패할경우 현재 배열값을 넘깁니다.\n\n이제  `filter()`  를 사용해  네 글자로 이루진 단어를 필터링하는 `censor()`를 구현해보겠습니다.\n```javascript\nconst censor = words => filter(  \n  word => word.length !== 4,  \n  words  \n);\n```\n인상적이지 않습니까? 다양한 작업(필터링, 순회)들이 추상화되었고  `censor()`  는 아주 짧은 함수가 됐습니다.\n\n`startsWithS()`도  마찬가지입니다.\n\n```javascript\n const censorstartsWithS = words => filter(  \n  word => word.length !== 4startsWith('s'),  \n  words  \n);\n```\n\n몇몇 독자들은 이미 JavaScript가 이러한 추상화를 제공한다는걸 알고 있을 겁니다.  `Array.prototype`메서드에는 `.reduce()`  `.filter()`   `.map()`와 같은 다양한 함수이 이미 존재합니다.\n\n고차 함수는 다양한 데이터유형에서 동일하게 작동하도록 추상화하는데도 사용됩니다.  예를 들어  `.filter()`가 꼭 문자열 배열에서만 작동하라는 법은 없습니다. 인자로 전달하는 함수가 다른 데이터 유형을 처리하게만 하면 됩니다.  `highpass()`  예제를 기억하십니까?\n\n```javascript\nconst highpass = cutoff => n => n >= cutoff;  \nconst gt3 = highpass(3);  \n[1, 2, 3, 4].filter(gt3); // [3, 4];\n```\n\n즉, 고차 함수를 사용하여 함수에 다형성을 부여할 수 있습니다. 보시다시피 고차 함수는 1차 함수보다 훨씬 다재다능합니다. 일반적으로, 실제 응용 프로그램애플리케이션은 고차함수와 매우 간단한 1 차 함수를 함께 사용합니다.\n\n[**다음: Reduce >**](https://midojeong.github.io/2018/03/31/reduce/)\n\n","source":"_posts/higher-order-functions.md","raw":"---\ntitle: 고차 함수\ncatalog: true\ndate: 2018-03-29 13:48:39\nsubtitle: \"Higher Order Functions\"\nheader-img: \"bg.jpg\"\nreadingTime: 13\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 고차 함수는 함수를 인수로 받거나 함수를 리턴하는 함수입니다.  반면에 1차 함수는 함수를 인수로 사용하거나 함수를 출력으로 리턴하지 않습니다. 이전 글에서 우리는  .map()  과  .filter() 예제를 보았습니다.  둘 다 인수로 함수를 사용합니다.  즉, 둘 다 고차 함수입니다. 단어 목록에서 네 글자로 이루어진 단어를 선택하는 1차 함수의 예를 살펴 보겠습니다. 이제 's'로 시작하는 모든 단어를 선택하려면 어떻게 해야 할까요? 또 다른 함수를 만들면 됩니다 딱봐도 두 함수가 동일한 코드를 많이 반복하고 있습니다. 코드를 더 일반화된 해결책으로 추상화하는 패턴이 있습니다.  두 함수는 공통점이 많습니다.  둘 다 목록을 순회^iterate^하고 주어진 조건으로 필터링합니다.\n---\n\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99)\n\n\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/03/31/reduce/)\n\n\n**고차 함수^higher^ ^order^ ^function^**  는 함수를 인수로 받거나 함수를 리턴하는 함수입니다.  반면에 1차 함수^first^ ^order^ ^function^는 함수를 인수로 사용하거나 함수를 출력으로 리턴하지 않습니다.\n\n이전 글에서 우리는  `.map()`  과  `.filter()` 예제를 보았습니다.  둘 다 인수로 함수를 사용합니다.  즉, 둘 다 고차 함수입니다.\n\n단어 목록에서 네 글자로 이루어진 단어를 선택하는 1차 함수의 예를 살펴 보겠습니다.\n\n```javascript\nconst censor = words => {  \n  const filtered = [];  \n  for (let i = 0, { length } = words; i < length; i++) {  \n    const word = words[i];  \n    if (word.length !== 4) filtered.push(word);  \n  }  \n  return filtered;  \n};\n\ncensor(['oops', 'gasp', 'shout', 'sun']);  \n// [ 'shout', 'sun' ]\n```\n이제 's'로 시작하는 모든 단어를 선택하려면 어떻게 해야 할까요? 또 다른 함수를 만들면 됩니다 :\n\n```javascript\nconst startsWithS = words => {  \n  const filtered = [];  \n  for (let i = 0, { length } = words; i < length; i++) {  \n    const word = words[i];  \n    if (word.startsWith('s')) filtered.push(word);  \n  }  \n  return filtered;  \n};\n\nstartsWithS(['oops', 'gasp', 'shout', 'sun']);  \n// [ 'shout', 'sun' ]\n```\n딱봐도 두 함수가 동일한 코드를 많이 반복하고 있습니다. 코드를 더 일반화된 해결책으로 추상화하는 패턴이 있습니다.  두 함수는 공통점이 많습니다.  둘 다 목록을 순회^iterate^하고 주어진 조건으로 필터링합니다.\n\n순회와 필터링을 위한 코드가 자기들을 추상화 해달라고 구걸하고 있습니다.  모든 종류의 유사한 함수들을 작성할 때 공유하고 재사용해달라고 말합니다. 사실 어떤 목록에서 물건을 선택하는 것은 매우 일반적인 작업입니다.\n\n다행스럽게도 JavaScript의 함수는 일급^first^ ^class^입니다.  그게 무슨 뜻이냐구요? 숫자, 문자열 또는 객체와 마찬가지로 함수는 다음과 같은 일을 할 수 있습니다.\n\n-   식별자 (변수)값으로 할당\n-   객체 속성 값에 할당 \n-   인수로 전달\n-   함수에서 리턴됨\n\n기본적으로 프로그램에 있는 다른 데이터들처럼 함수를 사용할 수 있으므로 추상화하기가 훨씬 쉬워졌습니다.  예를 들어 목록을 순회하는 과정을 추상화하고  데이터를  처리하는 함수인 **reducer**를 전달하여 리턴 값을 누적하는 함수를 만들 수 있습니다.  이 함수를 **reduce**  라고 부릅니다.\n\n```javascript\nconst reduce = (reducer, initial, arr) => {  \n  // shared stuff  \n  let acc = initial;  \n  for (let i = 0, { length } = arr; i < length; i++) {\n\n    // unique stuff in reducer() call  \n    acc = reducer(acc, arr[i]);\n\n  // more shared stuff  \n  }  \n  return acc;  \n};\n\nreduce((acc, curr) => acc + curr, 0, [1,2,3]); // 6\n```\n`reduce()`함수는 reducer 함수, 누적값^accumulator^의 초기값 그리고 순회할 배열을 인자로 받습니다. 배열의 각 항목마다 reducer가 호출되어 누적값과 현재 배열 요소를 전달합니다.  누적값에는 계속해서 값이 누적되며 배열의 모든 요소에 대해 순회한 이후 최종적인 누적값이 리턴됩니다.\n\n맨 아래줄에서는 reducer함수로 `(acc, curr) => acc + curr`를 전달하는데 이는 배열 요소를 계속하여 누적하는 프로세스가 됩니다. 다음으로 초기 값인  `0`  과 순회할 데이터 배열을 전달합니다.\n\n반복과 누적^accumulation^이 추상화되면서 이제는 좀 더 일반화 된  `filter()`  함수를 구현할 수 있습니다.\n\n```javascript\nconst filter = (  \n  fn, arr  \n) => reduce((acc, curr) => fn(curr) ?  \n  acc.concat([curr]) :  \n  acc, [], arr  \n);\n```\n`filter()`에서는 인수로 전달 된  `fn()`함수를 제외한 모든 것이 다른 곳에서 재사용될 수 있는 것들입니다.  이 때 `fn()`은 술어^predicate^라고합니다.  **술어**  는 부울 값을 리턴하는 함수입니다.\n\n전달받은 배열에서 값을 하나씩 순회하며 `fn()`을 적용합니다.  `fn(curr)`  테스트가  `true`  리턴하면  `curr`  값을 빈 배열에 계속하여 연결합니다.  테스트가 실패할경우 현재 배열값을 넘깁니다.\n\n이제  `filter()`  를 사용해  네 글자로 이루진 단어를 필터링하는 `censor()`를 구현해보겠습니다.\n```javascript\nconst censor = words => filter(  \n  word => word.length !== 4,  \n  words  \n);\n```\n인상적이지 않습니까? 다양한 작업(필터링, 순회)들이 추상화되었고  `censor()`  는 아주 짧은 함수가 됐습니다.\n\n`startsWithS()`도  마찬가지입니다.\n\n```javascript\n const censorstartsWithS = words => filter(  \n  word => word.length !== 4startsWith('s'),  \n  words  \n);\n```\n\n몇몇 독자들은 이미 JavaScript가 이러한 추상화를 제공한다는걸 알고 있을 겁니다.  `Array.prototype`메서드에는 `.reduce()`  `.filter()`   `.map()`와 같은 다양한 함수이 이미 존재합니다.\n\n고차 함수는 다양한 데이터유형에서 동일하게 작동하도록 추상화하는데도 사용됩니다.  예를 들어  `.filter()`가 꼭 문자열 배열에서만 작동하라는 법은 없습니다. 인자로 전달하는 함수가 다른 데이터 유형을 처리하게만 하면 됩니다.  `highpass()`  예제를 기억하십니까?\n\n```javascript\nconst highpass = cutoff => n => n >= cutoff;  \nconst gt3 = highpass(3);  \n[1, 2, 3, 4].filter(gt3); // [3, 4];\n```\n\n즉, 고차 함수를 사용하여 함수에 다형성을 부여할 수 있습니다. 보시다시피 고차 함수는 1차 함수보다 훨씬 다재다능합니다. 일반적으로, 실제 응용 프로그램애플리케이션은 고차함수와 매우 간단한 1 차 함수를 함께 사용합니다.\n\n[**다음: Reduce >**](https://midojeong.github.io/2018/03/31/reduce/)\n\n","slug":"higher-order-functions","published":1,"updated":"2018-04-06T10:37:13.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83de000fifp69v1889kf","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/03/31/reduce/\">다음&gt;</a></p>\n</blockquote>\n<p><strong>고차 함수<sup>higher</sup> <sup>order</sup> <sup>function</sup></strong>  는 함수를 인수로 받거나 함수를 리턴하는 함수입니다.  반면에 1차 함수<sup>first</sup> <sup>order</sup> <sup>function</sup>는 함수를 인수로 사용하거나 함수를 출력으로 리턴하지 않습니다.</p>\n<p>이전 글에서 우리는  <code>.map()</code>  과  <code>.filter()</code> 예제를 보았습니다.  둘 다 인수로 함수를 사용합니다.  즉, 둘 다 고차 함수입니다.</p>\n<p>단어 목록에서 네 글자로 이루어진 단어를 선택하는 1차 함수의 예를 살펴 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> censor = <span class=\"function\"><span class=\"params\">words</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> filtered = [];  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, &#123; length &#125; = words; i &lt; length; i++) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> word = words[i];  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (word.length !== <span class=\"number\">4</span>) filtered.push(word);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> filtered;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">censor([<span class=\"string\">'oops'</span>, <span class=\"string\">'gasp'</span>, <span class=\"string\">'shout'</span>, <span class=\"string\">'sun'</span>]);  </span><br><span class=\"line\"><span class=\"comment\">// [ 'shout', 'sun' ]</span></span><br></pre></td></tr></table></figure>\n<p>이제 's’로 시작하는 모든 단어를 선택하려면 어떻게 해야 할까요? 또 다른 함수를 만들면 됩니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> startsWithS = <span class=\"function\"><span class=\"params\">words</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> filtered = [];  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, &#123; length &#125; = words; i &lt; length; i++) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> word = words[i];  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (word.startsWith(<span class=\"string\">'s'</span>)) filtered.push(word);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> filtered;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">startsWithS([<span class=\"string\">'oops'</span>, <span class=\"string\">'gasp'</span>, <span class=\"string\">'shout'</span>, <span class=\"string\">'sun'</span>]);  </span><br><span class=\"line\"><span class=\"comment\">// [ 'shout', 'sun' ]</span></span><br></pre></td></tr></table></figure>\n<p>딱봐도 두 함수가 동일한 코드를 많이 반복하고 있습니다. 코드를 더 일반화된 해결책으로 추상화하는 패턴이 있습니다.  두 함수는 공통점이 많습니다.  둘 다 목록을 순회<sup>iterate</sup>하고 주어진 조건으로 필터링합니다.</p>\n<p>순회와 필터링을 위한 코드가 자기들을 추상화 해달라고 구걸하고 있습니다.  모든 종류의 유사한 함수들을 작성할 때 공유하고 재사용해달라고 말합니다. 사실 어떤 목록에서 물건을 선택하는 것은 매우 일반적인 작업입니다.</p>\n<p>다행스럽게도 JavaScript의 함수는 일급<sup>first</sup> <sup>class</sup>입니다.  그게 무슨 뜻이냐구요? 숫자, 문자열 또는 객체와 마찬가지로 함수는 다음과 같은 일을 할 수 있습니다.</p>\n<ul>\n<li>식별자 (변수)값으로 할당</li>\n<li>객체 속성 값에 할당</li>\n<li>인수로 전달</li>\n<li>함수에서 리턴됨</li>\n</ul>\n<p>기본적으로 프로그램에 있는 다른 데이터들처럼 함수를 사용할 수 있으므로 추상화하기가 훨씬 쉬워졌습니다.  예를 들어 목록을 순회하는 과정을 추상화하고  데이터를  처리하는 함수인 <strong>reducer</strong>를 전달하여 리턴 값을 누적하는 함수를 만들 수 있습니다.  이 함수를 <strong>reduce</strong>  라고 부릅니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reduce = <span class=\"function\">(<span class=\"params\">reducer, initial, arr</span>) =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"comment\">// shared stuff  </span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> acc = initial;  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, &#123; length &#125; = arr; i &lt; length; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// unique stuff in reducer() call  </span></span><br><span class=\"line\">    acc = reducer(acc, arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// more shared stuff  </span></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> acc;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">reduce(<span class=\"function\">(<span class=\"params\">acc, curr</span>) =&gt;</span> acc + curr, <span class=\"number\">0</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n<p><code>reduce()</code>함수는 reducer 함수, 누적값<sup>accumulator</sup>의 초기값 그리고 순회할 배열을 인자로 받습니다. 배열의 각 항목마다 reducer가 호출되어 누적값과 현재 배열 요소를 전달합니다.  누적값에는 계속해서 값이 누적되며 배열의 모든 요소에 대해 순회한 이후 최종적인 누적값이 리턴됩니다.</p>\n<p>맨 아래줄에서는 reducer함수로 <code>(acc, curr) =&gt; acc + curr</code>를 전달하는데 이는 배열 요소를 계속하여 누적하는 프로세스가 됩니다. 다음으로 초기 값인  <code>0</code>  과 순회할 데이터 배열을 전달합니다.</p>\n<p>반복과 누적<sup>accumulation</sup>이 추상화되면서 이제는 좀 더 일반화 된  <code>filter()</code>  함수를 구현할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> filter = (  </span><br><span class=\"line\">  fn, arr  </span><br><span class=\"line\">) =&gt; reduce(<span class=\"function\">(<span class=\"params\">acc, curr</span>) =&gt;</span> fn(curr) ?  </span><br><span class=\"line\">  acc.concat([curr]) :  </span><br><span class=\"line\">  acc, [], arr  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>filter()</code>에서는 인수로 전달 된  <code>fn()</code>함수를 제외한 모든 것이 다른 곳에서 재사용될 수 있는 것들입니다.  이 때 <code>fn()</code>은 술어<sup>predicate</sup>라고합니다.  <strong>술어</strong>  는 부울 값을 리턴하는 함수입니다.</p>\n<p>전달받은 배열에서 값을 하나씩 순회하며 <code>fn()</code>을 적용합니다.  <code>fn(curr)</code>  테스트가  <code>true</code>  리턴하면  <code>curr</code>  값을 빈 배열에 계속하여 연결합니다.  테스트가 실패할경우 현재 배열값을 넘깁니다.</p>\n<p>이제  <code>filter()</code>  를 사용해  네 글자로 이루진 단어를 필터링하는 <code>censor()</code>를 구현해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> censor = <span class=\"function\"><span class=\"params\">words</span> =&gt;</span> filter(  </span><br><span class=\"line\">  word =&gt; word.length !== <span class=\"number\">4</span>,  </span><br><span class=\"line\">  words  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>인상적이지 않습니까? 다양한 작업(필터링, 순회)들이 추상화되었고  <code>censor()</code>  는 아주 짧은 함수가 됐습니다.</p>\n<p><code>startsWithS()</code>도  마찬가지입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">const</span> censorstartsWithS = <span class=\"function\"><span class=\"params\">words</span> =&gt;</span> filter(  </span><br><span class=\"line\">  word =&gt; word.length !== <span class=\"number\">4</span>startsWith(<span class=\"string\">'s'</span>),  </span><br><span class=\"line\">  words  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>몇몇 독자들은 이미 JavaScript가 이러한 추상화를 제공한다는걸 알고 있을 겁니다.  <code>Array.prototype</code>메서드에는 <code>.reduce()</code>  <code>.filter()</code>   <code>.map()</code>와 같은 다양한 함수이 이미 존재합니다.</p>\n<p>고차 함수는 다양한 데이터유형에서 동일하게 작동하도록 추상화하는데도 사용됩니다.  예를 들어  <code>.filter()</code>가 꼭 문자열 배열에서만 작동하라는 법은 없습니다. 인자로 전달하는 함수가 다른 데이터 유형을 처리하게만 하면 됩니다.  <code>highpass()</code>  예제를 기억하십니까?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> highpass = <span class=\"function\"><span class=\"params\">cutoff</span> =&gt;</span> n =&gt; n &gt;= cutoff;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> gt3 = highpass(<span class=\"number\">3</span>);  </span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].filter(gt3); <span class=\"comment\">// [3, 4];</span></span><br></pre></td></tr></table></figure>\n<p>즉, 고차 함수를 사용하여 함수에 다형성을 부여할 수 있습니다. 보시다시피 고차 함수는 1차 함수보다 훨씬 다재다능합니다. 일반적으로, 실제 응용 프로그램애플리케이션은 고차함수와 매우 간단한 1 차 함수를 함께 사용합니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/03/31/reduce/\"><strong>다음: Reduce &gt;</strong></a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/03/31/reduce/\">다음&gt;</a></p>\n</blockquote>\n<p><strong>고차 함수<sup>higher</sup> <sup>order</sup> <sup>function</sup></strong>  는 함수를 인수로 받거나 함수를 리턴하는 함수입니다.  반면에 1차 함수<sup>first</sup> <sup>order</sup> <sup>function</sup>는 함수를 인수로 사용하거나 함수를 출력으로 리턴하지 않습니다.</p>\n<p>이전 글에서 우리는  <code>.map()</code>  과  <code>.filter()</code> 예제를 보았습니다.  둘 다 인수로 함수를 사용합니다.  즉, 둘 다 고차 함수입니다.</p>\n<p>단어 목록에서 네 글자로 이루어진 단어를 선택하는 1차 함수의 예를 살펴 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> censor = <span class=\"function\"><span class=\"params\">words</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> filtered = [];  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, &#123; length &#125; = words; i &lt; length; i++) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> word = words[i];  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (word.length !== <span class=\"number\">4</span>) filtered.push(word);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> filtered;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">censor([<span class=\"string\">'oops'</span>, <span class=\"string\">'gasp'</span>, <span class=\"string\">'shout'</span>, <span class=\"string\">'sun'</span>]);  </span><br><span class=\"line\"><span class=\"comment\">// [ 'shout', 'sun' ]</span></span><br></pre></td></tr></table></figure>\n<p>이제 's’로 시작하는 모든 단어를 선택하려면 어떻게 해야 할까요? 또 다른 함수를 만들면 됩니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> startsWithS = <span class=\"function\"><span class=\"params\">words</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> filtered = [];  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, &#123; length &#125; = words; i &lt; length; i++) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> word = words[i];  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (word.startsWith(<span class=\"string\">'s'</span>)) filtered.push(word);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> filtered;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">startsWithS([<span class=\"string\">'oops'</span>, <span class=\"string\">'gasp'</span>, <span class=\"string\">'shout'</span>, <span class=\"string\">'sun'</span>]);  </span><br><span class=\"line\"><span class=\"comment\">// [ 'shout', 'sun' ]</span></span><br></pre></td></tr></table></figure>\n<p>딱봐도 두 함수가 동일한 코드를 많이 반복하고 있습니다. 코드를 더 일반화된 해결책으로 추상화하는 패턴이 있습니다.  두 함수는 공통점이 많습니다.  둘 다 목록을 순회<sup>iterate</sup>하고 주어진 조건으로 필터링합니다.</p>\n<p>순회와 필터링을 위한 코드가 자기들을 추상화 해달라고 구걸하고 있습니다.  모든 종류의 유사한 함수들을 작성할 때 공유하고 재사용해달라고 말합니다. 사실 어떤 목록에서 물건을 선택하는 것은 매우 일반적인 작업입니다.</p>\n<p>다행스럽게도 JavaScript의 함수는 일급<sup>first</sup> <sup>class</sup>입니다.  그게 무슨 뜻이냐구요? 숫자, 문자열 또는 객체와 마찬가지로 함수는 다음과 같은 일을 할 수 있습니다.</p>\n<ul>\n<li>식별자 (변수)값으로 할당</li>\n<li>객체 속성 값에 할당</li>\n<li>인수로 전달</li>\n<li>함수에서 리턴됨</li>\n</ul>\n<p>기본적으로 프로그램에 있는 다른 데이터들처럼 함수를 사용할 수 있으므로 추상화하기가 훨씬 쉬워졌습니다.  예를 들어 목록을 순회하는 과정을 추상화하고  데이터를  처리하는 함수인 <strong>reducer</strong>를 전달하여 리턴 값을 누적하는 함수를 만들 수 있습니다.  이 함수를 <strong>reduce</strong>  라고 부릅니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reduce = <span class=\"function\">(<span class=\"params\">reducer, initial, arr</span>) =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"comment\">// shared stuff  </span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> acc = initial;  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, &#123; length &#125; = arr; i &lt; length; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// unique stuff in reducer() call  </span></span><br><span class=\"line\">    acc = reducer(acc, arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// more shared stuff  </span></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> acc;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">reduce(<span class=\"function\">(<span class=\"params\">acc, curr</span>) =&gt;</span> acc + curr, <span class=\"number\">0</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n<p><code>reduce()</code>함수는 reducer 함수, 누적값<sup>accumulator</sup>의 초기값 그리고 순회할 배열을 인자로 받습니다. 배열의 각 항목마다 reducer가 호출되어 누적값과 현재 배열 요소를 전달합니다.  누적값에는 계속해서 값이 누적되며 배열의 모든 요소에 대해 순회한 이후 최종적인 누적값이 리턴됩니다.</p>\n<p>맨 아래줄에서는 reducer함수로 <code>(acc, curr) =&gt; acc + curr</code>를 전달하는데 이는 배열 요소를 계속하여 누적하는 프로세스가 됩니다. 다음으로 초기 값인  <code>0</code>  과 순회할 데이터 배열을 전달합니다.</p>\n<p>반복과 누적<sup>accumulation</sup>이 추상화되면서 이제는 좀 더 일반화 된  <code>filter()</code>  함수를 구현할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> filter = (  </span><br><span class=\"line\">  fn, arr  </span><br><span class=\"line\">) =&gt; reduce(<span class=\"function\">(<span class=\"params\">acc, curr</span>) =&gt;</span> fn(curr) ?  </span><br><span class=\"line\">  acc.concat([curr]) :  </span><br><span class=\"line\">  acc, [], arr  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>filter()</code>에서는 인수로 전달 된  <code>fn()</code>함수를 제외한 모든 것이 다른 곳에서 재사용될 수 있는 것들입니다.  이 때 <code>fn()</code>은 술어<sup>predicate</sup>라고합니다.  <strong>술어</strong>  는 부울 값을 리턴하는 함수입니다.</p>\n<p>전달받은 배열에서 값을 하나씩 순회하며 <code>fn()</code>을 적용합니다.  <code>fn(curr)</code>  테스트가  <code>true</code>  리턴하면  <code>curr</code>  값을 빈 배열에 계속하여 연결합니다.  테스트가 실패할경우 현재 배열값을 넘깁니다.</p>\n<p>이제  <code>filter()</code>  를 사용해  네 글자로 이루진 단어를 필터링하는 <code>censor()</code>를 구현해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> censor = <span class=\"function\"><span class=\"params\">words</span> =&gt;</span> filter(  </span><br><span class=\"line\">  word =&gt; word.length !== <span class=\"number\">4</span>,  </span><br><span class=\"line\">  words  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>인상적이지 않습니까? 다양한 작업(필터링, 순회)들이 추상화되었고  <code>censor()</code>  는 아주 짧은 함수가 됐습니다.</p>\n<p><code>startsWithS()</code>도  마찬가지입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">const</span> censorstartsWithS = <span class=\"function\"><span class=\"params\">words</span> =&gt;</span> filter(  </span><br><span class=\"line\">  word =&gt; word.length !== <span class=\"number\">4</span>startsWith(<span class=\"string\">'s'</span>),  </span><br><span class=\"line\">  words  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>몇몇 독자들은 이미 JavaScript가 이러한 추상화를 제공한다는걸 알고 있을 겁니다.  <code>Array.prototype</code>메서드에는 <code>.reduce()</code>  <code>.filter()</code>   <code>.map()</code>와 같은 다양한 함수이 이미 존재합니다.</p>\n<p>고차 함수는 다양한 데이터유형에서 동일하게 작동하도록 추상화하는데도 사용됩니다.  예를 들어  <code>.filter()</code>가 꼭 문자열 배열에서만 작동하라는 법은 없습니다. 인자로 전달하는 함수가 다른 데이터 유형을 처리하게만 하면 됩니다.  <code>highpass()</code>  예제를 기억하십니까?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> highpass = <span class=\"function\"><span class=\"params\">cutoff</span> =&gt;</span> n =&gt; n &gt;= cutoff;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> gt3 = highpass(<span class=\"number\">3</span>);  </span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].filter(gt3); <span class=\"comment\">// [3, 4];</span></span><br></pre></td></tr></table></figure>\n<p>즉, 고차 함수를 사용하여 함수에 다형성을 부여할 수 있습니다. 보시다시피 고차 함수는 1차 함수보다 훨씬 다재다능합니다. 일반적으로, 실제 응용 프로그램애플리케이션은 고차함수와 매우 간단한 1 차 함수를 함께 사용합니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/03/31/reduce/\"><strong>다음: Reduce &gt;</strong></a></p>\n"},{"title":"ES6+와 팩토리 함수","catalog":true,"date":"2018-04-08T00:17:04.000Z","subtitle":"JavaScript Factory Functions with ES6+","header-img":"bg.jpg","readingTime":10,"catagories":["개발"],"preview":"팩토리 함수는 (새로운)객체를 리턴하는 함수입니다. 그러나 클래스나 생성자 함수는 아닙니다.  JavaScript에서는 모든 함수가 객체를 리턴할 수 있습니다. 이 때 `new` 키워드가 없으면 팩토리 함수입니다. JavaScript에서 팩토리 함수는 항상 매력적입니다. 클래스와  `new`  키워드의 복잡함 없이 객체 인스턴스를 쉽게 생성 할 수 있기 때문입니다.","_content":"\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/07/functional-mixins/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/)\n\n## Factory Function\n\n**팩토리 함수**는 (새로운)객체를 리턴하는 함수입니다. 그러나 클래스나 생성자 함수는 아닙니다.  JavaScript에서는 모든 함수가 객체를 리턴할 수 있습니다. 이 때 `new` 키워드가 없으면 팩토리 함수입니다.\n\nJavaScript에서 팩토리 함수는 항상 매력적입니다. 클래스와  `new`  키워드의 복잡함 없이 객체 인스턴스를 쉽게 생성 할 수 있기 때문입니다.\n\nJavaScript는 매우 유용한 객체 리터럴 구문을 제공합니다.  다음과 같습니다.\n```javascript\nconst user = {  \n  userName: 'echo',  \n  avatar: 'echo.png'  \n};\n```\n자바 스크립트의 객체 리터럴 표기법은 JSON과 마찬가지로  `:`  의 왼쪽은 속성의 이름이고 오른쪽은 값입니다.  점 표기법으로 속성에 액세스 할 수 있습니다.\n\n```javascript\nconsole.log(user.userName); // \"echo\"\n```\n\n대괄호 표기법을 사용하여 계산 된 속성 이름에 액세스 할 수 있습니다.\n\n```javascript\nconst key = 'avatar';\n\nconsole.log( user[key] ); // \"echo.png\"\n```\n\n스코프에 객체의 속성 이름과 동일한 이름의 변수가있는 경우, 객체를 리터럴로 생성할 때 콜론과 값을 생략할 수 있습니다.\n\n```javascript\nconst userName = 'echo';  \nconst avatar = 'echo.png';\n\nconst user = {  \n  userName,  \n  avatar  \n};\n\nconsole.log(user);  \n// { \"avatar\": \"echo.png\",   \"userName\": \"echo\" }\n```\n\n객체 리터럴은 간결한 메소드 구문을 지원합니다.  `.setUserName()`  메소드를 추가 해 보겠습니다.\n\n```javascript\nconst userName = 'echo';  \nconst avatar = 'echo.png';\n\nconst user = {  \n  userName,  \n  avatar,\n\n  setUserName (userName) {  \n    this.userName = userName;  \n    return this;  \n  }  \n};\n\nconsole.log(user.setUserName('Foo').userName); // \"Foo\"\n```\n\n이 때,  `this`는 메소드를 호출하는 오브젝트를 참조합니다.  객체의 메소드를 호출하려면 객체 점 표기법을 사용하여 메소에 액세스하고 괄호를 붙여 호출하면 됩니다.  예를 들어  `game.play()`는  `game`객체에  `.play()`를 적용합니다.  점 표기법을 사용하여 메소드를 적용하려면 해당 메소드가 해당 오브젝트의 속성이어야합니다.  함수 프로토타입 메소드인  `.call()`  ,  `.apply()`  또는  `.bind()`를 사용하여 임의의 객체에 메소드를 적용 할 수도 있습니다.\n\n이 경우  `user.setUserName('Foo')`는  `.setUserName()`을  `user`에게 적용합니다.  이 때 `this`는 `user`가 되며  `.setUserName()`  내부의  `this`를 통해  `user` 객체의  `.userName`  속성을 변경합니다. 마지막으로 메소드 체이닝을 할 수 있게 하기 위해 동일한 객체 인스턴스를 리턴하게 했습니다.\n\n## Literals for One, Factories for Many\n\n객체를 반복해서 생성해야 하는 경우 객체 리터럴과 팩토리 함수의 기능을 결합해야합니다.\n\n팩토리 함수를 사용하여 원하는 만큼 많은 객체를 생성 할 수 있습니다.  예를 들어 채팅 앱을 만드는 경우 사용자 본인을 나타내는 사용자 객체가 필요합니다. 그 외에 현재 로그인되어 있고 채팅중인 다른 모든 사용자를 나타내는 많은 다른 사용자 객체가 필요합니다. \n\n`user`  객체를  `createUser()`  팩토리로 바꿔보겠습니다.\n\n```javascript\nconst createUser = ({ userName, avatar }) => ({  \n  userName,  \n  avatar,  \n  setUserName (userName) {  \n    this.userName = userName;  \n    return this;  \n  }  \n});\n\nconsole.log(createUser({ userName: 'echo', avatar: 'echo.png' }));\n\n/*  \n{  \n  \"avatar\": \"echo.png\",  \n  \"userName\": \"echo\",  \n  \"setUserName\": [Function setUserName]  \n}  \n*/\n```\n\n## 암시적인 객체 리턴\n\n화살표 함수 ( `=>` )는 암시적인 리턴을 합니다. 함수 본문이 단일 식으로 구성되어 있으면  `return`  키워드를 생략 할 수 있습니다.  `() => 'foo'`는 아무 인자도 받지 않고 `'foo'`를 리턴합니다.\n\n객체 리터럴을 리턴할 때 주의해야 합니다.  기본적으로 JavaScript는 중괄호를 발견하면 당신이 함수 본문을 만들려고 한다고 여깁니다(e.g.`{ broken: true }`). 객체 리터럴을 암시적으로 반환하고 싶으면 중괄호 바깥을 괄호로 감싸주어야 합니다.\n```javascript\nconst noop = () => { foo: 'bar' };  \nconsole.log(noop()); // undefined\n\nconst createFoo = () => ({ foo: 'bar' });  \nconsole.log(createFoo()); // { foo: \"bar\" }\n```\n\n첫 번째에서  `foo:`는 레이블로 해석되고  `bar`는 할당되거나 리턴되지 않는 표현식으로 해석됩니다. 따라서 이 함수는  `undefined`를 리턴합니다.\n\n`createFoo()` 예제에서 괄호는 그 안에 있는 것이 함수 본문 블록이 아닌 평가되어야 할 식으로 해석하도록 합니다.\n\n## 해체 Destructuring^[해체, 파괴, 비구조화, 디스트럭쳐링 등 다양한 용어로 번역되고 있습니다. -역자]\n\n함수 서명을 주의깊게 보시기 바랍니다.\n\n```javascript\nconst createUser = ({ userName, avatar }) => ({\n```\n\n이 줄에서, 중괄호 (  `{`  ,  `}`  )는 객체를 해체하라는 의미로 해석됩니다.  이 함수는 하나의 인수 (객체)를 받지만 이를 해체하여  `userName`  과  `avatar`라는 두 매개변수에 값을 바인딩 합니다.  이러한 매개 변수는 함수 범위에서 변수로 사용될 수 있습니다.  배열을 해체할 수도 있습니다.\n\n```javascript\nconst swap = ([first, second]) => [second, first];\n\nconsole.log( swap([1, 2]) ); // [2, 1]\n```\n\n그리고 나머지 구문과 스프레드 연산자를(`...varName`  ) 사용하여 배열 (또는 인수 목록)에서 나머지 값을 수집 한 다음 해당 배열 요소를 개별 요소로 다시 펼칠 수 있습니다.\n\n```javascript\nconst rotate = ([first, ...rest]) => [...rest, first];\n\nconsole.log( rotate([1, 2, 3]) ); // [2, 3, 1]\n```\n\n## 계산된 속성 키\n\n앞에서 우리는 대괄호를 사용해 계산된 속성에 엑세스했습니다. 다시 말하자면 액세스 할 속성을 동적으로 결정했습니다.\n\n```javascript\nconst key = 'avatar';\n\nconsole.log( user[key] ); // \"echo.png\"\n```\n\n그렇다면 계산된 값을 키로 할당 할 수도 있습니다.\n\n```javascript\nconst arrToObj = ([key, value]) => ({ [key]: value });\n\nconsole.log( arrToObj([ 'foo', 'bar' ]) ); // { \"foo\": \"bar\" }\n```\n\n이 예제에서  `arrToObj`는 키/값 쌍 (일명 튜플)으로 구성된 배열을 가져 와서 객체로 변환합니다.  키의 이름을 알지 못하기 때문에 객체의 키/값 쌍을 설정하려면 속성 이름을 계산해야합니다.  이를 위해 대괄호 표기법을 빌려 객체 리터럴을 작성하는데 다시 사용합니다.\n\n```javascript\n  { [key]: value } \n```\n\n보간이 끝나면 객체가 완성됩니다:\n\n```javascript\n  { \"foo\": \"bar\"} \n```\n\n## 기본 매개 변수^Default^ ^Parameters^\n\nJavaScript의 함수는 기본 매개 변수 값을 지원하며 다음과 같은 몇 가지 이점이 있습니다.\n\n1.  사용자는 적절한 기본값으로 매개 변수를 생략 할 수 있습니다.\n2.  기본값은 예상되는 입력의 예를 제공하기 때문에 이 함수는 더 자체적으로 문서화됩니다.\n3.  IDE 및 정적 분석 도구는 기본값을 사용하여 매개 변수에 필요한 유형을 추론 할 수 있습니다.  예를 들어, 기본값  `1`은 매개 변수가  `Number`타입의 멤버를 사용할 수 있음을 의미합니다.\n\n다음 예제는 기본 매개 변수를 사용하여  `createUser` 팩토리의 예상 인터페이스를 문서화하고 사용자 정보가 제공되지 않은 경우  세부 정보를 `'Anonymous'`로 하여 자동으로 채 웁니다.\n\n```javascript\nconst createUser = ({  \n  userName = 'Anonymous',  \n  avatar = 'anon.png'  \n} = {}) => ({  \n  userName,  \n  avatar  \n});\n\nconsole.log(  \n  // { userName: \"echo\", avatar: 'anon.png' }  \n  createUser({ userName: 'echo' }),\n\n  // { userName: \"Anonymous\", avatar: 'anon.png' }  \n  createUser()  \n);\n```\n\n함수 서명의 마지막 부분은 아마도 약간 우습게 보일 것입니다.\n\n```javascript\n  } = {}) => ({ \n```\n\n인수 서명이 닫히기 직전 마지막에 있는  `= {}`는 `createUser`에게 아무 것도 전달되지 않았을 경우 `undefined`나 `null`을 매개 변수에 전달하는 것이 아닌 빈 객체를 전달하라는 의미 입니다. 빈 객체에 대해 기본값을 해체하여 할당하게되면 자동으로 속성값 설정됩니다. 즉 기본 값이 하는 일은 다음과 같습니다.\n\n> `undefined` 를 미리 정의 된 값으로 바꿉니다.\n\n`= {}`가 없으면  `undefined`의 속성에 액세스하려는 과정에서 `createUser()`  가 오류를 발생시킵니다.\n\n## 타입 추론\n\nJavaScript는이 글을 쓰는 시점에서 타입 주석 체계가 내장되어있지 않습니다. 그러나 JSDoc(점점 사용자가 줄고 있음),  Facebook의 [Flow](https://flow.org/),  Microsoft의 [TypeScript](https://www.typescriptlang.org/) 등의 몇 가지 경쟁 포맷이 갭을 메우기 위해 수년 동안  [급성장하고](https://www.typescriptlang.org/)  있습니다.  저는  [rtype](https://github.com/ericelliott/rtype)을 문서화에 사용합니다 - 이는 함수형 프로그래밍을 위한 TypeScript보다 훨씬 더 읽기 쉬운 표기법입니다.\n\n이 글을 쓰는 시점에는 타입 주석에 대해 확실한 승자가 없습니다.  JavaScript 스펙에 의해 어떠한 대안도 선택을 받지 못했으며, 각각에 명확한 결점이있는 것으로 보입니다.\n\n타입 추론은 데이터가 사용 된 문맥을 기반으로 유추하여 타입을 추론하는 프로세스입니다. JavaScript에서 이는 타입 주석의 좋은 대안입니다.\n\n표준 JavaScript 함수 서명으로 타입 추론을 위한 충분한 단서를 제공하면 비용이나 위험없이 타입 주석의 이점 대부분을 얻을 수 있습니다.\n\nTypeScript 또는 Flow와 같은 도구를 사용하기로한 경우에도 타입 추론으로 가능한 많은 작업을 수행하고 타입 추론이 부족한 상황에서 타입 주석을 달아야합니다.  예를 들어 JavaScript에는 공유 인터페이스를 정의하는 방법이 없습니다. 그러나 TypeScript 또는 rtype에서는 쉽고 유용합니다.\n\n[Tern.js](http://ternjs.net/)  는 다양한 텍스트 에디터와 IDE 용 플러그인이있는 JavaScript용 타입 추론 도구입니다.\n\nMicrosoft의 Visual Studio Code는 TypeScript의 타입 추론 기능을 일반 JavaScript 코드로 가져 오기 때문에 Tern이 필요하지 않습니다.\n\nJavaScript에서 함수의 기본 매개 변수를 지정하면 Tern.js, TypeScript 및 Flow와 같은 유형 유추가 가능한 도구는 작업 도중 올바르게  API를 사용할 수 있도록 IDE 힌트를 제공합니다.\n\n기본 값이 없다면 IDE(그리고 사람)는 매개 변수 타입을 파악할 수 있는 힌트를 충분히 확보하지 못합니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*2sP_9k1e0dkgYqdEPs0G3g.png)\n\n기본값이 없으면`userName`의 타입을 알 수 없습니다.\n\n기본값을 사용하면 IDE(그리고 사람)가 예제를 보고 유추 할 수 있습니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*tFUXCLA8ClAzsPgZXGGR9A.png)\n\n기본값을 보고, IDE는`userName` 매개 변수가 문자열을 기다리고 있다고 제안 할 수 있습니다.\n\n매개 변수를 고정 유형으로 제한하는 것이 의미가 있다는 것은 아닙니다(일반 함수와 고차 함수를 만들기 어려워 집니다). 하지만 적절히 사용한다면 기본 매개 변수만큼 유용한 것도 없습니다. TypeScript 또는 flow를 사용하고 있어도 마찬가지입니다.\n\n## 믹스인 합성을 위한 팩토리 함수\n\n팩토리는 API를 멋지게 호출하여 객체를 꺼내오는데 유용합니다. 일반적으로 이 정도면 충분하지만, 한 번에 여러 유형의 객체에 비슷한 기능을 구현하려는 경우가 있습니다. 이러한 기능을 보다 쉽게 재사용하려면 함수형 믹스인으로 추상화하면 됩니다.\n\n이 때야 말로 함수형 믹스인이 빛나는 곳입니다.  모든 객체 인스턴스에  `withConstructor`  속성을 추가하려면  `withConstructor`  믹스인을 빌드하십시오.\n\n`with-constructor.js`  :\n\n```javascript\nconst withConstructor = constructor => o => {  \n  const proto = Object.assign({},  \n    Object.getPrototypeOf(o),  \n    { constructor }  \n  );\n\n  return Object.assign(Object.create(proto), o);  \n};\n```\n\n이것을 가져와 다른 믹스인과 함께 사용할 수 있습니다.\n\n```javascript\nimport withConstructor from './with-constructor';\n\nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);  \n// or `import pipe from 'lodash/fp/flow';`\n\n// Set up some functional mixins  \nconst withFlying = o => {  \n  let isFlying = false;\n\n  return {  \n    ...o,  \n    fly () {  \n      isFlying = true;  \n      return this;  \n    },  \n    land () {  \n      isFlying = false;  \n      return this;  \n    },  \n    isFlying: () => isFlying  \n  }  \n};\n\nconst withBattery = ({ capacity }) => o => {  \n  let percentCharged = 100;\n\n  return {  \n    ...o,  \n    draw (percent) {  \n      const remaining = percentCharged - percent;  \n      percentCharged = remaining > 0 ? remaining : 0;  \n      return this;  \n    },  \n    getCharge: () => percentCharged,  \n    get capacity () {  \n      return capacity  \n    }  \n  };  \n};\n\nconst createDrone = ({ capacity = '3000mAh' }) => pipe(  \n  withFlying,  \n  withBattery({ capacity }),  \n  withConstructor(createDrone)  \n)({});\n\nconst myDrone = createDrone({ capacity: '5500mAh' });\n\nconsole.log(`  \n  can fly:  ${ myDrone.fly().isFlying() === true }  \n  can land: ${ myDrone.land().isFlying() === false }  \n  battery capacity: ${ myDrone.capacity }  \n  battery status: ${ myDrone.draw(50).getCharge() }%  \n  battery drained: ${ myDrone.draw(75).getCharge() }%  \n`);\n\nconsole.log(`  \n  constructor linked: ${ myDrone.constructor === createDrone }  \n`);\n```\n\n보시다시피 재사용 가능한  `withConstructor()` 믹스인은 다른 믹스인과 함께 파이프 라인으로 간단히 합쳐집니다.  `withBattery()`는 로봇, 전기 스케이트 보드 또는 보조 배터리와 같은 다른 종류의 객체와 함께 사용할 수 있습니다.  `withFlying()`  은 날아다니는 자동차, 로켓 또는 에어벌룬을 모델링하는데 사용될 수 있습니다.\n\n**Composition**은 특별한 코딩 기술이라기 보다는 사고 방식에 가깝습니다.  여러분은 여러 가지 방법으로 이를 적용 할 수 있습니다.  함수 합성은 기초부터 다시 만들 때 사용할 수 있는 가장 쉬운 방법이며, 팩토리 함수는 구현의 세부 사항을 친숙한 API로 포장하는 간단한 방법입니다.\n\n## 결론\n\nES6가 제공하는 편리한 구문들은 객체 생성 및 팩토리 함수를 다루기 쉽게 만듭니다. 대부분이 경우에는 이정도로 충분하지만, JavaScript이기 때문에 Java와 같은 느낌을 주는 또 다른 접근 방식이 있습니다 :  `class`  키워드.\n\nJavaScript에서 클래스는 팩토리보다 더 장황하고 제한적이며, 리팩토링할 때는 거의 지뢰밭을 걷는 느낌을 주지만 React와 Angular와 같은 주요 프론트 엔드 프레임 워크에 의해 사용되어 왔으며 몇 가지 드문 용도(복잡함을 감수할만한 가치가 있는 경우)가 있습니다.\n\n> \"때때로 우아한 구현은 단지 함수뿐입니다.  메소드가 아닙니다. 클래스도 아닙니다. 프레임워크도 아니고 그저 함수입니다.\"~ John Carmack\n\n가장 간단한 구현으로 시작하고 필요한 경우에만보다 복잡한 구현으로 이동하십시오.  객체를 다루는 관점에서는 다음과 같습니다.\n\n`Pure function -> factory -> functional mixin -> class`\n\n[**다음: 클래스로 합성하기가 까다로운 이유 >**](https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/)\n","source":"_posts/javaScript-factory-function-with-es6.md","raw":"---\ntitle: ES6+와 팩토리 함수\ncatalog: true\ndate: 2018-04-08 09:17:04\nsubtitle: JavaScript Factory Functions with ES6+\nheader-img: \"bg.jpg\"\nreadingTime: 10\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 팩토리 함수는 (새로운)객체를 리턴하는 함수입니다. 그러나 클래스나 생성자 함수는 아닙니다.  JavaScript에서는 모든 함수가 객체를 리턴할 수 있습니다. 이 때 `new` 키워드가 없으면 팩토리 함수입니다. JavaScript에서 팩토리 함수는 항상 매력적입니다. 클래스와  `new`  키워드의 복잡함 없이 객체 인스턴스를 쉽게 생성 할 수 있기 때문입니다.\n---\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/07/functional-mixins/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/)\n\n## Factory Function\n\n**팩토리 함수**는 (새로운)객체를 리턴하는 함수입니다. 그러나 클래스나 생성자 함수는 아닙니다.  JavaScript에서는 모든 함수가 객체를 리턴할 수 있습니다. 이 때 `new` 키워드가 없으면 팩토리 함수입니다.\n\nJavaScript에서 팩토리 함수는 항상 매력적입니다. 클래스와  `new`  키워드의 복잡함 없이 객체 인스턴스를 쉽게 생성 할 수 있기 때문입니다.\n\nJavaScript는 매우 유용한 객체 리터럴 구문을 제공합니다.  다음과 같습니다.\n```javascript\nconst user = {  \n  userName: 'echo',  \n  avatar: 'echo.png'  \n};\n```\n자바 스크립트의 객체 리터럴 표기법은 JSON과 마찬가지로  `:`  의 왼쪽은 속성의 이름이고 오른쪽은 값입니다.  점 표기법으로 속성에 액세스 할 수 있습니다.\n\n```javascript\nconsole.log(user.userName); // \"echo\"\n```\n\n대괄호 표기법을 사용하여 계산 된 속성 이름에 액세스 할 수 있습니다.\n\n```javascript\nconst key = 'avatar';\n\nconsole.log( user[key] ); // \"echo.png\"\n```\n\n스코프에 객체의 속성 이름과 동일한 이름의 변수가있는 경우, 객체를 리터럴로 생성할 때 콜론과 값을 생략할 수 있습니다.\n\n```javascript\nconst userName = 'echo';  \nconst avatar = 'echo.png';\n\nconst user = {  \n  userName,  \n  avatar  \n};\n\nconsole.log(user);  \n// { \"avatar\": \"echo.png\",   \"userName\": \"echo\" }\n```\n\n객체 리터럴은 간결한 메소드 구문을 지원합니다.  `.setUserName()`  메소드를 추가 해 보겠습니다.\n\n```javascript\nconst userName = 'echo';  \nconst avatar = 'echo.png';\n\nconst user = {  \n  userName,  \n  avatar,\n\n  setUserName (userName) {  \n    this.userName = userName;  \n    return this;  \n  }  \n};\n\nconsole.log(user.setUserName('Foo').userName); // \"Foo\"\n```\n\n이 때,  `this`는 메소드를 호출하는 오브젝트를 참조합니다.  객체의 메소드를 호출하려면 객체 점 표기법을 사용하여 메소에 액세스하고 괄호를 붙여 호출하면 됩니다.  예를 들어  `game.play()`는  `game`객체에  `.play()`를 적용합니다.  점 표기법을 사용하여 메소드를 적용하려면 해당 메소드가 해당 오브젝트의 속성이어야합니다.  함수 프로토타입 메소드인  `.call()`  ,  `.apply()`  또는  `.bind()`를 사용하여 임의의 객체에 메소드를 적용 할 수도 있습니다.\n\n이 경우  `user.setUserName('Foo')`는  `.setUserName()`을  `user`에게 적용합니다.  이 때 `this`는 `user`가 되며  `.setUserName()`  내부의  `this`를 통해  `user` 객체의  `.userName`  속성을 변경합니다. 마지막으로 메소드 체이닝을 할 수 있게 하기 위해 동일한 객체 인스턴스를 리턴하게 했습니다.\n\n## Literals for One, Factories for Many\n\n객체를 반복해서 생성해야 하는 경우 객체 리터럴과 팩토리 함수의 기능을 결합해야합니다.\n\n팩토리 함수를 사용하여 원하는 만큼 많은 객체를 생성 할 수 있습니다.  예를 들어 채팅 앱을 만드는 경우 사용자 본인을 나타내는 사용자 객체가 필요합니다. 그 외에 현재 로그인되어 있고 채팅중인 다른 모든 사용자를 나타내는 많은 다른 사용자 객체가 필요합니다. \n\n`user`  객체를  `createUser()`  팩토리로 바꿔보겠습니다.\n\n```javascript\nconst createUser = ({ userName, avatar }) => ({  \n  userName,  \n  avatar,  \n  setUserName (userName) {  \n    this.userName = userName;  \n    return this;  \n  }  \n});\n\nconsole.log(createUser({ userName: 'echo', avatar: 'echo.png' }));\n\n/*  \n{  \n  \"avatar\": \"echo.png\",  \n  \"userName\": \"echo\",  \n  \"setUserName\": [Function setUserName]  \n}  \n*/\n```\n\n## 암시적인 객체 리턴\n\n화살표 함수 ( `=>` )는 암시적인 리턴을 합니다. 함수 본문이 단일 식으로 구성되어 있으면  `return`  키워드를 생략 할 수 있습니다.  `() => 'foo'`는 아무 인자도 받지 않고 `'foo'`를 리턴합니다.\n\n객체 리터럴을 리턴할 때 주의해야 합니다.  기본적으로 JavaScript는 중괄호를 발견하면 당신이 함수 본문을 만들려고 한다고 여깁니다(e.g.`{ broken: true }`). 객체 리터럴을 암시적으로 반환하고 싶으면 중괄호 바깥을 괄호로 감싸주어야 합니다.\n```javascript\nconst noop = () => { foo: 'bar' };  \nconsole.log(noop()); // undefined\n\nconst createFoo = () => ({ foo: 'bar' });  \nconsole.log(createFoo()); // { foo: \"bar\" }\n```\n\n첫 번째에서  `foo:`는 레이블로 해석되고  `bar`는 할당되거나 리턴되지 않는 표현식으로 해석됩니다. 따라서 이 함수는  `undefined`를 리턴합니다.\n\n`createFoo()` 예제에서 괄호는 그 안에 있는 것이 함수 본문 블록이 아닌 평가되어야 할 식으로 해석하도록 합니다.\n\n## 해체 Destructuring^[해체, 파괴, 비구조화, 디스트럭쳐링 등 다양한 용어로 번역되고 있습니다. -역자]\n\n함수 서명을 주의깊게 보시기 바랍니다.\n\n```javascript\nconst createUser = ({ userName, avatar }) => ({\n```\n\n이 줄에서, 중괄호 (  `{`  ,  `}`  )는 객체를 해체하라는 의미로 해석됩니다.  이 함수는 하나의 인수 (객체)를 받지만 이를 해체하여  `userName`  과  `avatar`라는 두 매개변수에 값을 바인딩 합니다.  이러한 매개 변수는 함수 범위에서 변수로 사용될 수 있습니다.  배열을 해체할 수도 있습니다.\n\n```javascript\nconst swap = ([first, second]) => [second, first];\n\nconsole.log( swap([1, 2]) ); // [2, 1]\n```\n\n그리고 나머지 구문과 스프레드 연산자를(`...varName`  ) 사용하여 배열 (또는 인수 목록)에서 나머지 값을 수집 한 다음 해당 배열 요소를 개별 요소로 다시 펼칠 수 있습니다.\n\n```javascript\nconst rotate = ([first, ...rest]) => [...rest, first];\n\nconsole.log( rotate([1, 2, 3]) ); // [2, 3, 1]\n```\n\n## 계산된 속성 키\n\n앞에서 우리는 대괄호를 사용해 계산된 속성에 엑세스했습니다. 다시 말하자면 액세스 할 속성을 동적으로 결정했습니다.\n\n```javascript\nconst key = 'avatar';\n\nconsole.log( user[key] ); // \"echo.png\"\n```\n\n그렇다면 계산된 값을 키로 할당 할 수도 있습니다.\n\n```javascript\nconst arrToObj = ([key, value]) => ({ [key]: value });\n\nconsole.log( arrToObj([ 'foo', 'bar' ]) ); // { \"foo\": \"bar\" }\n```\n\n이 예제에서  `arrToObj`는 키/값 쌍 (일명 튜플)으로 구성된 배열을 가져 와서 객체로 변환합니다.  키의 이름을 알지 못하기 때문에 객체의 키/값 쌍을 설정하려면 속성 이름을 계산해야합니다.  이를 위해 대괄호 표기법을 빌려 객체 리터럴을 작성하는데 다시 사용합니다.\n\n```javascript\n  { [key]: value } \n```\n\n보간이 끝나면 객체가 완성됩니다:\n\n```javascript\n  { \"foo\": \"bar\"} \n```\n\n## 기본 매개 변수^Default^ ^Parameters^\n\nJavaScript의 함수는 기본 매개 변수 값을 지원하며 다음과 같은 몇 가지 이점이 있습니다.\n\n1.  사용자는 적절한 기본값으로 매개 변수를 생략 할 수 있습니다.\n2.  기본값은 예상되는 입력의 예를 제공하기 때문에 이 함수는 더 자체적으로 문서화됩니다.\n3.  IDE 및 정적 분석 도구는 기본값을 사용하여 매개 변수에 필요한 유형을 추론 할 수 있습니다.  예를 들어, 기본값  `1`은 매개 변수가  `Number`타입의 멤버를 사용할 수 있음을 의미합니다.\n\n다음 예제는 기본 매개 변수를 사용하여  `createUser` 팩토리의 예상 인터페이스를 문서화하고 사용자 정보가 제공되지 않은 경우  세부 정보를 `'Anonymous'`로 하여 자동으로 채 웁니다.\n\n```javascript\nconst createUser = ({  \n  userName = 'Anonymous',  \n  avatar = 'anon.png'  \n} = {}) => ({  \n  userName,  \n  avatar  \n});\n\nconsole.log(  \n  // { userName: \"echo\", avatar: 'anon.png' }  \n  createUser({ userName: 'echo' }),\n\n  // { userName: \"Anonymous\", avatar: 'anon.png' }  \n  createUser()  \n);\n```\n\n함수 서명의 마지막 부분은 아마도 약간 우습게 보일 것입니다.\n\n```javascript\n  } = {}) => ({ \n```\n\n인수 서명이 닫히기 직전 마지막에 있는  `= {}`는 `createUser`에게 아무 것도 전달되지 않았을 경우 `undefined`나 `null`을 매개 변수에 전달하는 것이 아닌 빈 객체를 전달하라는 의미 입니다. 빈 객체에 대해 기본값을 해체하여 할당하게되면 자동으로 속성값 설정됩니다. 즉 기본 값이 하는 일은 다음과 같습니다.\n\n> `undefined` 를 미리 정의 된 값으로 바꿉니다.\n\n`= {}`가 없으면  `undefined`의 속성에 액세스하려는 과정에서 `createUser()`  가 오류를 발생시킵니다.\n\n## 타입 추론\n\nJavaScript는이 글을 쓰는 시점에서 타입 주석 체계가 내장되어있지 않습니다. 그러나 JSDoc(점점 사용자가 줄고 있음),  Facebook의 [Flow](https://flow.org/),  Microsoft의 [TypeScript](https://www.typescriptlang.org/) 등의 몇 가지 경쟁 포맷이 갭을 메우기 위해 수년 동안  [급성장하고](https://www.typescriptlang.org/)  있습니다.  저는  [rtype](https://github.com/ericelliott/rtype)을 문서화에 사용합니다 - 이는 함수형 프로그래밍을 위한 TypeScript보다 훨씬 더 읽기 쉬운 표기법입니다.\n\n이 글을 쓰는 시점에는 타입 주석에 대해 확실한 승자가 없습니다.  JavaScript 스펙에 의해 어떠한 대안도 선택을 받지 못했으며, 각각에 명확한 결점이있는 것으로 보입니다.\n\n타입 추론은 데이터가 사용 된 문맥을 기반으로 유추하여 타입을 추론하는 프로세스입니다. JavaScript에서 이는 타입 주석의 좋은 대안입니다.\n\n표준 JavaScript 함수 서명으로 타입 추론을 위한 충분한 단서를 제공하면 비용이나 위험없이 타입 주석의 이점 대부분을 얻을 수 있습니다.\n\nTypeScript 또는 Flow와 같은 도구를 사용하기로한 경우에도 타입 추론으로 가능한 많은 작업을 수행하고 타입 추론이 부족한 상황에서 타입 주석을 달아야합니다.  예를 들어 JavaScript에는 공유 인터페이스를 정의하는 방법이 없습니다. 그러나 TypeScript 또는 rtype에서는 쉽고 유용합니다.\n\n[Tern.js](http://ternjs.net/)  는 다양한 텍스트 에디터와 IDE 용 플러그인이있는 JavaScript용 타입 추론 도구입니다.\n\nMicrosoft의 Visual Studio Code는 TypeScript의 타입 추론 기능을 일반 JavaScript 코드로 가져 오기 때문에 Tern이 필요하지 않습니다.\n\nJavaScript에서 함수의 기본 매개 변수를 지정하면 Tern.js, TypeScript 및 Flow와 같은 유형 유추가 가능한 도구는 작업 도중 올바르게  API를 사용할 수 있도록 IDE 힌트를 제공합니다.\n\n기본 값이 없다면 IDE(그리고 사람)는 매개 변수 타입을 파악할 수 있는 힌트를 충분히 확보하지 못합니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*2sP_9k1e0dkgYqdEPs0G3g.png)\n\n기본값이 없으면`userName`의 타입을 알 수 없습니다.\n\n기본값을 사용하면 IDE(그리고 사람)가 예제를 보고 유추 할 수 있습니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*tFUXCLA8ClAzsPgZXGGR9A.png)\n\n기본값을 보고, IDE는`userName` 매개 변수가 문자열을 기다리고 있다고 제안 할 수 있습니다.\n\n매개 변수를 고정 유형으로 제한하는 것이 의미가 있다는 것은 아닙니다(일반 함수와 고차 함수를 만들기 어려워 집니다). 하지만 적절히 사용한다면 기본 매개 변수만큼 유용한 것도 없습니다. TypeScript 또는 flow를 사용하고 있어도 마찬가지입니다.\n\n## 믹스인 합성을 위한 팩토리 함수\n\n팩토리는 API를 멋지게 호출하여 객체를 꺼내오는데 유용합니다. 일반적으로 이 정도면 충분하지만, 한 번에 여러 유형의 객체에 비슷한 기능을 구현하려는 경우가 있습니다. 이러한 기능을 보다 쉽게 재사용하려면 함수형 믹스인으로 추상화하면 됩니다.\n\n이 때야 말로 함수형 믹스인이 빛나는 곳입니다.  모든 객체 인스턴스에  `withConstructor`  속성을 추가하려면  `withConstructor`  믹스인을 빌드하십시오.\n\n`with-constructor.js`  :\n\n```javascript\nconst withConstructor = constructor => o => {  \n  const proto = Object.assign({},  \n    Object.getPrototypeOf(o),  \n    { constructor }  \n  );\n\n  return Object.assign(Object.create(proto), o);  \n};\n```\n\n이것을 가져와 다른 믹스인과 함께 사용할 수 있습니다.\n\n```javascript\nimport withConstructor from './with-constructor';\n\nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);  \n// or `import pipe from 'lodash/fp/flow';`\n\n// Set up some functional mixins  \nconst withFlying = o => {  \n  let isFlying = false;\n\n  return {  \n    ...o,  \n    fly () {  \n      isFlying = true;  \n      return this;  \n    },  \n    land () {  \n      isFlying = false;  \n      return this;  \n    },  \n    isFlying: () => isFlying  \n  }  \n};\n\nconst withBattery = ({ capacity }) => o => {  \n  let percentCharged = 100;\n\n  return {  \n    ...o,  \n    draw (percent) {  \n      const remaining = percentCharged - percent;  \n      percentCharged = remaining > 0 ? remaining : 0;  \n      return this;  \n    },  \n    getCharge: () => percentCharged,  \n    get capacity () {  \n      return capacity  \n    }  \n  };  \n};\n\nconst createDrone = ({ capacity = '3000mAh' }) => pipe(  \n  withFlying,  \n  withBattery({ capacity }),  \n  withConstructor(createDrone)  \n)({});\n\nconst myDrone = createDrone({ capacity: '5500mAh' });\n\nconsole.log(`  \n  can fly:  ${ myDrone.fly().isFlying() === true }  \n  can land: ${ myDrone.land().isFlying() === false }  \n  battery capacity: ${ myDrone.capacity }  \n  battery status: ${ myDrone.draw(50).getCharge() }%  \n  battery drained: ${ myDrone.draw(75).getCharge() }%  \n`);\n\nconsole.log(`  \n  constructor linked: ${ myDrone.constructor === createDrone }  \n`);\n```\n\n보시다시피 재사용 가능한  `withConstructor()` 믹스인은 다른 믹스인과 함께 파이프 라인으로 간단히 합쳐집니다.  `withBattery()`는 로봇, 전기 스케이트 보드 또는 보조 배터리와 같은 다른 종류의 객체와 함께 사용할 수 있습니다.  `withFlying()`  은 날아다니는 자동차, 로켓 또는 에어벌룬을 모델링하는데 사용될 수 있습니다.\n\n**Composition**은 특별한 코딩 기술이라기 보다는 사고 방식에 가깝습니다.  여러분은 여러 가지 방법으로 이를 적용 할 수 있습니다.  함수 합성은 기초부터 다시 만들 때 사용할 수 있는 가장 쉬운 방법이며, 팩토리 함수는 구현의 세부 사항을 친숙한 API로 포장하는 간단한 방법입니다.\n\n## 결론\n\nES6가 제공하는 편리한 구문들은 객체 생성 및 팩토리 함수를 다루기 쉽게 만듭니다. 대부분이 경우에는 이정도로 충분하지만, JavaScript이기 때문에 Java와 같은 느낌을 주는 또 다른 접근 방식이 있습니다 :  `class`  키워드.\n\nJavaScript에서 클래스는 팩토리보다 더 장황하고 제한적이며, 리팩토링할 때는 거의 지뢰밭을 걷는 느낌을 주지만 React와 Angular와 같은 주요 프론트 엔드 프레임 워크에 의해 사용되어 왔으며 몇 가지 드문 용도(복잡함을 감수할만한 가치가 있는 경우)가 있습니다.\n\n> \"때때로 우아한 구현은 단지 함수뿐입니다.  메소드가 아닙니다. 클래스도 아닙니다. 프레임워크도 아니고 그저 함수입니다.\"~ John Carmack\n\n가장 간단한 구현으로 시작하고 필요한 경우에만보다 복잡한 구현으로 이동하십시오.  객체를 다루는 관점에서는 다음과 같습니다.\n\n`Pure function -> factory -> functional mixin -> class`\n\n[**다음: 클래스로 합성하기가 까다로운 이유 >**](https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/)\n","slug":"javaScript-factory-function-with-es6","published":1,"updated":"2018-04-28T13:36:38.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83dn000hifp6mpforyb1","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/07/functional-mixins/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/\">다음&gt;</a></p>\n</blockquote>\n<h2 id=\"factory-function\">Factory Function</h2>\n<p><strong>팩토리 함수</strong>는 (새로운)객체를 리턴하는 함수입니다. 그러나 클래스나 생성자 함수는 아닙니다.  JavaScript에서는 모든 함수가 객체를 리턴할 수 있습니다. 이 때 <code>new</code> 키워드가 없으면 팩토리 함수입니다.</p>\n<p>JavaScript에서 팩토리 함수는 항상 매력적입니다. 클래스와  <code>new</code>  키워드의 복잡함 없이 객체 인스턴스를 쉽게 생성 할 수 있기 때문입니다.</p>\n<p>JavaScript는 매우 유용한 객체 리터럴 구문을 제공합니다.  다음과 같습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;  </span><br><span class=\"line\">  userName: <span class=\"string\">'echo'</span>,  </span><br><span class=\"line\">  avatar: <span class=\"string\">'echo.png'</span>  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>자바 스크립트의 객체 리터럴 표기법은 JSON과 마찬가지로  <code>:</code>  의 왼쪽은 속성의 이름이고 오른쪽은 값입니다.  점 표기법으로 속성에 액세스 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(user.userName); <span class=\"comment\">// \"echo\"</span></span><br></pre></td></tr></table></figure>\n<p>대괄호 표기법을 사용하여 계산 된 속성 이름에 액세스 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> key = <span class=\"string\">'avatar'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( user[key] ); <span class=\"comment\">// \"echo.png\"</span></span><br></pre></td></tr></table></figure>\n<p>스코프에 객체의 속성 이름과 동일한 이름의 변수가있는 경우, 객체를 리터럴로 생성할 때 콜론과 값을 생략할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> userName = <span class=\"string\">'echo'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> avatar = <span class=\"string\">'echo.png'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user);  </span><br><span class=\"line\"><span class=\"comment\">// &#123; \"avatar\": \"echo.png\",   \"userName\": \"echo\" &#125;</span></span><br></pre></td></tr></table></figure>\n<p>객체 리터럴은 간결한 메소드 구문을 지원합니다.  <code>.setUserName()</code>  메소드를 추가 해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> userName = <span class=\"string\">'echo'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> avatar = <span class=\"string\">'echo.png'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar,</span><br><span class=\"line\"></span><br><span class=\"line\">  setUserName (userName) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.userName = userName;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.setUserName(<span class=\"string\">'Foo'</span>).userName); <span class=\"comment\">// \"Foo\"</span></span><br></pre></td></tr></table></figure>\n<p>이 때,  <code>this</code>는 메소드를 호출하는 오브젝트를 참조합니다.  객체의 메소드를 호출하려면 객체 점 표기법을 사용하여 메소에 액세스하고 괄호를 붙여 호출하면 됩니다.  예를 들어  <code>game.play()</code>는  <code>game</code>객체에  <code>.play()</code>를 적용합니다.  점 표기법을 사용하여 메소드를 적용하려면 해당 메소드가 해당 오브젝트의 속성이어야합니다.  함수 프로토타입 메소드인  <code>.call()</code>  ,  <code>.apply()</code>  또는  <code>.bind()</code>를 사용하여 임의의 객체에 메소드를 적용 할 수도 있습니다.</p>\n<p>이 경우  <code>user.setUserName('Foo')</code>는  <code>.setUserName()</code>을  <code>user</code>에게 적용합니다.  이 때 <code>this</code>는 <code>user</code>가 되며  <code>.setUserName()</code>  내부의  <code>this</code>를 통해  <code>user</code> 객체의  <code>.userName</code>  속성을 변경합니다. 마지막으로 메소드 체이닝을 할 수 있게 하기 위해 동일한 객체 인스턴스를 리턴하게 했습니다.</p>\n<h2 id=\"literals-for-one-factories-for-many\">Literals for One, Factories for Many</h2>\n<p>객체를 반복해서 생성해야 하는 경우 객체 리터럴과 팩토리 함수의 기능을 결합해야합니다.</p>\n<p>팩토리 함수를 사용하여 원하는 만큼 많은 객체를 생성 할 수 있습니다.  예를 들어 채팅 앱을 만드는 경우 사용자 본인을 나타내는 사용자 객체가 필요합니다. 그 외에 현재 로그인되어 있고 채팅중인 다른 모든 사용자를 나타내는 많은 다른 사용자 객체가 필요합니다.</p>\n<p><code>user</code>  객체를  <code>createUser()</code>  팩토리로 바꿔보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = <span class=\"function\">(<span class=\"params\">&#123; userName, avatar &#125;</span>) =&gt;</span> (&#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar,  </span><br><span class=\"line\">  setUserName (userName) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.userName = userName;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(createUser(&#123; <span class=\"attr\">userName</span>: <span class=\"string\">'echo'</span>, <span class=\"attr\">avatar</span>: <span class=\"string\">'echo.png'</span> &#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">&#123;  </span></span><br><span class=\"line\"><span class=\"comment\">  \"avatar\": \"echo.png\",  </span></span><br><span class=\"line\"><span class=\"comment\">  \"userName\": \"echo\",  </span></span><br><span class=\"line\"><span class=\"comment\">  \"setUserName\": [Function setUserName]  </span></span><br><span class=\"line\"><span class=\"comment\">&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"암시적인-객체-리턴\">암시적인 객체 리턴</h2>\n<p>화살표 함수 ( <code>=&gt;</code> )는 암시적인 리턴을 합니다. 함수 본문이 단일 식으로 구성되어 있으면  <code>return</code>  키워드를 생략 할 수 있습니다.  <code>() =&gt; 'foo'</code>는 아무 인자도 받지 않고 <code>'foo'</code>를 리턴합니다.</p>\n<p>객체 리터럴을 리턴할 때 주의해야 합니다.  기본적으로 JavaScript는 중괄호를 발견하면 당신이 함수 본문을 만들려고 한다고 여깁니다(e.g.<code>{ broken: true }</code>). 객체 리터럴을 암시적으로 반환하고 싶으면 중괄호 바깥을 괄호로 감싸주어야 합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> noop = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span> &#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(noop()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createFoo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span> &#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(createFoo()); <span class=\"comment\">// &#123; foo: \"bar\" &#125;</span></span><br></pre></td></tr></table></figure>\n<p>첫 번째에서  <code>foo:</code>는 레이블로 해석되고  <code>bar</code>는 할당되거나 리턴되지 않는 표현식으로 해석됩니다. 따라서 이 함수는  <code>undefined</code>를 리턴합니다.</p>\n<p><code>createFoo()</code> 예제에서 괄호는 그 안에 있는 것이 함수 본문 블록이 아닌 평가되어야 할 식으로 해석하도록 합니다.</p>\n<h2 id=\"해체-destructuring1\">해체 Destructuring<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h2>\n<p>함수 서명을 주의깊게 보시기 바랍니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = <span class=\"function\">(<span class=\"params\">&#123; userName, avatar &#125;</span>) =&gt;</span> (&#123;</span><br></pre></td></tr></table></figure>\n<p>이 줄에서, 중괄호 (  <code>{</code>  ,  <code>}</code>  )는 객체를 해체하라는 의미로 해석됩니다.  이 함수는 하나의 인수 (객체)를 받지만 이를 해체하여  <code>userName</code>  과  <code>avatar</code>라는 두 매개변수에 값을 바인딩 합니다.  이러한 매개 변수는 함수 범위에서 변수로 사용될 수 있습니다.  배열을 해체할 수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> swap = <span class=\"function\">(<span class=\"params\">[first, second]</span>) =&gt;</span> [second, first];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( swap([<span class=\"number\">1</span>, <span class=\"number\">2</span>]) ); <span class=\"comment\">// [2, 1]</span></span><br></pre></td></tr></table></figure>\n<p>그리고 나머지 구문과 스프레드 연산자를(<code>...varName</code>  ) 사용하여 배열 (또는 인수 목록)에서 나머지 값을 수집 한 다음 해당 배열 요소를 개별 요소로 다시 펼칠 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rotate = <span class=\"function\">(<span class=\"params\">[first, ...rest]</span>) =&gt;</span> [...rest, first];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( rotate([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) ); <span class=\"comment\">// [2, 3, 1]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"계산된-속성-키\">계산된 속성 키</h2>\n<p>앞에서 우리는 대괄호를 사용해 계산된 속성에 엑세스했습니다. 다시 말하자면 액세스 할 속성을 동적으로 결정했습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> key = <span class=\"string\">'avatar'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( user[key] ); <span class=\"comment\">// \"echo.png\"</span></span><br></pre></td></tr></table></figure>\n<p>그렇다면 계산된 값을 키로 할당 할 수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrToObj = <span class=\"function\">(<span class=\"params\">[key, value]</span>) =&gt;</span> (&#123; [key]: value &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( arrToObj([ <span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span> ]) ); <span class=\"comment\">// &#123; \"foo\": \"bar\" &#125;</span></span><br></pre></td></tr></table></figure>\n<p>이 예제에서  <code>arrToObj</code>는 키/값 쌍 (일명 튜플)으로 구성된 배열을 가져 와서 객체로 변환합니다.  키의 이름을 알지 못하기 때문에 객체의 키/값 쌍을 설정하려면 속성 이름을 계산해야합니다.  이를 위해 대괄호 표기법을 빌려 객체 리터럴을 작성하는데 다시 사용합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; [key]: value &#125;</span><br></pre></td></tr></table></figure>\n<p>보간이 끝나면 객체가 완성됩니다:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"string\">\"foo\"</span>: <span class=\"string\">\"bar\"</span>&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"기본-매개-변수default-parameters\">기본 매개 변수<sup>Default</sup> <sup>Parameters</sup></h2>\n<p>JavaScript의 함수는 기본 매개 변수 값을 지원하며 다음과 같은 몇 가지 이점이 있습니다.</p>\n<ol>\n<li>사용자는 적절한 기본값으로 매개 변수를 생략 할 수 있습니다.</li>\n<li>기본값은 예상되는 입력의 예를 제공하기 때문에 이 함수는 더 자체적으로 문서화됩니다.</li>\n<li>IDE 및 정적 분석 도구는 기본값을 사용하여 매개 변수에 필요한 유형을 추론 할 수 있습니다.  예를 들어, 기본값  <code>1</code>은 매개 변수가  <code>Number</code>타입의 멤버를 사용할 수 있음을 의미합니다.</li>\n</ol>\n<p>다음 예제는 기본 매개 변수를 사용하여  <code>createUser</code> 팩토리의 예상 인터페이스를 문서화하고 사용자 정보가 제공되지 않은 경우  세부 정보를 <code>'Anonymous'</code>로 하여 자동으로 채 웁니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = (&#123;  </span><br><span class=\"line\">  userName = <span class=\"string\">'Anonymous'</span>,  </span><br><span class=\"line\">  avatar = <span class=\"string\">'anon.png'</span>  </span><br><span class=\"line\">&#125; = &#123;&#125;) =&gt; (&#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  <span class=\"comment\">// &#123; userName: \"echo\", avatar: 'anon.png' &#125;  </span></span><br><span class=\"line\">  createUser(&#123; <span class=\"attr\">userName</span>: <span class=\"string\">'echo'</span> &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// &#123; userName: \"Anonymous\", avatar: 'anon.png' &#125;  </span></span><br><span class=\"line\">  createUser()  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>함수 서명의 마지막 부분은 아마도 약간 우습게 보일 것입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#125; = &#123;&#125;) =&gt; (&#123;</span><br></pre></td></tr></table></figure>\n<p>인수 서명이 닫히기 직전 마지막에 있는  <code>= {}</code>는 <code>createUser</code>에게 아무 것도 전달되지 않았을 경우 <code>undefined</code>나 <code>null</code>을 매개 변수에 전달하는 것이 아닌 빈 객체를 전달하라는 의미 입니다. 빈 객체에 대해 기본값을 해체하여 할당하게되면 자동으로 속성값 설정됩니다. 즉 기본 값이 하는 일은 다음과 같습니다.</p>\n<blockquote>\n<p><code>undefined</code> 를 미리 정의 된 값으로 바꿉니다.</p>\n</blockquote>\n<p><code>= {}</code>가 없으면  <code>undefined</code>의 속성에 액세스하려는 과정에서 <code>createUser()</code>  가 오류를 발생시킵니다.</p>\n<h2 id=\"타입-추론\">타입 추론</h2>\n<p>JavaScript는이 글을 쓰는 시점에서 타입 주석 체계가 내장되어있지 않습니다. 그러나 JSDoc(점점 사용자가 줄고 있음),  Facebook의 <a href=\"https://flow.org/\" target=\"_blank\" rel=\"noopener\">Flow</a>,  Microsoft의 <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">TypeScript</a> 등의 몇 가지 경쟁 포맷이 갭을 메우기 위해 수년 동안  <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">급성장하고</a>  있습니다.  저는  <a href=\"https://github.com/ericelliott/rtype\" target=\"_blank\" rel=\"noopener\">rtype</a>을 문서화에 사용합니다 - 이는 함수형 프로그래밍을 위한 TypeScript보다 훨씬 더 읽기 쉬운 표기법입니다.</p>\n<p>이 글을 쓰는 시점에는 타입 주석에 대해 확실한 승자가 없습니다.  JavaScript 스펙에 의해 어떠한 대안도 선택을 받지 못했으며, 각각에 명확한 결점이있는 것으로 보입니다.</p>\n<p>타입 추론은 데이터가 사용 된 문맥을 기반으로 유추하여 타입을 추론하는 프로세스입니다. JavaScript에서 이는 타입 주석의 좋은 대안입니다.</p>\n<p>표준 JavaScript 함수 서명으로 타입 추론을 위한 충분한 단서를 제공하면 비용이나 위험없이 타입 주석의 이점 대부분을 얻을 수 있습니다.</p>\n<p>TypeScript 또는 Flow와 같은 도구를 사용하기로한 경우에도 타입 추론으로 가능한 많은 작업을 수행하고 타입 추론이 부족한 상황에서 타입 주석을 달아야합니다.  예를 들어 JavaScript에는 공유 인터페이스를 정의하는 방법이 없습니다. 그러나 TypeScript 또는 rtype에서는 쉽고 유용합니다.</p>\n<p><a href=\"http://ternjs.net/\" target=\"_blank\" rel=\"noopener\">Tern.js</a>  는 다양한 텍스트 에디터와 IDE 용 플러그인이있는 JavaScript용 타입 추론 도구입니다.</p>\n<p>Microsoft의 Visual Studio Code는 TypeScript의 타입 추론 기능을 일반 JavaScript 코드로 가져 오기 때문에 Tern이 필요하지 않습니다.</p>\n<p>JavaScript에서 함수의 기본 매개 변수를 지정하면 Tern.js, TypeScript 및 Flow와 같은 유형 유추가 가능한 도구는 작업 도중 올바르게  API를 사용할 수 있도록 IDE 힌트를 제공합니다.</p>\n<p>기본 값이 없다면 IDE(그리고 사람)는 매개 변수 타입을 파악할 수 있는 힌트를 충분히 확보하지 못합니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*2sP_9k1e0dkgYqdEPs0G3g.png\" alt=\"\"></p>\n<p>기본값이 없으면<code>userName</code>의 타입을 알 수 없습니다.</p>\n<p>기본값을 사용하면 IDE(그리고 사람)가 예제를 보고 유추 할 수 있습니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*tFUXCLA8ClAzsPgZXGGR9A.png\" alt=\"\"></p>\n<p>기본값을 보고, IDE는<code>userName</code> 매개 변수가 문자열을 기다리고 있다고 제안 할 수 있습니다.</p>\n<p>매개 변수를 고정 유형으로 제한하는 것이 의미가 있다는 것은 아닙니다(일반 함수와 고차 함수를 만들기 어려워 집니다). 하지만 적절히 사용한다면 기본 매개 변수만큼 유용한 것도 없습니다. TypeScript 또는 flow를 사용하고 있어도 마찬가지입니다.</p>\n<h2 id=\"믹스인-합성을-위한-팩토리-함수\">믹스인 합성을 위한 팩토리 함수</h2>\n<p>팩토리는 API를 멋지게 호출하여 객체를 꺼내오는데 유용합니다. 일반적으로 이 정도면 충분하지만, 한 번에 여러 유형의 객체에 비슷한 기능을 구현하려는 경우가 있습니다. 이러한 기능을 보다 쉽게 재사용하려면 함수형 믹스인으로 추상화하면 됩니다.</p>\n<p>이 때야 말로 함수형 믹스인이 빛나는 곳입니다.  모든 객체 인스턴스에  <code>withConstructor</code>  속성을 추가하려면  <code>withConstructor</code>  믹스인을 빌드하십시오.</p>\n<p><code>with-constructor.js</code>  :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withConstructor = <span class=\"function\"><span class=\"params\">constructor</span> =&gt;</span> o =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> proto = <span class=\"built_in\">Object</span>.assign(&#123;&#125;,  </span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.getPrototypeOf(o),  </span><br><span class=\"line\">    &#123; <span class=\"keyword\">constructor</span> &#125;  </span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  return Object.assign(Object.create(proto), o);  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>이것을 가져와 다른 믹스인과 함께 사용할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> withConstructor <span class=\"keyword\">from</span> <span class=\"string\">'./with-constructor'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);  </span><br><span class=\"line\"><span class=\"comment\">// or `import pipe from 'lodash/fp/flow';`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set up some functional mixins  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withFlying = <span class=\"function\"><span class=\"params\">o</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> isFlying = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;  </span><br><span class=\"line\">    ...o,  </span><br><span class=\"line\">    fly () &#123;  </span><br><span class=\"line\">      isFlying = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    land () &#123;  </span><br><span class=\"line\">      isFlying = <span class=\"literal\">false</span>;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    isFlying: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> isFlying  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> withBattery = <span class=\"function\">(<span class=\"params\">&#123; capacity &#125;</span>) =&gt;</span> o =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> percentCharged = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;  </span><br><span class=\"line\">    ...o,  </span><br><span class=\"line\">    draw (percent) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">const</span> remaining = percentCharged - percent;  </span><br><span class=\"line\">      percentCharged = remaining &gt; <span class=\"number\">0</span> ? remaining : <span class=\"number\">0</span>;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    getCharge: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> percentCharged,  </span><br><span class=\"line\">    get capacity () &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> capacity  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createDrone = <span class=\"function\">(<span class=\"params\">&#123; capacity = <span class=\"string\">'3000mAh'</span> &#125;</span>) =&gt;</span> pipe(  </span><br><span class=\"line\">  withFlying,  </span><br><span class=\"line\">  withBattery(&#123; capacity &#125;),  </span><br><span class=\"line\">  withConstructor(createDrone)  </span><br><span class=\"line\">)(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myDrone = createDrone(&#123; <span class=\"attr\">capacity</span>: <span class=\"string\">'5500mAh'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">  can fly:  <span class=\"subst\">$&#123; myDrone.fly().isFlying() === <span class=\"literal\">true</span> &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">  can land: <span class=\"subst\">$&#123; myDrone.land().isFlying() === <span class=\"literal\">false</span> &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">  battery capacity: <span class=\"subst\">$&#123; myDrone.capacity &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">  battery status: <span class=\"subst\">$&#123; myDrone.draw(<span class=\"number\">50</span>).getCharge() &#125;</span>%  </span></span><br><span class=\"line\"><span class=\"string\">  battery drained: <span class=\"subst\">$&#123; myDrone.draw(<span class=\"number\">75</span>).getCharge() &#125;</span>%  </span></span><br><span class=\"line\"><span class=\"string\">`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">  constructor linked: <span class=\"subst\">$&#123; myDrone.constructor === createDrone &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">`</span>);</span><br></pre></td></tr></table></figure>\n<p>보시다시피 재사용 가능한  <code>withConstructor()</code> 믹스인은 다른 믹스인과 함께 파이프 라인으로 간단히 합쳐집니다.  <code>withBattery()</code>는 로봇, 전기 스케이트 보드 또는 보조 배터리와 같은 다른 종류의 객체와 함께 사용할 수 있습니다.  <code>withFlying()</code>  은 날아다니는 자동차, 로켓 또는 에어벌룬을 모델링하는데 사용될 수 있습니다.</p>\n<p><strong>Composition</strong>은 특별한 코딩 기술이라기 보다는 사고 방식에 가깝습니다.  여러분은 여러 가지 방법으로 이를 적용 할 수 있습니다.  함수 합성은 기초부터 다시 만들 때 사용할 수 있는 가장 쉬운 방법이며, 팩토리 함수는 구현의 세부 사항을 친숙한 API로 포장하는 간단한 방법입니다.</p>\n<h2 id=\"결론\">결론</h2>\n<p>ES6가 제공하는 편리한 구문들은 객체 생성 및 팩토리 함수를 다루기 쉽게 만듭니다. 대부분이 경우에는 이정도로 충분하지만, JavaScript이기 때문에 Java와 같은 느낌을 주는 또 다른 접근 방식이 있습니다 :  <code>class</code>  키워드.</p>\n<p>JavaScript에서 클래스는 팩토리보다 더 장황하고 제한적이며, 리팩토링할 때는 거의 지뢰밭을 걷는 느낌을 주지만 React와 Angular와 같은 주요 프론트 엔드 프레임 워크에 의해 사용되어 왔으며 몇 가지 드문 용도(복잡함을 감수할만한 가치가 있는 경우)가 있습니다.</p>\n<blockquote>\n<p>“때때로 우아한 구현은 단지 함수뿐입니다.  메소드가 아닙니다. 클래스도 아닙니다. 프레임워크도 아니고 그저 함수입니다.”~ John Carmack</p>\n</blockquote>\n<p>가장 간단한 구현으로 시작하고 필요한 경우에만보다 복잡한 구현으로 이동하십시오.  객체를 다루는 관점에서는 다음과 같습니다.</p>\n<p><code>Pure function -&gt; factory -&gt; functional mixin -&gt; class</code></p>\n<p><a href=\"https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/\"><strong>다음: 클래스로 합성하기가 까다로운 이유 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>해체, 파괴, 비구조화, 디스트럭쳐링 등 다양한 용어로 번역되고 있습니다. -역자 <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/07/functional-mixins/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/\">다음&gt;</a></p>\n</blockquote>\n<h2>Factory Function</h2>\n<p><strong>팩토리 함수</strong>는 (새로운)객체를 리턴하는 함수입니다. 그러나 클래스나 생성자 함수는 아닙니다.  JavaScript에서는 모든 함수가 객체를 리턴할 수 있습니다. 이 때 <code>new</code> 키워드가 없으면 팩토리 함수입니다.</p>\n<p>JavaScript에서 팩토리 함수는 항상 매력적입니다. 클래스와  <code>new</code>  키워드의 복잡함 없이 객체 인스턴스를 쉽게 생성 할 수 있기 때문입니다.</p>\n<p>JavaScript는 매우 유용한 객체 리터럴 구문을 제공합니다.  다음과 같습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;  </span><br><span class=\"line\">  userName: <span class=\"string\">'echo'</span>,  </span><br><span class=\"line\">  avatar: <span class=\"string\">'echo.png'</span>  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>자바 스크립트의 객체 리터럴 표기법은 JSON과 마찬가지로  <code>:</code>  의 왼쪽은 속성의 이름이고 오른쪽은 값입니다.  점 표기법으로 속성에 액세스 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(user.userName); <span class=\"comment\">// \"echo\"</span></span><br></pre></td></tr></table></figure>\n<p>대괄호 표기법을 사용하여 계산 된 속성 이름에 액세스 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> key = <span class=\"string\">'avatar'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( user[key] ); <span class=\"comment\">// \"echo.png\"</span></span><br></pre></td></tr></table></figure>\n<p>스코프에 객체의 속성 이름과 동일한 이름의 변수가있는 경우, 객체를 리터럴로 생성할 때 콜론과 값을 생략할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> userName = <span class=\"string\">'echo'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> avatar = <span class=\"string\">'echo.png'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user);  </span><br><span class=\"line\"><span class=\"comment\">// &#123; \"avatar\": \"echo.png\",   \"userName\": \"echo\" &#125;</span></span><br></pre></td></tr></table></figure>\n<p>객체 리터럴은 간결한 메소드 구문을 지원합니다.  <code>.setUserName()</code>  메소드를 추가 해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> userName = <span class=\"string\">'echo'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> avatar = <span class=\"string\">'echo.png'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar,</span><br><span class=\"line\"></span><br><span class=\"line\">  setUserName (userName) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.userName = userName;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.setUserName(<span class=\"string\">'Foo'</span>).userName); <span class=\"comment\">// \"Foo\"</span></span><br></pre></td></tr></table></figure>\n<p>이 때,  <code>this</code>는 메소드를 호출하는 오브젝트를 참조합니다.  객체의 메소드를 호출하려면 객체 점 표기법을 사용하여 메소에 액세스하고 괄호를 붙여 호출하면 됩니다.  예를 들어  <code>game.play()</code>는  <code>game</code>객체에  <code>.play()</code>를 적용합니다.  점 표기법을 사용하여 메소드를 적용하려면 해당 메소드가 해당 오브젝트의 속성이어야합니다.  함수 프로토타입 메소드인  <code>.call()</code>  ,  <code>.apply()</code>  또는  <code>.bind()</code>를 사용하여 임의의 객체에 메소드를 적용 할 수도 있습니다.</p>\n<p>이 경우  <code>user.setUserName('Foo')</code>는  <code>.setUserName()</code>을  <code>user</code>에게 적용합니다.  이 때 <code>this</code>는 <code>user</code>가 되며  <code>.setUserName()</code>  내부의  <code>this</code>를 통해  <code>user</code> 객체의  <code>.userName</code>  속성을 변경합니다. 마지막으로 메소드 체이닝을 할 수 있게 하기 위해 동일한 객체 인스턴스를 리턴하게 했습니다.</p>\n<h2>Literals for One, Factories for Many</h2>\n<p>객체를 반복해서 생성해야 하는 경우 객체 리터럴과 팩토리 함수의 기능을 결합해야합니다.</p>\n<p>팩토리 함수를 사용하여 원하는 만큼 많은 객체를 생성 할 수 있습니다.  예를 들어 채팅 앱을 만드는 경우 사용자 본인을 나타내는 사용자 객체가 필요합니다. 그 외에 현재 로그인되어 있고 채팅중인 다른 모든 사용자를 나타내는 많은 다른 사용자 객체가 필요합니다.</p>\n<p><code>user</code>  객체를  <code>createUser()</code>  팩토리로 바꿔보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = <span class=\"function\">(<span class=\"params\">&#123; userName, avatar &#125;</span>) =&gt;</span> (&#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar,  </span><br><span class=\"line\">  setUserName (userName) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.userName = userName;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(createUser(&#123; <span class=\"attr\">userName</span>: <span class=\"string\">'echo'</span>, <span class=\"attr\">avatar</span>: <span class=\"string\">'echo.png'</span> &#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">&#123;  </span></span><br><span class=\"line\"><span class=\"comment\">  \"avatar\": \"echo.png\",  </span></span><br><span class=\"line\"><span class=\"comment\">  \"userName\": \"echo\",  </span></span><br><span class=\"line\"><span class=\"comment\">  \"setUserName\": [Function setUserName]  </span></span><br><span class=\"line\"><span class=\"comment\">&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2>암시적인 객체 리턴</h2>\n<p>화살표 함수 ( <code>=&gt;</code> )는 암시적인 리턴을 합니다. 함수 본문이 단일 식으로 구성되어 있으면  <code>return</code>  키워드를 생략 할 수 있습니다.  <code>() =&gt; 'foo'</code>는 아무 인자도 받지 않고 <code>'foo'</code>를 리턴합니다.</p>\n<p>객체 리터럴을 리턴할 때 주의해야 합니다.  기본적으로 JavaScript는 중괄호를 발견하면 당신이 함수 본문을 만들려고 한다고 여깁니다(e.g.<code>{ broken: true }</code>). 객체 리터럴을 암시적으로 반환하고 싶으면 중괄호 바깥을 괄호로 감싸주어야 합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> noop = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span> &#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(noop()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createFoo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span> &#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(createFoo()); <span class=\"comment\">// &#123; foo: \"bar\" &#125;</span></span><br></pre></td></tr></table></figure>\n<p>첫 번째에서  <code>foo:</code>는 레이블로 해석되고  <code>bar</code>는 할당되거나 리턴되지 않는 표현식으로 해석됩니다. 따라서 이 함수는  <code>undefined</code>를 리턴합니다.</p>\n<p><code>createFoo()</code> 예제에서 괄호는 그 안에 있는 것이 함수 본문 블록이 아닌 평가되어야 할 식으로 해석하도록 합니다.</p>\n<h2>해체 Destructuring<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></h2>\n<p>함수 서명을 주의깊게 보시기 바랍니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = <span class=\"function\">(<span class=\"params\">&#123; userName, avatar &#125;</span>) =&gt;</span> (&#123;</span><br></pre></td></tr></table></figure>\n<p>이 줄에서, 중괄호 (  <code>{</code>  ,  <code>}</code>  )는 객체를 해체하라는 의미로 해석됩니다.  이 함수는 하나의 인수 (객체)를 받지만 이를 해체하여  <code>userName</code>  과  <code>avatar</code>라는 두 매개변수에 값을 바인딩 합니다.  이러한 매개 변수는 함수 범위에서 변수로 사용될 수 있습니다.  배열을 해체할 수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> swap = <span class=\"function\">(<span class=\"params\">[first, second]</span>) =&gt;</span> [second, first];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( swap([<span class=\"number\">1</span>, <span class=\"number\">2</span>]) ); <span class=\"comment\">// [2, 1]</span></span><br></pre></td></tr></table></figure>\n<p>그리고 나머지 구문과 스프레드 연산자를(<code>...varName</code>  ) 사용하여 배열 (또는 인수 목록)에서 나머지 값을 수집 한 다음 해당 배열 요소를 개별 요소로 다시 펼칠 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rotate = <span class=\"function\">(<span class=\"params\">[first, ...rest]</span>) =&gt;</span> [...rest, first];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( rotate([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) ); <span class=\"comment\">// [2, 3, 1]</span></span><br></pre></td></tr></table></figure>\n<h2>계산된 속성 키</h2>\n<p>앞에서 우리는 대괄호를 사용해 계산된 속성에 엑세스했습니다. 다시 말하자면 액세스 할 속성을 동적으로 결정했습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> key = <span class=\"string\">'avatar'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( user[key] ); <span class=\"comment\">// \"echo.png\"</span></span><br></pre></td></tr></table></figure>\n<p>그렇다면 계산된 값을 키로 할당 할 수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrToObj = <span class=\"function\">(<span class=\"params\">[key, value]</span>) =&gt;</span> (&#123; [key]: value &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( arrToObj([ <span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span> ]) ); <span class=\"comment\">// &#123; \"foo\": \"bar\" &#125;</span></span><br></pre></td></tr></table></figure>\n<p>이 예제에서  <code>arrToObj</code>는 키/값 쌍 (일명 튜플)으로 구성된 배열을 가져 와서 객체로 변환합니다.  키의 이름을 알지 못하기 때문에 객체의 키/값 쌍을 설정하려면 속성 이름을 계산해야합니다.  이를 위해 대괄호 표기법을 빌려 객체 리터럴을 작성하는데 다시 사용합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; [key]: value &#125;</span><br></pre></td></tr></table></figure>\n<p>보간이 끝나면 객체가 완성됩니다:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"string\">\"foo\"</span>: <span class=\"string\">\"bar\"</span>&#125;</span><br></pre></td></tr></table></figure>\n<h2>기본 매개 변수<sup>Default</sup> <sup>Parameters</sup></h2>\n<p>JavaScript의 함수는 기본 매개 변수 값을 지원하며 다음과 같은 몇 가지 이점이 있습니다.</p>\n<ol>\n<li>사용자는 적절한 기본값으로 매개 변수를 생략 할 수 있습니다.</li>\n<li>기본값은 예상되는 입력의 예를 제공하기 때문에 이 함수는 더 자체적으로 문서화됩니다.</li>\n<li>IDE 및 정적 분석 도구는 기본값을 사용하여 매개 변수에 필요한 유형을 추론 할 수 있습니다.  예를 들어, 기본값  <code>1</code>은 매개 변수가  <code>Number</code>타입의 멤버를 사용할 수 있음을 의미합니다.</li>\n</ol>\n<p>다음 예제는 기본 매개 변수를 사용하여  <code>createUser</code> 팩토리의 예상 인터페이스를 문서화하고 사용자 정보가 제공되지 않은 경우  세부 정보를 <code>'Anonymous'</code>로 하여 자동으로 채 웁니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createUser = (&#123;  </span><br><span class=\"line\">  userName = <span class=\"string\">'Anonymous'</span>,  </span><br><span class=\"line\">  avatar = <span class=\"string\">'anon.png'</span>  </span><br><span class=\"line\">&#125; = &#123;&#125;) =&gt; (&#123;  </span><br><span class=\"line\">  userName,  </span><br><span class=\"line\">  avatar  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  <span class=\"comment\">// &#123; userName: \"echo\", avatar: 'anon.png' &#125;  </span></span><br><span class=\"line\">  createUser(&#123; <span class=\"attr\">userName</span>: <span class=\"string\">'echo'</span> &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// &#123; userName: \"Anonymous\", avatar: 'anon.png' &#125;  </span></span><br><span class=\"line\">  createUser()  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>함수 서명의 마지막 부분은 아마도 약간 우습게 보일 것입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#125; = &#123;&#125;) =&gt; (&#123;</span><br></pre></td></tr></table></figure>\n<p>인수 서명이 닫히기 직전 마지막에 있는  <code>= {}</code>는 <code>createUser</code>에게 아무 것도 전달되지 않았을 경우 <code>undefined</code>나 <code>null</code>을 매개 변수에 전달하는 것이 아닌 빈 객체를 전달하라는 의미 입니다. 빈 객체에 대해 기본값을 해체하여 할당하게되면 자동으로 속성값 설정됩니다. 즉 기본 값이 하는 일은 다음과 같습니다.</p>\n<blockquote>\n<p><code>undefined</code> 를 미리 정의 된 값으로 바꿉니다.</p>\n</blockquote>\n<p><code>= {}</code>가 없으면  <code>undefined</code>의 속성에 액세스하려는 과정에서 <code>createUser()</code>  가 오류를 발생시킵니다.</p>\n<h2>타입 추론</h2>\n<p>JavaScript는이 글을 쓰는 시점에서 타입 주석 체계가 내장되어있지 않습니다. 그러나 JSDoc(점점 사용자가 줄고 있음),  Facebook의 <a href=\"https://flow.org/\" target=\"_blank\" rel=\"noopener\">Flow</a>,  Microsoft의 <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">TypeScript</a> 등의 몇 가지 경쟁 포맷이 갭을 메우기 위해 수년 동안  <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">급성장하고</a>  있습니다.  저는  <a href=\"https://github.com/ericelliott/rtype\" target=\"_blank\" rel=\"noopener\">rtype</a>을 문서화에 사용합니다 - 이는 함수형 프로그래밍을 위한 TypeScript보다 훨씬 더 읽기 쉬운 표기법입니다.</p>\n<p>이 글을 쓰는 시점에는 타입 주석에 대해 확실한 승자가 없습니다.  JavaScript 스펙에 의해 어떠한 대안도 선택을 받지 못했으며, 각각에 명확한 결점이있는 것으로 보입니다.</p>\n<p>타입 추론은 데이터가 사용 된 문맥을 기반으로 유추하여 타입을 추론하는 프로세스입니다. JavaScript에서 이는 타입 주석의 좋은 대안입니다.</p>\n<p>표준 JavaScript 함수 서명으로 타입 추론을 위한 충분한 단서를 제공하면 비용이나 위험없이 타입 주석의 이점 대부분을 얻을 수 있습니다.</p>\n<p>TypeScript 또는 Flow와 같은 도구를 사용하기로한 경우에도 타입 추론으로 가능한 많은 작업을 수행하고 타입 추론이 부족한 상황에서 타입 주석을 달아야합니다.  예를 들어 JavaScript에는 공유 인터페이스를 정의하는 방법이 없습니다. 그러나 TypeScript 또는 rtype에서는 쉽고 유용합니다.</p>\n<p><a href=\"http://ternjs.net/\" target=\"_blank\" rel=\"noopener\">Tern.js</a>  는 다양한 텍스트 에디터와 IDE 용 플러그인이있는 JavaScript용 타입 추론 도구입니다.</p>\n<p>Microsoft의 Visual Studio Code는 TypeScript의 타입 추론 기능을 일반 JavaScript 코드로 가져 오기 때문에 Tern이 필요하지 않습니다.</p>\n<p>JavaScript에서 함수의 기본 매개 변수를 지정하면 Tern.js, TypeScript 및 Flow와 같은 유형 유추가 가능한 도구는 작업 도중 올바르게  API를 사용할 수 있도록 IDE 힌트를 제공합니다.</p>\n<p>기본 값이 없다면 IDE(그리고 사람)는 매개 변수 타입을 파악할 수 있는 힌트를 충분히 확보하지 못합니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*2sP_9k1e0dkgYqdEPs0G3g.png\" alt=\"\"></p>\n<p>기본값이 없으면<code>userName</code>의 타입을 알 수 없습니다.</p>\n<p>기본값을 사용하면 IDE(그리고 사람)가 예제를 보고 유추 할 수 있습니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*tFUXCLA8ClAzsPgZXGGR9A.png\" alt=\"\"></p>\n<p>기본값을 보고, IDE는<code>userName</code> 매개 변수가 문자열을 기다리고 있다고 제안 할 수 있습니다.</p>\n<p>매개 변수를 고정 유형으로 제한하는 것이 의미가 있다는 것은 아닙니다(일반 함수와 고차 함수를 만들기 어려워 집니다). 하지만 적절히 사용한다면 기본 매개 변수만큼 유용한 것도 없습니다. TypeScript 또는 flow를 사용하고 있어도 마찬가지입니다.</p>\n<h2>믹스인 합성을 위한 팩토리 함수</h2>\n<p>팩토리는 API를 멋지게 호출하여 객체를 꺼내오는데 유용합니다. 일반적으로 이 정도면 충분하지만, 한 번에 여러 유형의 객체에 비슷한 기능을 구현하려는 경우가 있습니다. 이러한 기능을 보다 쉽게 재사용하려면 함수형 믹스인으로 추상화하면 됩니다.</p>\n<p>이 때야 말로 함수형 믹스인이 빛나는 곳입니다.  모든 객체 인스턴스에  <code>withConstructor</code>  속성을 추가하려면  <code>withConstructor</code>  믹스인을 빌드하십시오.</p>\n<p><code>with-constructor.js</code>  :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withConstructor = <span class=\"function\"><span class=\"params\">constructor</span> =&gt;</span> o =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> proto = <span class=\"built_in\">Object</span>.assign(&#123;&#125;,  </span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.getPrototypeOf(o),  </span><br><span class=\"line\">    &#123; <span class=\"keyword\">constructor</span> &#125;  </span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  return Object.assign(Object.create(proto), o);  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>이것을 가져와 다른 믹스인과 함께 사용할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> withConstructor <span class=\"keyword\">from</span> <span class=\"string\">'./with-constructor'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);  </span><br><span class=\"line\"><span class=\"comment\">// or `import pipe from 'lodash/fp/flow';`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set up some functional mixins  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withFlying = <span class=\"function\"><span class=\"params\">o</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> isFlying = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;  </span><br><span class=\"line\">    ...o,  </span><br><span class=\"line\">    fly () &#123;  </span><br><span class=\"line\">      isFlying = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    land () &#123;  </span><br><span class=\"line\">      isFlying = <span class=\"literal\">false</span>;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    isFlying: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> isFlying  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> withBattery = <span class=\"function\">(<span class=\"params\">&#123; capacity &#125;</span>) =&gt;</span> o =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> percentCharged = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;  </span><br><span class=\"line\">    ...o,  </span><br><span class=\"line\">    draw (percent) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">const</span> remaining = percentCharged - percent;  </span><br><span class=\"line\">      percentCharged = remaining &gt; <span class=\"number\">0</span> ? remaining : <span class=\"number\">0</span>;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    getCharge: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> percentCharged,  </span><br><span class=\"line\">    get capacity () &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> capacity  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createDrone = <span class=\"function\">(<span class=\"params\">&#123; capacity = <span class=\"string\">'3000mAh'</span> &#125;</span>) =&gt;</span> pipe(  </span><br><span class=\"line\">  withFlying,  </span><br><span class=\"line\">  withBattery(&#123; capacity &#125;),  </span><br><span class=\"line\">  withConstructor(createDrone)  </span><br><span class=\"line\">)(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myDrone = createDrone(&#123; <span class=\"attr\">capacity</span>: <span class=\"string\">'5500mAh'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">  can fly:  <span class=\"subst\">$&#123; myDrone.fly().isFlying() === <span class=\"literal\">true</span> &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">  can land: <span class=\"subst\">$&#123; myDrone.land().isFlying() === <span class=\"literal\">false</span> &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">  battery capacity: <span class=\"subst\">$&#123; myDrone.capacity &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">  battery status: <span class=\"subst\">$&#123; myDrone.draw(<span class=\"number\">50</span>).getCharge() &#125;</span>%  </span></span><br><span class=\"line\"><span class=\"string\">  battery drained: <span class=\"subst\">$&#123; myDrone.draw(<span class=\"number\">75</span>).getCharge() &#125;</span>%  </span></span><br><span class=\"line\"><span class=\"string\">`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">  constructor linked: <span class=\"subst\">$&#123; myDrone.constructor === createDrone &#125;</span>  </span></span><br><span class=\"line\"><span class=\"string\">`</span>);</span><br></pre></td></tr></table></figure>\n<p>보시다시피 재사용 가능한  <code>withConstructor()</code> 믹스인은 다른 믹스인과 함께 파이프 라인으로 간단히 합쳐집니다.  <code>withBattery()</code>는 로봇, 전기 스케이트 보드 또는 보조 배터리와 같은 다른 종류의 객체와 함께 사용할 수 있습니다.  <code>withFlying()</code>  은 날아다니는 자동차, 로켓 또는 에어벌룬을 모델링하는데 사용될 수 있습니다.</p>\n<p><strong>Composition</strong>은 특별한 코딩 기술이라기 보다는 사고 방식에 가깝습니다.  여러분은 여러 가지 방법으로 이를 적용 할 수 있습니다.  함수 합성은 기초부터 다시 만들 때 사용할 수 있는 가장 쉬운 방법이며, 팩토리 함수는 구현의 세부 사항을 친숙한 API로 포장하는 간단한 방법입니다.</p>\n<h2>결론</h2>\n<p>ES6가 제공하는 편리한 구문들은 객체 생성 및 팩토리 함수를 다루기 쉽게 만듭니다. 대부분이 경우에는 이정도로 충분하지만, JavaScript이기 때문에 Java와 같은 느낌을 주는 또 다른 접근 방식이 있습니다 :  <code>class</code>  키워드.</p>\n<p>JavaScript에서 클래스는 팩토리보다 더 장황하고 제한적이며, 리팩토링할 때는 거의 지뢰밭을 걷는 느낌을 주지만 React와 Angular와 같은 주요 프론트 엔드 프레임 워크에 의해 사용되어 왔으며 몇 가지 드문 용도(복잡함을 감수할만한 가치가 있는 경우)가 있습니다.</p>\n<blockquote>\n<p>“때때로 우아한 구현은 단지 함수뿐입니다.  메소드가 아닙니다. 클래스도 아닙니다. 프레임워크도 아니고 그저 함수입니다.”~ John Carmack</p>\n</blockquote>\n<p>가장 간단한 구현으로 시작하고 필요한 경우에만보다 복잡한 구현으로 이동하십시오.  객체를 다루는 관점에서는 다음과 같습니다.</p>\n<p><code>Pure function -&gt; factory -&gt; functional mixin -&gt; class</code></p>\n<p><a href=\"https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/\"><strong>다음: 클래스로 합성하기가 까다로운 이유 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>해체, 파괴, 비구조화, 디스트럭쳐링 등 다양한 용어로 번역되고 있습니다. -역자 <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n"},{"title":"JavaScript 모나드","catalog":true,"date":"2018-04-18T01:29:57.000Z","subtitle":"JavaScript Monads Made Simple","header-img":"bg.jpg","readingTime":16,"catagories":["개발"],"preview":"모나드Monad는 특정 컨텍스트에 속한 함수를 합성하는 도구입니다. 특정 컨텍스트란  계산, 분기, I/O, 값을 반환하는 과정 등을 예로 들 수 있습니다.  모나드 타입은 리프팅 함수a => M(b)를 합성할 수 있도록 lift, flat, map을 활용해 타입을 정렬합니다.  이 과정은 결국 임의의 타입 a를  b로 맵핑하는 것이며 계산 컨텍스트 속에 lift, flatten 및 map이 숨겨져 있습니다.","_content":"\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/javascript-monads-made-simple-7856be57bfe8)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/)\n\n모나드를 이해하기 위해선 다음을 이미 알고 있어야 합니다.\n\n-   함수 합성 :  `compose(f, g)(x) = (f ∘ g)(x) = f(g(x))`\n-   Functor의 기본 :  `Array.map()`에 대한 이해.\n\n----------\n\n> \"모나드를 이해하고 나면 갑자기 설명할 방법이 떠오르지 않습니다.\"Lady Monadgreen’s curse ~ Gilad Bracha (used famously by Douglas Crockford)\n\n----------\n\n> \"Hoenikker 박사가 말했습니다. 8살짜리 아이에게 자신이 하고있는 일을 설명 할 수 없는 과학자는 돌팔이입니다.\"~ Kurt Vonnegut의 소설 Cat 's Cradle\n\n\n인터넷에서 \"모나드\"를 검색하면 불가사의한 카테고리 이론 문서들의 포격을 받게 되며,  그 후 부리토와 우주복을 예로 들어 모나드를 \"정말 쉽게\" 설명하고 있는 글들을 마주치게 됩니다.\n\n모나드는 간단합니다.  그러나 이를 설명하고 있는 용어들은 어렵습니다. 우리는 본질을 파고들어야 합니다.\n\n**모나드**는 특정 컨텍스트에 속한 함수를 합성하는 도구입니다. 특정 컨텍스트란  계산, 분기, I/O, 값을 반환하는 과정 등을 예로 들 수 있습니다.  모나드 타입은 리프팅 함수`a => M(b)`를 합성할 수 있도록 lift, flat, map을 활용해 타입을 정렬합니다.  이 과정은 결국 임의의 타입  `a`를  `b`로 맵핑하는 것이며 계산 컨텍스트 속에 lift, flatten 및 map이 숨겨져 있습니다.\n\n-   함수 맵:  `a => b`\n-   컨텍스트가 있는 Functor 맵:   `Functor(a) => Functor(b)` \n-   컨텍스트와 Flatten을 사용하는 모나드 맵:   `Monad(Monad(a)) => Monad(b)`\n\n**컨텍스트**와 **flatten** 그리고 **map**이 과연 무엇일까요?\n\n-   **Map**이란 \"`a`에 특정 함수를 적용해  `b`를 리턴합니다\"라는 의미입니다. 특정 입력을 받아 특정 출력을 반환합니다.\n-   **컨텍스트**는 모나드 합성에 관련된 구현 세부 사항입니다.  Functor/모나드 API와 동작방식은 모나드를 앱의 나머지 부분과 합성할 수 있게 하는 컨텍스트를 제공합니다.  Functor와 모나드의 핵심은 이 컨텍스트를 추상화하여 어떤 것을 합성하고 연산하는 동안 문제가 생기지 않게 만드는데 있습니다.  컨텍스트 내에서 맵핑한다는 것은  `a => b`라는 함수를 컨텍스트 내부에 있는 값 `a`에 적용해서 새로운 값 `b`을  동일한 컨텍스트로 리턴한다는 의미입니다.  Observable이 왼쪽에 있으면 오른쪽에도 있어야 합니다. `Observable(a) => Observable(b)`   왼쪽에 배열이 있으면 오른쪽에도 있어야 합니다.  `Array(a) => Array(b)` \n-   **Type lift**는 값을 컨텍스트로 감싸는 것 입니다. 해당 값을 가지고 할 수 있는 동작, 연산들을 정의해놓은 API가 바로 컨텍스트이며, 컨텍스트 자체와 관련된 연산들도 포함되어있습니다.   `a => F(a)`(모나드는 일종의 펑터입니다).\n-   **Flatten**은 컨텍스트 속에 있는 값을 빼내는 것을 의미 합니다 .  `F(a) => a`  \n\n\n예:\n\n```javascript\nconst x = 20;             // Some data of type `a`  \nconst f = n => n * 2;     // A function from `a` to `b`  \nconst arr = Array.of(x);  // The type lift.  \n// JS has type lift sugar for arrays: [x]\n\n// .map() applies the function f to the value x  \n// in the context of the array.  \nconst result = arr.map(f); // [40]\n```\n\n이 경우  컨텍스트는 `Array`가 되고 `x`는 컨텍스트에 담겨 맵핑되는 값입니다.\n\n이 예제는 이중배열을 다루진 않지만,  `.concat()`로 배열을 flatten할 수 있습니다.\n\n```javascript\n[].concat.apply([], [[1], [2, 3], [4]]); // [1, 2, 3, 4]\n```\n\n## 여러분은 이미 모나드를 사용하고 있습니다.\n\n기술 수준이나 카테고리 이론에 대한 이해도와 상관없이 모나드를 사용하면 코드를 더 쉽게 짤 수 있습니다. 모나드를 활용하지 못한다면 코드가 더 어려워질 것입니다. (e.g., 콜백 지옥, 중첩 된 조건문, 스파게티 코드)\n\n소프트웨어 개발의 본질은 합성이고 모나드는 합성을 쉽게 할 수 있도록 도와주는 역할을 합니다.\n\n-   함수 맵:  `a => b`,  특정 타입의 함수를 합성할 수 있습니다.\n-  컨텍스트가 있는 Functor 맵: `Functor(a) => Functor(b)`,  함수를 합성 할 수 있습니다.  `F(a) => F(b)`\n-   컨텍스트와 flatten을 사용하는 모나드 맵:  `Monad(Monad(a)) => Monad(b)`, lift 함수를 합성할 수 있습니다.  `a => F(b)`\n\n이들은 모두  **함수 합성**을 표현하는 다른 방식입니다.  함수는 합성되기 위해 존재합니다. 함수는 복잡한 문제를 쉽게 풀 수 있는 간단한 문제로 분해하고 솔루션들을 여러 가지 방법으로 합성하여 애플리케이션을 만들 수 있도록 도와줍니다.\n\n함수를 이해하고 올바르게 사용하려면 합성을 더 깊이 이해해야 합니다.\n\n함수를 합성한다는 것은 데이터가 흐르는 파이프라인을 만드는 것과 같습니다. 파이프라인의 첫 단계에 특정 값을 넣으면 마지막 단계에서 변환된 값이 출력됩니다.  그러나 이것이 작동하려면 파이프 라인의 각 단계에서 이전 단계에서 반환하는 데이터 형식이 필요합니다.\n\n일반 함수를 합성하는 것은 간단합니다. 타입을 쉽게 정렬시킬 수 있기 때문이죠. 리턴 타입  `b`를 인풋 타입  `b`와 일치 시키면 됩니다.\n\n```\ng:           a => b  \nf:                b => c  \nh = f(g(a)): a    =>   c\n```\n\nFunctor를 합성하는 것도 간단합니다.  타입을 정렬시킬 수 있기 때문이죠. \n\n```\ng:             F(a) => F(b)  \nf:                     F(b) => F(c)  \nh = f(g(Fa)):  F(a)    =>      F(c)\n```\n\n그러나  `a => F(b)`,  `b => F(c)`라는 함수를 합성하려면 모나드가 필요합니다.  모나드와 Functor를 구분하기 위해 `F()` 대신  `M()`이라고 쓰겠습니다.\n\n```\ng:                  a => M(b)  \nf:                       b => M(c)  \nh = composeM(f, g): a    =>   M(c)\n```\n\n잠깐. 이 예제에서는  _함수 타입들이  정렬되지 않았습니다!_   `f`의 입력으로 `b`라는 타입이 필요하지만 실제로 전달받은 타입은  `M(b)`(monad of `b`)였고 결국`composeM()`에는  `g`가 리턴한 `M(b)`에서 `b`를 빼내는 과정이 필요합니다.   이 프로세스(`.bind()`  또는  `.chain()`)속에  flatten과 mapping이 숨겨져있습니다.\n\n다음 함수로 전달하기 전에  `M(b)`에서 `b`를 추출(unwrapping, flatten)합니다.\n\n```\ng:             a => M(b) flattens to => b  \nf:                                      b           maps to => M(c)  \nh composeM(f, g):  \n               a       flatten(M(b)) => b => map(b => M(c)) => M(c)\n```\n\n모나드는  `a => M(b)`형식의 함수들을 합성할 수 있도록 타입을 정렬시킵니다.\n\n`M(b) => b`로의 `flatten`과   `b => M(c)`로의 `map`은    `chain` 연산 내부에서 호출되며 `chain`은  `composeM()` 내부에서 호출됩니다.  이러한 세부 구현은 추상화되어있기 때문에 사용자가 걱정할 필요가 없습니다.  따라서 일반 함수를 합성하는 것과 같은 방식으로 모나드 타입 함수를 합성할 수 있습니다.\n\n모나드가 필요한 이유는 실제로 프로그램의 여러 모듈에서 단지  `a => b`와 같은  간단한 맵핑만 처리하는 것이 아니기 때문입니다.  일부 함수는 부수작용(프라미스, 스트림)이나 분기(Maybe), 예외 (Either) 등을 처리해야합니다.\n\n다음은 좀 더 구체적인 예입니다.  비동기 API에서 User 데이터를 가져온 뒤 해당 데이터를 다른 비동기 API에 전달하여 계산을 수행해야하는 경우를 알아보겠습니다.\n```\ngetUserById(id: String) => Promise(User)  \nhasPermision(User) => Promise(Boolean)\n```\n\n 함수를 몇 개 정의하겠습니다.  우선 유틸리티 함수입니다.  `compose()`  및  `trace()`  :\n\n```javascript\nconst compose = (...fns) => x => fns.reduceRight((y, f) => f(y), x);\n\nconst trace = label => value => {  \n  console.log(`${ label }: ${ value }`);  \n  return value;  \n};\n```\n\n함수들을 합성해보겠습니다.\n\n```javascript\n{  \n  const label = 'API call composition';\n\n  // a => Promise(b)  \n  const getUserById = id => id === 3 ?  \n    Promise.resolve({ name: 'Kurt', role: 'Author' }) :  \n    undefined  \n  ;\n\n  // b => Promise(c)  \n  const hasPermission = ({ role }) => (  \n    Promise.resolve(role === 'Author')  \n  );\n\n  // Try to compose them. Warning: this will fail.  \n  const authUser = compose(hasPermission, getUserById);\n\n  // Oops! Always false!  \n  authUser(3).then(trace(label));  \n}\n```\n\n`hasPermission()`과  `getUserById()`를 합성하여  `authUser()`를 만드려고 합니다. 그러나  `hasPermission()`이  `User`타입 대신  `Promise(User)`를 받게되는 문제가 발생합니다.  이 문제를 해결하려면 `compose()`  대신    `composePromises()`를 사용해야 합니다.  이는 `.then()`을 사용해 함수를 합성하는 특수한 유틸리티입니다.\n\n```javascript\n{  \n  const composeM = chainMethod => (...ms) => (  \n    ms.reduce((f, g) => x => g(x)[chainMethod](f))  \n  );\n\n  const composePromises = composeM('then');\n\n  const label = 'API call composition';\n\n  // a => Promise(b)  \n  const getUserById = id => id === 3 ?  \n    Promise.resolve({ name: 'Kurt', role: 'Author' }) :  \n    undefined  \n  ;\n\n  // b => Promise(c)  \n  const hasPermission = ({ role }) => (  \n    Promise.resolve(role === 'Author')  \n  );\n\n  // Compose the functions (this works!)  \n  const authUser = composePromises(hasPermission, getUserById);\n\n  authUser(3).then(trace(label)); // true  \n}\n```\n`composeM()`에 대해서는 나중에 다시 알아볼 것 입니다.\n\n모나드의 핵심을 기억하십니까? :\n\n-   함수 맵:  `a => b`\n-   컨텍스트가 있는 Functor 맵:   `Functor(a) => Functor(b)` \n-   컨텍스트와 Flatten을 사용하는 모나드 맵:   `Monad(Monad(a)) => Monad(b)`\n\n이 경우, 프라미스가 곧 모나드이기 때문에,  프라미스을 반환하는 함수들을 합성할 때  `hasPermission()`은 `User`타입  대신에  `Promise(User)`를 받게됩니다. 모나드 연산의 왼쪽 항 `Monad(Monad(a))`에서 바깥 쪽  `Monad()`  래퍼를 벗겨낼 경우 `Monad(a) => Monad(b)`가 됩니다.  이는 일반적인 functor `.map()`과 동일합니다. 즉, `Monad(x) => x` 처럼 래퍼를 벗겨낼 수 있다면 모나드 연산을 만들 수 있습니다. \n\n## 모나드의 구성요소\n\n모나드는 간단한 대칭을 기반으로합니다. 즉, 값을 컨텍스트로 래핑하는 방법과 컨텍스트에서 값의 랩핑을 해제하는 방법입니다.\n\n-   **Lift / Unit :**  어떤 타입을 모나드 컨텍스트로 리프트 :  `a => M(a)`\n-   **Flatten / Join :**  컨텍스트에서 타입을 추출 :  `M(a) => a`\n\n그리고 모나드는 펑터에 속하기 때문에 다음과 같이 맵핑 할 수도 있습니다.\n\n-   **Map :**  컨텍스트가 유지되는 맵핑 :  `M(a) -> M(b)`\n\nFlatten과 Map을 결합하면  [하인리히 클레이슬리](https://en.wikipedia.org/wiki/Heinrich_Kleisli)의  이름을 딴 모나드 리프팅 함수들을 합성하는 **Chain**, 일명 클레이슬리 컴포지션을 만들 수 있습니다.\n\n-   **FlatMap / Chain :** Flatten + Map :  `M(M(a)) => M(b)`\n\n모나드의 경우  `.map()`  메소드는 퍼블릭 API에서 생략되는 경우가 많습니다. Lift + flatten을 명시적으로  `.map()`이라고 부르지는 않습니다. 그러나 이를 만드는 일은 간단합니다.  리프트 (aka of/unit)를 한뒤 체인 (aka bind/flatMap)을 하면 `.map()`이 됩니다. \n\n```javascript\nconst MyMonad = value => ({  \n  // <... insert arbitrary chain and of here ...>  \n  map (f) {  \n    return this.chain(a => this.constructor.of(f(a)));  \n  }  \n});\n```\n\n따라서   `.of()`  및  `.chain()`/`.join()`을 정의하면  `.map()`을 정의할 수 있습니다. \n\n리프트는 factory/constructor 이며 `constructor.of()`  메서드입니다.  카테고리 이론에서 \"단위^unit^\"라고 불립니다.  타입을 모나드의 컨텍스트로 감싸는 일입니다.  a를  `Monad`  of  `a`  로 바꿉니다.\n\nHaskell에서는 리프트를 (매우 헷갈리게)`return`이라고 부르며 거의 모든 사람들이 그것을 함수의 리턴과 혼동합니다. 따라서 저는 말할 때  \"들어 올리기, 승격, 리프트\" 또는 \"타입 리프트\"라고 부르며 코드에서는  `.of()`라고 부릅니다.\n\n값을 빼내는 프로세스 (`.chain()`에서 map이 빠진 것)는 일반적으로  `flatten()`  또는  `join()` 이라고 합니다.  `flatten()`/`join()`은  `.chain()/.flatMap()`에 포함되어 있기 때문에 완전히 생략되는 경우가 많습니다.  flattening은 합성과 관련되어 있으므로 매핑과 결합되는 경우가 많습니다.  기억하세요, unwrapping + map은  `a => M(a)` 형식의 함수들을 합성하는데 필요합니다.\n\n어떤 종류의 모나드를 사용 하느냐에 따라 unwrapping 프로세스가 매우 간단해질 수 있습니다.  Identity 모나드의 경우, 결과 값을 다시 모나드 컨텍스트로 가져 오지 않는다는 점을 제외하고는  `.map()`과 같습니다.  래핑의 한 레이어를 버리는 효과가 있습니다.\n\n```javascript\n{ // Identity monad  \nconst Id = value => ({  \n  // Functor mapping  \n  // Preserve the wrapping for .map() by   \n  // passing the mapped value into the type  \n  // lift:  \n  map: f => Id.of(f(value)),\n\n  // Monad chaining  \n  // Discard one level of wrapping  \n  // by omitting the .of() type lift:  \n  chain: f => f(value),\n\n  // Just a convenient way to inspect  \n  // the values:  \n  toString: () => `Id(${ value })`  \n});\n\n// The type lift for this monad is just  \n// a reference to the factory.  \nId.of = Id;\n```\n\n그러나 unwrapping 프로세스는 일반적으로 부수효과, 오류,  분기 또는 비동기 I/O와 같은 불순한 요소가 숨겨지는 부분이기도합니다.  합성은 모든 소프트웨어 개발에서 실제로 흥미로운 일들이 일어나는 곳입니다.\n\n예를 들어 프라미스에서 `.chain()`은  `.then()`이라 불립니다. `promise.then(f)`를 호출하면  `f()`가  즉시 실행되지 않습니다.  대신 프라미스을 기다린 뒤  `f()`를  호출합니다.\n\n예:\n\n```javascript\n{  \n  const x = 20;                 // The value  \n  const p = Promise.resolve(x); // The context  \n  const f = n =>   \n    Promise.resolve(n * 2);     // The function\n\n  const result = p.then(f);     // The application\n\n  result.then(  \n    r => console.log(r)         // 40  \n  );  \n}\n```\n\n프라미스의  `.then()`은 `.chain()`과  _거의_  동일합니다.\n\n엄격하게 따졌을 때 프라미스는 모나드가 아니라는 말을 들은적 있을 겁니다.  값이 프라미스일 경우에만 언래핑하며 그렇지 않은 경우  `.then()`은  `.map()`처럼 동작합니다.\n\n\n즉, 프라미스 값과 다른 값에 대해 다르게 동작하는  `.then()`은 Functor 및  모나드가 충족시켜야 하는  수학 법칙을 엄격하게 따르는 것이 아닙니다.  현실적으로는 여러분이 이러한 원칙과 실제 작동방식을 알고있는 한, 그것들을 둘 중 하나로 취급 할 수 있습니다.  단지 일부 합성 유틸리티들로 프라미스를 합성했을 때 예상대로 작동하지 않을 수 있습니다.\n\n## 모나드 합성하기(클레이슬리^Kleisli^ 합성)\n\npromise-lifting 함수를 작성하는 데 사용한  `composeM`  함수에 대해 자세히 살펴 보겠습니다.\n\n```javascript\nconst composeM = method => (...ms) => (  \n  ms.reduce((f, g) => x => g(x)[method](f))  \n);\n```\n\n이 이상한 reducer가 의미하는 것은 함수 합성의 대수적 정의입니다 :  `f(g(x))`. 더 쉽게 알아보겠습니다.\n\n```javascript\n{  \n  // The algebraic definition of function composition:  \n  // (f ∘ g)(x) = f(g(x))  \n  const compose = (f, g) => x => f(g(x));\n\n  const x = 20;    // The value  \n  const arr = [x]; // The container\n\n  // Some functions to compose  \n  const g = n => n + 1;  \n  const f = n => n * 2;\n\n  // Proof that .map() accomplishes function composition.  \n  // Chaining calls to map is function composition.  \n  trace('map composes')([  \n    arr.map(g).map(f),  \n    arr.map(compose(f, g))  \n  ]);  \n  // => [42], [42]  \n}\n```\n\n이는  `.map()`  메소드를 제공하는 모든 Functor(e.g., Array)에 대해 작동하는 합성 유틸리티를 작성할 수 있다는 것입니다.\n\n```javascript\nconst composeMap = (...ms) => (  \n  ms.reduce((f, g) => x => g(x).map(f))  \n);\n```\n\n이것은 일반적인  `f(g(x))`를 약간 재구성한 것 입니다.  `a -> Functor(b)`  유형의 함수가 여러 개 있으면 각 함수를 반복하여 값  `x`를 적용  합니다. `.reduce()`  메소드는 두가지 인자, reducer(이 경우  `f`  )와 배열의 아이템 (`g`)을 받는 함수를 사용합니다.\n\n각 반복에서 다음의  `f`가 되는 새로운 함수  ( `x => g(x).map(f)` )를 반환합니다.  우리는 이미  `x => g(x).map(f)`가  `compose(f, g)(x)`를 functor의 컨텍스트로 들어 올리는 것과 같음을 증명했습니다.  즉, 컨테이너의 값에  `f(g(x))`를 적용하는 것과 같습니다. 이 경우 배열 내의 값에 합성함수를 적용하는 것입니다.\n\n> 성능 경고 : 배열에 대해서는 권장하지 않습니다.  이런 방식으로 함수를 합성하려면 전체 배열(수십만개의 항목이 있을지도 모르는)을 여러번 반복해야 합니다.  배열을 맵핑해야할 경우 간단한  `a -> b`  함수를 먼저 합성한 다음 한 번 매핑하거나  `.reduce()`  또는 트랜스듀서를 사용하여 반복을 최적화하십시오.\n\n배열에 이런식의 동기, 느긋하지 않은^eager^ 방식으로 함수를 적용하는 것은 과합니다.  그러나 많은 비동기, 느긋한 방식들에 대해서 예외 나 null 값을 분기하는 것과 같은 지저분한 작업을 처리해야합니다.\n\n바로 그럴때 모나드가 필요해집니다. 모나드는 합성 체인에서 이전의 비동기 또는 분기 동작에 의존하는 값을 처리할 수 있습니다.  이 경우 일반적인 함수 합성으로는 값을 얻을 수 없습니다.  모나드를 반환하는 작업은  `a => b` 대신  `a => Monad(b)`  형식을 하고 있습니다.\n\n데이터를 받아 API를 실행하고 값을 리턴받아 다시 다른 API를 실행하고 해당 데이터에 대한 계산 결과를 반환하는 함수가 있다면 `a => Monad(b)`  타입의 함수들을 합성해야 합니다.  API 호출은 비동기식이므로 프라미스나 Observable과 같은 값으로 반환 값을 래핑해야합니다.  달리 말하면, 함수들의 서명은 각각  `a -> Monad(b)`6과  `b -> Monad(c)`가 됩니다.\n\n`g: a -> b`  ,  `f: b -> c`타입의 함수들을 합성하는 것은 쉽습니다. 타입들이 정렬된 이상 `h: a -> c`는 단지  `a => f(g(a))`일  뿐이기 때문입니다.\n\n`g: a -> Monad(b)`  ,  `f: b -> Monad(c)` 타입의 함수들을 합성하는 것은 조금 더 어렵습니다. 타입들이 정렬되지 않았고 `f`는  `Monad(b)`가  아닌  `b`를  기대하고 있기 때문에 `h: a -> Monad(c)`  는  `a => f(g(a))`로 표현될 수 없습니다.\n\n좀 더 구체적으로 접근하기 위해 프라미스를 리턴하는 한쌍의 비동기 함수를 합성해 보겠습니다.\n\n```javascript\n{  \n  const label = 'Promise composition';\n\n  const g = n => Promise.resolve(n + 1);  \n  const f = n => Promise.resolve(n * 2);\n\n  const h = composePromises(f, g);\n\n  h(20)  \n    .then(trace(label))  \n  ;  \n  // Promise composition: 42  \n}\n```\n\n올바른 결과가 나오도록 하려면`composePromises()`를  어떻게 만들어야야할까요?  _힌트 : 이미 본 적이 있습니다._\n\n`composeMap()`  함수를 기억하십니까?  `.map()`을  `.then()`으로 바꾸면됩니다.  `Promise.then()`은 기본적으로 비동기  `.map()`  입니다.\n\n```javascript\n{  \n  const composePromises = (...ms) => (  \n    ms.reduce((f, g) => x => g(x).then(f))  \n  );\n\n  const label = 'Promise composition';\n\n  const g = n => Promise.resolve(n + 1);  \n  const f = n => Promise.resolve(n * 2);\n\n  const h = composePromises(f, g);\n\n  h(20)  \n    .then(trace(label))  \n  ;  \n  // Promise composition: 42  \n}\n```\n\n두 번째 함수  `f`(  `g`  다음에 오는)가 받게되는 입력 값은 프라미스입니다. 하지만 `f`가 원하는 타입은 `Promise(b)`가 아니라 `b`였습니다.  무슨 일이 일어난걸까요?\n\n`.then()`  내부에는  `Promise(b) -> b`  를 하는 언래핑 프로세스가 있습니다.  이 작업이 바로  `join`  또는  `flatten`입니다.\n\n즉, `composeMap()`  및  `composePromises()`가 거의 동일한 함수임을 알 수 있습니다.  이 두 가지를 모두 처리 할 수있는 고차 함수를 만들어 보겠습니다.  chain 메서드를 커링하기 위해 대괄호 표기법을 사용하겠습니다.\n\n```javascript\nconst composeM = method => (...ms) => (  \n  ms.reduce((f, g) => x => g(x)[method](f))  \n);\n```\n\n이제 다음과 같은 특수한 구현들을 만들 수 있습니다.\n\n```javascript\nconst composePromises = composeM('then');  \nconst composeMap = composeM('map');  \nconst composeFlatMap = composeM('flatMap');\n```\n\n## 모나드의 법칙\n\n여러분이 어떤 모나드를 만들기 전에 모든 모나드가 충족시켜야 할 세가지 법칙을 알아보겠습니다.\n\n1.  Left identity :  `unit(x).chain(f) ==== f(x)`\n2.  Right identity :  `m.chain(unit) ==== m`\n3.  결합법칙^Associativity^ :  `m.chain(f).chain(g) ==== m.chain(x => f(x).chain(g))`\n\n### Identity laws\n\n![](https://cdn-images-1.medium.com/max/1600/1*X_bUJJYudP8MlhN0FLEGKg.png)\n\nLeft and right identity\n\n모나드는 Functor입니다.  Functor는  `A -> B`라는  카테고리 사이의 사상입니다.  사상은 화살표로 표시됩니다.  객체들 간에 명시적으로 표시된 화살표들 외에도 카테고리의 각 객체에 화살표가 있습니다.  즉, 카테고리의 모든 객체  `X`  에 대해 화살표  `X -> X`가  있습니다.  이 화살표는 ID 화살표로 알려져 있으며 일반적으로 객체 자신을 가리키는 작은 원형 화살표로 그려집니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*3jcLj7wdwWaUJ22X2iT7OA.png)\n\n항등 사상\n\n### 결합법칙\n\n연산을 할 때 괄호를 어디에 두어도 상관이 없다는 의미입니다.  덧셈의 경우  `a + (b + c)`는  `(a + b) + c`와 결과가 같습니다.  함수 합성에 대해서도 마찬가지입니다.  `(f ∘ g) ∘ h = f ∘ (g ∘ h)`  .\n\nKleisli 합성에서도 마찬가지입니다. 대신 거꾸로 읽어야합니다.  합성 연산자( `chain` )를 보게되면 다음을 떠올리세요.\n\n```javascript\nh(x).chain(x => g(x).chain(f)) ==== (h(x).chain(g)).chain(f)\n```\n\n### 모나드 법칙 증명하기\n\nIdentity 모나드가 모나드 법칙을 충족시킨다는 것을 증명해보겠습니다.\n\n```javascript\n{ // Identity monad  \n  const Id = value => ({  \n    // Functor mapping  \n    // Preserve the wrapping for .map() by   \n    // passing the mapped value into the type  \n    // lift:  \n    map: f => Id.of(f(value)),\n\n    // Monad chaining  \n    // Discard one level of wrapping  \n    // by omitting the .of() type lift:  \n    chain: f => f(value),\n\n    // Just a convenient way to inspect  \n    // the values:  \n    toString: () => `Id(${ value })`  \n  });\n\n  // The type lift for this monad is just  \n  // a reference to the factory.  \n  Id.of = Id;\n\n  const g = n => Id(n + 1);  \n  const f = n => Id(n * 2);\n\n  // Left identity  \n  // unit(x).chain(f) ==== f(x)  \n  trace('Id monad left identity')([  \n    Id(x).chain(f),  \n    f(x)  \n  ]);  \n  // Id monad left identity: Id(40), Id(40)  \n  \n\n  // Right identity  \n  // m.chain(unit) ==== m  \n  trace('Id monad right identity')([  \n    Id(x).chain(Id.of),  \n    Id(x)  \n  ]);  \n  // Id monad right identity: Id(20), Id(20)\n\n  // Associativity  \n  // m.chain(f).chain(g) ====  \n  // m.chain(x => f(x).chain(g)    \n  trace('Id monad associativity')([  \n    Id(x).chain(g).chain(f),  \n    Id(x).chain(x => g(x).chain(f))  \n  ]);  \n  // Id monad associativity: Id(42), Id(42)  \n}\n```\n\n## 결론\n\n모나드는 타입 리프팅 함수( `g: a => M(b)`  ,  `f: b => M(c)`  )를 합성하는 방법을 기술한 인터페이스입니다.  이를 위해 모나드는  `f()`를 적용하기 전  `M(b)`를  `b`로  flatten합니다.  즉, funtor는 맵핑할  수 있는 것이며 모나드는 flatten한 뒤 맵핑할 수 있는 것입니다. :\n\n-   함수 맵:  `a => b`\n-   컨텍스트가 있는 Functor 맵:   `Functor(a) => Functor(b)` \n-   컨텍스트와 Flatten을 사용하는 모나드 맵:   `Monad(Monad(a)) => Monad(b)`\n\n\n모나드는 간단한 대칭성을 기반으로합니다. 즉, 값을 컨텍스트로 래핑하는 방법과 컨텍스트에서 래핑을 해제하는 방법입니다.\n\n-   Lift / Unit : 어떤 값을 모나드 컨텍스트로 타입 리프트 :  `a => M(a)`\n-   Flatten / Join : 컨텍스트에서 값을 언래핑 :  `M(a) => a`\n\n그리고 모나드는 Functor이기 때문에 다음과 같이 맵핑 할 수도 있습니다.\n\n-   Map : 컨텍스트가 유지되는 맵핑 :  `M(a) -> M(b)`\n\nFlatten과 map을 결합하면 리프팅 함수들을 합성하기위한 chain, 일명 Kleisli 합성을 만들 수 있습니다.\n\n-   FlatMap / Chain : Flatten + map :  `M(M(a)) => M(b)`\n\n모나드는 3 개의 법칙(공리)을 만족해야하며 이는 모나드 법칙으로 불립니다.\n\n-   Left identity :  `unit(x).chain(f) ==== f(x)`\n-   Right identity :  `m.chain(unit) ==== m`\n-   결합법칙 :  `m.chain(f).chain(g) ==== m.chain(x => f(x).chain(g)`\n\n프라미스, 옵저버블 등 여러분은 매일매일 JavaScript에서 모나드를 사용하고 있습니다.  Kleisli 합성을 사용하면 데이터 타입 API의 세부 사항을 신경쓰지 않고 데이터가 흘러가는 로직을 만들 수 있습니다. \n\n따라서 모나드는 코드를 단순화하는 매우 강력한 도구입니다.  모나드를 사용하기 위해 내부에서 무슨 일이 벌어지고 있는지 이해하거나 걱정할 필요는 없습니다. 다만, 이제는 모나드에 대해 더 많이 알게었고, 그 속에서 무슨일이 일어나는지 더이상 두려워하지 않게 되었습니다.\n\n레이디 모나드린의 저주를 두려워 할 필요가 없습니다.\n\n[**다음: Mocking은 코드 냄새(Code Smell)입니다 >**](https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/)","source":"_posts/javascript-monads-made-simple.md","raw":"---\ntitle: JavaScript 모나드\ncatalog: true\ndate: 2018-04-18 10:29:57\nsubtitle: JavaScript Monads Made Simple\nheader-img: \"bg.jpg\"\nreadingTime: 16\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 모나드Monad는 특정 컨텍스트에 속한 함수를 합성하는 도구입니다. 특정 컨텍스트란  계산, 분기, I/O, 값을 반환하는 과정 등을 예로 들 수 있습니다.  모나드 타입은 리프팅 함수a => M(b)를 합성할 수 있도록 lift, flat, map을 활용해 타입을 정렬합니다.  이 과정은 결국 임의의 타입 a를  b로 맵핑하는 것이며 계산 컨텍스트 속에 lift, flatten 및 map이 숨겨져 있습니다.\n---\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/javascript-monads-made-simple-7856be57bfe8)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/)\n\n모나드를 이해하기 위해선 다음을 이미 알고 있어야 합니다.\n\n-   함수 합성 :  `compose(f, g)(x) = (f ∘ g)(x) = f(g(x))`\n-   Functor의 기본 :  `Array.map()`에 대한 이해.\n\n----------\n\n> \"모나드를 이해하고 나면 갑자기 설명할 방법이 떠오르지 않습니다.\"Lady Monadgreen’s curse ~ Gilad Bracha (used famously by Douglas Crockford)\n\n----------\n\n> \"Hoenikker 박사가 말했습니다. 8살짜리 아이에게 자신이 하고있는 일을 설명 할 수 없는 과학자는 돌팔이입니다.\"~ Kurt Vonnegut의 소설 Cat 's Cradle\n\n\n인터넷에서 \"모나드\"를 검색하면 불가사의한 카테고리 이론 문서들의 포격을 받게 되며,  그 후 부리토와 우주복을 예로 들어 모나드를 \"정말 쉽게\" 설명하고 있는 글들을 마주치게 됩니다.\n\n모나드는 간단합니다.  그러나 이를 설명하고 있는 용어들은 어렵습니다. 우리는 본질을 파고들어야 합니다.\n\n**모나드**는 특정 컨텍스트에 속한 함수를 합성하는 도구입니다. 특정 컨텍스트란  계산, 분기, I/O, 값을 반환하는 과정 등을 예로 들 수 있습니다.  모나드 타입은 리프팅 함수`a => M(b)`를 합성할 수 있도록 lift, flat, map을 활용해 타입을 정렬합니다.  이 과정은 결국 임의의 타입  `a`를  `b`로 맵핑하는 것이며 계산 컨텍스트 속에 lift, flatten 및 map이 숨겨져 있습니다.\n\n-   함수 맵:  `a => b`\n-   컨텍스트가 있는 Functor 맵:   `Functor(a) => Functor(b)` \n-   컨텍스트와 Flatten을 사용하는 모나드 맵:   `Monad(Monad(a)) => Monad(b)`\n\n**컨텍스트**와 **flatten** 그리고 **map**이 과연 무엇일까요?\n\n-   **Map**이란 \"`a`에 특정 함수를 적용해  `b`를 리턴합니다\"라는 의미입니다. 특정 입력을 받아 특정 출력을 반환합니다.\n-   **컨텍스트**는 모나드 합성에 관련된 구현 세부 사항입니다.  Functor/모나드 API와 동작방식은 모나드를 앱의 나머지 부분과 합성할 수 있게 하는 컨텍스트를 제공합니다.  Functor와 모나드의 핵심은 이 컨텍스트를 추상화하여 어떤 것을 합성하고 연산하는 동안 문제가 생기지 않게 만드는데 있습니다.  컨텍스트 내에서 맵핑한다는 것은  `a => b`라는 함수를 컨텍스트 내부에 있는 값 `a`에 적용해서 새로운 값 `b`을  동일한 컨텍스트로 리턴한다는 의미입니다.  Observable이 왼쪽에 있으면 오른쪽에도 있어야 합니다. `Observable(a) => Observable(b)`   왼쪽에 배열이 있으면 오른쪽에도 있어야 합니다.  `Array(a) => Array(b)` \n-   **Type lift**는 값을 컨텍스트로 감싸는 것 입니다. 해당 값을 가지고 할 수 있는 동작, 연산들을 정의해놓은 API가 바로 컨텍스트이며, 컨텍스트 자체와 관련된 연산들도 포함되어있습니다.   `a => F(a)`(모나드는 일종의 펑터입니다).\n-   **Flatten**은 컨텍스트 속에 있는 값을 빼내는 것을 의미 합니다 .  `F(a) => a`  \n\n\n예:\n\n```javascript\nconst x = 20;             // Some data of type `a`  \nconst f = n => n * 2;     // A function from `a` to `b`  \nconst arr = Array.of(x);  // The type lift.  \n// JS has type lift sugar for arrays: [x]\n\n// .map() applies the function f to the value x  \n// in the context of the array.  \nconst result = arr.map(f); // [40]\n```\n\n이 경우  컨텍스트는 `Array`가 되고 `x`는 컨텍스트에 담겨 맵핑되는 값입니다.\n\n이 예제는 이중배열을 다루진 않지만,  `.concat()`로 배열을 flatten할 수 있습니다.\n\n```javascript\n[].concat.apply([], [[1], [2, 3], [4]]); // [1, 2, 3, 4]\n```\n\n## 여러분은 이미 모나드를 사용하고 있습니다.\n\n기술 수준이나 카테고리 이론에 대한 이해도와 상관없이 모나드를 사용하면 코드를 더 쉽게 짤 수 있습니다. 모나드를 활용하지 못한다면 코드가 더 어려워질 것입니다. (e.g., 콜백 지옥, 중첩 된 조건문, 스파게티 코드)\n\n소프트웨어 개발의 본질은 합성이고 모나드는 합성을 쉽게 할 수 있도록 도와주는 역할을 합니다.\n\n-   함수 맵:  `a => b`,  특정 타입의 함수를 합성할 수 있습니다.\n-  컨텍스트가 있는 Functor 맵: `Functor(a) => Functor(b)`,  함수를 합성 할 수 있습니다.  `F(a) => F(b)`\n-   컨텍스트와 flatten을 사용하는 모나드 맵:  `Monad(Monad(a)) => Monad(b)`, lift 함수를 합성할 수 있습니다.  `a => F(b)`\n\n이들은 모두  **함수 합성**을 표현하는 다른 방식입니다.  함수는 합성되기 위해 존재합니다. 함수는 복잡한 문제를 쉽게 풀 수 있는 간단한 문제로 분해하고 솔루션들을 여러 가지 방법으로 합성하여 애플리케이션을 만들 수 있도록 도와줍니다.\n\n함수를 이해하고 올바르게 사용하려면 합성을 더 깊이 이해해야 합니다.\n\n함수를 합성한다는 것은 데이터가 흐르는 파이프라인을 만드는 것과 같습니다. 파이프라인의 첫 단계에 특정 값을 넣으면 마지막 단계에서 변환된 값이 출력됩니다.  그러나 이것이 작동하려면 파이프 라인의 각 단계에서 이전 단계에서 반환하는 데이터 형식이 필요합니다.\n\n일반 함수를 합성하는 것은 간단합니다. 타입을 쉽게 정렬시킬 수 있기 때문이죠. 리턴 타입  `b`를 인풋 타입  `b`와 일치 시키면 됩니다.\n\n```\ng:           a => b  \nf:                b => c  \nh = f(g(a)): a    =>   c\n```\n\nFunctor를 합성하는 것도 간단합니다.  타입을 정렬시킬 수 있기 때문이죠. \n\n```\ng:             F(a) => F(b)  \nf:                     F(b) => F(c)  \nh = f(g(Fa)):  F(a)    =>      F(c)\n```\n\n그러나  `a => F(b)`,  `b => F(c)`라는 함수를 합성하려면 모나드가 필요합니다.  모나드와 Functor를 구분하기 위해 `F()` 대신  `M()`이라고 쓰겠습니다.\n\n```\ng:                  a => M(b)  \nf:                       b => M(c)  \nh = composeM(f, g): a    =>   M(c)\n```\n\n잠깐. 이 예제에서는  _함수 타입들이  정렬되지 않았습니다!_   `f`의 입력으로 `b`라는 타입이 필요하지만 실제로 전달받은 타입은  `M(b)`(monad of `b`)였고 결국`composeM()`에는  `g`가 리턴한 `M(b)`에서 `b`를 빼내는 과정이 필요합니다.   이 프로세스(`.bind()`  또는  `.chain()`)속에  flatten과 mapping이 숨겨져있습니다.\n\n다음 함수로 전달하기 전에  `M(b)`에서 `b`를 추출(unwrapping, flatten)합니다.\n\n```\ng:             a => M(b) flattens to => b  \nf:                                      b           maps to => M(c)  \nh composeM(f, g):  \n               a       flatten(M(b)) => b => map(b => M(c)) => M(c)\n```\n\n모나드는  `a => M(b)`형식의 함수들을 합성할 수 있도록 타입을 정렬시킵니다.\n\n`M(b) => b`로의 `flatten`과   `b => M(c)`로의 `map`은    `chain` 연산 내부에서 호출되며 `chain`은  `composeM()` 내부에서 호출됩니다.  이러한 세부 구현은 추상화되어있기 때문에 사용자가 걱정할 필요가 없습니다.  따라서 일반 함수를 합성하는 것과 같은 방식으로 모나드 타입 함수를 합성할 수 있습니다.\n\n모나드가 필요한 이유는 실제로 프로그램의 여러 모듈에서 단지  `a => b`와 같은  간단한 맵핑만 처리하는 것이 아니기 때문입니다.  일부 함수는 부수작용(프라미스, 스트림)이나 분기(Maybe), 예외 (Either) 등을 처리해야합니다.\n\n다음은 좀 더 구체적인 예입니다.  비동기 API에서 User 데이터를 가져온 뒤 해당 데이터를 다른 비동기 API에 전달하여 계산을 수행해야하는 경우를 알아보겠습니다.\n```\ngetUserById(id: String) => Promise(User)  \nhasPermision(User) => Promise(Boolean)\n```\n\n 함수를 몇 개 정의하겠습니다.  우선 유틸리티 함수입니다.  `compose()`  및  `trace()`  :\n\n```javascript\nconst compose = (...fns) => x => fns.reduceRight((y, f) => f(y), x);\n\nconst trace = label => value => {  \n  console.log(`${ label }: ${ value }`);  \n  return value;  \n};\n```\n\n함수들을 합성해보겠습니다.\n\n```javascript\n{  \n  const label = 'API call composition';\n\n  // a => Promise(b)  \n  const getUserById = id => id === 3 ?  \n    Promise.resolve({ name: 'Kurt', role: 'Author' }) :  \n    undefined  \n  ;\n\n  // b => Promise(c)  \n  const hasPermission = ({ role }) => (  \n    Promise.resolve(role === 'Author')  \n  );\n\n  // Try to compose them. Warning: this will fail.  \n  const authUser = compose(hasPermission, getUserById);\n\n  // Oops! Always false!  \n  authUser(3).then(trace(label));  \n}\n```\n\n`hasPermission()`과  `getUserById()`를 합성하여  `authUser()`를 만드려고 합니다. 그러나  `hasPermission()`이  `User`타입 대신  `Promise(User)`를 받게되는 문제가 발생합니다.  이 문제를 해결하려면 `compose()`  대신    `composePromises()`를 사용해야 합니다.  이는 `.then()`을 사용해 함수를 합성하는 특수한 유틸리티입니다.\n\n```javascript\n{  \n  const composeM = chainMethod => (...ms) => (  \n    ms.reduce((f, g) => x => g(x)[chainMethod](f))  \n  );\n\n  const composePromises = composeM('then');\n\n  const label = 'API call composition';\n\n  // a => Promise(b)  \n  const getUserById = id => id === 3 ?  \n    Promise.resolve({ name: 'Kurt', role: 'Author' }) :  \n    undefined  \n  ;\n\n  // b => Promise(c)  \n  const hasPermission = ({ role }) => (  \n    Promise.resolve(role === 'Author')  \n  );\n\n  // Compose the functions (this works!)  \n  const authUser = composePromises(hasPermission, getUserById);\n\n  authUser(3).then(trace(label)); // true  \n}\n```\n`composeM()`에 대해서는 나중에 다시 알아볼 것 입니다.\n\n모나드의 핵심을 기억하십니까? :\n\n-   함수 맵:  `a => b`\n-   컨텍스트가 있는 Functor 맵:   `Functor(a) => Functor(b)` \n-   컨텍스트와 Flatten을 사용하는 모나드 맵:   `Monad(Monad(a)) => Monad(b)`\n\n이 경우, 프라미스가 곧 모나드이기 때문에,  프라미스을 반환하는 함수들을 합성할 때  `hasPermission()`은 `User`타입  대신에  `Promise(User)`를 받게됩니다. 모나드 연산의 왼쪽 항 `Monad(Monad(a))`에서 바깥 쪽  `Monad()`  래퍼를 벗겨낼 경우 `Monad(a) => Monad(b)`가 됩니다.  이는 일반적인 functor `.map()`과 동일합니다. 즉, `Monad(x) => x` 처럼 래퍼를 벗겨낼 수 있다면 모나드 연산을 만들 수 있습니다. \n\n## 모나드의 구성요소\n\n모나드는 간단한 대칭을 기반으로합니다. 즉, 값을 컨텍스트로 래핑하는 방법과 컨텍스트에서 값의 랩핑을 해제하는 방법입니다.\n\n-   **Lift / Unit :**  어떤 타입을 모나드 컨텍스트로 리프트 :  `a => M(a)`\n-   **Flatten / Join :**  컨텍스트에서 타입을 추출 :  `M(a) => a`\n\n그리고 모나드는 펑터에 속하기 때문에 다음과 같이 맵핑 할 수도 있습니다.\n\n-   **Map :**  컨텍스트가 유지되는 맵핑 :  `M(a) -> M(b)`\n\nFlatten과 Map을 결합하면  [하인리히 클레이슬리](https://en.wikipedia.org/wiki/Heinrich_Kleisli)의  이름을 딴 모나드 리프팅 함수들을 합성하는 **Chain**, 일명 클레이슬리 컴포지션을 만들 수 있습니다.\n\n-   **FlatMap / Chain :** Flatten + Map :  `M(M(a)) => M(b)`\n\n모나드의 경우  `.map()`  메소드는 퍼블릭 API에서 생략되는 경우가 많습니다. Lift + flatten을 명시적으로  `.map()`이라고 부르지는 않습니다. 그러나 이를 만드는 일은 간단합니다.  리프트 (aka of/unit)를 한뒤 체인 (aka bind/flatMap)을 하면 `.map()`이 됩니다. \n\n```javascript\nconst MyMonad = value => ({  \n  // <... insert arbitrary chain and of here ...>  \n  map (f) {  \n    return this.chain(a => this.constructor.of(f(a)));  \n  }  \n});\n```\n\n따라서   `.of()`  및  `.chain()`/`.join()`을 정의하면  `.map()`을 정의할 수 있습니다. \n\n리프트는 factory/constructor 이며 `constructor.of()`  메서드입니다.  카테고리 이론에서 \"단위^unit^\"라고 불립니다.  타입을 모나드의 컨텍스트로 감싸는 일입니다.  a를  `Monad`  of  `a`  로 바꿉니다.\n\nHaskell에서는 리프트를 (매우 헷갈리게)`return`이라고 부르며 거의 모든 사람들이 그것을 함수의 리턴과 혼동합니다. 따라서 저는 말할 때  \"들어 올리기, 승격, 리프트\" 또는 \"타입 리프트\"라고 부르며 코드에서는  `.of()`라고 부릅니다.\n\n값을 빼내는 프로세스 (`.chain()`에서 map이 빠진 것)는 일반적으로  `flatten()`  또는  `join()` 이라고 합니다.  `flatten()`/`join()`은  `.chain()/.flatMap()`에 포함되어 있기 때문에 완전히 생략되는 경우가 많습니다.  flattening은 합성과 관련되어 있으므로 매핑과 결합되는 경우가 많습니다.  기억하세요, unwrapping + map은  `a => M(a)` 형식의 함수들을 합성하는데 필요합니다.\n\n어떤 종류의 모나드를 사용 하느냐에 따라 unwrapping 프로세스가 매우 간단해질 수 있습니다.  Identity 모나드의 경우, 결과 값을 다시 모나드 컨텍스트로 가져 오지 않는다는 점을 제외하고는  `.map()`과 같습니다.  래핑의 한 레이어를 버리는 효과가 있습니다.\n\n```javascript\n{ // Identity monad  \nconst Id = value => ({  \n  // Functor mapping  \n  // Preserve the wrapping for .map() by   \n  // passing the mapped value into the type  \n  // lift:  \n  map: f => Id.of(f(value)),\n\n  // Monad chaining  \n  // Discard one level of wrapping  \n  // by omitting the .of() type lift:  \n  chain: f => f(value),\n\n  // Just a convenient way to inspect  \n  // the values:  \n  toString: () => `Id(${ value })`  \n});\n\n// The type lift for this monad is just  \n// a reference to the factory.  \nId.of = Id;\n```\n\n그러나 unwrapping 프로세스는 일반적으로 부수효과, 오류,  분기 또는 비동기 I/O와 같은 불순한 요소가 숨겨지는 부분이기도합니다.  합성은 모든 소프트웨어 개발에서 실제로 흥미로운 일들이 일어나는 곳입니다.\n\n예를 들어 프라미스에서 `.chain()`은  `.then()`이라 불립니다. `promise.then(f)`를 호출하면  `f()`가  즉시 실행되지 않습니다.  대신 프라미스을 기다린 뒤  `f()`를  호출합니다.\n\n예:\n\n```javascript\n{  \n  const x = 20;                 // The value  \n  const p = Promise.resolve(x); // The context  \n  const f = n =>   \n    Promise.resolve(n * 2);     // The function\n\n  const result = p.then(f);     // The application\n\n  result.then(  \n    r => console.log(r)         // 40  \n  );  \n}\n```\n\n프라미스의  `.then()`은 `.chain()`과  _거의_  동일합니다.\n\n엄격하게 따졌을 때 프라미스는 모나드가 아니라는 말을 들은적 있을 겁니다.  값이 프라미스일 경우에만 언래핑하며 그렇지 않은 경우  `.then()`은  `.map()`처럼 동작합니다.\n\n\n즉, 프라미스 값과 다른 값에 대해 다르게 동작하는  `.then()`은 Functor 및  모나드가 충족시켜야 하는  수학 법칙을 엄격하게 따르는 것이 아닙니다.  현실적으로는 여러분이 이러한 원칙과 실제 작동방식을 알고있는 한, 그것들을 둘 중 하나로 취급 할 수 있습니다.  단지 일부 합성 유틸리티들로 프라미스를 합성했을 때 예상대로 작동하지 않을 수 있습니다.\n\n## 모나드 합성하기(클레이슬리^Kleisli^ 합성)\n\npromise-lifting 함수를 작성하는 데 사용한  `composeM`  함수에 대해 자세히 살펴 보겠습니다.\n\n```javascript\nconst composeM = method => (...ms) => (  \n  ms.reduce((f, g) => x => g(x)[method](f))  \n);\n```\n\n이 이상한 reducer가 의미하는 것은 함수 합성의 대수적 정의입니다 :  `f(g(x))`. 더 쉽게 알아보겠습니다.\n\n```javascript\n{  \n  // The algebraic definition of function composition:  \n  // (f ∘ g)(x) = f(g(x))  \n  const compose = (f, g) => x => f(g(x));\n\n  const x = 20;    // The value  \n  const arr = [x]; // The container\n\n  // Some functions to compose  \n  const g = n => n + 1;  \n  const f = n => n * 2;\n\n  // Proof that .map() accomplishes function composition.  \n  // Chaining calls to map is function composition.  \n  trace('map composes')([  \n    arr.map(g).map(f),  \n    arr.map(compose(f, g))  \n  ]);  \n  // => [42], [42]  \n}\n```\n\n이는  `.map()`  메소드를 제공하는 모든 Functor(e.g., Array)에 대해 작동하는 합성 유틸리티를 작성할 수 있다는 것입니다.\n\n```javascript\nconst composeMap = (...ms) => (  \n  ms.reduce((f, g) => x => g(x).map(f))  \n);\n```\n\n이것은 일반적인  `f(g(x))`를 약간 재구성한 것 입니다.  `a -> Functor(b)`  유형의 함수가 여러 개 있으면 각 함수를 반복하여 값  `x`를 적용  합니다. `.reduce()`  메소드는 두가지 인자, reducer(이 경우  `f`  )와 배열의 아이템 (`g`)을 받는 함수를 사용합니다.\n\n각 반복에서 다음의  `f`가 되는 새로운 함수  ( `x => g(x).map(f)` )를 반환합니다.  우리는 이미  `x => g(x).map(f)`가  `compose(f, g)(x)`를 functor의 컨텍스트로 들어 올리는 것과 같음을 증명했습니다.  즉, 컨테이너의 값에  `f(g(x))`를 적용하는 것과 같습니다. 이 경우 배열 내의 값에 합성함수를 적용하는 것입니다.\n\n> 성능 경고 : 배열에 대해서는 권장하지 않습니다.  이런 방식으로 함수를 합성하려면 전체 배열(수십만개의 항목이 있을지도 모르는)을 여러번 반복해야 합니다.  배열을 맵핑해야할 경우 간단한  `a -> b`  함수를 먼저 합성한 다음 한 번 매핑하거나  `.reduce()`  또는 트랜스듀서를 사용하여 반복을 최적화하십시오.\n\n배열에 이런식의 동기, 느긋하지 않은^eager^ 방식으로 함수를 적용하는 것은 과합니다.  그러나 많은 비동기, 느긋한 방식들에 대해서 예외 나 null 값을 분기하는 것과 같은 지저분한 작업을 처리해야합니다.\n\n바로 그럴때 모나드가 필요해집니다. 모나드는 합성 체인에서 이전의 비동기 또는 분기 동작에 의존하는 값을 처리할 수 있습니다.  이 경우 일반적인 함수 합성으로는 값을 얻을 수 없습니다.  모나드를 반환하는 작업은  `a => b` 대신  `a => Monad(b)`  형식을 하고 있습니다.\n\n데이터를 받아 API를 실행하고 값을 리턴받아 다시 다른 API를 실행하고 해당 데이터에 대한 계산 결과를 반환하는 함수가 있다면 `a => Monad(b)`  타입의 함수들을 합성해야 합니다.  API 호출은 비동기식이므로 프라미스나 Observable과 같은 값으로 반환 값을 래핑해야합니다.  달리 말하면, 함수들의 서명은 각각  `a -> Monad(b)`6과  `b -> Monad(c)`가 됩니다.\n\n`g: a -> b`  ,  `f: b -> c`타입의 함수들을 합성하는 것은 쉽습니다. 타입들이 정렬된 이상 `h: a -> c`는 단지  `a => f(g(a))`일  뿐이기 때문입니다.\n\n`g: a -> Monad(b)`  ,  `f: b -> Monad(c)` 타입의 함수들을 합성하는 것은 조금 더 어렵습니다. 타입들이 정렬되지 않았고 `f`는  `Monad(b)`가  아닌  `b`를  기대하고 있기 때문에 `h: a -> Monad(c)`  는  `a => f(g(a))`로 표현될 수 없습니다.\n\n좀 더 구체적으로 접근하기 위해 프라미스를 리턴하는 한쌍의 비동기 함수를 합성해 보겠습니다.\n\n```javascript\n{  \n  const label = 'Promise composition';\n\n  const g = n => Promise.resolve(n + 1);  \n  const f = n => Promise.resolve(n * 2);\n\n  const h = composePromises(f, g);\n\n  h(20)  \n    .then(trace(label))  \n  ;  \n  // Promise composition: 42  \n}\n```\n\n올바른 결과가 나오도록 하려면`composePromises()`를  어떻게 만들어야야할까요?  _힌트 : 이미 본 적이 있습니다._\n\n`composeMap()`  함수를 기억하십니까?  `.map()`을  `.then()`으로 바꾸면됩니다.  `Promise.then()`은 기본적으로 비동기  `.map()`  입니다.\n\n```javascript\n{  \n  const composePromises = (...ms) => (  \n    ms.reduce((f, g) => x => g(x).then(f))  \n  );\n\n  const label = 'Promise composition';\n\n  const g = n => Promise.resolve(n + 1);  \n  const f = n => Promise.resolve(n * 2);\n\n  const h = composePromises(f, g);\n\n  h(20)  \n    .then(trace(label))  \n  ;  \n  // Promise composition: 42  \n}\n```\n\n두 번째 함수  `f`(  `g`  다음에 오는)가 받게되는 입력 값은 프라미스입니다. 하지만 `f`가 원하는 타입은 `Promise(b)`가 아니라 `b`였습니다.  무슨 일이 일어난걸까요?\n\n`.then()`  내부에는  `Promise(b) -> b`  를 하는 언래핑 프로세스가 있습니다.  이 작업이 바로  `join`  또는  `flatten`입니다.\n\n즉, `composeMap()`  및  `composePromises()`가 거의 동일한 함수임을 알 수 있습니다.  이 두 가지를 모두 처리 할 수있는 고차 함수를 만들어 보겠습니다.  chain 메서드를 커링하기 위해 대괄호 표기법을 사용하겠습니다.\n\n```javascript\nconst composeM = method => (...ms) => (  \n  ms.reduce((f, g) => x => g(x)[method](f))  \n);\n```\n\n이제 다음과 같은 특수한 구현들을 만들 수 있습니다.\n\n```javascript\nconst composePromises = composeM('then');  \nconst composeMap = composeM('map');  \nconst composeFlatMap = composeM('flatMap');\n```\n\n## 모나드의 법칙\n\n여러분이 어떤 모나드를 만들기 전에 모든 모나드가 충족시켜야 할 세가지 법칙을 알아보겠습니다.\n\n1.  Left identity :  `unit(x).chain(f) ==== f(x)`\n2.  Right identity :  `m.chain(unit) ==== m`\n3.  결합법칙^Associativity^ :  `m.chain(f).chain(g) ==== m.chain(x => f(x).chain(g))`\n\n### Identity laws\n\n![](https://cdn-images-1.medium.com/max/1600/1*X_bUJJYudP8MlhN0FLEGKg.png)\n\nLeft and right identity\n\n모나드는 Functor입니다.  Functor는  `A -> B`라는  카테고리 사이의 사상입니다.  사상은 화살표로 표시됩니다.  객체들 간에 명시적으로 표시된 화살표들 외에도 카테고리의 각 객체에 화살표가 있습니다.  즉, 카테고리의 모든 객체  `X`  에 대해 화살표  `X -> X`가  있습니다.  이 화살표는 ID 화살표로 알려져 있으며 일반적으로 객체 자신을 가리키는 작은 원형 화살표로 그려집니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*3jcLj7wdwWaUJ22X2iT7OA.png)\n\n항등 사상\n\n### 결합법칙\n\n연산을 할 때 괄호를 어디에 두어도 상관이 없다는 의미입니다.  덧셈의 경우  `a + (b + c)`는  `(a + b) + c`와 결과가 같습니다.  함수 합성에 대해서도 마찬가지입니다.  `(f ∘ g) ∘ h = f ∘ (g ∘ h)`  .\n\nKleisli 합성에서도 마찬가지입니다. 대신 거꾸로 읽어야합니다.  합성 연산자( `chain` )를 보게되면 다음을 떠올리세요.\n\n```javascript\nh(x).chain(x => g(x).chain(f)) ==== (h(x).chain(g)).chain(f)\n```\n\n### 모나드 법칙 증명하기\n\nIdentity 모나드가 모나드 법칙을 충족시킨다는 것을 증명해보겠습니다.\n\n```javascript\n{ // Identity monad  \n  const Id = value => ({  \n    // Functor mapping  \n    // Preserve the wrapping for .map() by   \n    // passing the mapped value into the type  \n    // lift:  \n    map: f => Id.of(f(value)),\n\n    // Monad chaining  \n    // Discard one level of wrapping  \n    // by omitting the .of() type lift:  \n    chain: f => f(value),\n\n    // Just a convenient way to inspect  \n    // the values:  \n    toString: () => `Id(${ value })`  \n  });\n\n  // The type lift for this monad is just  \n  // a reference to the factory.  \n  Id.of = Id;\n\n  const g = n => Id(n + 1);  \n  const f = n => Id(n * 2);\n\n  // Left identity  \n  // unit(x).chain(f) ==== f(x)  \n  trace('Id monad left identity')([  \n    Id(x).chain(f),  \n    f(x)  \n  ]);  \n  // Id monad left identity: Id(40), Id(40)  \n  \n\n  // Right identity  \n  // m.chain(unit) ==== m  \n  trace('Id monad right identity')([  \n    Id(x).chain(Id.of),  \n    Id(x)  \n  ]);  \n  // Id monad right identity: Id(20), Id(20)\n\n  // Associativity  \n  // m.chain(f).chain(g) ====  \n  // m.chain(x => f(x).chain(g)    \n  trace('Id monad associativity')([  \n    Id(x).chain(g).chain(f),  \n    Id(x).chain(x => g(x).chain(f))  \n  ]);  \n  // Id monad associativity: Id(42), Id(42)  \n}\n```\n\n## 결론\n\n모나드는 타입 리프팅 함수( `g: a => M(b)`  ,  `f: b => M(c)`  )를 합성하는 방법을 기술한 인터페이스입니다.  이를 위해 모나드는  `f()`를 적용하기 전  `M(b)`를  `b`로  flatten합니다.  즉, funtor는 맵핑할  수 있는 것이며 모나드는 flatten한 뒤 맵핑할 수 있는 것입니다. :\n\n-   함수 맵:  `a => b`\n-   컨텍스트가 있는 Functor 맵:   `Functor(a) => Functor(b)` \n-   컨텍스트와 Flatten을 사용하는 모나드 맵:   `Monad(Monad(a)) => Monad(b)`\n\n\n모나드는 간단한 대칭성을 기반으로합니다. 즉, 값을 컨텍스트로 래핑하는 방법과 컨텍스트에서 래핑을 해제하는 방법입니다.\n\n-   Lift / Unit : 어떤 값을 모나드 컨텍스트로 타입 리프트 :  `a => M(a)`\n-   Flatten / Join : 컨텍스트에서 값을 언래핑 :  `M(a) => a`\n\n그리고 모나드는 Functor이기 때문에 다음과 같이 맵핑 할 수도 있습니다.\n\n-   Map : 컨텍스트가 유지되는 맵핑 :  `M(a) -> M(b)`\n\nFlatten과 map을 결합하면 리프팅 함수들을 합성하기위한 chain, 일명 Kleisli 합성을 만들 수 있습니다.\n\n-   FlatMap / Chain : Flatten + map :  `M(M(a)) => M(b)`\n\n모나드는 3 개의 법칙(공리)을 만족해야하며 이는 모나드 법칙으로 불립니다.\n\n-   Left identity :  `unit(x).chain(f) ==== f(x)`\n-   Right identity :  `m.chain(unit) ==== m`\n-   결합법칙 :  `m.chain(f).chain(g) ==== m.chain(x => f(x).chain(g)`\n\n프라미스, 옵저버블 등 여러분은 매일매일 JavaScript에서 모나드를 사용하고 있습니다.  Kleisli 합성을 사용하면 데이터 타입 API의 세부 사항을 신경쓰지 않고 데이터가 흘러가는 로직을 만들 수 있습니다. \n\n따라서 모나드는 코드를 단순화하는 매우 강력한 도구입니다.  모나드를 사용하기 위해 내부에서 무슨 일이 벌어지고 있는지 이해하거나 걱정할 필요는 없습니다. 다만, 이제는 모나드에 대해 더 많이 알게었고, 그 속에서 무슨일이 일어나는지 더이상 두려워하지 않게 되었습니다.\n\n레이디 모나드린의 저주를 두려워 할 필요가 없습니다.\n\n[**다음: Mocking은 코드 냄새(Code Smell)입니다 >**](https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/)","slug":"javascript-monads-made-simple","published":1,"updated":"2018-04-28T13:39:06.075Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83dz000kifp665ciwfo8","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/javascript-monads-made-simple-7856be57bfe8\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/\">다음&gt;</a></p>\n</blockquote>\n<p>모나드를 이해하기 위해선 다음을 이미 알고 있어야 합니다.</p>\n<ul>\n<li>함수 합성 :  <code>compose(f, g)(x) = (f ∘ g)(x) = f(g(x))</code></li>\n<li>Functor의 기본 :  <code>Array.map()</code>에 대한 이해.</li>\n</ul>\n<hr>\n<blockquote>\n<p>&quot;모나드를 이해하고 나면 갑자기 설명할 방법이 떠오르지 않습니다.&quot;Lady Monadgreen’s curse ~ Gilad Bracha (used famously by Douglas Crockford)</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“Hoenikker 박사가 말했습니다. 8살짜리 아이에게 자신이 하고있는 일을 설명 할 수 없는 과학자는 돌팔이입니다.”~ Kurt Vonnegut의 소설 Cat 's Cradle</p>\n</blockquote>\n<p>인터넷에서 &quot;모나드&quot;를 검색하면 불가사의한 카테고리 이론 문서들의 포격을 받게 되며,  그 후 부리토와 우주복을 예로 들어 모나드를 “정말 쉽게” 설명하고 있는 글들을 마주치게 됩니다.</p>\n<p>모나드는 간단합니다.  그러나 이를 설명하고 있는 용어들은 어렵습니다. 우리는 본질을 파고들어야 합니다.</p>\n<p><strong>모나드</strong>는 특정 컨텍스트에 속한 함수를 합성하는 도구입니다. 특정 컨텍스트란  계산, 분기, I/O, 값을 반환하는 과정 등을 예로 들 수 있습니다.  모나드 타입은 리프팅 함수<code>a =&gt; M(b)</code>를 합성할 수 있도록 lift, flat, map을 활용해 타입을 정렬합니다.  이 과정은 결국 임의의 타입  <code>a</code>를  <code>b</code>로 맵핑하는 것이며 계산 컨텍스트 속에 lift, flatten 및 map이 숨겨져 있습니다.</p>\n<ul>\n<li>함수 맵:  <code>a =&gt; b</code></li>\n<li>컨텍스트가 있는 Functor 맵:   <code>Functor(a) =&gt; Functor(b)</code></li>\n<li>컨텍스트와 Flatten을 사용하는 모나드 맵:   <code>Monad(Monad(a)) =&gt; Monad(b)</code></li>\n</ul>\n<p><strong>컨텍스트</strong>와 <strong>flatten</strong> 그리고 <strong>map</strong>이 과연 무엇일까요?</p>\n<ul>\n<li><strong>Map</strong>이란 &quot;<code>a</code>에 특정 함수를 적용해  <code>b</code>를 리턴합니다&quot;라는 의미입니다. 특정 입력을 받아 특정 출력을 반환합니다.</li>\n<li><strong>컨텍스트</strong>는 모나드 합성에 관련된 구현 세부 사항입니다.  Functor/모나드 API와 동작방식은 모나드를 앱의 나머지 부분과 합성할 수 있게 하는 컨텍스트를 제공합니다.  Functor와 모나드의 핵심은 이 컨텍스트를 추상화하여 어떤 것을 합성하고 연산하는 동안 문제가 생기지 않게 만드는데 있습니다.  컨텍스트 내에서 맵핑한다는 것은  <code>a =&gt; b</code>라는 함수를 컨텍스트 내부에 있는 값 <code>a</code>에 적용해서 새로운 값 <code>b</code>을  동일한 컨텍스트로 리턴한다는 의미입니다.  Observable이 왼쪽에 있으면 오른쪽에도 있어야 합니다. <code>Observable(a) =&gt; Observable(b)</code>   왼쪽에 배열이 있으면 오른쪽에도 있어야 합니다.  <code>Array(a) =&gt; Array(b)</code></li>\n<li><strong>Type lift</strong>는 값을 컨텍스트로 감싸는 것 입니다. 해당 값을 가지고 할 수 있는 동작, 연산들을 정의해놓은 API가 바로 컨텍스트이며, 컨텍스트 자체와 관련된 연산들도 포함되어있습니다.   <code>a =&gt; F(a)</code>(모나드는 일종의 펑터입니다).</li>\n<li><strong>Flatten</strong>은 컨텍스트 속에 있는 값을 빼내는 것을 의미 합니다 .  <code>F(a) =&gt; a</code></li>\n</ul>\n<p>예:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;             <span class=\"comment\">// Some data of type `a`  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;     <span class=\"comment\">// A function from `a` to `b`  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"built_in\">Array</span>.of(x);  <span class=\"comment\">// The type lift.  </span></span><br><span class=\"line\"><span class=\"comment\">// JS has type lift sugar for arrays: [x]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// .map() applies the function f to the value x  </span></span><br><span class=\"line\"><span class=\"comment\">// in the context of the array.  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = arr.map(f); <span class=\"comment\">// [40]</span></span><br></pre></td></tr></table></figure>\n<p>이 경우  컨텍스트는 <code>Array</code>가 되고 <code>x</code>는 컨텍스트에 담겨 맵핑되는 값입니다.</p>\n<p>이 예제는 이중배열을 다루진 않지만,  <code>.concat()</code>로 배열을 flatten할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].concat.apply([], [[<span class=\"number\">1</span>], [<span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>]]); <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"여러분은-이미-모나드를-사용하고-있습니다\">여러분은 이미 모나드를 사용하고 있습니다.</h2>\n<p>기술 수준이나 카테고리 이론에 대한 이해도와 상관없이 모나드를 사용하면 코드를 더 쉽게 짤 수 있습니다. 모나드를 활용하지 못한다면 코드가 더 어려워질 것입니다. (e.g., 콜백 지옥, 중첩 된 조건문, 스파게티 코드)</p>\n<p>소프트웨어 개발의 본질은 합성이고 모나드는 합성을 쉽게 할 수 있도록 도와주는 역할을 합니다.</p>\n<ul>\n<li>함수 맵:  <code>a =&gt; b</code>,  특정 타입의 함수를 합성할 수 있습니다.</li>\n<li>컨텍스트가 있는 Functor 맵: <code>Functor(a) =&gt; Functor(b)</code>,  함수를 합성 할 수 있습니다.  <code>F(a) =&gt; F(b)</code></li>\n<li>컨텍스트와 flatten을 사용하는 모나드 맵:  <code>Monad(Monad(a)) =&gt; Monad(b)</code>, lift 함수를 합성할 수 있습니다.  <code>a =&gt; F(b)</code></li>\n</ul>\n<p>이들은 모두  <strong>함수 합성</strong>을 표현하는 다른 방식입니다.  함수는 합성되기 위해 존재합니다. 함수는 복잡한 문제를 쉽게 풀 수 있는 간단한 문제로 분해하고 솔루션들을 여러 가지 방법으로 합성하여 애플리케이션을 만들 수 있도록 도와줍니다.</p>\n<p>함수를 이해하고 올바르게 사용하려면 합성을 더 깊이 이해해야 합니다.</p>\n<p>함수를 합성한다는 것은 데이터가 흐르는 파이프라인을 만드는 것과 같습니다. 파이프라인의 첫 단계에 특정 값을 넣으면 마지막 단계에서 변환된 값이 출력됩니다.  그러나 이것이 작동하려면 파이프 라인의 각 단계에서 이전 단계에서 반환하는 데이터 형식이 필요합니다.</p>\n<p>일반 함수를 합성하는 것은 간단합니다. 타입을 쉽게 정렬시킬 수 있기 때문이죠. 리턴 타입  <code>b</code>를 인풋 타입  <code>b</code>와 일치 시키면 됩니다.</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g:           <span class=\"selector-tag\">a</span> =&gt; <span class=\"selector-tag\">b</span>  </span><br><span class=\"line\">f:                <span class=\"selector-tag\">b</span> =&gt; c  </span><br><span class=\"line\">h = f(g(a)): <span class=\"selector-tag\">a</span>    =&gt;   c</span><br></pre></td></tr></table></figure>\n<p>Functor를 합성하는 것도 간단합니다.  타입을 정렬시킬 수 있기 때문이죠.</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g:             F<span class=\"comment\">(a)</span> =&gt; F<span class=\"comment\">(b)</span>  </span><br><span class=\"line\">f:                     F<span class=\"comment\">(b)</span> =&gt; F<span class=\"comment\">(c)</span>  </span><br><span class=\"line\">h = f<span class=\"comment\">(g(Fa)</span>):  F<span class=\"comment\">(a)</span>    =&gt;      F<span class=\"comment\">(c)</span></span><br></pre></td></tr></table></figure>\n<p>그러나  <code>a =&gt; F(b)</code>,  <code>b =&gt; F(c)</code>라는 함수를 합성하려면 모나드가 필요합니다.  모나드와 Functor를 구분하기 위해 <code>F()</code> 대신  <code>M()</code>이라고 쓰겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g:                  <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> M(b)  </span><br><span class=\"line\">f:                       <span class=\"function\"><span class=\"params\">b</span> =&gt;</span> M(c)  </span><br><span class=\"line\">h = composeM(f, g): <span class=\"function\"><span class=\"params\">a</span>    =&gt;</span>   M(c)</span><br></pre></td></tr></table></figure>\n<p>잠깐. 이 예제에서는  <em>함수 타입들이  정렬되지 않았습니다!</em>   <code>f</code>의 입력으로 <code>b</code>라는 타입이 필요하지만 실제로 전달받은 타입은  <code>M(b)</code>(monad of <code>b</code>)였고 결국<code>composeM()</code>에는  <code>g</code>가 리턴한 <code>M(b)</code>에서 <code>b</code>를 빼내는 과정이 필요합니다.   이 프로세스(<code>.bind()</code>  또는  <code>.chain()</code>)속에  flatten과 mapping이 숨겨져있습니다.</p>\n<p>다음 함수로 전달하기 전에  <code>M(b)</code>에서 <code>b</code>를 추출(unwrapping, flatten)합니다.</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g:             <span class=\"selector-tag\">a</span> =&gt; M(b) flattens to =&gt; <span class=\"selector-tag\">b</span>  </span><br><span class=\"line\">f:                                      <span class=\"selector-tag\">b</span>           maps to =&gt; M(c)  </span><br><span class=\"line\">h composeM(f, g):  </span><br><span class=\"line\">               <span class=\"selector-tag\">a</span>       flatten(M(b)) =&gt; <span class=\"selector-tag\">b</span> =&gt; map(<span class=\"selector-tag\">b</span> =&gt; M(c)) =&gt; M(c)</span><br></pre></td></tr></table></figure>\n<p>모나드는  <code>a =&gt; M(b)</code>형식의 함수들을 합성할 수 있도록 타입을 정렬시킵니다.</p>\n<p><code>M(b) =&gt; b</code>로의 <code>flatten</code>과   <code>b =&gt; M(c)</code>로의 <code>map</code>은    <code>chain</code> 연산 내부에서 호출되며 <code>chain</code>은  <code>composeM()</code> 내부에서 호출됩니다.  이러한 세부 구현은 추상화되어있기 때문에 사용자가 걱정할 필요가 없습니다.  따라서 일반 함수를 합성하는 것과 같은 방식으로 모나드 타입 함수를 합성할 수 있습니다.</p>\n<p>모나드가 필요한 이유는 실제로 프로그램의 여러 모듈에서 단지  <code>a =&gt; b</code>와 같은  간단한 맵핑만 처리하는 것이 아니기 때문입니다.  일부 함수는 부수작용(프라미스, 스트림)이나 분기(Maybe), 예외 (Either) 등을 처리해야합니다.</p>\n<p>다음은 좀 더 구체적인 예입니다.  비동기 API에서 User 데이터를 가져온 뒤 해당 데이터를 다른 비동기 API에 전달하여 계산을 수행해야하는 경우를 알아보겠습니다.</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserById(<span class=\"name\">id</span>: String) =&gt; Promise(<span class=\"name\">User</span>)  </span><br><span class=\"line\">hasPermision(<span class=\"name\">User</span>) =&gt; Promise(<span class=\"name\">Boolean</span>)</span><br></pre></td></tr></table></figure>\n<p>함수를 몇 개 정의하겠습니다.  우선 유틸리티 함수입니다.  <code>compose()</code>  및  <code>trace()</code>  :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduceRight(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> trace = <span class=\"function\"><span class=\"params\">label</span> =&gt;</span> value =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123; label &#125;</span>: <span class=\"subst\">$&#123; value &#125;</span>`</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>함수들을 합성해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> label = <span class=\"string\">'API call composition'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// a =&gt; Promise(b)  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getUserById = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> id === <span class=\"number\">3</span> ?  </span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Kurt'</span>, <span class=\"attr\">role</span>: <span class=\"string\">'Author'</span> &#125;) :  </span><br><span class=\"line\">    <span class=\"literal\">undefined</span>  </span><br><span class=\"line\">  ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// b =&gt; Promise(c)  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hasPermission = <span class=\"function\">(<span class=\"params\">&#123; role &#125;</span>) =&gt;</span> (  </span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(role === <span class=\"string\">'Author'</span>)  </span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Try to compose them. Warning: this will fail.  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> authUser = compose(hasPermission, getUserById);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Oops! Always false!  </span></span><br><span class=\"line\">  authUser(<span class=\"number\">3</span>).then(trace(label));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>hasPermission()</code>과  <code>getUserById()</code>를 합성하여  <code>authUser()</code>를 만드려고 합니다. 그러나  <code>hasPermission()</code>이  <code>User</code>타입 대신  <code>Promise(User)</code>를 받게되는 문제가 발생합니다.  이 문제를 해결하려면 <code>compose()</code>  대신    <code>composePromises()</code>를 사용해야 합니다.  이는 <code>.then()</code>을 사용해 함수를 합성하는 특수한 유틸리티입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> composeM = <span class=\"function\"><span class=\"params\">chainMethod</span> =&gt;</span> (...ms) =&gt; (  </span><br><span class=\"line\">    ms.reduce(<span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; g(x)[chainMethod](f))  </span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> composePromises = composeM(<span class=\"string\">'then'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> label = <span class=\"string\">'API call composition'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// a =&gt; Promise(b)  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getUserById = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> id === <span class=\"number\">3</span> ?  </span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Kurt'</span>, <span class=\"attr\">role</span>: <span class=\"string\">'Author'</span> &#125;) :  </span><br><span class=\"line\">    <span class=\"literal\">undefined</span>  </span><br><span class=\"line\">  ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// b =&gt; Promise(c)  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hasPermission = <span class=\"function\">(<span class=\"params\">&#123; role &#125;</span>) =&gt;</span> (  </span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(role === <span class=\"string\">'Author'</span>)  </span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Compose the functions (this works!)  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> authUser = composePromises(hasPermission, getUserById);</span><br><span class=\"line\"></span><br><span class=\"line\">  authUser(<span class=\"number\">3</span>).then(trace(label)); <span class=\"comment\">// true  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>composeM()</code>에 대해서는 나중에 다시 알아볼 것 입니다.</p>\n<p>모나드의 핵심을 기억하십니까? :</p>\n<ul>\n<li>함수 맵:  <code>a =&gt; b</code></li>\n<li>컨텍스트가 있는 Functor 맵:   <code>Functor(a) =&gt; Functor(b)</code></li>\n<li>컨텍스트와 Flatten을 사용하는 모나드 맵:   <code>Monad(Monad(a)) =&gt; Monad(b)</code></li>\n</ul>\n<p>이 경우, 프라미스가 곧 모나드이기 때문에,  프라미스을 반환하는 함수들을 합성할 때  <code>hasPermission()</code>은 <code>User</code>타입  대신에  <code>Promise(User)</code>를 받게됩니다. 모나드 연산의 왼쪽 항 <code>Monad(Monad(a))</code>에서 바깥 쪽  <code>Monad()</code>  래퍼를 벗겨낼 경우 <code>Monad(a) =&gt; Monad(b)</code>가 됩니다.  이는 일반적인 functor <code>.map()</code>과 동일합니다. 즉, <code>Monad(x) =&gt; x</code> 처럼 래퍼를 벗겨낼 수 있다면 모나드 연산을 만들 수 있습니다.</p>\n<h2 id=\"모나드의-구성요소\">모나드의 구성요소</h2>\n<p>모나드는 간단한 대칭을 기반으로합니다. 즉, 값을 컨텍스트로 래핑하는 방법과 컨텍스트에서 값의 랩핑을 해제하는 방법입니다.</p>\n<ul>\n<li><strong>Lift / Unit :</strong>  어떤 타입을 모나드 컨텍스트로 리프트 :  <code>a =&gt; M(a)</code></li>\n<li><strong>Flatten / Join :</strong>  컨텍스트에서 타입을 추출 :  <code>M(a) =&gt; a</code></li>\n</ul>\n<p>그리고 모나드는 펑터에 속하기 때문에 다음과 같이 맵핑 할 수도 있습니다.</p>\n<ul>\n<li><strong>Map :</strong>  컨텍스트가 유지되는 맵핑 :  <code>M(a) -&gt; M(b)</code></li>\n</ul>\n<p>Flatten과 Map을 결합하면  <a href=\"https://en.wikipedia.org/wiki/Heinrich_Kleisli\" target=\"_blank\" rel=\"noopener\">하인리히 클레이슬리</a>의  이름을 딴 모나드 리프팅 함수들을 합성하는 <strong>Chain</strong>, 일명 클레이슬리 컴포지션을 만들 수 있습니다.</p>\n<ul>\n<li><strong>FlatMap / Chain :</strong> Flatten + Map :  <code>M(M(a)) =&gt; M(b)</code></li>\n</ul>\n<p>모나드의 경우  <code>.map()</code>  메소드는 퍼블릭 API에서 생략되는 경우가 많습니다. Lift + flatten을 명시적으로  <code>.map()</code>이라고 부르지는 않습니다. 그러나 이를 만드는 일은 간단합니다.  리프트 (aka of/unit)를 한뒤 체인 (aka bind/flatMap)을 하면 <code>.map()</code>이 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyMonad = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  <span class=\"comment\">// &lt;... insert arbitrary chain and of here ...&gt;  </span></span><br><span class=\"line\">  map (f) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.chain(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"keyword\">this</span>.constructor.of(f(a)));  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>따라서   <code>.of()</code>  및  <code>.chain()</code>/<code>.join()</code>을 정의하면  <code>.map()</code>을 정의할 수 있습니다.</p>\n<p>리프트는 factory/constructor 이며 <code>constructor.of()</code>  메서드입니다.  카테고리 이론에서 &quot;단위<sup>unit</sup>&quot;라고 불립니다.  타입을 모나드의 컨텍스트로 감싸는 일입니다.  a를  <code>Monad</code>  of  <code>a</code>  로 바꿉니다.</p>\n<p>Haskell에서는 리프트를 (매우 헷갈리게)<code>return</code>이라고 부르며 거의 모든 사람들이 그것을 함수의 리턴과 혼동합니다. 따라서 저는 말할 때  “들어 올리기, 승격, 리프트” 또는 &quot;타입 리프트&quot;라고 부르며 코드에서는  <code>.of()</code>라고 부릅니다.</p>\n<p>값을 빼내는 프로세스 (<code>.chain()</code>에서 map이 빠진 것)는 일반적으로  <code>flatten()</code>  또는  <code>join()</code> 이라고 합니다.  <code>flatten()</code>/<code>join()</code>은  <code>.chain()/.flatMap()</code>에 포함되어 있기 때문에 완전히 생략되는 경우가 많습니다.  flattening은 합성과 관련되어 있으므로 매핑과 결합되는 경우가 많습니다.  기억하세요, unwrapping + map은  <code>a =&gt; M(a)</code> 형식의 함수들을 합성하는데 필요합니다.</p>\n<p>어떤 종류의 모나드를 사용 하느냐에 따라 unwrapping 프로세스가 매우 간단해질 수 있습니다.  Identity 모나드의 경우, 결과 값을 다시 모나드 컨텍스트로 가져 오지 않는다는 점을 제외하고는  <code>.map()</code>과 같습니다.  래핑의 한 레이어를 버리는 효과가 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"comment\">// Identity monad  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Id = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  <span class=\"comment\">// Functor mapping  </span></span><br><span class=\"line\">  <span class=\"comment\">// Preserve the wrapping for .map() by   </span></span><br><span class=\"line\">  <span class=\"comment\">// passing the mapped value into the type  </span></span><br><span class=\"line\">  <span class=\"comment\">// lift:  </span></span><br><span class=\"line\">  map: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> Id.of(f(value)),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Monad chaining  </span></span><br><span class=\"line\">  <span class=\"comment\">// Discard one level of wrapping  </span></span><br><span class=\"line\">  <span class=\"comment\">// by omitting the .of() type lift:  </span></span><br><span class=\"line\">  chain: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f(value),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Just a convenient way to inspect  </span></span><br><span class=\"line\">  <span class=\"comment\">// the values:  </span></span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`Id(<span class=\"subst\">$&#123; value &#125;</span>)`</span>  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The type lift for this monad is just  </span></span><br><span class=\"line\"><span class=\"comment\">// a reference to the factory.  </span></span><br><span class=\"line\">Id.of = Id;</span><br></pre></td></tr></table></figure>\n<p>그러나 unwrapping 프로세스는 일반적으로 부수효과, 오류,  분기 또는 비동기 I/O와 같은 불순한 요소가 숨겨지는 부분이기도합니다.  합성은 모든 소프트웨어 개발에서 실제로 흥미로운 일들이 일어나는 곳입니다.</p>\n<p>예를 들어 프라미스에서 <code>.chain()</code>은  <code>.then()</code>이라 불립니다. <code>promise.then(f)</code>를 호출하면  <code>f()</code>가  즉시 실행되지 않습니다.  대신 프라미스을 기다린 뒤  <code>f()</code>를  호출합니다.</p>\n<p>예:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;                 <span class=\"comment\">// The value  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.resolve(x); <span class=\"comment\">// The context  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span>   </span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(n * <span class=\"number\">2</span>);     <span class=\"comment\">// The function</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = p.then(f);     <span class=\"comment\">// The application</span></span><br><span class=\"line\"></span><br><span class=\"line\">  result.then(  </span><br><span class=\"line\">    r =&gt; <span class=\"built_in\">console</span>.log(r)         <span class=\"comment\">// 40  </span></span><br><span class=\"line\">  );  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>프라미스의  <code>.then()</code>은 <code>.chain()</code>과  <em>거의</em>  동일합니다.</p>\n<p>엄격하게 따졌을 때 프라미스는 모나드가 아니라는 말을 들은적 있을 겁니다.  값이 프라미스일 경우에만 언래핑하며 그렇지 않은 경우  <code>.then()</code>은  <code>.map()</code>처럼 동작합니다.</p>\n<p>즉, 프라미스 값과 다른 값에 대해 다르게 동작하는  <code>.then()</code>은 Functor 및  모나드가 충족시켜야 하는  수학 법칙을 엄격하게 따르는 것이 아닙니다.  현실적으로는 여러분이 이러한 원칙과 실제 작동방식을 알고있는 한, 그것들을 둘 중 하나로 취급 할 수 있습니다.  단지 일부 합성 유틸리티들로 프라미스를 합성했을 때 예상대로 작동하지 않을 수 있습니다.</p>\n<h2 id=\"모나드-합성하기클레이슬리kleisli-합성\">모나드 합성하기(클레이슬리<sup>Kleisli</sup> 합성)</h2>\n<p>promise-lifting 함수를 작성하는 데 사용한  <code>composeM</code>  함수에 대해 자세히 살펴 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> composeM = <span class=\"function\"><span class=\"params\">method</span> =&gt;</span> (...ms) =&gt; (  </span><br><span class=\"line\">  ms.reduce(<span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; g(x)[method](f))  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>이 이상한 reducer가 의미하는 것은 함수 합성의 대수적 정의입니다 :  <code>f(g(x))</code>. 더 쉽게 알아보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"comment\">// The algebraic definition of function composition:  </span></span><br><span class=\"line\">  <span class=\"comment\">// (f ∘ g)(x) = f(g(x))  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> compose = <span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; f(g(x));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;    <span class=\"comment\">// The value  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [x]; <span class=\"comment\">// The container</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Some functions to compose  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Proof that .map() accomplishes function composition.  </span></span><br><span class=\"line\">  <span class=\"comment\">// Chaining calls to map is function composition.  </span></span><br><span class=\"line\">  trace(<span class=\"string\">'map composes'</span>)([  </span><br><span class=\"line\">    arr.map(g).map(f),  </span><br><span class=\"line\">    arr.map(compose(f, g))  </span><br><span class=\"line\">  ]);  </span><br><span class=\"line\">  <span class=\"comment\">// =&gt; [42], [42]  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이는  <code>.map()</code>  메소드를 제공하는 모든 Functor(e.g., Array)에 대해 작동하는 합성 유틸리티를 작성할 수 있다는 것입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> composeMap = <span class=\"function\">(<span class=\"params\">...ms</span>) =&gt;</span> (  </span><br><span class=\"line\">  ms.reduce(<span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; g(x).map(f))  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>이것은 일반적인  <code>f(g(x))</code>를 약간 재구성한 것 입니다.  <code>a -&gt; Functor(b)</code>  유형의 함수가 여러 개 있으면 각 함수를 반복하여 값  <code>x</code>를 적용  합니다. <code>.reduce()</code>  메소드는 두가지 인자, reducer(이 경우  <code>f</code>  )와 배열의 아이템 (<code>g</code>)을 받는 함수를 사용합니다.</p>\n<p>각 반복에서 다음의  <code>f</code>가 되는 새로운 함수  ( <code>x =&gt; g(x).map(f)</code> )를 반환합니다.  우리는 이미  <code>x =&gt; g(x).map(f)</code>가  <code>compose(f, g)(x)</code>를 functor의 컨텍스트로 들어 올리는 것과 같음을 증명했습니다.  즉, 컨테이너의 값에  <code>f(g(x))</code>를 적용하는 것과 같습니다. 이 경우 배열 내의 값에 합성함수를 적용하는 것입니다.</p>\n<blockquote>\n<p>성능 경고 : 배열에 대해서는 권장하지 않습니다.  이런 방식으로 함수를 합성하려면 전체 배열(수십만개의 항목이 있을지도 모르는)을 여러번 반복해야 합니다.  배열을 맵핑해야할 경우 간단한  <code>a -&gt; b</code>  함수를 먼저 합성한 다음 한 번 매핑하거나  <code>.reduce()</code>  또는 트랜스듀서를 사용하여 반복을 최적화하십시오.</p>\n</blockquote>\n<p>배열에 이런식의 동기, 느긋하지 않은<sup>eager</sup> 방식으로 함수를 적용하는 것은 과합니다.  그러나 많은 비동기, 느긋한 방식들에 대해서 예외 나 null 값을 분기하는 것과 같은 지저분한 작업을 처리해야합니다.</p>\n<p>바로 그럴때 모나드가 필요해집니다. 모나드는 합성 체인에서 이전의 비동기 또는 분기 동작에 의존하는 값을 처리할 수 있습니다.  이 경우 일반적인 함수 합성으로는 값을 얻을 수 없습니다.  모나드를 반환하는 작업은  <code>a =&gt; b</code> 대신  <code>a =&gt; Monad(b)</code>  형식을 하고 있습니다.</p>\n<p>데이터를 받아 API를 실행하고 값을 리턴받아 다시 다른 API를 실행하고 해당 데이터에 대한 계산 결과를 반환하는 함수가 있다면 <code>a =&gt; Monad(b)</code>  타입의 함수들을 합성해야 합니다.  API 호출은 비동기식이므로 프라미스나 Observable과 같은 값으로 반환 값을 래핑해야합니다.  달리 말하면, 함수들의 서명은 각각  <code>a -&gt; Monad(b)</code>6과  <code>b -&gt; Monad(c)</code>가 됩니다.</p>\n<p><code>g: a -&gt; b</code>  ,  <code>f: b -&gt; c</code>타입의 함수들을 합성하는 것은 쉽습니다. 타입들이 정렬된 이상 <code>h: a -&gt; c</code>는 단지  <code>a =&gt; f(g(a))</code>일  뿐이기 때문입니다.</p>\n<p><code>g: a -&gt; Monad(b)</code>  ,  <code>f: b -&gt; Monad(c)</code> 타입의 함수들을 합성하는 것은 조금 더 어렵습니다. 타입들이 정렬되지 않았고 <code>f</code>는  <code>Monad(b)</code>가  아닌  <code>b</code>를  기대하고 있기 때문에 <code>h: a -&gt; Monad(c)</code>  는  <code>a =&gt; f(g(a))</code>로 표현될 수 없습니다.</p>\n<p>좀 더 구체적으로 접근하기 위해 프라미스를 리턴하는 한쌍의 비동기 함수를 합성해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> label = <span class=\"string\">'Promise composition'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(n + <span class=\"number\">1</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(n * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> h = composePromises(f, g);</span><br><span class=\"line\"></span><br><span class=\"line\">  h(<span class=\"number\">20</span>)  </span><br><span class=\"line\">    .then(trace(label))  </span><br><span class=\"line\">  ;  </span><br><span class=\"line\">  <span class=\"comment\">// Promise composition: 42  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>올바른 결과가 나오도록 하려면<code>composePromises()</code>를  어떻게 만들어야야할까요?  <em>힌트 : 이미 본 적이 있습니다.</em></p>\n<p><code>composeMap()</code>  함수를 기억하십니까?  <code>.map()</code>을  <code>.then()</code>으로 바꾸면됩니다.  <code>Promise.then()</code>은 기본적으로 비동기  <code>.map()</code>  입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> composePromises = <span class=\"function\">(<span class=\"params\">...ms</span>) =&gt;</span> (  </span><br><span class=\"line\">    ms.reduce(<span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; g(x).then(f))  </span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> label = <span class=\"string\">'Promise composition'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(n + <span class=\"number\">1</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(n * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> h = composePromises(f, g);</span><br><span class=\"line\"></span><br><span class=\"line\">  h(<span class=\"number\">20</span>)  </span><br><span class=\"line\">    .then(trace(label))  </span><br><span class=\"line\">  ;  </span><br><span class=\"line\">  <span class=\"comment\">// Promise composition: 42  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>두 번째 함수  <code>f</code>(  <code>g</code>  다음에 오는)가 받게되는 입력 값은 프라미스입니다. 하지만 <code>f</code>가 원하는 타입은 <code>Promise(b)</code>가 아니라 <code>b</code>였습니다.  무슨 일이 일어난걸까요?</p>\n<p><code>.then()</code>  내부에는  <code>Promise(b) -&gt; b</code>  를 하는 언래핑 프로세스가 있습니다.  이 작업이 바로  <code>join</code>  또는  <code>flatten</code>입니다.</p>\n<p>즉, <code>composeMap()</code>  및  <code>composePromises()</code>가 거의 동일한 함수임을 알 수 있습니다.  이 두 가지를 모두 처리 할 수있는 고차 함수를 만들어 보겠습니다.  chain 메서드를 커링하기 위해 대괄호 표기법을 사용하겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> composeM = <span class=\"function\"><span class=\"params\">method</span> =&gt;</span> (...ms) =&gt; (  </span><br><span class=\"line\">  ms.reduce(<span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; g(x)[method](f))  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>이제 다음과 같은 특수한 구현들을 만들 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> composePromises = composeM(<span class=\"string\">'then'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> composeMap = composeM(<span class=\"string\">'map'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> composeFlatMap = composeM(<span class=\"string\">'flatMap'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"모나드의-법칙\">모나드의 법칙</h2>\n<p>여러분이 어떤 모나드를 만들기 전에 모든 모나드가 충족시켜야 할 세가지 법칙을 알아보겠습니다.</p>\n<ol>\n<li>Left identity :  <code>unit(x).chain(f) ==== f(x)</code></li>\n<li>Right identity :  <code>m.chain(unit) ==== m</code></li>\n<li>결합법칙<sup>Associativity</sup> :  <code>m.chain(f).chain(g) ==== m.chain(x =&gt; f(x).chain(g))</code></li>\n</ol>\n<h3 id=\"identity-laws\">Identity laws</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*X_bUJJYudP8MlhN0FLEGKg.png\" alt=\"\"></p>\n<p>Left and right identity</p>\n<p>모나드는 Functor입니다.  Functor는  <code>A -&gt; B</code>라는  카테고리 사이의 사상입니다.  사상은 화살표로 표시됩니다.  객체들 간에 명시적으로 표시된 화살표들 외에도 카테고리의 각 객체에 화살표가 있습니다.  즉, 카테고리의 모든 객체  <code>X</code>  에 대해 화살표  <code>X -&gt; X</code>가  있습니다.  이 화살표는 ID 화살표로 알려져 있으며 일반적으로 객체 자신을 가리키는 작은 원형 화살표로 그려집니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*3jcLj7wdwWaUJ22X2iT7OA.png\" alt=\"\"></p>\n<p>항등 사상</p>\n<h3 id=\"결합법칙\">결합법칙</h3>\n<p>연산을 할 때 괄호를 어디에 두어도 상관이 없다는 의미입니다.  덧셈의 경우  <code>a + (b + c)</code>는  <code>(a + b) + c</code>와 결과가 같습니다.  함수 합성에 대해서도 마찬가지입니다.  <code>(f ∘ g) ∘ h = f ∘ (g ∘ h)</code>  .</p>\n<p>Kleisli 합성에서도 마찬가지입니다. 대신 거꾸로 읽어야합니다.  합성 연산자( <code>chain</code> )를 보게되면 다음을 떠올리세요.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h(x).chain(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> g(x).chain(f)) ==== (h(x).chain(g)).chain(f)</span><br></pre></td></tr></table></figure>\n<h3 id=\"모나드-법칙-증명하기\">모나드 법칙 증명하기</h3>\n<p>Identity 모나드가 모나드 법칙을 충족시킨다는 것을 증명해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"comment\">// Identity monad  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Id = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// Functor mapping  </span></span><br><span class=\"line\">    <span class=\"comment\">// Preserve the wrapping for .map() by   </span></span><br><span class=\"line\">    <span class=\"comment\">// passing the mapped value into the type  </span></span><br><span class=\"line\">    <span class=\"comment\">// lift:  </span></span><br><span class=\"line\">    map: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> Id.of(f(value)),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Monad chaining  </span></span><br><span class=\"line\">    <span class=\"comment\">// Discard one level of wrapping  </span></span><br><span class=\"line\">    <span class=\"comment\">// by omitting the .of() type lift:  </span></span><br><span class=\"line\">    chain: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f(value),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Just a convenient way to inspect  </span></span><br><span class=\"line\">    <span class=\"comment\">// the values:  </span></span><br><span class=\"line\">    toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`Id(<span class=\"subst\">$&#123; value &#125;</span>)`</span>  </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The type lift for this monad is just  </span></span><br><span class=\"line\">  <span class=\"comment\">// a reference to the factory.  </span></span><br><span class=\"line\">  Id.of = Id;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> Id(n + <span class=\"number\">1</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> Id(n * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Left identity  </span></span><br><span class=\"line\">  <span class=\"comment\">// unit(x).chain(f) ==== f(x)  </span></span><br><span class=\"line\">  trace(<span class=\"string\">'Id monad left identity'</span>)([  </span><br><span class=\"line\">    Id(x).chain(f),  </span><br><span class=\"line\">    f(x)  </span><br><span class=\"line\">  ]);  </span><br><span class=\"line\">  <span class=\"comment\">// Id monad left identity: Id(40), Id(40)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Right identity  </span></span><br><span class=\"line\">  <span class=\"comment\">// m.chain(unit) ==== m  </span></span><br><span class=\"line\">  trace(<span class=\"string\">'Id monad right identity'</span>)([  </span><br><span class=\"line\">    Id(x).chain(Id.of),  </span><br><span class=\"line\">    Id(x)  </span><br><span class=\"line\">  ]);  </span><br><span class=\"line\">  <span class=\"comment\">// Id monad right identity: Id(20), Id(20)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Associativity  </span></span><br><span class=\"line\">  <span class=\"comment\">// m.chain(f).chain(g) ====  </span></span><br><span class=\"line\">  <span class=\"comment\">// m.chain(x =&gt; f(x).chain(g)    </span></span><br><span class=\"line\">  trace(<span class=\"string\">'Id monad associativity'</span>)([  </span><br><span class=\"line\">    Id(x).chain(g).chain(f),  </span><br><span class=\"line\">    Id(x).chain(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> g(x).chain(f))  </span><br><span class=\"line\">  ]);  </span><br><span class=\"line\">  <span class=\"comment\">// Id monad associativity: Id(42), Id(42)  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"결론\">결론</h2>\n<p>모나드는 타입 리프팅 함수( <code>g: a =&gt; M(b)</code>  ,  <code>f: b =&gt; M(c)</code>  )를 합성하는 방법을 기술한 인터페이스입니다.  이를 위해 모나드는  <code>f()</code>를 적용하기 전  <code>M(b)</code>를  <code>b</code>로  flatten합니다.  즉, funtor는 맵핑할  수 있는 것이며 모나드는 flatten한 뒤 맵핑할 수 있는 것입니다. :</p>\n<ul>\n<li>함수 맵:  <code>a =&gt; b</code></li>\n<li>컨텍스트가 있는 Functor 맵:   <code>Functor(a) =&gt; Functor(b)</code></li>\n<li>컨텍스트와 Flatten을 사용하는 모나드 맵:   <code>Monad(Monad(a)) =&gt; Monad(b)</code></li>\n</ul>\n<p>모나드는 간단한 대칭성을 기반으로합니다. 즉, 값을 컨텍스트로 래핑하는 방법과 컨텍스트에서 래핑을 해제하는 방법입니다.</p>\n<ul>\n<li>Lift / Unit : 어떤 값을 모나드 컨텍스트로 타입 리프트 :  <code>a =&gt; M(a)</code></li>\n<li>Flatten / Join : 컨텍스트에서 값을 언래핑 :  <code>M(a) =&gt; a</code></li>\n</ul>\n<p>그리고 모나드는 Functor이기 때문에 다음과 같이 맵핑 할 수도 있습니다.</p>\n<ul>\n<li>Map : 컨텍스트가 유지되는 맵핑 :  <code>M(a) -&gt; M(b)</code></li>\n</ul>\n<p>Flatten과 map을 결합하면 리프팅 함수들을 합성하기위한 chain, 일명 Kleisli 합성을 만들 수 있습니다.</p>\n<ul>\n<li>FlatMap / Chain : Flatten + map :  <code>M(M(a)) =&gt; M(b)</code></li>\n</ul>\n<p>모나드는 3 개의 법칙(공리)을 만족해야하며 이는 모나드 법칙으로 불립니다.</p>\n<ul>\n<li>Left identity :  <code>unit(x).chain(f) ==== f(x)</code></li>\n<li>Right identity :  <code>m.chain(unit) ==== m</code></li>\n<li>결합법칙 :  <code>m.chain(f).chain(g) ==== m.chain(x =&gt; f(x).chain(g)</code></li>\n</ul>\n<p>프라미스, 옵저버블 등 여러분은 매일매일 JavaScript에서 모나드를 사용하고 있습니다.  Kleisli 합성을 사용하면 데이터 타입 API의 세부 사항을 신경쓰지 않고 데이터가 흘러가는 로직을 만들 수 있습니다.</p>\n<p>따라서 모나드는 코드를 단순화하는 매우 강력한 도구입니다.  모나드를 사용하기 위해 내부에서 무슨 일이 벌어지고 있는지 이해하거나 걱정할 필요는 없습니다. 다만, 이제는 모나드에 대해 더 많이 알게었고, 그 속에서 무슨일이 일어나는지 더이상 두려워하지 않게 되었습니다.</p>\n<p>레이디 모나드린의 저주를 두려워 할 필요가 없습니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/\"><strong>다음: Mocking은 코드 냄새(Code Smell)입니다 &gt;</strong></a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/javascript-monads-made-simple-7856be57bfe8\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/\">다음&gt;</a></p>\n</blockquote>\n<p>모나드를 이해하기 위해선 다음을 이미 알고 있어야 합니다.</p>\n<ul>\n<li>함수 합성 :  <code>compose(f, g)(x) = (f ∘ g)(x) = f(g(x))</code></li>\n<li>Functor의 기본 :  <code>Array.map()</code>에 대한 이해.</li>\n</ul>\n<hr>\n<blockquote>\n<p>&quot;모나드를 이해하고 나면 갑자기 설명할 방법이 떠오르지 않습니다.&quot;Lady Monadgreen’s curse ~ Gilad Bracha (used famously by Douglas Crockford)</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“Hoenikker 박사가 말했습니다. 8살짜리 아이에게 자신이 하고있는 일을 설명 할 수 없는 과학자는 돌팔이입니다.”~ Kurt Vonnegut의 소설 Cat 's Cradle</p>\n</blockquote>\n<p>인터넷에서 &quot;모나드&quot;를 검색하면 불가사의한 카테고리 이론 문서들의 포격을 받게 되며,  그 후 부리토와 우주복을 예로 들어 모나드를 “정말 쉽게” 설명하고 있는 글들을 마주치게 됩니다.</p>\n<p>모나드는 간단합니다.  그러나 이를 설명하고 있는 용어들은 어렵습니다. 우리는 본질을 파고들어야 합니다.</p>\n<p><strong>모나드</strong>는 특정 컨텍스트에 속한 함수를 합성하는 도구입니다. 특정 컨텍스트란  계산, 분기, I/O, 값을 반환하는 과정 등을 예로 들 수 있습니다.  모나드 타입은 리프팅 함수<code>a =&gt; M(b)</code>를 합성할 수 있도록 lift, flat, map을 활용해 타입을 정렬합니다.  이 과정은 결국 임의의 타입  <code>a</code>를  <code>b</code>로 맵핑하는 것이며 계산 컨텍스트 속에 lift, flatten 및 map이 숨겨져 있습니다.</p>\n<ul>\n<li>함수 맵:  <code>a =&gt; b</code></li>\n<li>컨텍스트가 있는 Functor 맵:   <code>Functor(a) =&gt; Functor(b)</code></li>\n<li>컨텍스트와 Flatten을 사용하는 모나드 맵:   <code>Monad(Monad(a)) =&gt; Monad(b)</code></li>\n</ul>\n<p><strong>컨텍스트</strong>와 <strong>flatten</strong> 그리고 <strong>map</strong>이 과연 무엇일까요?</p>\n<ul>\n<li><strong>Map</strong>이란 &quot;<code>a</code>에 특정 함수를 적용해  <code>b</code>를 리턴합니다&quot;라는 의미입니다. 특정 입력을 받아 특정 출력을 반환합니다.</li>\n<li><strong>컨텍스트</strong>는 모나드 합성에 관련된 구현 세부 사항입니다.  Functor/모나드 API와 동작방식은 모나드를 앱의 나머지 부분과 합성할 수 있게 하는 컨텍스트를 제공합니다.  Functor와 모나드의 핵심은 이 컨텍스트를 추상화하여 어떤 것을 합성하고 연산하는 동안 문제가 생기지 않게 만드는데 있습니다.  컨텍스트 내에서 맵핑한다는 것은  <code>a =&gt; b</code>라는 함수를 컨텍스트 내부에 있는 값 <code>a</code>에 적용해서 새로운 값 <code>b</code>을  동일한 컨텍스트로 리턴한다는 의미입니다.  Observable이 왼쪽에 있으면 오른쪽에도 있어야 합니다. <code>Observable(a) =&gt; Observable(b)</code>   왼쪽에 배열이 있으면 오른쪽에도 있어야 합니다.  <code>Array(a) =&gt; Array(b)</code></li>\n<li><strong>Type lift</strong>는 값을 컨텍스트로 감싸는 것 입니다. 해당 값을 가지고 할 수 있는 동작, 연산들을 정의해놓은 API가 바로 컨텍스트이며, 컨텍스트 자체와 관련된 연산들도 포함되어있습니다.   <code>a =&gt; F(a)</code>(모나드는 일종의 펑터입니다).</li>\n<li><strong>Flatten</strong>은 컨텍스트 속에 있는 값을 빼내는 것을 의미 합니다 .  <code>F(a) =&gt; a</code></li>\n</ul>\n<p>예:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;             <span class=\"comment\">// Some data of type `a`  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;     <span class=\"comment\">// A function from `a` to `b`  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"built_in\">Array</span>.of(x);  <span class=\"comment\">// The type lift.  </span></span><br><span class=\"line\"><span class=\"comment\">// JS has type lift sugar for arrays: [x]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// .map() applies the function f to the value x  </span></span><br><span class=\"line\"><span class=\"comment\">// in the context of the array.  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = arr.map(f); <span class=\"comment\">// [40]</span></span><br></pre></td></tr></table></figure>\n<p>이 경우  컨텍스트는 <code>Array</code>가 되고 <code>x</code>는 컨텍스트에 담겨 맵핑되는 값입니다.</p>\n<p>이 예제는 이중배열을 다루진 않지만,  <code>.concat()</code>로 배열을 flatten할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].concat.apply([], [[<span class=\"number\">1</span>], [<span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>]]); <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<h2>여러분은 이미 모나드를 사용하고 있습니다.</h2>\n<p>기술 수준이나 카테고리 이론에 대한 이해도와 상관없이 모나드를 사용하면 코드를 더 쉽게 짤 수 있습니다. 모나드를 활용하지 못한다면 코드가 더 어려워질 것입니다. (e.g., 콜백 지옥, 중첩 된 조건문, 스파게티 코드)</p>\n<p>소프트웨어 개발의 본질은 합성이고 모나드는 합성을 쉽게 할 수 있도록 도와주는 역할을 합니다.</p>\n<ul>\n<li>함수 맵:  <code>a =&gt; b</code>,  특정 타입의 함수를 합성할 수 있습니다.</li>\n<li>컨텍스트가 있는 Functor 맵: <code>Functor(a) =&gt; Functor(b)</code>,  함수를 합성 할 수 있습니다.  <code>F(a) =&gt; F(b)</code></li>\n<li>컨텍스트와 flatten을 사용하는 모나드 맵:  <code>Monad(Monad(a)) =&gt; Monad(b)</code>, lift 함수를 합성할 수 있습니다.  <code>a =&gt; F(b)</code></li>\n</ul>\n<p>이들은 모두  <strong>함수 합성</strong>을 표현하는 다른 방식입니다.  함수는 합성되기 위해 존재합니다. 함수는 복잡한 문제를 쉽게 풀 수 있는 간단한 문제로 분해하고 솔루션들을 여러 가지 방법으로 합성하여 애플리케이션을 만들 수 있도록 도와줍니다.</p>\n<p>함수를 이해하고 올바르게 사용하려면 합성을 더 깊이 이해해야 합니다.</p>\n<p>함수를 합성한다는 것은 데이터가 흐르는 파이프라인을 만드는 것과 같습니다. 파이프라인의 첫 단계에 특정 값을 넣으면 마지막 단계에서 변환된 값이 출력됩니다.  그러나 이것이 작동하려면 파이프 라인의 각 단계에서 이전 단계에서 반환하는 데이터 형식이 필요합니다.</p>\n<p>일반 함수를 합성하는 것은 간단합니다. 타입을 쉽게 정렬시킬 수 있기 때문이죠. 리턴 타입  <code>b</code>를 인풋 타입  <code>b</code>와 일치 시키면 됩니다.</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g:           <span class=\"selector-tag\">a</span> =&gt; <span class=\"selector-tag\">b</span>  </span><br><span class=\"line\">f:                <span class=\"selector-tag\">b</span> =&gt; c  </span><br><span class=\"line\">h = f(g(a)): <span class=\"selector-tag\">a</span>    =&gt;   c</span><br></pre></td></tr></table></figure>\n<p>Functor를 합성하는 것도 간단합니다.  타입을 정렬시킬 수 있기 때문이죠.</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g:             F<span class=\"comment\">(a)</span> =&gt; F<span class=\"comment\">(b)</span>  </span><br><span class=\"line\">f:                     F<span class=\"comment\">(b)</span> =&gt; F<span class=\"comment\">(c)</span>  </span><br><span class=\"line\">h = f<span class=\"comment\">(g(Fa)</span>):  F<span class=\"comment\">(a)</span>    =&gt;      F<span class=\"comment\">(c)</span></span><br></pre></td></tr></table></figure>\n<p>그러나  <code>a =&gt; F(b)</code>,  <code>b =&gt; F(c)</code>라는 함수를 합성하려면 모나드가 필요합니다.  모나드와 Functor를 구분하기 위해 <code>F()</code> 대신  <code>M()</code>이라고 쓰겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g:                  <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> M(b)  </span><br><span class=\"line\">f:                       <span class=\"function\"><span class=\"params\">b</span> =&gt;</span> M(c)  </span><br><span class=\"line\">h = composeM(f, g): <span class=\"function\"><span class=\"params\">a</span>    =&gt;</span>   M(c)</span><br></pre></td></tr></table></figure>\n<p>잠깐. 이 예제에서는  <em>함수 타입들이  정렬되지 않았습니다!</em>   <code>f</code>의 입력으로 <code>b</code>라는 타입이 필요하지만 실제로 전달받은 타입은  <code>M(b)</code>(monad of <code>b</code>)였고 결국<code>composeM()</code>에는  <code>g</code>가 리턴한 <code>M(b)</code>에서 <code>b</code>를 빼내는 과정이 필요합니다.   이 프로세스(<code>.bind()</code>  또는  <code>.chain()</code>)속에  flatten과 mapping이 숨겨져있습니다.</p>\n<p>다음 함수로 전달하기 전에  <code>M(b)</code>에서 <code>b</code>를 추출(unwrapping, flatten)합니다.</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g:             <span class=\"selector-tag\">a</span> =&gt; M(b) flattens to =&gt; <span class=\"selector-tag\">b</span>  </span><br><span class=\"line\">f:                                      <span class=\"selector-tag\">b</span>           maps to =&gt; M(c)  </span><br><span class=\"line\">h composeM(f, g):  </span><br><span class=\"line\">               <span class=\"selector-tag\">a</span>       flatten(M(b)) =&gt; <span class=\"selector-tag\">b</span> =&gt; map(<span class=\"selector-tag\">b</span> =&gt; M(c)) =&gt; M(c)</span><br></pre></td></tr></table></figure>\n<p>모나드는  <code>a =&gt; M(b)</code>형식의 함수들을 합성할 수 있도록 타입을 정렬시킵니다.</p>\n<p><code>M(b) =&gt; b</code>로의 <code>flatten</code>과   <code>b =&gt; M(c)</code>로의 <code>map</code>은    <code>chain</code> 연산 내부에서 호출되며 <code>chain</code>은  <code>composeM()</code> 내부에서 호출됩니다.  이러한 세부 구현은 추상화되어있기 때문에 사용자가 걱정할 필요가 없습니다.  따라서 일반 함수를 합성하는 것과 같은 방식으로 모나드 타입 함수를 합성할 수 있습니다.</p>\n<p>모나드가 필요한 이유는 실제로 프로그램의 여러 모듈에서 단지  <code>a =&gt; b</code>와 같은  간단한 맵핑만 처리하는 것이 아니기 때문입니다.  일부 함수는 부수작용(프라미스, 스트림)이나 분기(Maybe), 예외 (Either) 등을 처리해야합니다.</p>\n<p>다음은 좀 더 구체적인 예입니다.  비동기 API에서 User 데이터를 가져온 뒤 해당 데이터를 다른 비동기 API에 전달하여 계산을 수행해야하는 경우를 알아보겠습니다.</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserById(<span class=\"name\">id</span>: String) =&gt; Promise(<span class=\"name\">User</span>)  </span><br><span class=\"line\">hasPermision(<span class=\"name\">User</span>) =&gt; Promise(<span class=\"name\">Boolean</span>)</span><br></pre></td></tr></table></figure>\n<p>함수를 몇 개 정의하겠습니다.  우선 유틸리티 함수입니다.  <code>compose()</code>  및  <code>trace()</code>  :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduceRight(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> trace = <span class=\"function\"><span class=\"params\">label</span> =&gt;</span> value =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123; label &#125;</span>: <span class=\"subst\">$&#123; value &#125;</span>`</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>함수들을 합성해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> label = <span class=\"string\">'API call composition'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// a =&gt; Promise(b)  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getUserById = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> id === <span class=\"number\">3</span> ?  </span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Kurt'</span>, <span class=\"attr\">role</span>: <span class=\"string\">'Author'</span> &#125;) :  </span><br><span class=\"line\">    <span class=\"literal\">undefined</span>  </span><br><span class=\"line\">  ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// b =&gt; Promise(c)  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hasPermission = <span class=\"function\">(<span class=\"params\">&#123; role &#125;</span>) =&gt;</span> (  </span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(role === <span class=\"string\">'Author'</span>)  </span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Try to compose them. Warning: this will fail.  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> authUser = compose(hasPermission, getUserById);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Oops! Always false!  </span></span><br><span class=\"line\">  authUser(<span class=\"number\">3</span>).then(trace(label));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>hasPermission()</code>과  <code>getUserById()</code>를 합성하여  <code>authUser()</code>를 만드려고 합니다. 그러나  <code>hasPermission()</code>이  <code>User</code>타입 대신  <code>Promise(User)</code>를 받게되는 문제가 발생합니다.  이 문제를 해결하려면 <code>compose()</code>  대신    <code>composePromises()</code>를 사용해야 합니다.  이는 <code>.then()</code>을 사용해 함수를 합성하는 특수한 유틸리티입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> composeM = <span class=\"function\"><span class=\"params\">chainMethod</span> =&gt;</span> (...ms) =&gt; (  </span><br><span class=\"line\">    ms.reduce(<span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; g(x)[chainMethod](f))  </span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> composePromises = composeM(<span class=\"string\">'then'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> label = <span class=\"string\">'API call composition'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// a =&gt; Promise(b)  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getUserById = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> id === <span class=\"number\">3</span> ?  </span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Kurt'</span>, <span class=\"attr\">role</span>: <span class=\"string\">'Author'</span> &#125;) :  </span><br><span class=\"line\">    <span class=\"literal\">undefined</span>  </span><br><span class=\"line\">  ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// b =&gt; Promise(c)  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hasPermission = <span class=\"function\">(<span class=\"params\">&#123; role &#125;</span>) =&gt;</span> (  </span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(role === <span class=\"string\">'Author'</span>)  </span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Compose the functions (this works!)  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> authUser = composePromises(hasPermission, getUserById);</span><br><span class=\"line\"></span><br><span class=\"line\">  authUser(<span class=\"number\">3</span>).then(trace(label)); <span class=\"comment\">// true  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>composeM()</code>에 대해서는 나중에 다시 알아볼 것 입니다.</p>\n<p>모나드의 핵심을 기억하십니까? :</p>\n<ul>\n<li>함수 맵:  <code>a =&gt; b</code></li>\n<li>컨텍스트가 있는 Functor 맵:   <code>Functor(a) =&gt; Functor(b)</code></li>\n<li>컨텍스트와 Flatten을 사용하는 모나드 맵:   <code>Monad(Monad(a)) =&gt; Monad(b)</code></li>\n</ul>\n<p>이 경우, 프라미스가 곧 모나드이기 때문에,  프라미스을 반환하는 함수들을 합성할 때  <code>hasPermission()</code>은 <code>User</code>타입  대신에  <code>Promise(User)</code>를 받게됩니다. 모나드 연산의 왼쪽 항 <code>Monad(Monad(a))</code>에서 바깥 쪽  <code>Monad()</code>  래퍼를 벗겨낼 경우 <code>Monad(a) =&gt; Monad(b)</code>가 됩니다.  이는 일반적인 functor <code>.map()</code>과 동일합니다. 즉, <code>Monad(x) =&gt; x</code> 처럼 래퍼를 벗겨낼 수 있다면 모나드 연산을 만들 수 있습니다.</p>\n<h2>모나드의 구성요소</h2>\n<p>모나드는 간단한 대칭을 기반으로합니다. 즉, 값을 컨텍스트로 래핑하는 방법과 컨텍스트에서 값의 랩핑을 해제하는 방법입니다.</p>\n<ul>\n<li><strong>Lift / Unit :</strong>  어떤 타입을 모나드 컨텍스트로 리프트 :  <code>a =&gt; M(a)</code></li>\n<li><strong>Flatten / Join :</strong>  컨텍스트에서 타입을 추출 :  <code>M(a) =&gt; a</code></li>\n</ul>\n<p>그리고 모나드는 펑터에 속하기 때문에 다음과 같이 맵핑 할 수도 있습니다.</p>\n<ul>\n<li><strong>Map :</strong>  컨텍스트가 유지되는 맵핑 :  <code>M(a) -&gt; M(b)</code></li>\n</ul>\n<p>Flatten과 Map을 결합하면  <a href=\"https://en.wikipedia.org/wiki/Heinrich_Kleisli\" target=\"_blank\" rel=\"noopener\">하인리히 클레이슬리</a>의  이름을 딴 모나드 리프팅 함수들을 합성하는 <strong>Chain</strong>, 일명 클레이슬리 컴포지션을 만들 수 있습니다.</p>\n<ul>\n<li><strong>FlatMap / Chain :</strong> Flatten + Map :  <code>M(M(a)) =&gt; M(b)</code></li>\n</ul>\n<p>모나드의 경우  <code>.map()</code>  메소드는 퍼블릭 API에서 생략되는 경우가 많습니다. Lift + flatten을 명시적으로  <code>.map()</code>이라고 부르지는 않습니다. 그러나 이를 만드는 일은 간단합니다.  리프트 (aka of/unit)를 한뒤 체인 (aka bind/flatMap)을 하면 <code>.map()</code>이 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyMonad = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  <span class=\"comment\">// &lt;... insert arbitrary chain and of here ...&gt;  </span></span><br><span class=\"line\">  map (f) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.chain(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"keyword\">this</span>.constructor.of(f(a)));  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>따라서   <code>.of()</code>  및  <code>.chain()</code>/<code>.join()</code>을 정의하면  <code>.map()</code>을 정의할 수 있습니다.</p>\n<p>리프트는 factory/constructor 이며 <code>constructor.of()</code>  메서드입니다.  카테고리 이론에서 &quot;단위<sup>unit</sup>&quot;라고 불립니다.  타입을 모나드의 컨텍스트로 감싸는 일입니다.  a를  <code>Monad</code>  of  <code>a</code>  로 바꿉니다.</p>\n<p>Haskell에서는 리프트를 (매우 헷갈리게)<code>return</code>이라고 부르며 거의 모든 사람들이 그것을 함수의 리턴과 혼동합니다. 따라서 저는 말할 때  “들어 올리기, 승격, 리프트” 또는 &quot;타입 리프트&quot;라고 부르며 코드에서는  <code>.of()</code>라고 부릅니다.</p>\n<p>값을 빼내는 프로세스 (<code>.chain()</code>에서 map이 빠진 것)는 일반적으로  <code>flatten()</code>  또는  <code>join()</code> 이라고 합니다.  <code>flatten()</code>/<code>join()</code>은  <code>.chain()/.flatMap()</code>에 포함되어 있기 때문에 완전히 생략되는 경우가 많습니다.  flattening은 합성과 관련되어 있으므로 매핑과 결합되는 경우가 많습니다.  기억하세요, unwrapping + map은  <code>a =&gt; M(a)</code> 형식의 함수들을 합성하는데 필요합니다.</p>\n<p>어떤 종류의 모나드를 사용 하느냐에 따라 unwrapping 프로세스가 매우 간단해질 수 있습니다.  Identity 모나드의 경우, 결과 값을 다시 모나드 컨텍스트로 가져 오지 않는다는 점을 제외하고는  <code>.map()</code>과 같습니다.  래핑의 한 레이어를 버리는 효과가 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"comment\">// Identity monad  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Id = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  <span class=\"comment\">// Functor mapping  </span></span><br><span class=\"line\">  <span class=\"comment\">// Preserve the wrapping for .map() by   </span></span><br><span class=\"line\">  <span class=\"comment\">// passing the mapped value into the type  </span></span><br><span class=\"line\">  <span class=\"comment\">// lift:  </span></span><br><span class=\"line\">  map: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> Id.of(f(value)),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Monad chaining  </span></span><br><span class=\"line\">  <span class=\"comment\">// Discard one level of wrapping  </span></span><br><span class=\"line\">  <span class=\"comment\">// by omitting the .of() type lift:  </span></span><br><span class=\"line\">  chain: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f(value),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Just a convenient way to inspect  </span></span><br><span class=\"line\">  <span class=\"comment\">// the values:  </span></span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`Id(<span class=\"subst\">$&#123; value &#125;</span>)`</span>  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The type lift for this monad is just  </span></span><br><span class=\"line\"><span class=\"comment\">// a reference to the factory.  </span></span><br><span class=\"line\">Id.of = Id;</span><br></pre></td></tr></table></figure>\n<p>그러나 unwrapping 프로세스는 일반적으로 부수효과, 오류,  분기 또는 비동기 I/O와 같은 불순한 요소가 숨겨지는 부분이기도합니다.  합성은 모든 소프트웨어 개발에서 실제로 흥미로운 일들이 일어나는 곳입니다.</p>\n<p>예를 들어 프라미스에서 <code>.chain()</code>은  <code>.then()</code>이라 불립니다. <code>promise.then(f)</code>를 호출하면  <code>f()</code>가  즉시 실행되지 않습니다.  대신 프라미스을 기다린 뒤  <code>f()</code>를  호출합니다.</p>\n<p>예:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;                 <span class=\"comment\">// The value  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.resolve(x); <span class=\"comment\">// The context  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span>   </span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(n * <span class=\"number\">2</span>);     <span class=\"comment\">// The function</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = p.then(f);     <span class=\"comment\">// The application</span></span><br><span class=\"line\"></span><br><span class=\"line\">  result.then(  </span><br><span class=\"line\">    r =&gt; <span class=\"built_in\">console</span>.log(r)         <span class=\"comment\">// 40  </span></span><br><span class=\"line\">  );  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>프라미스의  <code>.then()</code>은 <code>.chain()</code>과  <em>거의</em>  동일합니다.</p>\n<p>엄격하게 따졌을 때 프라미스는 모나드가 아니라는 말을 들은적 있을 겁니다.  값이 프라미스일 경우에만 언래핑하며 그렇지 않은 경우  <code>.then()</code>은  <code>.map()</code>처럼 동작합니다.</p>\n<p>즉, 프라미스 값과 다른 값에 대해 다르게 동작하는  <code>.then()</code>은 Functor 및  모나드가 충족시켜야 하는  수학 법칙을 엄격하게 따르는 것이 아닙니다.  현실적으로는 여러분이 이러한 원칙과 실제 작동방식을 알고있는 한, 그것들을 둘 중 하나로 취급 할 수 있습니다.  단지 일부 합성 유틸리티들로 프라미스를 합성했을 때 예상대로 작동하지 않을 수 있습니다.</p>\n<h2>모나드 합성하기(클레이슬리<sup>Kleisli</sup> 합성)</h2>\n<p>promise-lifting 함수를 작성하는 데 사용한  <code>composeM</code>  함수에 대해 자세히 살펴 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> composeM = <span class=\"function\"><span class=\"params\">method</span> =&gt;</span> (...ms) =&gt; (  </span><br><span class=\"line\">  ms.reduce(<span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; g(x)[method](f))  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>이 이상한 reducer가 의미하는 것은 함수 합성의 대수적 정의입니다 :  <code>f(g(x))</code>. 더 쉽게 알아보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"comment\">// The algebraic definition of function composition:  </span></span><br><span class=\"line\">  <span class=\"comment\">// (f ∘ g)(x) = f(g(x))  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> compose = <span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; f(g(x));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">20</span>;    <span class=\"comment\">// The value  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [x]; <span class=\"comment\">// The container</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Some functions to compose  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Proof that .map() accomplishes function composition.  </span></span><br><span class=\"line\">  <span class=\"comment\">// Chaining calls to map is function composition.  </span></span><br><span class=\"line\">  trace(<span class=\"string\">'map composes'</span>)([  </span><br><span class=\"line\">    arr.map(g).map(f),  </span><br><span class=\"line\">    arr.map(compose(f, g))  </span><br><span class=\"line\">  ]);  </span><br><span class=\"line\">  <span class=\"comment\">// =&gt; [42], [42]  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이는  <code>.map()</code>  메소드를 제공하는 모든 Functor(e.g., Array)에 대해 작동하는 합성 유틸리티를 작성할 수 있다는 것입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> composeMap = <span class=\"function\">(<span class=\"params\">...ms</span>) =&gt;</span> (  </span><br><span class=\"line\">  ms.reduce(<span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; g(x).map(f))  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>이것은 일반적인  <code>f(g(x))</code>를 약간 재구성한 것 입니다.  <code>a -&gt; Functor(b)</code>  유형의 함수가 여러 개 있으면 각 함수를 반복하여 값  <code>x</code>를 적용  합니다. <code>.reduce()</code>  메소드는 두가지 인자, reducer(이 경우  <code>f</code>  )와 배열의 아이템 (<code>g</code>)을 받는 함수를 사용합니다.</p>\n<p>각 반복에서 다음의  <code>f</code>가 되는 새로운 함수  ( <code>x =&gt; g(x).map(f)</code> )를 반환합니다.  우리는 이미  <code>x =&gt; g(x).map(f)</code>가  <code>compose(f, g)(x)</code>를 functor의 컨텍스트로 들어 올리는 것과 같음을 증명했습니다.  즉, 컨테이너의 값에  <code>f(g(x))</code>를 적용하는 것과 같습니다. 이 경우 배열 내의 값에 합성함수를 적용하는 것입니다.</p>\n<blockquote>\n<p>성능 경고 : 배열에 대해서는 권장하지 않습니다.  이런 방식으로 함수를 합성하려면 전체 배열(수십만개의 항목이 있을지도 모르는)을 여러번 반복해야 합니다.  배열을 맵핑해야할 경우 간단한  <code>a -&gt; b</code>  함수를 먼저 합성한 다음 한 번 매핑하거나  <code>.reduce()</code>  또는 트랜스듀서를 사용하여 반복을 최적화하십시오.</p>\n</blockquote>\n<p>배열에 이런식의 동기, 느긋하지 않은<sup>eager</sup> 방식으로 함수를 적용하는 것은 과합니다.  그러나 많은 비동기, 느긋한 방식들에 대해서 예외 나 null 값을 분기하는 것과 같은 지저분한 작업을 처리해야합니다.</p>\n<p>바로 그럴때 모나드가 필요해집니다. 모나드는 합성 체인에서 이전의 비동기 또는 분기 동작에 의존하는 값을 처리할 수 있습니다.  이 경우 일반적인 함수 합성으로는 값을 얻을 수 없습니다.  모나드를 반환하는 작업은  <code>a =&gt; b</code> 대신  <code>a =&gt; Monad(b)</code>  형식을 하고 있습니다.</p>\n<p>데이터를 받아 API를 실행하고 값을 리턴받아 다시 다른 API를 실행하고 해당 데이터에 대한 계산 결과를 반환하는 함수가 있다면 <code>a =&gt; Monad(b)</code>  타입의 함수들을 합성해야 합니다.  API 호출은 비동기식이므로 프라미스나 Observable과 같은 값으로 반환 값을 래핑해야합니다.  달리 말하면, 함수들의 서명은 각각  <code>a -&gt; Monad(b)</code>6과  <code>b -&gt; Monad(c)</code>가 됩니다.</p>\n<p><code>g: a -&gt; b</code>  ,  <code>f: b -&gt; c</code>타입의 함수들을 합성하는 것은 쉽습니다. 타입들이 정렬된 이상 <code>h: a -&gt; c</code>는 단지  <code>a =&gt; f(g(a))</code>일  뿐이기 때문입니다.</p>\n<p><code>g: a -&gt; Monad(b)</code>  ,  <code>f: b -&gt; Monad(c)</code> 타입의 함수들을 합성하는 것은 조금 더 어렵습니다. 타입들이 정렬되지 않았고 <code>f</code>는  <code>Monad(b)</code>가  아닌  <code>b</code>를  기대하고 있기 때문에 <code>h: a -&gt; Monad(c)</code>  는  <code>a =&gt; f(g(a))</code>로 표현될 수 없습니다.</p>\n<p>좀 더 구체적으로 접근하기 위해 프라미스를 리턴하는 한쌍의 비동기 함수를 합성해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> label = <span class=\"string\">'Promise composition'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(n + <span class=\"number\">1</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(n * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> h = composePromises(f, g);</span><br><span class=\"line\"></span><br><span class=\"line\">  h(<span class=\"number\">20</span>)  </span><br><span class=\"line\">    .then(trace(label))  </span><br><span class=\"line\">  ;  </span><br><span class=\"line\">  <span class=\"comment\">// Promise composition: 42  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>올바른 결과가 나오도록 하려면<code>composePromises()</code>를  어떻게 만들어야야할까요?  <em>힌트 : 이미 본 적이 있습니다.</em></p>\n<p><code>composeMap()</code>  함수를 기억하십니까?  <code>.map()</code>을  <code>.then()</code>으로 바꾸면됩니다.  <code>Promise.then()</code>은 기본적으로 비동기  <code>.map()</code>  입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> composePromises = <span class=\"function\">(<span class=\"params\">...ms</span>) =&gt;</span> (  </span><br><span class=\"line\">    ms.reduce(<span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; g(x).then(f))  </span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> label = <span class=\"string\">'Promise composition'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(n + <span class=\"number\">1</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(n * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> h = composePromises(f, g);</span><br><span class=\"line\"></span><br><span class=\"line\">  h(<span class=\"number\">20</span>)  </span><br><span class=\"line\">    .then(trace(label))  </span><br><span class=\"line\">  ;  </span><br><span class=\"line\">  <span class=\"comment\">// Promise composition: 42  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>두 번째 함수  <code>f</code>(  <code>g</code>  다음에 오는)가 받게되는 입력 값은 프라미스입니다. 하지만 <code>f</code>가 원하는 타입은 <code>Promise(b)</code>가 아니라 <code>b</code>였습니다.  무슨 일이 일어난걸까요?</p>\n<p><code>.then()</code>  내부에는  <code>Promise(b) -&gt; b</code>  를 하는 언래핑 프로세스가 있습니다.  이 작업이 바로  <code>join</code>  또는  <code>flatten</code>입니다.</p>\n<p>즉, <code>composeMap()</code>  및  <code>composePromises()</code>가 거의 동일한 함수임을 알 수 있습니다.  이 두 가지를 모두 처리 할 수있는 고차 함수를 만들어 보겠습니다.  chain 메서드를 커링하기 위해 대괄호 표기법을 사용하겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> composeM = <span class=\"function\"><span class=\"params\">method</span> =&gt;</span> (...ms) =&gt; (  </span><br><span class=\"line\">  ms.reduce(<span class=\"function\">(<span class=\"params\">f, g</span>) =&gt;</span> x =&gt; g(x)[method](f))  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>이제 다음과 같은 특수한 구현들을 만들 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> composePromises = composeM(<span class=\"string\">'then'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> composeMap = composeM(<span class=\"string\">'map'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> composeFlatMap = composeM(<span class=\"string\">'flatMap'</span>);</span><br></pre></td></tr></table></figure>\n<h2>모나드의 법칙</h2>\n<p>여러분이 어떤 모나드를 만들기 전에 모든 모나드가 충족시켜야 할 세가지 법칙을 알아보겠습니다.</p>\n<ol>\n<li>Left identity :  <code>unit(x).chain(f) ==== f(x)</code></li>\n<li>Right identity :  <code>m.chain(unit) ==== m</code></li>\n<li>결합법칙<sup>Associativity</sup> :  <code>m.chain(f).chain(g) ==== m.chain(x =&gt; f(x).chain(g))</code></li>\n</ol>\n<h3>Identity laws</h3>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*X_bUJJYudP8MlhN0FLEGKg.png\" alt=\"\"></p>\n<p>Left and right identity</p>\n<p>모나드는 Functor입니다.  Functor는  <code>A -&gt; B</code>라는  카테고리 사이의 사상입니다.  사상은 화살표로 표시됩니다.  객체들 간에 명시적으로 표시된 화살표들 외에도 카테고리의 각 객체에 화살표가 있습니다.  즉, 카테고리의 모든 객체  <code>X</code>  에 대해 화살표  <code>X -&gt; X</code>가  있습니다.  이 화살표는 ID 화살표로 알려져 있으며 일반적으로 객체 자신을 가리키는 작은 원형 화살표로 그려집니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*3jcLj7wdwWaUJ22X2iT7OA.png\" alt=\"\"></p>\n<p>항등 사상</p>\n<h3>결합법칙</h3>\n<p>연산을 할 때 괄호를 어디에 두어도 상관이 없다는 의미입니다.  덧셈의 경우  <code>a + (b + c)</code>는  <code>(a + b) + c</code>와 결과가 같습니다.  함수 합성에 대해서도 마찬가지입니다.  <code>(f ∘ g) ∘ h = f ∘ (g ∘ h)</code>  .</p>\n<p>Kleisli 합성에서도 마찬가지입니다. 대신 거꾸로 읽어야합니다.  합성 연산자( <code>chain</code> )를 보게되면 다음을 떠올리세요.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h(x).chain(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> g(x).chain(f)) ==== (h(x).chain(g)).chain(f)</span><br></pre></td></tr></table></figure>\n<h3>모나드 법칙 증명하기</h3>\n<p>Identity 모나드가 모나드 법칙을 충족시킨다는 것을 증명해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"comment\">// Identity monad  </span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Id = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// Functor mapping  </span></span><br><span class=\"line\">    <span class=\"comment\">// Preserve the wrapping for .map() by   </span></span><br><span class=\"line\">    <span class=\"comment\">// passing the mapped value into the type  </span></span><br><span class=\"line\">    <span class=\"comment\">// lift:  </span></span><br><span class=\"line\">    map: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> Id.of(f(value)),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Monad chaining  </span></span><br><span class=\"line\">    <span class=\"comment\">// Discard one level of wrapping  </span></span><br><span class=\"line\">    <span class=\"comment\">// by omitting the .of() type lift:  </span></span><br><span class=\"line\">    chain: <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f(value),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Just a convenient way to inspect  </span></span><br><span class=\"line\">    <span class=\"comment\">// the values:  </span></span><br><span class=\"line\">    toString: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`Id(<span class=\"subst\">$&#123; value &#125;</span>)`</span>  </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The type lift for this monad is just  </span></span><br><span class=\"line\">  <span class=\"comment\">// a reference to the factory.  </span></span><br><span class=\"line\">  Id.of = Id;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> Id(n + <span class=\"number\">1</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> Id(n * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Left identity  </span></span><br><span class=\"line\">  <span class=\"comment\">// unit(x).chain(f) ==== f(x)  </span></span><br><span class=\"line\">  trace(<span class=\"string\">'Id monad left identity'</span>)([  </span><br><span class=\"line\">    Id(x).chain(f),  </span><br><span class=\"line\">    f(x)  </span><br><span class=\"line\">  ]);  </span><br><span class=\"line\">  <span class=\"comment\">// Id monad left identity: Id(40), Id(40)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Right identity  </span></span><br><span class=\"line\">  <span class=\"comment\">// m.chain(unit) ==== m  </span></span><br><span class=\"line\">  trace(<span class=\"string\">'Id monad right identity'</span>)([  </span><br><span class=\"line\">    Id(x).chain(Id.of),  </span><br><span class=\"line\">    Id(x)  </span><br><span class=\"line\">  ]);  </span><br><span class=\"line\">  <span class=\"comment\">// Id monad right identity: Id(20), Id(20)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Associativity  </span></span><br><span class=\"line\">  <span class=\"comment\">// m.chain(f).chain(g) ====  </span></span><br><span class=\"line\">  <span class=\"comment\">// m.chain(x =&gt; f(x).chain(g)    </span></span><br><span class=\"line\">  trace(<span class=\"string\">'Id monad associativity'</span>)([  </span><br><span class=\"line\">    Id(x).chain(g).chain(f),  </span><br><span class=\"line\">    Id(x).chain(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> g(x).chain(f))  </span><br><span class=\"line\">  ]);  </span><br><span class=\"line\">  <span class=\"comment\">// Id monad associativity: Id(42), Id(42)  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>결론</h2>\n<p>모나드는 타입 리프팅 함수( <code>g: a =&gt; M(b)</code>  ,  <code>f: b =&gt; M(c)</code>  )를 합성하는 방법을 기술한 인터페이스입니다.  이를 위해 모나드는  <code>f()</code>를 적용하기 전  <code>M(b)</code>를  <code>b</code>로  flatten합니다.  즉, funtor는 맵핑할  수 있는 것이며 모나드는 flatten한 뒤 맵핑할 수 있는 것입니다. :</p>\n<ul>\n<li>함수 맵:  <code>a =&gt; b</code></li>\n<li>컨텍스트가 있는 Functor 맵:   <code>Functor(a) =&gt; Functor(b)</code></li>\n<li>컨텍스트와 Flatten을 사용하는 모나드 맵:   <code>Monad(Monad(a)) =&gt; Monad(b)</code></li>\n</ul>\n<p>모나드는 간단한 대칭성을 기반으로합니다. 즉, 값을 컨텍스트로 래핑하는 방법과 컨텍스트에서 래핑을 해제하는 방법입니다.</p>\n<ul>\n<li>Lift / Unit : 어떤 값을 모나드 컨텍스트로 타입 리프트 :  <code>a =&gt; M(a)</code></li>\n<li>Flatten / Join : 컨텍스트에서 값을 언래핑 :  <code>M(a) =&gt; a</code></li>\n</ul>\n<p>그리고 모나드는 Functor이기 때문에 다음과 같이 맵핑 할 수도 있습니다.</p>\n<ul>\n<li>Map : 컨텍스트가 유지되는 맵핑 :  <code>M(a) -&gt; M(b)</code></li>\n</ul>\n<p>Flatten과 map을 결합하면 리프팅 함수들을 합성하기위한 chain, 일명 Kleisli 합성을 만들 수 있습니다.</p>\n<ul>\n<li>FlatMap / Chain : Flatten + map :  <code>M(M(a)) =&gt; M(b)</code></li>\n</ul>\n<p>모나드는 3 개의 법칙(공리)을 만족해야하며 이는 모나드 법칙으로 불립니다.</p>\n<ul>\n<li>Left identity :  <code>unit(x).chain(f) ==== f(x)</code></li>\n<li>Right identity :  <code>m.chain(unit) ==== m</code></li>\n<li>결합법칙 :  <code>m.chain(f).chain(g) ==== m.chain(x =&gt; f(x).chain(g)</code></li>\n</ul>\n<p>프라미스, 옵저버블 등 여러분은 매일매일 JavaScript에서 모나드를 사용하고 있습니다.  Kleisli 합성을 사용하면 데이터 타입 API의 세부 사항을 신경쓰지 않고 데이터가 흘러가는 로직을 만들 수 있습니다.</p>\n<p>따라서 모나드는 코드를 단순화하는 매우 강력한 도구입니다.  모나드를 사용하기 위해 내부에서 무슨 일이 벌어지고 있는지 이해하거나 걱정할 필요는 없습니다. 다만, 이제는 모나드에 대해 더 많이 알게었고, 그 속에서 무슨일이 일어나는지 더이상 두려워하지 않게 되었습니다.</p>\n<p>레이디 모나드린의 저주를 두려워 할 필요가 없습니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/\"><strong>다음: Mocking은 코드 냄새(Code Smell)입니다 &gt;</strong></a></p>\n"},{"title":"Mocking은 코드 냄새(Code Smell)입니다","catalog":true,"date":"2018-04-19T18:54:56.000Z","subtitle":"Mocking is a Code Smell","header-img":"bg.jpg","readingTime":24,"catagories":["개발"],"preview":"코드 냄새란 일반적으로 시스템의 더 깊은 문제에 해당하에 깊숙히 숨어있는 문제를 드러내는 표면적인 표시입니다. Martin Fowler.  TDD와 유닛 테스트를 할 때 가장 손이 많이 가는 부분은 테스트할 유닛을 분리하는 과정에서 필요한 mocking을 만드는 일 입니다. 몇몇 사람들은 유닛 테스트가 정말로 의미있는 일인지 의심스러워 하기도 합니다.  실제로, 저는 개발자들이 mock, fake, stub을 만들다 길을 잃고  실제 코드가 전혀 실행되지 않는  유닛 테스트를 작성하는걸 보았습니다. 아이고.","_content":"\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/)\n\nTDD와 유닛 테스트를 할 때 가장 손이 많이 가는 부분은 테스트할 유닛을 분리하는 과정에서 필요한 **mocking**을 만드는 일 입니다. 몇몇 사람들은 유닛 테스트가 정말로 의미있는 일인지 의심스러워 하기도 합니다.  실제로, 저는 개발자들이 mock, fake, stub을 만들다 길을 잃고  _실제 코드가 전혀 실행되지 않는_  유닛 테스트를 작성하는걸 보았습니다. 아이고..\n\n다른 한편으로는 개발자가 TDD에 스스로를 너무 옭아매는 모습이 자주 보입니다. 이 경우 개발자는 코드베이스를 더 복잡하게 만들어버릴지라도 무조건 100% 코드 커버리지를 달성해야 한다고 생각합니다. \n\n저는 mocking에서 코드 냄새를 맡으라고  말합니다. 그러나 대부분의 개발자들은 100% 유닛 테스트 커버리지를 달성할 수 있다는 TDD 신봉자 단계를 거치게 되며 이 기간 동안에는 대규모의 모의 객체를 사용하지 않는 세상을 상상할 수 없습니다.  모의 객체^mocks^를 응용 프로그램에 집어 넣기 위해 의존성 주입^dependency^ ^injection^ (DI)함수로 자신의 코드유닛을 감싸거나 더 안좋은 경우, 서비스를 의존성 주입 컨테이너로 만들어버리기도 합니다.\n\nAngular는 모든 컴포넌트 클래스에 의존성을 주입하며 DI를 기본적인 디커플링 수단으로 사용하도록 유혹합니다.  하지만 의존성 주입이 디커플링을 수행하는 가장 좋은 방법은 아닙니다.\n\n## TDD는 더 나은 디자인으로 이어질 때 그 의미가 있습니다.\n\n> 제대로된 TDD를 배운다는 것은 제대로 앱을 모듈화시키는 법을 배우는 것과 같습니다.\n\nTDD는 코드를 복잡하게 만드는것이 아닌 단순하게 만들어야 합니다. 코드를 더 잘 테스트 할 수 있게 고치는 댓가로 가독성과 유지보수성을 내주어선 안됩니다.  DI 보일러 플레이트로 코드를 부풀리고 있다면 잘못된 TDD를 하고있는 겁니다.\n\n온 세상을 mocking할 수 있다는 환상을가지고 앱에 의존성을 주입하고 있다면 그것이 도움이 되기 보다는 해가 될 가능성이 매우 높습니다.  테스트 가능한 코드를 작성하는 과정에서 코드가 단순해져야 합니다.  우리에게 필요한 것은 적은 수의 코드 라인과 보다 읽기 쉽고 유연하며 유지 보수가 가능한 구조입니다.  의존성 주입은 반대 효과를냅니다.\n\n제가 말하고 싶은 것은 이 두 가지 입니다.\n\n1.  의존성 주입 없이도 디커플링된 코드를 작성할 수 있습니다.\n2.  코드 커버리지를 최대화하려는 시도는 좋지 않습니다. 100%에 다가갈수록 애플리케이션 코드는 복잡해지고 결국 버그를 줄인다는 목표를 뒤엎고 말게 됩니다.\n\n 복잡한 코드에는 종종 자질구레한 코드들도 함께 있습니다. 잘 정돈된 코드를 작성하는 것은 집을 깔끔하게 유지하려는 것과 같은 이유입니다.\n\n-  코드가 어수선해지면 버그가 숨을 수 있는 편리한 장소가 생기고 더 많은 버그가 발생합니다.\n-   뭔가를 찾기 위해서는 우선 정돈된 환경이 필요합니다.\n\n\n## 코드 냄새^Code^ ^smell^란 무엇입니까?\n\n> _\"코드 냄새란 일반적으로 시스템 깊숙히 숨어있는 문제를 드러내는 표면적인 표시입니다.\"~ Martin Fowler_\n\n> **코드 스멜**(code smell←코드 냄새)은 컴퓨터 프로그래밍 코드에서 더 심오한 문제를 일으킬 가능성이 있는 프로그램 소스 코드의 증상을 가리킨다.  ~ Wikipedia\n\n나쁜 코드 냄새를 맡았다고 해서 곧바로 뭔가 잘못 되었고 이를 고쳐야 한다는 것을 의미하진 않습니다.  코드 냄새란 당신에게 뭔가를 향상시킬 수있는 기회를 알려주는 _경험 법칙_ 입니다.\n\n이 글은 모든 mocking이 나쁘다는 것을 의미하지 않으며 mocking을 절대 하면 안된다고 말하는게 아닙니다.\n\n코드의 유형에 따라 다양한 수준 (및 다른 종류)의 mocking이 필요합니다. I/O를 다루는 코드는 I/O 를 테스트하는 것 이외에 다른 방법은 거의 없습니다. 이 경우 모의 테스트를 줄이면 유닛 테스트 커버리지가 0%에 가까워 질 수 있습니다.\n\n로직이 없는 코드는(파이프와 순수 함수들로만 이루어진) 유닛 테스트 커버리지가 0%가 되어도 괜찮습니다. 대신 통합 또는 기능 테스트 커버리지가 100 %에 가까워질 것입니다.  그러나 로직(조건식, 변수 할당, 메소드 호출 등)이 있다면 유닛 테스트 커버리지가 필요하며, 이 때 코드를 단순화하고 mocking 요구사항을 줄이는 목표를 세울 수 있습니다.\n\n## Mock(모의)란 무엇입니까?\n\nMock이란 유닛 테스트에서 실제 구현 코드를 대신하는 **테스트 더블**^[test double, 여기서 double이란 스턴드 대역 배우(stunt double)와 같은 대역이란 뜻입니다.]입니다.  모의 객체는 테스트가 진행되는 동안 테스트 코드에 의해 조작, 변경되고 이를 assert 구문으로 확인합니다. Assert 구문에 테스트 더블이 쓰인다면 이는 모의입니다.\n\n\"모의(mock)\"라는 용어는 여러 종류의 테스트 더블을 포괄하는 일반적인 용어입니다. 앞으로의 논의에서 우리는 \"모의(mock)\"와 \"테스트 더블(test double)\"이라는 단어를 동등하게, 상호 교환적으로 사용하겠습니다.  모든 테스트 더블 (dummies, spies, fake 등)은 테스트 대상과 단단하게 결합된 실제 코드를 나타냅니다. 따라서 테스트 더블은 일종의 커플링이 있다는 것을 뜻하며, 구현을 단순화하고 향상시킬 수 있다는 의미입니다. 그리고 모의 객체가 필요하지 않도록 코드를 바꾸는 것은 테스트를 근본적으로 단순화시키는 방법입니다.\n\n## 유닛 테스트란 무엇입니까?\n\n**유닛 테스트**는 개별 유닛(모듈, 함수, 클래스)을 나머지 프로그램과 분리하여 테스트하는 행위입니다,\n\n유닛 테스트와 달리 **통합 테스트**^Integration^ ^test^란 두 개 이상의 유닛 간의 통합을 테스트하는 것입니다.   **기능 테스트**^Functional^ ^test^란 사용자의 관점에서 애플리케이션을 테스트하는 것 입니다.  사용자 워크 플로 테스트는 UI 조작에서 데이터 레이어가 업데이트되고 그것들이 다시 화면에 출력되는 과정을 모두 관찰합니다.  기능 테스트는 앱이 실행되는 맥락에서 모든 장치와 유닛을 테스트하기 때문에 통합 테스트의 하위 집합이라고 볼 수 있습니다.\n\n일반적으로 유닛은 유닛의 공용 인터페이스 (일명 \"퍼블릭 API\"또는 \"surface area\") 만 사용하여 테스트됩니다.  이것을 **블랙 박스 테스트**라고합니다.  블랙 박스 테스팅은 고장나기 쉬운 테스트입니다.  왜냐하면 시간이 지남에 따라 퍼블릭 API는 그대로인데 유닛의 구현 세부 사항이 변경되기 때문입니다. 내부 구현 방식까지 다루는 화이트 박스 테스트는 더더욱 고장나기 쉬운데, 퍼블릭 API가 예상대로 계속 작동하더라도 구현 세부 사항을 변경하면 테스트가 중단 될 수 있기 때문입니다.  즉, 화이트 박스 테스트에는 훨씬 많은 시간과 노력이 들어갑니다.\n\n## 테스트 커버리지^[테스트 적용 범위]란 무엇입니까?\n\n코드 커버리지란 테스트 케이스가 다루는 코드의 양을 의미합니다.  테스트 도중 어떤 코드의 행이 사용되었는지 기록하여 커버리지 리포트를 작성합니다. 일반적으로 우리는 커버리지를 높이려고 노력하지만 100 %에 가까워 질수록 테스트 효율이 감소하기 시작합니다.\n\n경험에 비추어 볼 때, 90%가 넘는 커버리지는 남은 버그들을 없애는데 거의 상관 관계가없는 것 같습니다.\n\n왜 그럴까요?  100% 테스트 된 코드란 코드가 의도 한대로 작동한다는 것을 100% 확신시켜주는 의미 아닙니까?\n\n이 문제는 그리 간단하지 않습니다.\n\n대부분의 사람들은 두 가지 종류의 커버리지가 있다는 것을 모릅니다.\n\n1.  **코드 커버리지** : 코드가 실행되는 정도\n2.  **케이스 커버리지** :  테스트 스위트가 커버하는 유스 케이스의 수\n\n케이스 커버리지는 유스 케이스 시나리오를 다룹니다 : 코드가 실제 환경, 실제 네트워크에서 어떻게 작동할 것인가? 악의적인 목적으로, 소프트웨어 설계를 의도적으로 파괴하려는 해커한테 어떻게 작동 할 것인가?\n\n커버리지 리포트는 케이스 커버리지가 아닌 코드 커버리지의 부족한 점을 알려줍니다.  그러나 동일한 코드가 둘 이상의 유스 케이스에 적용될 수 있을 뿐더러 단일 유즈 케이스가 테스트 대상 외부에 있는 코드, 별도의 애플리케이션 또는 서드파티 API에 의존 할 수도 있습니다.\n\n유스 케이스는 환경, 여러 단위, 사용자 및 네트워킹 조건을 포함 할 수 있으므로 필요한 모든 유스 케이스를 유닛 테스트들 밖에 없는 테스트 스위트로 처리하는 것은 불가능합니다.  유닛 테스트는 통합되지 않은, 격리 된 테스트 단위를 의미하므로 유닛 테스트로만 이루어진 테스트 스위트는 항상 통합 및 기능 유스  케이스 시나리오에 대해 거의 0%의 커버리지를 달성하게 될 것입니다.\n\n100% 코드 커버리지는 100% 케이스 커버리지를 보장하지 않습니다.\n\n100% 코드 커버리지를 목표로 하는 개발자는 잘못된 목표를 쫓고 있습니다.\n\n## 단단한 결합(Tight Coupling)이란 무엇입니까?\n\n모의 객체가 필요하다는 것은 유닛 테스트를 위해 유닛을 분리해야 하며 이 때 유닛간의 결합이 있기 때문입니다.  긴밀한 결합은 코드를보다 단단하고 부서지기 쉽게 만듭니다. 코드가 변경되었을 때 프로그램이 멈추게 됩니다.  일반적으로 느슨한 결합은 코드를 확장하고 유지하기 쉽게 만듭니다. 여기에 더해 mocking에 대한 필요성을 없앰으로써 테스트를 더 쉽게한다는 사실은 두말할 필요도 없습니다.\n\n이것으로부터 우리가 뭔가를 mocking 하고있다면 그 대신에 유닛간의 결합을 줄임으로써 코드를보다 유연하게 만들 수 있는 가능성이 존재한다는 것을 추론 할 수 있습니다.  그리하면 더 이상 가짜 코드들이 필요하지 않습니다.\n\n커플링(또는 결합)이란 코드 유닛(모듈, 함수, 클래스 등)이 다른 코드 유닛에 종속되는 정도입니다.  밀접한 결합 또는 높은 결합도는 종속된 코드들이 변경 될 때 유닛이 망가질 가능성을 나타냅니다.  즉, 커플링이 빡빡할수록 응용 프로그램을 유지 관리하거나 확장하는 것이 어렵습니다.  느슨한 결합은 버그를 수정하고 응용 프로그램을 새로운 유스 케이스로 확장 할 때 마주치는 복잡성을 줄입니다.\n\n커플링에는 여러 형태가 있습니다.\n\n-   **하위 클래스 커플링 :**  하위 클래스는 상위 클래스의 구현 및 전체 계층 구조에 의존합니다. OO 디자인에서 사용할 수있는 가장 단단한 형태의 결합입니다.\n-   **의존 코드 제어 :**  전달받은 메소드 이름으로 수행 할 작업을 지시하는 것처럼 종속된 유닛들을 제어하는 ​​코드.  API가 변경되면 종속된 코드가 중단됩니다.\n-   **변경 가능한 상태 :**  다른 코드와 변경 가능한 상태를 공유하는 코드. (e.g.공유된 객체의 속성을 변경하는 일)  코드가 실행되는 상대적인 타이밍이 바뀔 경우 종속 코드가 손상 될 수 있습니다.  타이밍이 비 결정적이라면, 모든 종속 유닛을 완전히 뜯어보지 않는 이상 프로그램 정확성을 달성하는 것이 불가능할 수 있습니다. 예를 들어, 해결 불가능한 레이스 컨디션이 있을 수 있습니다.  한 버그를 수정하면 다른 종속 유닛에 새로운 버그가 나타날 수 있습니다.\n-   **형태적 종속성 :**  다른 코드와 특정 데이터 구조를 공유하며 구조의 일부분만 사용하는 코드입니다.  구조적인의 형태가 변경되면 종속 코드가 손상 될 수 있습니다.\n-   **이벤트 / 메시지 커플링 :**  메시지 전달, 이벤트 등을 통해 다른 유닛과 통신하는 코드.\n\n## 무엇이 단단한 결합을 만드는가?\n\n단단한 결합에는 많은 원인이 있습니다.\n\n-   **변이**  vs  _불변성_\n-   **부수효과**  vs  _순수함 /부수효과를 분리_\n-   **책임 과부하**  vs  _Do One Thing (DOT)_\n-   **절차를 기술**  vs  _구조를 기술_\n-   **명령형 구성**  vs  _선언적인 구성_\n\n명령형 및 객체 지향 코드는 함수형 코드보다 단단하게 결합되기 쉽습니다.  그러나  함수형 스타일로 프로그래밍한다고 해서 단단한 결합에 무적이 되진 않습니다. 다만 함수형 프로그래밍은 프로그램의 기본 구성 단위로 순수 함수를 사용하며 이는  본질적으로 느슨한 결합들을 형성합니다.\n\n순수 함수 :\n\n-   동일한 입력이 주어지면 항상 동일한 출력을 반환\n-   부수효과 없음\n\n순수 함수는 어떻게 결합도를 낮출까요?\n\n-   **Immutability :**  순수 함수는 기존 값을 변경하지 않습니다.  대신 새로운 값을 반환합니다.\n-   **No side effects :**  순수 함수가 유일하게 표현하는 것은 리턴 값입니다. 따라서 화면, DOM, 콘솔, 표준 입출력, 네트워크, 디스크 입출력 등과 같은 외부 상태와 연관있는 다른 함수의 조작을 방해할 가능성이 없습니다. \n-   **Do One Thing :**  순수 함수는 단일 임무를 수행합니다. 입력과 출력을 맵핑하는 임무입니다.  객체 및 클래스 기반 코드는 몇줄 안되는 코드에게 과한 책임을 지우는 경향이 있습니다. 책임 과부하를 피하십시오.\n-   **Structure, not instructions :**  순수 함수는 안전하게 메모이제이션 할 수 있습니다. 즉, 시스템 메모리가 무한하다고 가정할 때  함수 입력을 인덱스로 사용하여 테이블에서 해당 값을 검색하는 조회 테이블로 바꿀 수 있습니다.  다시 말해 순수 함수는 컴퓨터에게 내리는 명령이 아닌 데이터 간의 구조적 관계를 설명하므로 서로 충돌하는 두 가지 명령이 서로의 발가락을 밟고 문제를 일으킬 수 없습니다.\n\n## 합성은 mocking과 무슨 관계가 있습니까?\n\n **Everything**.  소프트웨어 개발의 본질은 큰 문제를 작고 독립적인 조각으로 분해하고 작은 솔루션들을 합쳐 큰 문제를 해결하는 과정입니다.\n\n> 문제를 분해하는 전략이 실패했을 때 mocking이 필요해집니다.\n\n큰 문제를 작은 부분으로 나누는 데 사용되는 조그만  유닛이 서로 의존 할 때 mocking이 필요합니다.  다시 말하자면  _우리가 생각한  원자 단위가 실제로 원자가 아니며,_  우리의 분해 전략이 큰 문제를 더 작고 독립적인 문제로 분해하지 못했을 때 필요합니다.\n\n문제를 성공적으로 분해했다면 일반적인 합성 유틸리티들을 사용해 솔루션 조각들을 다시 합칠 수 있습니다.  예 :\n\n-   **함수 합성**  e.g.,  `lodash/fp/compose`\n-   **컴포넌트 합성**  e.g., 함수 합성으로 고차 컴포넌트 작성\n-   **상태 저장소/모델 합성**  e.g.,  [Redux combineReducers](http://redux.js.org/docs/api/combineReducers.html)\n-   **객체 또는 팩토리 합성** e.g. 객체 믹스인 또는 함수형 믹스인\n-   **프로세스 합성**  e.g. 트랜스듀서^transducer^ ^[   [Understanding Transducers in JavaScript](https://medium.com/@roman01la/understanding-transducers-in-javascript-3500d3bd9624)를 참고 ]\n-   **프로미스 또는 모나드 합성**  e.g., `asyncPipe()`  또는  `composeM()`,  `composeK()` Kleisli 합성 \n-   기타..\n\n이러한 유틸리티들을 사용하는 경우 합성의 재료가 되는 각 요소들은 다른 요소를  _mocking하지 않고도_  격리 된 유닛 테스트를 수행 할 수 있습니다  _._\n\n합성 자체는 완벽하게 선언적이므로  _유닛 테스트_ 가 필요한 로직이 없습니다. (그리고 이런 합성 유틸리티는 자체적인 유닛 테스트가 있는 서드파티 라이브러리입니다).\n\n이러한 상황에서 유닛 테스트를 하는 건 아무런 의미가 없습니다.  대신 통합 테스트가 필요합니다.\n\n익숙한 예제를 가지고 명령적^Imperative^ 합성과 선언적^Declarative^ 합성을 비교해 보겠습니다.\n\n```javascript\n// Function composition OR  \n// import pipe from 'lodash/fp/flow';  \nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\n\n// Functions to compose  \nconst g = n => n + 1;  \nconst f = n => n * 2;\n\n// Imperative composition  \nconst doStuffBadly = x => {  \n  const afterG = g(x);  \n  const afterF = f(afterG);  \n  return afterF;  \n};\n\n// Declarative composition  \nconst doStuffBetter = pipe(g, f);\n\nconsole.log(  \n  doStuffBadly(20), // 42  \n  doStuffBetter(20) // 42  \n);\n```\n\n함수 합성은 함수의 반환 값에 다른 함수를 적용하는 프로세스입니다.  즉, 함수의 파이프 라인을 만든 다음 입력 값을 파이프 라인에 전달하면 물건이 공장 조립 라인을 통과하듯 값이 개별 함수들을 거쳐가며 변환됩니다.  결국, 파이프 라인의 마지막 함수는 최종 값을 반환합니다.\n\n```\ninitialValue -> [g] -> [f] -> result\n```\n\n이는 패러다임과 무관하게 모든 주류 언어들이 애플리케이션 코드를 구성하는 주요 수단입니다.  자바조차도 클래스 인스턴스간 메세지를 전달하는 기본 메커니즘으로 함수 (메소드)를 사용합니다.\n\n함수를 수동으로(명령형으로) 합성하거나 자동으로(선언적으로) 합성할 수 있습니다. 함수가 퍼스트 클래스가 아닌 언어에서는 선택권이 많지 않습니다. 명령형으로 할 수 밖에 없습니다.  자바 스크립트 (그리고 거의 모든 주요 대중 언어)에서는 선언적으로 합성할 수 있습니다.\n\n명령형이란 컴퓨터에게 단계적으로 뭔가를 수행하도록 명령한다는 의미입니다. How-To 가이드입니다.  위의 예에서 명령형 스타일은 다음과 같습니다.\n\n1.  인수를 취하여  `x` 를 대입하십시오.\n2.  `afterG`  라는 바인딩을 선언하고 `g(x)` 의 결과를 할당하십시오.\n3.  `afterF`  라는 바인딩을 선언하고  `f(afterG)`  의 결과를 할당합니다.\n4.  `afterF`  의 값을 리턴합니다.\n\n명령형 버전에는 테스트해야 할 로직들이 있습니다.  비록 단순한 과제일지라도 잘못된 변수를 전달하거나 리턴하는 곳에서 버그가 발생하는 것을 자주 보았습니다.\n\n선언적 스타일은 우리가 사물 간의 관계를 컴퓨터에 알리는 것을 의미합니다. 그것은 등식을 사용해서 구조에 대해 설명하는 것 입니다.  선언적 스타일은 다음과 같습니다 :\n\n-   `doStuffBetter` 는  `g` 와  `f` 의 파이프 컴포지션입니다.\n\n이게 전부입니다.\n\n`f`와  `g`에 대한 유닛 테스트가 존재하고  `pipe()`가 자체 유닛 테스트 (Ramda의  `pipe()`  또는 Lodash의 `flow()` 를 사용)를 사용한다고 가정하면 더이상 유닛 테스트를 해야될 로직이 없습니다.\n\n이 스타일이 올바르게 작동하려면 유닛들이  _분리_ 되어야 합니다.\n\n## 커플링을 제거하려면 어떻게 해야합니까?\n\n커플링을 제거하려면 먼저 종속성이 어디서 발생하며 그 형태가 어떤지 알아야 합니다. 다음은 중요한 예들입니다. 그 순서는 대략적으로 커플링의 긴밀한 정도입니다.\n\n단단한 결합 :\n\n-   클래스 상속 (상속 계층이 증가할 때마다, 각 자손 클래스가 많아질 때 마다 결합도는 배가 됩니다)\n-   전역 변수\n-   변경 가능한 전역 상태 (브라우저 DOM, 공유 저장소, 네트워크 등)\n-   부수효과가 있는 모듈 가져오기\n-   합성 과정에 숨어든 암시적인 종속성  e.g., `const enhancedWidgetFactory = compose(eventEmitter, widgetFactory, enhancements);`  `widgetFactory`는 `eventEmitter`에게 의존합니다.\n-   의존성 주입 컨테이너\n-   의존성 주입 파라미터\n-   컨트롤 파라미터 (외부 유닛이 해당 유닛의행동을 지시하고 통제하는 것)\n-   변경 가능한 매개 변수\n\n느슨한 결합:\n\n-   부수효과가 없는 모듈 가져오기 (블랙 박스 테스트를 할 때 import된 모든 모듈을 분리할 필요는 없음)\n-   메시지 전달 / pubsub\n-   변경 불가능한 매개 변수 \n\n아이러니하게도, 커플링을 발생시키는 원인의 대부분은 원래 커플링을 줄이기 위해 설계된 메커니즘들입니다. 왜냐하면 문제를 풀기 위한 작은 솔루션들을 완전한 애플리케이션으로 재구성하기 위해 어떻게든 이들을 통합하고 연결해야 했기 때문입니다.  좋은 방법과 나쁜 방법이 있을 뿐입니다.  단단한 커플링을 유발하는 원인들이 실제로 그렇게 되는 경우에는 피해야 합니다.  느슨한 커플링 옵션은 일반적으로 건강한 앱을 만드는 바람직한 방법입니다.\n\n많은 책과 블로그 포스트에서 의존성 주입 컨테이너와 매개 변수를 \"느슨한 결합\"으로 분류합니다. 왜 이들이 \"단단한 커플링\" 그룹에 속하는지 혼란스러울 수 있습니다.  커플링은 바이너리가 아닙니다.  그라디언트 스케일입니다.  즉, 어떤 그룹에든 다소 주관적이고 임의적으로 속할 수 있습니다.\n\n따라서 제가 간단하고 객관적인 리트머스 테스트를 준비했습니다.\n\n의존성을 mocking하지 않고 유닛을 테스트 할 수 있습니까?  그렇게 할 수 없다면 mocking은 의존성과  _밀접하게 결합_  되어 있는 것입니다.\n\n유닛의 종속성이 높을수록 문제가 되는 커플링이 발생할 가능성이 커집니다. 커플링이 어디서 발생하는지 이해했습니다. 이제 어떻게 해야 하는지 알아보겠습니다.\n\n1.  클래스, 명령형 프로시저 또는 무언가를 변경하는 함수 대신 **순수 함수**를 프로그램의 원자 단위로 사용하십시오.\n2.  프로그램 로직과  **부수효과**를  **격리**하십시오.  즉, I/O (네트워크, 디스크 I/O, UI 렌더링, 로깅 등)와 로직을 섞지 마십시오.\n3.  독립적인 구성 요소에서  **종속성을 만드는 로직**을  **제거**하여 유닛 테스트가 필요없는 선언적 구성이 될 수 있도록 하십시오.  로직이 없다면 단위 테스트에 아무런 의미가 없습니다.\n\n즉, 네트워크 요청을 설정하고 핸들러를 요청하는 코드는 유닛 테스트가 필요하지 않습니다. 대신 통합 테스트를 하십시오.\n\n> _I/O를 유닛 테스트 하지 마십시오._ \n\n> _I/O는 통합을 위한 것입니다._  _통합 테스트를 하십시오._\n\n통합 테스트를 위해 mocking하고 가짜를 만드는 것은 전혀 문제되지 않습니다.\n\n## 순수 함수 사용\n\n순수 함수를 사용하기 위해선 약간의 연습이 필요하며, 그러한 연습 없이는 원하는 작업을 수행하기 위해 코드를 작성하는 방법이 명확하지 않을 수 있습니다. 순수 함수는 전역 변수, 전달 된 인수, 네트워크, 디스크 또는 화면을 직접 변경할 수 없습니다. 오로지 값을 반환하는 일만 할 수 있습니다.\n\n순수 함수가 배열이나 객체를 전달받아 해당 객체의 변경된 버전을 반환는 경우 객체를 변경하고 리턴할 수 없습니다. 객체의 새 사본을 만들어 변경사항을 적용하고 리턴해야 합니다. 배열  [접근 메소드](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype)  (변경 메소드가 아님),  `Object.assign()`, 빈 객체를 생성, 배열 또는 객체 스프레드 구문을 사용하여 이를 수행 할 수 있습니다.  예 :\n\n```javascript\n// Not pure  \nconst signInUser = user => user.isSignedIn = true;\n\nconst foo = {  \n  name: 'Foo',  \n  isSignedIn: false  \n};\n\n// Foo was mutated  \nconsole.log(  \n  signInUser(foo), // true  \n  foo              // { name: \"Foo\", isSignedIn: true }  \n);\n```\n\nvs...\n\n```javascript\n// Pure  \nconst signInUser = user => ({...user, isSignedIn: true });\n\nconst foo = {  \n  name: 'Foo',  \n  isSignedIn: false  \n};\n\n// Foo was not mutated  \nconsole.log(  \n  signInUser(foo), // { name: \"Foo\", isSignedIn: true }  \n  foo              // { name: \"Foo\", isSignedIn: false }  \n);\n```\n\n또는 [Mori](http://swannodette.github.io/mori/),  [Immutable.js](https://facebook.github.io/immutable-js/)와 같은 불변 데이터 타입 라이브러리를 사용하는 방법도 있습니다.  언젠가 JavaScript가 Clojure와 비슷한 불변 데이터 타입을 지원해주기를 바라고 있습니다. \n\n기존 객체를 재사용하는 대신 새 객체를 생성하기 때문에 성능이 저하될 수 있다고 생각할 수도 있지만, 여기엔 사실 좋은 부수효과 있습니다. 객체의 변경여부를 항등연산자로 (  `===`  ) 확인할 수 있습니다. 즉, 우리는 하나라도 변경된 것을 발견하기 위해 객체 내부를 구석구석 확인하지 않아도 됩니다. \n\n이 방법을 사용하면 복잡한 상태 트리가 있는 React 구성 요소를 더 빨리 렌더링할 수 있습니다. 각 렌더 패스 별로 심도있게 순회할 필요가 없어지기 때문입니다. `PureComponent`를 상속하여 얕은 `prop` 및 `state` 비교로  `shouldComponentUpdate()`를 구현할 수 있게됩니다.  객체의 주소가 변경되지 않았음을 탐지하면 상태 트리의 해당 부분에서 아무 것도 변하지 않았으며 트리를 모두 순회하지 않고도 계속 진행하면 된다는 것을 알 수 있습니다.\n\n순수 함수는 메모이제이션 할 수 있습니다. 이전에 동일한 입력을 처리한적이 있다면 전체 객체를 다시 만들 필요가 없습니다. 미리 계산 된 값을 테이블에 저장하는 방식으로 계산 복잡도를 메모리와 교환할 수 있습니다. 많은 메모리가 필요하지 않고 계산적으로 비싼 프로세스의 경우, 이는 훌륭한 최적화 전략이 될 수 있습니다.\n\n순수 함수는 또한 부수효과가 없기 때문에 **분할-정복** 전략을 사용하여 분산처리시스템에게 계산을 맡기는 것이 안전합니다.  이 전략은 원래 그래픽 용으로 설계된  GPU를 사용하여 이미지, 비디오 또는 오디오 프레임을 처리하는 데 주로 사용되지만 시뮬레이션, 과학실험 컴퓨팅과 같은 다른 용도로 많이 사용됩니다.\n\n다시 말해, 값을 변경하는 방식이 항상 빠르지는 않으며 매크로 최적화를 희생하여 마이크로 최적화를 수행하기 때문에 더 느린 경우가 많습니다.\n\n## 프로그램의 주요 로직과 부수효과를 분리\n\n부수효과와 나머지 프로그램 로직을 분리하는데 도움이 되는 몇 가지 전략이 있습니다.  다음은 그 중 일부입니다.\n\n1.  pub/sub 패턴을 사용하여 뷰와 프로그램 로직에서 I/O를 분리하십시오.  UI 뷰와 프로그램 로직에서 부수효과를 발생시키는 코드를 직접 호출하는 대신 이벤트 또는 액션 객체를 보내 통신하는게 좋습니다.\n2.  I/O에서 로직을 분리하십시오. e.g.,  `asyncPipe()`를 사용해 프로미스를 리턴하는 함수를 합성\n3.  I/O 코드에서 직접 계산 하지 않고 지연된 계산을 표현하는 객체를 사용하십시오. e.g.,  [redux-saga](https://github.com/redux-saga/redux-saga)의  `call()`  은 실제로 함수를 호출하지 않습니다.  대신, 함수와 인수에 대한 레퍼런스가 담긴 객체를 반환하며, saga 미들웨어가 이를 호출합니다.  따라서  `call()`과 그것을 사용하는 모든 함수가  _순수 함수가되고_, 쉽게 유닛 테스트를 만들 수 있으며  _mocking이 필요하지 않습니다._\n\n### pub / sub 사용\n\nPub/sub은 게시^Publish^/구독^Subscribe^ 패턴의 약자입니다.  이 패턴에서 유닛은 서로 직접 호출하지 않습니다.  대신, 다른 유닛(구독자)가 들을 수있는 메시지를 게시합니다.  게시자는 어떤 유닛이 자신을 구독할지 알지 못하며 구독자는 게시자가 게시할 내용을 알지 못합니다.\n\nPub/sub의 좋은 예로 DOM(Document Object Model)이 있습니다.  애플리케이션의 모든 컴포넌트는 마우스 이동, 클릭, 스크롤 이벤트, 키 입력 등과 같이 DOM 요소에서 전달 된 이벤트를 수신 할 수 있습니다.  모든 사람들이 jQuery로 웹 애플리케이션을 만들던 시절, jQuery의 커스텀 이벤트는 DOM을 pub/sub 이벤트 버스로 사용하여 렌더링과 로직을 분리했습니다.\n\nPub/sub는 또한 Redux에서 볼 수 있습니다.  Redux에서는 애플리케이션 상태에 대한 전역 모델(저장소라고 함)을 만듭니다. 직접 모델을 조작하는 대신 뷰 및 I/O 핸들러는 액션 객체를 저장소에 보냅니다(dispatch라고 표현합니다).  액션 객체가 가지고 있는 `type`이라는 특별한 키를 다양한 reducers들이 듣고 응답할 수 있습니다. 또한 Redux는 특정 액션 타입을 수신하고 응답 할 수있는 미들웨어를 지원합니다.  이렇게하면 뷰에서 애플리케이션 상태가 처리되는 방법을 알 필요가 없으며 상태 로직이 뷰에 대해 알 필요가 없습니다.\n\n덕분에 디스패처를 간단하게 수정하는 것 만으로 미들웨어를 통해 액션 로깅/분석, 저장소 또는 서버와의 상태 동기화, 서버 및 네트워크 피어와의 실시간 통신 기능 패치와 같은 복잡한 문제들을 다룰 수 있습니다.\n\n### I/O와 로직을 분리\n\n모나드(e.g., 프로미스) 합성을 ​​사용해 프로그램의 의존 로직을 제거할 수 있습니다. 예를 들어 다음 함수의 로직은 모든 비동기 함수를 mocking하지 않고서는 유닛 테스트를 할 수 없게 설계되어있습니다.\n\n```javascript\nasync function uploadFiles({user, folder, files}) {  \n  const dbUser = await readUser(user);  \n  const folderInfo = await getFolderInfo(folder);  \n  if (await haveWriteAccess({dbUser, folderInfo})) {  \n    return uploadToFolder({dbUser, folderInfo, files });  \n  } else {  \n    throw new Error(\"No write access to that folder\");  \n  }  \n}\n```\n\n이를 실행할 수 있도록 도와주는 의사 코드를 작성해 보겠습니다.\n\n```javascript\nconst log = (...args) => console.log(...args);\n\n// Ignore these. In your real code you'd import  \n// the real things.  \nconst readUser = () => Promise.resolve(true);  \nconst getFolderInfo = () => Promise.resolve(true);  \nconst haveWriteAccess = () => Promise.resolve(true);  \nconst uploadToFolder = () => Promise.resolve('Success!');\n\n// gibberish starting variables  \nconst user = '123';  \nconst folder = '456';  \nconst files = ['a', 'b', 'c'];\n\nasync function uploadFiles({user, folder, files}) {  \n  const dbUser = await readUser({ user });  \n  const folderInfo = await getFolderInfo({ folder });  \n  if (await haveWriteAccess({dbUser, folderInfo})) {  \n    return uploadToFolder({dbUser, folderInfo, files });  \n  } else {  \n    throw new Error(\"No write access to that folder\");  \n  }  \n}\n\nuploadFiles({user, folder, files})  \n  .then(log)  \n;\n```\n\n`asyncPipe()`로 프로미스를 합성할 수 있도록 리팩터링합니다.\n\n```javascript\nconst asyncPipe = (...fns) => x => (  \n  fns.reduce(async (y, f) => f(await y), x)  \n);\n\nconst uploadFiles = asyncPipe(  \n  readUser,  \n  getFolderInfo,  \n  haveWriteAccess,  \n  uploadToFolder  \n);\n\nuploadFiles({user, folder, files})  \n  .then(log)  \n;\n```\n\n프로미스는 자체적으로 조건부 분기하도록 설계되어있기 때문에 `if` 로직을 쉽게 제거 할 수 있습니다.  로직과 I/O는 잘 섞이지 않기 때문에 I/O 의존적인 코드에서 로직을 제거하는 것이 좋습니다.\n\n이러한 종류의 합성 작업을 하기 위해서는 다음 두 가지를 보장해야합니다.\n\n1.  `haveWriteAccess()`는 사용자가 쓰기 권한이 없는 경우 거절해야 합니다.  조건 로직을 프로미스 컨텍스트로 옮겼기에 따로 유닛 테스트를 할 필요가 없습니다.(JS 엔진 코드에 자체 테스트가 생성됩니다).\n2.  각 함수는 동일한 데이터 타입을 사용하여 처리됩니다.  우리는 `{ user, folder, files, dbUser?, folderInfo? }`를 키로 사용하는 `pipelineData`  타입을 만든 것 입니다.  이렇게 하면 각 구성 요소들이 특정 구조를 공유한다는 종속성이 생기지만 이러한 함수를 추상화시켜 보다 일반적인 버전을 만들 수 있으며 간단하게 래핑하여 다양한 파이프라인에 적용할 수 있습니다.\n\n이러한 조건들이 충족되면 다른 함수들을 mocking하지 않고 각 함수를 서로 격리하여 테스트하기 쉬워집니다. 우리가 파이프라인에서 모든 로직을 추출했으므로,이 파일에서 유닛 테스트를 하는 것은 아무런 의미가 없습니다.  결국 테스트가 필요해지는 것은 통합 뿐입니다.\n\n> 기억하세요:   _로직과  I/O는 별도의 관심사입니다._\n> _로직이란 생각하는 것입니다._  _효과란 행동입니다._  _행동하기 전에 생각해야 합니다!_\n\n### 미래의 계산을 나타내는 객체 사용\n\nredux-saga의 전략은 미래의 계산을 나타내는 객체를 사용하는 것입니다.  이 아이디어는 모나드를 반환하는 것과 유사합니다. 단, 항상 모나드가 반환되는 것은 아닙니다.  모나드는 체이닝으로 함수를 합성할 수 있지만, 대신 명령형 코드를 사용하여 함수를 수동으로 연결할 수 있습니다.  다음은 redux-saga가 어떻게 동작하는지에 대한 대략적인 스케치입니다.\n\n```javascript\n// sugar for console.log we'll use later  \nconst log = msg => console.log(msg);\n\nconst call = (fn, ...args) => ({ fn, args });  \nconst put = (msg) => ({ msg });\n\n// imported from I/O API  \nconst sendMessage = msg => Promise.resolve('some response');\n\n// imported from state handler/Reducer  \nconst handleResponse = response => ({  \n  type: 'RECEIVED_RESPONSE',  \n  payload: response  \n});\n\nconst handleError = err => ({  \n  type: 'IO_ERROR',  \n  payload: err  \n});  \n  \n\nfunction* sendMessageSaga (msg) {  \n  try {  \n    const response = yield call(sendMessage, msg);  \n    yield put(handleResponse(response));  \n  } catch (err) {  \n    yield put(handleError(err));  \n  }  \n}\n```\n\n네트워크 API를 mocking하거나 부수효과를 일으키지 않고도 모든 호출을 볼 수 있습니다.  보너스 : 비 결정적인 네트워크 상태 등을 걱정하지 않고도 애플리케이션을 매우 쉽게 디버깅 할 수 있습니다.\n\n네트워크 오류를 시뮬레이션하고 싶습니까?  \n간단하게 `iter.throw(NetworkError)`를 호출하면 됩니다.\n\n다른 곳에서는 일부 라이브러리 미들웨어가 함수를 작동시키고 실제로 프로덕션 애플리케이션에서 부수효과를 발생시킵니다.\n\n```javascript\nconst iter = sendMessageSaga('Hello, world!');\n\n// Returns an object representing the status and value:  \nconst step1 = iter.next();\n\nlog(step1);  \n/* =>  \n{  \n  done: false,  \n  value: {  \n    fn: sendMessage  \n    args: [\"Hello, world!\"]  \n  }  \n}  \n*/\n```\n\n `call()`  객체를 해체하여 yield하는 방식으로 미래의 계산을 검사하거나 호출합니다.\n\n```javascript\nconst { value: {fn, args }} = step1;\n```\n\n실제로는 미들웨어에서 실행되며 테스트 및 디버깅 할 때는 이 부분을 건너뛸 수 있습니다.\n\n```javascript\nconst step2 = fn(args);\n\nstep2.then(log); // \"some response\"\n```\n\nAPI 또는 http 호출을 mocking하지 않고 네트워크 응답을 시뮬레이션 하려면  `.next()`에 가짜 리스폰스를 전달하면 됩니다.\n\n```javascript\niter.next (simulatedNetworkResponse); \n```\n\n결국  `done`이  `true`가 될 때까지  `.next()`를  계속 호출하면 됩니다.\n\n유닛 테스트에서 제너레이터와 계산 표현을 사용해 모든 것을 **부수효과 없이** 시뮬레이션할 수 있습니다.  값을  `.next()`에 전달해 가짜 응답을 만들거나 에러를 이터레이터로 전달해 가짜 에러상황 및 거절된 프로미스를 시뮬레이션할 수 있습니다.\n\n결국, 부수효과가 많은 복잡한 통합 워크 플로의 경우에서도 mocking을 할 필요가 없어집니다.\n\n## \"코드 냄새\"는 법칙이 아닌 경고 신호입니다.  Mock은 Evil하지 않습니다.\n\n더 나은 아키텍처를 사용할 수 있음에도 실제로는 다른 사람들의 API를 사용하고 레거시 코드와 통합해야 합니다. 이들 중에는 순수하지 않은 코드들이 많이 있습니다.  이러한 경우에 테스트 더블을 격리시켜 사용해야 합니다. 예를 들어, express는 컨티뉴에이션 패싱 기법으로 공유 가변 상태^shared^ ^mutable^ ^state^ 및 모델의 부수효과들을 전달합니다.\n\n일반적인 예를 살펴 보겠습니다.  사람들은 익스프레스 서버 스크립트에 의존성 주입을 해야한다고 말합니다. 그렇지 않다면 어떻게 익스프레스 앱에 들어가는 것들을 테스트 할 수 있는지 궁금해합니다.  예 :\n\n```javascript\nconst express = require('express');  \nconst app = express();\n\napp.get('/', function (req, res) {  \n  res.send('Hello World!')  \n});\n\napp.listen(3000, function () {  \n  console.log('Example app listening on port 3000!')  \n});\n```\n\n_이 파일_  을 \"유닛 테스트\"하려면,  우리는 의존성 주입 솔루션을 개발한 다음 모든 것을 mocks으로 (아마도  `express()`  자체도 포함해서) 전달해야 할 것입니다.  그러나 이 파일이 매우 복잡해질 경우, 즉 여러 리퀘스트 핸들러들이 서로 다른 익스프레스 기능을 사용하고 있고 다양한 로직들에 의존하고 있다면 아마도 꽤 정교한 mock들을 만들어야 할 것입니다.  저는 개발자들이 익스프레스 인스턴스, 세션 미들웨어, 로그 처리기, 실시간 네트워크 프로토콜 등과 같은 정교한 가짜와 모의 객체를 생성하는 것을 자주 봤습니다.  어떻게 해야 할까요? 대답은 간단합니다.\n\n> 이 파일은 유닛 테스트하면 안됩니다.\n\n익스프레스 앱의 서버 정의 파일은 말 그대로 앱의 주요  **통합**  지점입니다. 이 파일을 테스트한다는 것은 프로그램 로직, 익스프레스 및 앱의 모든 핸들러 간의 통합을 테스트하는 것입니다.  100% 유닛 테스트 커버리지를 달성할 수 있다고 하더라도 통합 테스트를 건너 뛰면 **절대로** 안됩니다.\n\n이 파일을 유닛 테스트하려고 하는 대신 프로그램 로직을 별도의 유닛로 분리하고 유닛 테스트를 하십시오. 서버 파일은 실제 통합 테스트를 해야 합니다. 다시 말해 실제로 네트워크에 연결하고 실제 HTTP 메시지를 주고받고,  [supertest](https://github.com/visionmedia/supertest)와 같은 도구를 사용해 헤더를 테스트하십시오.\n\nHello World Express 예제를 더 쉽게 테스트 할 수 있도록 리팩터링 해 봅시다.\n\n`hello`  핸들러를 자체 파일로 분리해 유닛 테스트를 만들어야 합니다.  앱의 나머지 구성 요소를 mocking할 필요가 없습니다.  이는 분명히 순수 함수가 아니므로  `.send()`  호출하도록 응답 객체를 mocking해야 합니다.\n\n```javascript\n  const hello = (req, res) => res.send ( 'Hello World!'); \n```\n\n이런 식으로 테스트 해 볼 수 있습니다 :\n\n```javascript\n{  \n  const expected = 'Hello World!';  \n  const msg = `should call .send() with ${ expected }`;\n\n  const res = {  \n    send: (actual) => {  \n      if (actual !== expected) {  \n        throw new Error(`NOT OK ${ msg }`);  \n      }  \n      console.log(`OK: ${ msg }`);  \n    }  \n  }\n\n  hello({}, res);  \n}\n```\n\nListen 핸들러를 자체 파일로 분리해 유닛 테스트를 만들겠습니다.  이 때도 같은 문제가 등장합니다.  익스프레스 핸들러들은 순수하지 않으므로 로거를 집어넣어 스파이웨어가 호출되는지 확인해야합니다.  테스트는 이전 예와 비슷합니다.\n\n```javascript\nconst handleListen = \n       (log, port) => \n                () => \n        log(`Example app listening on port ${ port }!`);\n```\n\n이제 서버 파일엔 통합 로직만 남겨졌습니다.\n\n```javascript\nconst express = require('express');\n\nconst hello = require('./hello.js');  \nconst handleListen = require('./handleListen');  \nconst log = require('./log');\n\nconst port = 3000;  \nconst app = express();\n\napp.get('/', hello);\n\napp.listen(port, handleListen(port, log));\n```\n\n여전히 통합 테스트는 필요하지만 유닛 테스트를 아무리 추가해도 케이스 커버리지는 향상되지 않습니다.  우리는 logger를  `handleListen()`에 전달하기 위해 최소한의 의존성 주입 패턴을 사용하지만 의존성 주입 프레임 워크가 필요하진 않습니다.\n\n## 모의(mocking) 테스트는 통합 테스트에 적합합니다.\n\n통합 테스트는 유닛간의 상호작용과 통합을 테스트하기 때문에 CPU 클러스터 또는 네트워크상의 별도의 프로세스에 존재하는 다른 유닛과의 통신 중에 발생할 수있는 다양한 조건과 상황을 재현해야 합니다.  서버나 네트워크 프로토콜, 네트워크 메시지 등을 가짜로 만드는 것은 너무나 당연합니다.\n\n때로는 유닛이 타사 API와 통신하는 것을 테스트해야 하며 때로는 이러한 API가 실제로 테스트하려면 엄청나게 비쌉니다.  실제 서비스에 대한 워크 플로우 트랜잭션을 기록한 후 fake 서버에서 이를 다시 재생하면 유닛이 별도의 네트워크 프로세스에서 실행중인 타사 서비스와 얼마나 잘 통합되어 있는지 테스트할 수 있습니다.  \"이 메시지 헤더가 올바른 형식입니까?\"같은 상황을 테스트하는 가장 좋은 방법입니다.\n\n네트워크 대역폭을 제한하고, 네트워크 지연을 연출하고, 네트워크 오류를 생성하고, 통신 레이어를 mocking하는 등 유닛 테스트가 할 수 없는 많은 다른 조건을 테스트하는 통합 테스트 도구들이 많이 있습니다.\n\n통합 테스트없이 100% 케이스 커버리지를 달성하는 것은 불가능합니다.  100% 유닛 테스트 커버리지를 달성하더라도 이를 건너 뛰면 안됩니다. 100%가 100%가 아닙니다.\n\n\n[**다음: 객체 합성이라는 숨겨진 보물 >**](https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/)","source":"_posts/mocking-is-a-code-smell.md","raw":"---\ntitle: Mocking은 코드 냄새(Code Smell)입니다\ncatalog: true\ndate: 2018-04-20 03:54:56\nsubtitle: Mocking is a Code Smell\nheader-img: \"bg.jpg\"\nreadingTime: 24\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 코드 냄새란 일반적으로 시스템의 더 깊은 문제에 해당하에 깊숙히 숨어있는 문제를 드러내는 표면적인 표시입니다. Martin Fowler.  TDD와 유닛 테스트를 할 때 가장 손이 많이 가는 부분은 테스트할 유닛을 분리하는 과정에서 필요한 mocking을 만드는 일 입니다. 몇몇 사람들은 유닛 테스트가 정말로 의미있는 일인지 의심스러워 하기도 합니다.  실제로, 저는 개발자들이 mock, fake, stub을 만들다 길을 잃고  실제 코드가 전혀 실행되지 않는  유닛 테스트를 작성하는걸 보았습니다. 아이고.\n---\n\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/)\n\nTDD와 유닛 테스트를 할 때 가장 손이 많이 가는 부분은 테스트할 유닛을 분리하는 과정에서 필요한 **mocking**을 만드는 일 입니다. 몇몇 사람들은 유닛 테스트가 정말로 의미있는 일인지 의심스러워 하기도 합니다.  실제로, 저는 개발자들이 mock, fake, stub을 만들다 길을 잃고  _실제 코드가 전혀 실행되지 않는_  유닛 테스트를 작성하는걸 보았습니다. 아이고..\n\n다른 한편으로는 개발자가 TDD에 스스로를 너무 옭아매는 모습이 자주 보입니다. 이 경우 개발자는 코드베이스를 더 복잡하게 만들어버릴지라도 무조건 100% 코드 커버리지를 달성해야 한다고 생각합니다. \n\n저는 mocking에서 코드 냄새를 맡으라고  말합니다. 그러나 대부분의 개발자들은 100% 유닛 테스트 커버리지를 달성할 수 있다는 TDD 신봉자 단계를 거치게 되며 이 기간 동안에는 대규모의 모의 객체를 사용하지 않는 세상을 상상할 수 없습니다.  모의 객체^mocks^를 응용 프로그램에 집어 넣기 위해 의존성 주입^dependency^ ^injection^ (DI)함수로 자신의 코드유닛을 감싸거나 더 안좋은 경우, 서비스를 의존성 주입 컨테이너로 만들어버리기도 합니다.\n\nAngular는 모든 컴포넌트 클래스에 의존성을 주입하며 DI를 기본적인 디커플링 수단으로 사용하도록 유혹합니다.  하지만 의존성 주입이 디커플링을 수행하는 가장 좋은 방법은 아닙니다.\n\n## TDD는 더 나은 디자인으로 이어질 때 그 의미가 있습니다.\n\n> 제대로된 TDD를 배운다는 것은 제대로 앱을 모듈화시키는 법을 배우는 것과 같습니다.\n\nTDD는 코드를 복잡하게 만드는것이 아닌 단순하게 만들어야 합니다. 코드를 더 잘 테스트 할 수 있게 고치는 댓가로 가독성과 유지보수성을 내주어선 안됩니다.  DI 보일러 플레이트로 코드를 부풀리고 있다면 잘못된 TDD를 하고있는 겁니다.\n\n온 세상을 mocking할 수 있다는 환상을가지고 앱에 의존성을 주입하고 있다면 그것이 도움이 되기 보다는 해가 될 가능성이 매우 높습니다.  테스트 가능한 코드를 작성하는 과정에서 코드가 단순해져야 합니다.  우리에게 필요한 것은 적은 수의 코드 라인과 보다 읽기 쉽고 유연하며 유지 보수가 가능한 구조입니다.  의존성 주입은 반대 효과를냅니다.\n\n제가 말하고 싶은 것은 이 두 가지 입니다.\n\n1.  의존성 주입 없이도 디커플링된 코드를 작성할 수 있습니다.\n2.  코드 커버리지를 최대화하려는 시도는 좋지 않습니다. 100%에 다가갈수록 애플리케이션 코드는 복잡해지고 결국 버그를 줄인다는 목표를 뒤엎고 말게 됩니다.\n\n 복잡한 코드에는 종종 자질구레한 코드들도 함께 있습니다. 잘 정돈된 코드를 작성하는 것은 집을 깔끔하게 유지하려는 것과 같은 이유입니다.\n\n-  코드가 어수선해지면 버그가 숨을 수 있는 편리한 장소가 생기고 더 많은 버그가 발생합니다.\n-   뭔가를 찾기 위해서는 우선 정돈된 환경이 필요합니다.\n\n\n## 코드 냄새^Code^ ^smell^란 무엇입니까?\n\n> _\"코드 냄새란 일반적으로 시스템 깊숙히 숨어있는 문제를 드러내는 표면적인 표시입니다.\"~ Martin Fowler_\n\n> **코드 스멜**(code smell←코드 냄새)은 컴퓨터 프로그래밍 코드에서 더 심오한 문제를 일으킬 가능성이 있는 프로그램 소스 코드의 증상을 가리킨다.  ~ Wikipedia\n\n나쁜 코드 냄새를 맡았다고 해서 곧바로 뭔가 잘못 되었고 이를 고쳐야 한다는 것을 의미하진 않습니다.  코드 냄새란 당신에게 뭔가를 향상시킬 수있는 기회를 알려주는 _경험 법칙_ 입니다.\n\n이 글은 모든 mocking이 나쁘다는 것을 의미하지 않으며 mocking을 절대 하면 안된다고 말하는게 아닙니다.\n\n코드의 유형에 따라 다양한 수준 (및 다른 종류)의 mocking이 필요합니다. I/O를 다루는 코드는 I/O 를 테스트하는 것 이외에 다른 방법은 거의 없습니다. 이 경우 모의 테스트를 줄이면 유닛 테스트 커버리지가 0%에 가까워 질 수 있습니다.\n\n로직이 없는 코드는(파이프와 순수 함수들로만 이루어진) 유닛 테스트 커버리지가 0%가 되어도 괜찮습니다. 대신 통합 또는 기능 테스트 커버리지가 100 %에 가까워질 것입니다.  그러나 로직(조건식, 변수 할당, 메소드 호출 등)이 있다면 유닛 테스트 커버리지가 필요하며, 이 때 코드를 단순화하고 mocking 요구사항을 줄이는 목표를 세울 수 있습니다.\n\n## Mock(모의)란 무엇입니까?\n\nMock이란 유닛 테스트에서 실제 구현 코드를 대신하는 **테스트 더블**^[test double, 여기서 double이란 스턴드 대역 배우(stunt double)와 같은 대역이란 뜻입니다.]입니다.  모의 객체는 테스트가 진행되는 동안 테스트 코드에 의해 조작, 변경되고 이를 assert 구문으로 확인합니다. Assert 구문에 테스트 더블이 쓰인다면 이는 모의입니다.\n\n\"모의(mock)\"라는 용어는 여러 종류의 테스트 더블을 포괄하는 일반적인 용어입니다. 앞으로의 논의에서 우리는 \"모의(mock)\"와 \"테스트 더블(test double)\"이라는 단어를 동등하게, 상호 교환적으로 사용하겠습니다.  모든 테스트 더블 (dummies, spies, fake 등)은 테스트 대상과 단단하게 결합된 실제 코드를 나타냅니다. 따라서 테스트 더블은 일종의 커플링이 있다는 것을 뜻하며, 구현을 단순화하고 향상시킬 수 있다는 의미입니다. 그리고 모의 객체가 필요하지 않도록 코드를 바꾸는 것은 테스트를 근본적으로 단순화시키는 방법입니다.\n\n## 유닛 테스트란 무엇입니까?\n\n**유닛 테스트**는 개별 유닛(모듈, 함수, 클래스)을 나머지 프로그램과 분리하여 테스트하는 행위입니다,\n\n유닛 테스트와 달리 **통합 테스트**^Integration^ ^test^란 두 개 이상의 유닛 간의 통합을 테스트하는 것입니다.   **기능 테스트**^Functional^ ^test^란 사용자의 관점에서 애플리케이션을 테스트하는 것 입니다.  사용자 워크 플로 테스트는 UI 조작에서 데이터 레이어가 업데이트되고 그것들이 다시 화면에 출력되는 과정을 모두 관찰합니다.  기능 테스트는 앱이 실행되는 맥락에서 모든 장치와 유닛을 테스트하기 때문에 통합 테스트의 하위 집합이라고 볼 수 있습니다.\n\n일반적으로 유닛은 유닛의 공용 인터페이스 (일명 \"퍼블릭 API\"또는 \"surface area\") 만 사용하여 테스트됩니다.  이것을 **블랙 박스 테스트**라고합니다.  블랙 박스 테스팅은 고장나기 쉬운 테스트입니다.  왜냐하면 시간이 지남에 따라 퍼블릭 API는 그대로인데 유닛의 구현 세부 사항이 변경되기 때문입니다. 내부 구현 방식까지 다루는 화이트 박스 테스트는 더더욱 고장나기 쉬운데, 퍼블릭 API가 예상대로 계속 작동하더라도 구현 세부 사항을 변경하면 테스트가 중단 될 수 있기 때문입니다.  즉, 화이트 박스 테스트에는 훨씬 많은 시간과 노력이 들어갑니다.\n\n## 테스트 커버리지^[테스트 적용 범위]란 무엇입니까?\n\n코드 커버리지란 테스트 케이스가 다루는 코드의 양을 의미합니다.  테스트 도중 어떤 코드의 행이 사용되었는지 기록하여 커버리지 리포트를 작성합니다. 일반적으로 우리는 커버리지를 높이려고 노력하지만 100 %에 가까워 질수록 테스트 효율이 감소하기 시작합니다.\n\n경험에 비추어 볼 때, 90%가 넘는 커버리지는 남은 버그들을 없애는데 거의 상관 관계가없는 것 같습니다.\n\n왜 그럴까요?  100% 테스트 된 코드란 코드가 의도 한대로 작동한다는 것을 100% 확신시켜주는 의미 아닙니까?\n\n이 문제는 그리 간단하지 않습니다.\n\n대부분의 사람들은 두 가지 종류의 커버리지가 있다는 것을 모릅니다.\n\n1.  **코드 커버리지** : 코드가 실행되는 정도\n2.  **케이스 커버리지** :  테스트 스위트가 커버하는 유스 케이스의 수\n\n케이스 커버리지는 유스 케이스 시나리오를 다룹니다 : 코드가 실제 환경, 실제 네트워크에서 어떻게 작동할 것인가? 악의적인 목적으로, 소프트웨어 설계를 의도적으로 파괴하려는 해커한테 어떻게 작동 할 것인가?\n\n커버리지 리포트는 케이스 커버리지가 아닌 코드 커버리지의 부족한 점을 알려줍니다.  그러나 동일한 코드가 둘 이상의 유스 케이스에 적용될 수 있을 뿐더러 단일 유즈 케이스가 테스트 대상 외부에 있는 코드, 별도의 애플리케이션 또는 서드파티 API에 의존 할 수도 있습니다.\n\n유스 케이스는 환경, 여러 단위, 사용자 및 네트워킹 조건을 포함 할 수 있으므로 필요한 모든 유스 케이스를 유닛 테스트들 밖에 없는 테스트 스위트로 처리하는 것은 불가능합니다.  유닛 테스트는 통합되지 않은, 격리 된 테스트 단위를 의미하므로 유닛 테스트로만 이루어진 테스트 스위트는 항상 통합 및 기능 유스  케이스 시나리오에 대해 거의 0%의 커버리지를 달성하게 될 것입니다.\n\n100% 코드 커버리지는 100% 케이스 커버리지를 보장하지 않습니다.\n\n100% 코드 커버리지를 목표로 하는 개발자는 잘못된 목표를 쫓고 있습니다.\n\n## 단단한 결합(Tight Coupling)이란 무엇입니까?\n\n모의 객체가 필요하다는 것은 유닛 테스트를 위해 유닛을 분리해야 하며 이 때 유닛간의 결합이 있기 때문입니다.  긴밀한 결합은 코드를보다 단단하고 부서지기 쉽게 만듭니다. 코드가 변경되었을 때 프로그램이 멈추게 됩니다.  일반적으로 느슨한 결합은 코드를 확장하고 유지하기 쉽게 만듭니다. 여기에 더해 mocking에 대한 필요성을 없앰으로써 테스트를 더 쉽게한다는 사실은 두말할 필요도 없습니다.\n\n이것으로부터 우리가 뭔가를 mocking 하고있다면 그 대신에 유닛간의 결합을 줄임으로써 코드를보다 유연하게 만들 수 있는 가능성이 존재한다는 것을 추론 할 수 있습니다.  그리하면 더 이상 가짜 코드들이 필요하지 않습니다.\n\n커플링(또는 결합)이란 코드 유닛(모듈, 함수, 클래스 등)이 다른 코드 유닛에 종속되는 정도입니다.  밀접한 결합 또는 높은 결합도는 종속된 코드들이 변경 될 때 유닛이 망가질 가능성을 나타냅니다.  즉, 커플링이 빡빡할수록 응용 프로그램을 유지 관리하거나 확장하는 것이 어렵습니다.  느슨한 결합은 버그를 수정하고 응용 프로그램을 새로운 유스 케이스로 확장 할 때 마주치는 복잡성을 줄입니다.\n\n커플링에는 여러 형태가 있습니다.\n\n-   **하위 클래스 커플링 :**  하위 클래스는 상위 클래스의 구현 및 전체 계층 구조에 의존합니다. OO 디자인에서 사용할 수있는 가장 단단한 형태의 결합입니다.\n-   **의존 코드 제어 :**  전달받은 메소드 이름으로 수행 할 작업을 지시하는 것처럼 종속된 유닛들을 제어하는 ​​코드.  API가 변경되면 종속된 코드가 중단됩니다.\n-   **변경 가능한 상태 :**  다른 코드와 변경 가능한 상태를 공유하는 코드. (e.g.공유된 객체의 속성을 변경하는 일)  코드가 실행되는 상대적인 타이밍이 바뀔 경우 종속 코드가 손상 될 수 있습니다.  타이밍이 비 결정적이라면, 모든 종속 유닛을 완전히 뜯어보지 않는 이상 프로그램 정확성을 달성하는 것이 불가능할 수 있습니다. 예를 들어, 해결 불가능한 레이스 컨디션이 있을 수 있습니다.  한 버그를 수정하면 다른 종속 유닛에 새로운 버그가 나타날 수 있습니다.\n-   **형태적 종속성 :**  다른 코드와 특정 데이터 구조를 공유하며 구조의 일부분만 사용하는 코드입니다.  구조적인의 형태가 변경되면 종속 코드가 손상 될 수 있습니다.\n-   **이벤트 / 메시지 커플링 :**  메시지 전달, 이벤트 등을 통해 다른 유닛과 통신하는 코드.\n\n## 무엇이 단단한 결합을 만드는가?\n\n단단한 결합에는 많은 원인이 있습니다.\n\n-   **변이**  vs  _불변성_\n-   **부수효과**  vs  _순수함 /부수효과를 분리_\n-   **책임 과부하**  vs  _Do One Thing (DOT)_\n-   **절차를 기술**  vs  _구조를 기술_\n-   **명령형 구성**  vs  _선언적인 구성_\n\n명령형 및 객체 지향 코드는 함수형 코드보다 단단하게 결합되기 쉽습니다.  그러나  함수형 스타일로 프로그래밍한다고 해서 단단한 결합에 무적이 되진 않습니다. 다만 함수형 프로그래밍은 프로그램의 기본 구성 단위로 순수 함수를 사용하며 이는  본질적으로 느슨한 결합들을 형성합니다.\n\n순수 함수 :\n\n-   동일한 입력이 주어지면 항상 동일한 출력을 반환\n-   부수효과 없음\n\n순수 함수는 어떻게 결합도를 낮출까요?\n\n-   **Immutability :**  순수 함수는 기존 값을 변경하지 않습니다.  대신 새로운 값을 반환합니다.\n-   **No side effects :**  순수 함수가 유일하게 표현하는 것은 리턴 값입니다. 따라서 화면, DOM, 콘솔, 표준 입출력, 네트워크, 디스크 입출력 등과 같은 외부 상태와 연관있는 다른 함수의 조작을 방해할 가능성이 없습니다. \n-   **Do One Thing :**  순수 함수는 단일 임무를 수행합니다. 입력과 출력을 맵핑하는 임무입니다.  객체 및 클래스 기반 코드는 몇줄 안되는 코드에게 과한 책임을 지우는 경향이 있습니다. 책임 과부하를 피하십시오.\n-   **Structure, not instructions :**  순수 함수는 안전하게 메모이제이션 할 수 있습니다. 즉, 시스템 메모리가 무한하다고 가정할 때  함수 입력을 인덱스로 사용하여 테이블에서 해당 값을 검색하는 조회 테이블로 바꿀 수 있습니다.  다시 말해 순수 함수는 컴퓨터에게 내리는 명령이 아닌 데이터 간의 구조적 관계를 설명하므로 서로 충돌하는 두 가지 명령이 서로의 발가락을 밟고 문제를 일으킬 수 없습니다.\n\n## 합성은 mocking과 무슨 관계가 있습니까?\n\n **Everything**.  소프트웨어 개발의 본질은 큰 문제를 작고 독립적인 조각으로 분해하고 작은 솔루션들을 합쳐 큰 문제를 해결하는 과정입니다.\n\n> 문제를 분해하는 전략이 실패했을 때 mocking이 필요해집니다.\n\n큰 문제를 작은 부분으로 나누는 데 사용되는 조그만  유닛이 서로 의존 할 때 mocking이 필요합니다.  다시 말하자면  _우리가 생각한  원자 단위가 실제로 원자가 아니며,_  우리의 분해 전략이 큰 문제를 더 작고 독립적인 문제로 분해하지 못했을 때 필요합니다.\n\n문제를 성공적으로 분해했다면 일반적인 합성 유틸리티들을 사용해 솔루션 조각들을 다시 합칠 수 있습니다.  예 :\n\n-   **함수 합성**  e.g.,  `lodash/fp/compose`\n-   **컴포넌트 합성**  e.g., 함수 합성으로 고차 컴포넌트 작성\n-   **상태 저장소/모델 합성**  e.g.,  [Redux combineReducers](http://redux.js.org/docs/api/combineReducers.html)\n-   **객체 또는 팩토리 합성** e.g. 객체 믹스인 또는 함수형 믹스인\n-   **프로세스 합성**  e.g. 트랜스듀서^transducer^ ^[   [Understanding Transducers in JavaScript](https://medium.com/@roman01la/understanding-transducers-in-javascript-3500d3bd9624)를 참고 ]\n-   **프로미스 또는 모나드 합성**  e.g., `asyncPipe()`  또는  `composeM()`,  `composeK()` Kleisli 합성 \n-   기타..\n\n이러한 유틸리티들을 사용하는 경우 합성의 재료가 되는 각 요소들은 다른 요소를  _mocking하지 않고도_  격리 된 유닛 테스트를 수행 할 수 있습니다  _._\n\n합성 자체는 완벽하게 선언적이므로  _유닛 테스트_ 가 필요한 로직이 없습니다. (그리고 이런 합성 유틸리티는 자체적인 유닛 테스트가 있는 서드파티 라이브러리입니다).\n\n이러한 상황에서 유닛 테스트를 하는 건 아무런 의미가 없습니다.  대신 통합 테스트가 필요합니다.\n\n익숙한 예제를 가지고 명령적^Imperative^ 합성과 선언적^Declarative^ 합성을 비교해 보겠습니다.\n\n```javascript\n// Function composition OR  \n// import pipe from 'lodash/fp/flow';  \nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\n\n// Functions to compose  \nconst g = n => n + 1;  \nconst f = n => n * 2;\n\n// Imperative composition  \nconst doStuffBadly = x => {  \n  const afterG = g(x);  \n  const afterF = f(afterG);  \n  return afterF;  \n};\n\n// Declarative composition  \nconst doStuffBetter = pipe(g, f);\n\nconsole.log(  \n  doStuffBadly(20), // 42  \n  doStuffBetter(20) // 42  \n);\n```\n\n함수 합성은 함수의 반환 값에 다른 함수를 적용하는 프로세스입니다.  즉, 함수의 파이프 라인을 만든 다음 입력 값을 파이프 라인에 전달하면 물건이 공장 조립 라인을 통과하듯 값이 개별 함수들을 거쳐가며 변환됩니다.  결국, 파이프 라인의 마지막 함수는 최종 값을 반환합니다.\n\n```\ninitialValue -> [g] -> [f] -> result\n```\n\n이는 패러다임과 무관하게 모든 주류 언어들이 애플리케이션 코드를 구성하는 주요 수단입니다.  자바조차도 클래스 인스턴스간 메세지를 전달하는 기본 메커니즘으로 함수 (메소드)를 사용합니다.\n\n함수를 수동으로(명령형으로) 합성하거나 자동으로(선언적으로) 합성할 수 있습니다. 함수가 퍼스트 클래스가 아닌 언어에서는 선택권이 많지 않습니다. 명령형으로 할 수 밖에 없습니다.  자바 스크립트 (그리고 거의 모든 주요 대중 언어)에서는 선언적으로 합성할 수 있습니다.\n\n명령형이란 컴퓨터에게 단계적으로 뭔가를 수행하도록 명령한다는 의미입니다. How-To 가이드입니다.  위의 예에서 명령형 스타일은 다음과 같습니다.\n\n1.  인수를 취하여  `x` 를 대입하십시오.\n2.  `afterG`  라는 바인딩을 선언하고 `g(x)` 의 결과를 할당하십시오.\n3.  `afterF`  라는 바인딩을 선언하고  `f(afterG)`  의 결과를 할당합니다.\n4.  `afterF`  의 값을 리턴합니다.\n\n명령형 버전에는 테스트해야 할 로직들이 있습니다.  비록 단순한 과제일지라도 잘못된 변수를 전달하거나 리턴하는 곳에서 버그가 발생하는 것을 자주 보았습니다.\n\n선언적 스타일은 우리가 사물 간의 관계를 컴퓨터에 알리는 것을 의미합니다. 그것은 등식을 사용해서 구조에 대해 설명하는 것 입니다.  선언적 스타일은 다음과 같습니다 :\n\n-   `doStuffBetter` 는  `g` 와  `f` 의 파이프 컴포지션입니다.\n\n이게 전부입니다.\n\n`f`와  `g`에 대한 유닛 테스트가 존재하고  `pipe()`가 자체 유닛 테스트 (Ramda의  `pipe()`  또는 Lodash의 `flow()` 를 사용)를 사용한다고 가정하면 더이상 유닛 테스트를 해야될 로직이 없습니다.\n\n이 스타일이 올바르게 작동하려면 유닛들이  _분리_ 되어야 합니다.\n\n## 커플링을 제거하려면 어떻게 해야합니까?\n\n커플링을 제거하려면 먼저 종속성이 어디서 발생하며 그 형태가 어떤지 알아야 합니다. 다음은 중요한 예들입니다. 그 순서는 대략적으로 커플링의 긴밀한 정도입니다.\n\n단단한 결합 :\n\n-   클래스 상속 (상속 계층이 증가할 때마다, 각 자손 클래스가 많아질 때 마다 결합도는 배가 됩니다)\n-   전역 변수\n-   변경 가능한 전역 상태 (브라우저 DOM, 공유 저장소, 네트워크 등)\n-   부수효과가 있는 모듈 가져오기\n-   합성 과정에 숨어든 암시적인 종속성  e.g., `const enhancedWidgetFactory = compose(eventEmitter, widgetFactory, enhancements);`  `widgetFactory`는 `eventEmitter`에게 의존합니다.\n-   의존성 주입 컨테이너\n-   의존성 주입 파라미터\n-   컨트롤 파라미터 (외부 유닛이 해당 유닛의행동을 지시하고 통제하는 것)\n-   변경 가능한 매개 변수\n\n느슨한 결합:\n\n-   부수효과가 없는 모듈 가져오기 (블랙 박스 테스트를 할 때 import된 모든 모듈을 분리할 필요는 없음)\n-   메시지 전달 / pubsub\n-   변경 불가능한 매개 변수 \n\n아이러니하게도, 커플링을 발생시키는 원인의 대부분은 원래 커플링을 줄이기 위해 설계된 메커니즘들입니다. 왜냐하면 문제를 풀기 위한 작은 솔루션들을 완전한 애플리케이션으로 재구성하기 위해 어떻게든 이들을 통합하고 연결해야 했기 때문입니다.  좋은 방법과 나쁜 방법이 있을 뿐입니다.  단단한 커플링을 유발하는 원인들이 실제로 그렇게 되는 경우에는 피해야 합니다.  느슨한 커플링 옵션은 일반적으로 건강한 앱을 만드는 바람직한 방법입니다.\n\n많은 책과 블로그 포스트에서 의존성 주입 컨테이너와 매개 변수를 \"느슨한 결합\"으로 분류합니다. 왜 이들이 \"단단한 커플링\" 그룹에 속하는지 혼란스러울 수 있습니다.  커플링은 바이너리가 아닙니다.  그라디언트 스케일입니다.  즉, 어떤 그룹에든 다소 주관적이고 임의적으로 속할 수 있습니다.\n\n따라서 제가 간단하고 객관적인 리트머스 테스트를 준비했습니다.\n\n의존성을 mocking하지 않고 유닛을 테스트 할 수 있습니까?  그렇게 할 수 없다면 mocking은 의존성과  _밀접하게 결합_  되어 있는 것입니다.\n\n유닛의 종속성이 높을수록 문제가 되는 커플링이 발생할 가능성이 커집니다. 커플링이 어디서 발생하는지 이해했습니다. 이제 어떻게 해야 하는지 알아보겠습니다.\n\n1.  클래스, 명령형 프로시저 또는 무언가를 변경하는 함수 대신 **순수 함수**를 프로그램의 원자 단위로 사용하십시오.\n2.  프로그램 로직과  **부수효과**를  **격리**하십시오.  즉, I/O (네트워크, 디스크 I/O, UI 렌더링, 로깅 등)와 로직을 섞지 마십시오.\n3.  독립적인 구성 요소에서  **종속성을 만드는 로직**을  **제거**하여 유닛 테스트가 필요없는 선언적 구성이 될 수 있도록 하십시오.  로직이 없다면 단위 테스트에 아무런 의미가 없습니다.\n\n즉, 네트워크 요청을 설정하고 핸들러를 요청하는 코드는 유닛 테스트가 필요하지 않습니다. 대신 통합 테스트를 하십시오.\n\n> _I/O를 유닛 테스트 하지 마십시오._ \n\n> _I/O는 통합을 위한 것입니다._  _통합 테스트를 하십시오._\n\n통합 테스트를 위해 mocking하고 가짜를 만드는 것은 전혀 문제되지 않습니다.\n\n## 순수 함수 사용\n\n순수 함수를 사용하기 위해선 약간의 연습이 필요하며, 그러한 연습 없이는 원하는 작업을 수행하기 위해 코드를 작성하는 방법이 명확하지 않을 수 있습니다. 순수 함수는 전역 변수, 전달 된 인수, 네트워크, 디스크 또는 화면을 직접 변경할 수 없습니다. 오로지 값을 반환하는 일만 할 수 있습니다.\n\n순수 함수가 배열이나 객체를 전달받아 해당 객체의 변경된 버전을 반환는 경우 객체를 변경하고 리턴할 수 없습니다. 객체의 새 사본을 만들어 변경사항을 적용하고 리턴해야 합니다. 배열  [접근 메소드](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype)  (변경 메소드가 아님),  `Object.assign()`, 빈 객체를 생성, 배열 또는 객체 스프레드 구문을 사용하여 이를 수행 할 수 있습니다.  예 :\n\n```javascript\n// Not pure  \nconst signInUser = user => user.isSignedIn = true;\n\nconst foo = {  \n  name: 'Foo',  \n  isSignedIn: false  \n};\n\n// Foo was mutated  \nconsole.log(  \n  signInUser(foo), // true  \n  foo              // { name: \"Foo\", isSignedIn: true }  \n);\n```\n\nvs...\n\n```javascript\n// Pure  \nconst signInUser = user => ({...user, isSignedIn: true });\n\nconst foo = {  \n  name: 'Foo',  \n  isSignedIn: false  \n};\n\n// Foo was not mutated  \nconsole.log(  \n  signInUser(foo), // { name: \"Foo\", isSignedIn: true }  \n  foo              // { name: \"Foo\", isSignedIn: false }  \n);\n```\n\n또는 [Mori](http://swannodette.github.io/mori/),  [Immutable.js](https://facebook.github.io/immutable-js/)와 같은 불변 데이터 타입 라이브러리를 사용하는 방법도 있습니다.  언젠가 JavaScript가 Clojure와 비슷한 불변 데이터 타입을 지원해주기를 바라고 있습니다. \n\n기존 객체를 재사용하는 대신 새 객체를 생성하기 때문에 성능이 저하될 수 있다고 생각할 수도 있지만, 여기엔 사실 좋은 부수효과 있습니다. 객체의 변경여부를 항등연산자로 (  `===`  ) 확인할 수 있습니다. 즉, 우리는 하나라도 변경된 것을 발견하기 위해 객체 내부를 구석구석 확인하지 않아도 됩니다. \n\n이 방법을 사용하면 복잡한 상태 트리가 있는 React 구성 요소를 더 빨리 렌더링할 수 있습니다. 각 렌더 패스 별로 심도있게 순회할 필요가 없어지기 때문입니다. `PureComponent`를 상속하여 얕은 `prop` 및 `state` 비교로  `shouldComponentUpdate()`를 구현할 수 있게됩니다.  객체의 주소가 변경되지 않았음을 탐지하면 상태 트리의 해당 부분에서 아무 것도 변하지 않았으며 트리를 모두 순회하지 않고도 계속 진행하면 된다는 것을 알 수 있습니다.\n\n순수 함수는 메모이제이션 할 수 있습니다. 이전에 동일한 입력을 처리한적이 있다면 전체 객체를 다시 만들 필요가 없습니다. 미리 계산 된 값을 테이블에 저장하는 방식으로 계산 복잡도를 메모리와 교환할 수 있습니다. 많은 메모리가 필요하지 않고 계산적으로 비싼 프로세스의 경우, 이는 훌륭한 최적화 전략이 될 수 있습니다.\n\n순수 함수는 또한 부수효과가 없기 때문에 **분할-정복** 전략을 사용하여 분산처리시스템에게 계산을 맡기는 것이 안전합니다.  이 전략은 원래 그래픽 용으로 설계된  GPU를 사용하여 이미지, 비디오 또는 오디오 프레임을 처리하는 데 주로 사용되지만 시뮬레이션, 과학실험 컴퓨팅과 같은 다른 용도로 많이 사용됩니다.\n\n다시 말해, 값을 변경하는 방식이 항상 빠르지는 않으며 매크로 최적화를 희생하여 마이크로 최적화를 수행하기 때문에 더 느린 경우가 많습니다.\n\n## 프로그램의 주요 로직과 부수효과를 분리\n\n부수효과와 나머지 프로그램 로직을 분리하는데 도움이 되는 몇 가지 전략이 있습니다.  다음은 그 중 일부입니다.\n\n1.  pub/sub 패턴을 사용하여 뷰와 프로그램 로직에서 I/O를 분리하십시오.  UI 뷰와 프로그램 로직에서 부수효과를 발생시키는 코드를 직접 호출하는 대신 이벤트 또는 액션 객체를 보내 통신하는게 좋습니다.\n2.  I/O에서 로직을 분리하십시오. e.g.,  `asyncPipe()`를 사용해 프로미스를 리턴하는 함수를 합성\n3.  I/O 코드에서 직접 계산 하지 않고 지연된 계산을 표현하는 객체를 사용하십시오. e.g.,  [redux-saga](https://github.com/redux-saga/redux-saga)의  `call()`  은 실제로 함수를 호출하지 않습니다.  대신, 함수와 인수에 대한 레퍼런스가 담긴 객체를 반환하며, saga 미들웨어가 이를 호출합니다.  따라서  `call()`과 그것을 사용하는 모든 함수가  _순수 함수가되고_, 쉽게 유닛 테스트를 만들 수 있으며  _mocking이 필요하지 않습니다._\n\n### pub / sub 사용\n\nPub/sub은 게시^Publish^/구독^Subscribe^ 패턴의 약자입니다.  이 패턴에서 유닛은 서로 직접 호출하지 않습니다.  대신, 다른 유닛(구독자)가 들을 수있는 메시지를 게시합니다.  게시자는 어떤 유닛이 자신을 구독할지 알지 못하며 구독자는 게시자가 게시할 내용을 알지 못합니다.\n\nPub/sub의 좋은 예로 DOM(Document Object Model)이 있습니다.  애플리케이션의 모든 컴포넌트는 마우스 이동, 클릭, 스크롤 이벤트, 키 입력 등과 같이 DOM 요소에서 전달 된 이벤트를 수신 할 수 있습니다.  모든 사람들이 jQuery로 웹 애플리케이션을 만들던 시절, jQuery의 커스텀 이벤트는 DOM을 pub/sub 이벤트 버스로 사용하여 렌더링과 로직을 분리했습니다.\n\nPub/sub는 또한 Redux에서 볼 수 있습니다.  Redux에서는 애플리케이션 상태에 대한 전역 모델(저장소라고 함)을 만듭니다. 직접 모델을 조작하는 대신 뷰 및 I/O 핸들러는 액션 객체를 저장소에 보냅니다(dispatch라고 표현합니다).  액션 객체가 가지고 있는 `type`이라는 특별한 키를 다양한 reducers들이 듣고 응답할 수 있습니다. 또한 Redux는 특정 액션 타입을 수신하고 응답 할 수있는 미들웨어를 지원합니다.  이렇게하면 뷰에서 애플리케이션 상태가 처리되는 방법을 알 필요가 없으며 상태 로직이 뷰에 대해 알 필요가 없습니다.\n\n덕분에 디스패처를 간단하게 수정하는 것 만으로 미들웨어를 통해 액션 로깅/분석, 저장소 또는 서버와의 상태 동기화, 서버 및 네트워크 피어와의 실시간 통신 기능 패치와 같은 복잡한 문제들을 다룰 수 있습니다.\n\n### I/O와 로직을 분리\n\n모나드(e.g., 프로미스) 합성을 ​​사용해 프로그램의 의존 로직을 제거할 수 있습니다. 예를 들어 다음 함수의 로직은 모든 비동기 함수를 mocking하지 않고서는 유닛 테스트를 할 수 없게 설계되어있습니다.\n\n```javascript\nasync function uploadFiles({user, folder, files}) {  \n  const dbUser = await readUser(user);  \n  const folderInfo = await getFolderInfo(folder);  \n  if (await haveWriteAccess({dbUser, folderInfo})) {  \n    return uploadToFolder({dbUser, folderInfo, files });  \n  } else {  \n    throw new Error(\"No write access to that folder\");  \n  }  \n}\n```\n\n이를 실행할 수 있도록 도와주는 의사 코드를 작성해 보겠습니다.\n\n```javascript\nconst log = (...args) => console.log(...args);\n\n// Ignore these. In your real code you'd import  \n// the real things.  \nconst readUser = () => Promise.resolve(true);  \nconst getFolderInfo = () => Promise.resolve(true);  \nconst haveWriteAccess = () => Promise.resolve(true);  \nconst uploadToFolder = () => Promise.resolve('Success!');\n\n// gibberish starting variables  \nconst user = '123';  \nconst folder = '456';  \nconst files = ['a', 'b', 'c'];\n\nasync function uploadFiles({user, folder, files}) {  \n  const dbUser = await readUser({ user });  \n  const folderInfo = await getFolderInfo({ folder });  \n  if (await haveWriteAccess({dbUser, folderInfo})) {  \n    return uploadToFolder({dbUser, folderInfo, files });  \n  } else {  \n    throw new Error(\"No write access to that folder\");  \n  }  \n}\n\nuploadFiles({user, folder, files})  \n  .then(log)  \n;\n```\n\n`asyncPipe()`로 프로미스를 합성할 수 있도록 리팩터링합니다.\n\n```javascript\nconst asyncPipe = (...fns) => x => (  \n  fns.reduce(async (y, f) => f(await y), x)  \n);\n\nconst uploadFiles = asyncPipe(  \n  readUser,  \n  getFolderInfo,  \n  haveWriteAccess,  \n  uploadToFolder  \n);\n\nuploadFiles({user, folder, files})  \n  .then(log)  \n;\n```\n\n프로미스는 자체적으로 조건부 분기하도록 설계되어있기 때문에 `if` 로직을 쉽게 제거 할 수 있습니다.  로직과 I/O는 잘 섞이지 않기 때문에 I/O 의존적인 코드에서 로직을 제거하는 것이 좋습니다.\n\n이러한 종류의 합성 작업을 하기 위해서는 다음 두 가지를 보장해야합니다.\n\n1.  `haveWriteAccess()`는 사용자가 쓰기 권한이 없는 경우 거절해야 합니다.  조건 로직을 프로미스 컨텍스트로 옮겼기에 따로 유닛 테스트를 할 필요가 없습니다.(JS 엔진 코드에 자체 테스트가 생성됩니다).\n2.  각 함수는 동일한 데이터 타입을 사용하여 처리됩니다.  우리는 `{ user, folder, files, dbUser?, folderInfo? }`를 키로 사용하는 `pipelineData`  타입을 만든 것 입니다.  이렇게 하면 각 구성 요소들이 특정 구조를 공유한다는 종속성이 생기지만 이러한 함수를 추상화시켜 보다 일반적인 버전을 만들 수 있으며 간단하게 래핑하여 다양한 파이프라인에 적용할 수 있습니다.\n\n이러한 조건들이 충족되면 다른 함수들을 mocking하지 않고 각 함수를 서로 격리하여 테스트하기 쉬워집니다. 우리가 파이프라인에서 모든 로직을 추출했으므로,이 파일에서 유닛 테스트를 하는 것은 아무런 의미가 없습니다.  결국 테스트가 필요해지는 것은 통합 뿐입니다.\n\n> 기억하세요:   _로직과  I/O는 별도의 관심사입니다._\n> _로직이란 생각하는 것입니다._  _효과란 행동입니다._  _행동하기 전에 생각해야 합니다!_\n\n### 미래의 계산을 나타내는 객체 사용\n\nredux-saga의 전략은 미래의 계산을 나타내는 객체를 사용하는 것입니다.  이 아이디어는 모나드를 반환하는 것과 유사합니다. 단, 항상 모나드가 반환되는 것은 아닙니다.  모나드는 체이닝으로 함수를 합성할 수 있지만, 대신 명령형 코드를 사용하여 함수를 수동으로 연결할 수 있습니다.  다음은 redux-saga가 어떻게 동작하는지에 대한 대략적인 스케치입니다.\n\n```javascript\n// sugar for console.log we'll use later  \nconst log = msg => console.log(msg);\n\nconst call = (fn, ...args) => ({ fn, args });  \nconst put = (msg) => ({ msg });\n\n// imported from I/O API  \nconst sendMessage = msg => Promise.resolve('some response');\n\n// imported from state handler/Reducer  \nconst handleResponse = response => ({  \n  type: 'RECEIVED_RESPONSE',  \n  payload: response  \n});\n\nconst handleError = err => ({  \n  type: 'IO_ERROR',  \n  payload: err  \n});  \n  \n\nfunction* sendMessageSaga (msg) {  \n  try {  \n    const response = yield call(sendMessage, msg);  \n    yield put(handleResponse(response));  \n  } catch (err) {  \n    yield put(handleError(err));  \n  }  \n}\n```\n\n네트워크 API를 mocking하거나 부수효과를 일으키지 않고도 모든 호출을 볼 수 있습니다.  보너스 : 비 결정적인 네트워크 상태 등을 걱정하지 않고도 애플리케이션을 매우 쉽게 디버깅 할 수 있습니다.\n\n네트워크 오류를 시뮬레이션하고 싶습니까?  \n간단하게 `iter.throw(NetworkError)`를 호출하면 됩니다.\n\n다른 곳에서는 일부 라이브러리 미들웨어가 함수를 작동시키고 실제로 프로덕션 애플리케이션에서 부수효과를 발생시킵니다.\n\n```javascript\nconst iter = sendMessageSaga('Hello, world!');\n\n// Returns an object representing the status and value:  \nconst step1 = iter.next();\n\nlog(step1);  \n/* =>  \n{  \n  done: false,  \n  value: {  \n    fn: sendMessage  \n    args: [\"Hello, world!\"]  \n  }  \n}  \n*/\n```\n\n `call()`  객체를 해체하여 yield하는 방식으로 미래의 계산을 검사하거나 호출합니다.\n\n```javascript\nconst { value: {fn, args }} = step1;\n```\n\n실제로는 미들웨어에서 실행되며 테스트 및 디버깅 할 때는 이 부분을 건너뛸 수 있습니다.\n\n```javascript\nconst step2 = fn(args);\n\nstep2.then(log); // \"some response\"\n```\n\nAPI 또는 http 호출을 mocking하지 않고 네트워크 응답을 시뮬레이션 하려면  `.next()`에 가짜 리스폰스를 전달하면 됩니다.\n\n```javascript\niter.next (simulatedNetworkResponse); \n```\n\n결국  `done`이  `true`가 될 때까지  `.next()`를  계속 호출하면 됩니다.\n\n유닛 테스트에서 제너레이터와 계산 표현을 사용해 모든 것을 **부수효과 없이** 시뮬레이션할 수 있습니다.  값을  `.next()`에 전달해 가짜 응답을 만들거나 에러를 이터레이터로 전달해 가짜 에러상황 및 거절된 프로미스를 시뮬레이션할 수 있습니다.\n\n결국, 부수효과가 많은 복잡한 통합 워크 플로의 경우에서도 mocking을 할 필요가 없어집니다.\n\n## \"코드 냄새\"는 법칙이 아닌 경고 신호입니다.  Mock은 Evil하지 않습니다.\n\n더 나은 아키텍처를 사용할 수 있음에도 실제로는 다른 사람들의 API를 사용하고 레거시 코드와 통합해야 합니다. 이들 중에는 순수하지 않은 코드들이 많이 있습니다.  이러한 경우에 테스트 더블을 격리시켜 사용해야 합니다. 예를 들어, express는 컨티뉴에이션 패싱 기법으로 공유 가변 상태^shared^ ^mutable^ ^state^ 및 모델의 부수효과들을 전달합니다.\n\n일반적인 예를 살펴 보겠습니다.  사람들은 익스프레스 서버 스크립트에 의존성 주입을 해야한다고 말합니다. 그렇지 않다면 어떻게 익스프레스 앱에 들어가는 것들을 테스트 할 수 있는지 궁금해합니다.  예 :\n\n```javascript\nconst express = require('express');  \nconst app = express();\n\napp.get('/', function (req, res) {  \n  res.send('Hello World!')  \n});\n\napp.listen(3000, function () {  \n  console.log('Example app listening on port 3000!')  \n});\n```\n\n_이 파일_  을 \"유닛 테스트\"하려면,  우리는 의존성 주입 솔루션을 개발한 다음 모든 것을 mocks으로 (아마도  `express()`  자체도 포함해서) 전달해야 할 것입니다.  그러나 이 파일이 매우 복잡해질 경우, 즉 여러 리퀘스트 핸들러들이 서로 다른 익스프레스 기능을 사용하고 있고 다양한 로직들에 의존하고 있다면 아마도 꽤 정교한 mock들을 만들어야 할 것입니다.  저는 개발자들이 익스프레스 인스턴스, 세션 미들웨어, 로그 처리기, 실시간 네트워크 프로토콜 등과 같은 정교한 가짜와 모의 객체를 생성하는 것을 자주 봤습니다.  어떻게 해야 할까요? 대답은 간단합니다.\n\n> 이 파일은 유닛 테스트하면 안됩니다.\n\n익스프레스 앱의 서버 정의 파일은 말 그대로 앱의 주요  **통합**  지점입니다. 이 파일을 테스트한다는 것은 프로그램 로직, 익스프레스 및 앱의 모든 핸들러 간의 통합을 테스트하는 것입니다.  100% 유닛 테스트 커버리지를 달성할 수 있다고 하더라도 통합 테스트를 건너 뛰면 **절대로** 안됩니다.\n\n이 파일을 유닛 테스트하려고 하는 대신 프로그램 로직을 별도의 유닛로 분리하고 유닛 테스트를 하십시오. 서버 파일은 실제 통합 테스트를 해야 합니다. 다시 말해 실제로 네트워크에 연결하고 실제 HTTP 메시지를 주고받고,  [supertest](https://github.com/visionmedia/supertest)와 같은 도구를 사용해 헤더를 테스트하십시오.\n\nHello World Express 예제를 더 쉽게 테스트 할 수 있도록 리팩터링 해 봅시다.\n\n`hello`  핸들러를 자체 파일로 분리해 유닛 테스트를 만들어야 합니다.  앱의 나머지 구성 요소를 mocking할 필요가 없습니다.  이는 분명히 순수 함수가 아니므로  `.send()`  호출하도록 응답 객체를 mocking해야 합니다.\n\n```javascript\n  const hello = (req, res) => res.send ( 'Hello World!'); \n```\n\n이런 식으로 테스트 해 볼 수 있습니다 :\n\n```javascript\n{  \n  const expected = 'Hello World!';  \n  const msg = `should call .send() with ${ expected }`;\n\n  const res = {  \n    send: (actual) => {  \n      if (actual !== expected) {  \n        throw new Error(`NOT OK ${ msg }`);  \n      }  \n      console.log(`OK: ${ msg }`);  \n    }  \n  }\n\n  hello({}, res);  \n}\n```\n\nListen 핸들러를 자체 파일로 분리해 유닛 테스트를 만들겠습니다.  이 때도 같은 문제가 등장합니다.  익스프레스 핸들러들은 순수하지 않으므로 로거를 집어넣어 스파이웨어가 호출되는지 확인해야합니다.  테스트는 이전 예와 비슷합니다.\n\n```javascript\nconst handleListen = \n       (log, port) => \n                () => \n        log(`Example app listening on port ${ port }!`);\n```\n\n이제 서버 파일엔 통합 로직만 남겨졌습니다.\n\n```javascript\nconst express = require('express');\n\nconst hello = require('./hello.js');  \nconst handleListen = require('./handleListen');  \nconst log = require('./log');\n\nconst port = 3000;  \nconst app = express();\n\napp.get('/', hello);\n\napp.listen(port, handleListen(port, log));\n```\n\n여전히 통합 테스트는 필요하지만 유닛 테스트를 아무리 추가해도 케이스 커버리지는 향상되지 않습니다.  우리는 logger를  `handleListen()`에 전달하기 위해 최소한의 의존성 주입 패턴을 사용하지만 의존성 주입 프레임 워크가 필요하진 않습니다.\n\n## 모의(mocking) 테스트는 통합 테스트에 적합합니다.\n\n통합 테스트는 유닛간의 상호작용과 통합을 테스트하기 때문에 CPU 클러스터 또는 네트워크상의 별도의 프로세스에 존재하는 다른 유닛과의 통신 중에 발생할 수있는 다양한 조건과 상황을 재현해야 합니다.  서버나 네트워크 프로토콜, 네트워크 메시지 등을 가짜로 만드는 것은 너무나 당연합니다.\n\n때로는 유닛이 타사 API와 통신하는 것을 테스트해야 하며 때로는 이러한 API가 실제로 테스트하려면 엄청나게 비쌉니다.  실제 서비스에 대한 워크 플로우 트랜잭션을 기록한 후 fake 서버에서 이를 다시 재생하면 유닛이 별도의 네트워크 프로세스에서 실행중인 타사 서비스와 얼마나 잘 통합되어 있는지 테스트할 수 있습니다.  \"이 메시지 헤더가 올바른 형식입니까?\"같은 상황을 테스트하는 가장 좋은 방법입니다.\n\n네트워크 대역폭을 제한하고, 네트워크 지연을 연출하고, 네트워크 오류를 생성하고, 통신 레이어를 mocking하는 등 유닛 테스트가 할 수 없는 많은 다른 조건을 테스트하는 통합 테스트 도구들이 많이 있습니다.\n\n통합 테스트없이 100% 케이스 커버리지를 달성하는 것은 불가능합니다.  100% 유닛 테스트 커버리지를 달성하더라도 이를 건너 뛰면 안됩니다. 100%가 100%가 아닙니다.\n\n\n[**다음: 객체 합성이라는 숨겨진 보물 >**](https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/)","slug":"mocking-is-a-code-smell","published":1,"updated":"2018-04-28T13:40:06.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83e6000mifp6a04foe4k","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/\">다음&gt;</a></p>\n</blockquote>\n<p>TDD와 유닛 테스트를 할 때 가장 손이 많이 가는 부분은 테스트할 유닛을 분리하는 과정에서 필요한 <strong>mocking</strong>을 만드는 일 입니다. 몇몇 사람들은 유닛 테스트가 정말로 의미있는 일인지 의심스러워 하기도 합니다.  실제로, 저는 개발자들이 mock, fake, stub을 만들다 길을 잃고  <em>실제 코드가 전혀 실행되지 않는</em>  유닛 테스트를 작성하는걸 보았습니다. 아이고…</p>\n<p>다른 한편으로는 개발자가 TDD에 스스로를 너무 옭아매는 모습이 자주 보입니다. 이 경우 개발자는 코드베이스를 더 복잡하게 만들어버릴지라도 무조건 100% 코드 커버리지를 달성해야 한다고 생각합니다.</p>\n<p>저는 mocking에서 코드 냄새를 맡으라고  말합니다. 그러나 대부분의 개발자들은 100% 유닛 테스트 커버리지를 달성할 수 있다는 TDD 신봉자 단계를 거치게 되며 이 기간 동안에는 대규모의 모의 객체를 사용하지 않는 세상을 상상할 수 없습니다.  모의 객체<sup>mocks</sup>를 응용 프로그램에 집어 넣기 위해 의존성 주입<sup>dependency</sup> <sup>injection</sup> (DI)함수로 자신의 코드유닛을 감싸거나 더 안좋은 경우, 서비스를 의존성 주입 컨테이너로 만들어버리기도 합니다.</p>\n<p>Angular는 모든 컴포넌트 클래스에 의존성을 주입하며 DI를 기본적인 디커플링 수단으로 사용하도록 유혹합니다.  하지만 의존성 주입이 디커플링을 수행하는 가장 좋은 방법은 아닙니다.</p>\n<h2 id=\"tdd는-더-나은-디자인으로-이어질-때-그-의미가-있습니다\">TDD는 더 나은 디자인으로 이어질 때 그 의미가 있습니다.</h2>\n<blockquote>\n<p>제대로된 TDD를 배운다는 것은 제대로 앱을 모듈화시키는 법을 배우는 것과 같습니다.</p>\n</blockquote>\n<p>TDD는 코드를 복잡하게 만드는것이 아닌 단순하게 만들어야 합니다. 코드를 더 잘 테스트 할 수 있게 고치는 댓가로 가독성과 유지보수성을 내주어선 안됩니다.  DI 보일러 플레이트로 코드를 부풀리고 있다면 잘못된 TDD를 하고있는 겁니다.</p>\n<p>온 세상을 mocking할 수 있다는 환상을가지고 앱에 의존성을 주입하고 있다면 그것이 도움이 되기 보다는 해가 될 가능성이 매우 높습니다.  테스트 가능한 코드를 작성하는 과정에서 코드가 단순해져야 합니다.  우리에게 필요한 것은 적은 수의 코드 라인과 보다 읽기 쉽고 유연하며 유지 보수가 가능한 구조입니다.  의존성 주입은 반대 효과를냅니다.</p>\n<p>제가 말하고 싶은 것은 이 두 가지 입니다.</p>\n<ol>\n<li>의존성 주입 없이도 디커플링된 코드를 작성할 수 있습니다.</li>\n<li>코드 커버리지를 최대화하려는 시도는 좋지 않습니다. 100%에 다가갈수록 애플리케이션 코드는 복잡해지고 결국 버그를 줄인다는 목표를 뒤엎고 말게 됩니다.</li>\n</ol>\n<p>복잡한 코드에는 종종 자질구레한 코드들도 함께 있습니다. 잘 정돈된 코드를 작성하는 것은 집을 깔끔하게 유지하려는 것과 같은 이유입니다.</p>\n<ul>\n<li>코드가 어수선해지면 버그가 숨을 수 있는 편리한 장소가 생기고 더 많은 버그가 발생합니다.</li>\n<li>뭔가를 찾기 위해서는 우선 정돈된 환경이 필요합니다.</li>\n</ul>\n<h2 id=\"코드-냄새code-smell란-무엇입니까\">코드 냄새<sup>Code</sup> <sup>smell</sup>란 무엇입니까?</h2>\n<blockquote>\n<p><em>“코드 냄새란 일반적으로 시스템 깊숙히 숨어있는 문제를 드러내는 표면적인 표시입니다.”~ Martin Fowler</em></p>\n</blockquote>\n<blockquote>\n<p><strong>코드 스멜</strong>(code smell←코드 냄새)은 컴퓨터 프로그래밍 코드에서 더 심오한 문제를 일으킬 가능성이 있는 프로그램 소스 코드의 증상을 가리킨다.  ~ Wikipedia</p>\n</blockquote>\n<p>나쁜 코드 냄새를 맡았다고 해서 곧바로 뭔가 잘못 되었고 이를 고쳐야 한다는 것을 의미하진 않습니다.  코드 냄새란 당신에게 뭔가를 향상시킬 수있는 기회를 알려주는 <em>경험 법칙</em> 입니다.</p>\n<p>이 글은 모든 mocking이 나쁘다는 것을 의미하지 않으며 mocking을 절대 하면 안된다고 말하는게 아닙니다.</p>\n<p>코드의 유형에 따라 다양한 수준 (및 다른 종류)의 mocking이 필요합니다. I/O를 다루는 코드는 I/O 를 테스트하는 것 이외에 다른 방법은 거의 없습니다. 이 경우 모의 테스트를 줄이면 유닛 테스트 커버리지가 0%에 가까워 질 수 있습니다.</p>\n<p>로직이 없는 코드는(파이프와 순수 함수들로만 이루어진) 유닛 테스트 커버리지가 0%가 되어도 괜찮습니다. 대신 통합 또는 기능 테스트 커버리지가 100 %에 가까워질 것입니다.  그러나 로직(조건식, 변수 할당, 메소드 호출 등)이 있다면 유닛 테스트 커버리지가 필요하며, 이 때 코드를 단순화하고 mocking 요구사항을 줄이는 목표를 세울 수 있습니다.</p>\n<h2 id=\"mock모의란-무엇입니까\">Mock(모의)란 무엇입니까?</h2>\n<p>Mock이란 유닛 테스트에서 실제 구현 코드를 대신하는 <strong>테스트 더블</strong><sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>입니다.  모의 객체는 테스트가 진행되는 동안 테스트 코드에 의해 조작, 변경되고 이를 assert 구문으로 확인합니다. Assert 구문에 테스트 더블이 쓰인다면 이는 모의입니다.</p>\n<p>&quot;모의(mock)&quot;라는 용어는 여러 종류의 테스트 더블을 포괄하는 일반적인 용어입니다. 앞으로의 논의에서 우리는 &quot;모의(mock)&quot;와 &quot;테스트 더블(test double)&quot;이라는 단어를 동등하게, 상호 교환적으로 사용하겠습니다.  모든 테스트 더블 (dummies, spies, fake 등)은 테스트 대상과 단단하게 결합된 실제 코드를 나타냅니다. 따라서 테스트 더블은 일종의 커플링이 있다는 것을 뜻하며, 구현을 단순화하고 향상시킬 수 있다는 의미입니다. 그리고 모의 객체가 필요하지 않도록 코드를 바꾸는 것은 테스트를 근본적으로 단순화시키는 방법입니다.</p>\n<h2 id=\"유닛-테스트란-무엇입니까\">유닛 테스트란 무엇입니까?</h2>\n<p><strong>유닛 테스트</strong>는 개별 유닛(모듈, 함수, 클래스)을 나머지 프로그램과 분리하여 테스트하는 행위입니다,</p>\n<p>유닛 테스트와 달리 <strong>통합 테스트</strong><sup>Integration</sup> <sup>test</sup>란 두 개 이상의 유닛 간의 통합을 테스트하는 것입니다.   <strong>기능 테스트</strong><sup>Functional</sup> <sup>test</sup>란 사용자의 관점에서 애플리케이션을 테스트하는 것 입니다.  사용자 워크 플로 테스트는 UI 조작에서 데이터 레이어가 업데이트되고 그것들이 다시 화면에 출력되는 과정을 모두 관찰합니다.  기능 테스트는 앱이 실행되는 맥락에서 모든 장치와 유닛을 테스트하기 때문에 통합 테스트의 하위 집합이라고 볼 수 있습니다.</p>\n<p>일반적으로 유닛은 유닛의 공용 인터페이스 (일명 &quot;퍼블릭 API&quot;또는 “surface area”) 만 사용하여 테스트됩니다.  이것을 <strong>블랙 박스 테스트</strong>라고합니다.  블랙 박스 테스팅은 고장나기 쉬운 테스트입니다.  왜냐하면 시간이 지남에 따라 퍼블릭 API는 그대로인데 유닛의 구현 세부 사항이 변경되기 때문입니다. 내부 구현 방식까지 다루는 화이트 박스 테스트는 더더욱 고장나기 쉬운데, 퍼블릭 API가 예상대로 계속 작동하더라도 구현 세부 사항을 변경하면 테스트가 중단 될 수 있기 때문입니다.  즉, 화이트 박스 테스트에는 훨씬 많은 시간과 노력이 들어갑니다.</p>\n<h2 id=\"테스트-커버리지2란-무엇입니까\">테스트 커버리지<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>란 무엇입니까?</h2>\n<p>코드 커버리지란 테스트 케이스가 다루는 코드의 양을 의미합니다.  테스트 도중 어떤 코드의 행이 사용되었는지 기록하여 커버리지 리포트를 작성합니다. 일반적으로 우리는 커버리지를 높이려고 노력하지만 100 %에 가까워 질수록 테스트 효율이 감소하기 시작합니다.</p>\n<p>경험에 비추어 볼 때, 90%가 넘는 커버리지는 남은 버그들을 없애는데 거의 상관 관계가없는 것 같습니다.</p>\n<p>왜 그럴까요?  100% 테스트 된 코드란 코드가 의도 한대로 작동한다는 것을 100% 확신시켜주는 의미 아닙니까?</p>\n<p>이 문제는 그리 간단하지 않습니다.</p>\n<p>대부분의 사람들은 두 가지 종류의 커버리지가 있다는 것을 모릅니다.</p>\n<ol>\n<li><strong>코드 커버리지</strong> : 코드가 실행되는 정도</li>\n<li><strong>케이스 커버리지</strong> :  테스트 스위트가 커버하는 유스 케이스의 수</li>\n</ol>\n<p>케이스 커버리지는 유스 케이스 시나리오를 다룹니다 : 코드가 실제 환경, 실제 네트워크에서 어떻게 작동할 것인가? 악의적인 목적으로, 소프트웨어 설계를 의도적으로 파괴하려는 해커한테 어떻게 작동 할 것인가?</p>\n<p>커버리지 리포트는 케이스 커버리지가 아닌 코드 커버리지의 부족한 점을 알려줍니다.  그러나 동일한 코드가 둘 이상의 유스 케이스에 적용될 수 있을 뿐더러 단일 유즈 케이스가 테스트 대상 외부에 있는 코드, 별도의 애플리케이션 또는 서드파티 API에 의존 할 수도 있습니다.</p>\n<p>유스 케이스는 환경, 여러 단위, 사용자 및 네트워킹 조건을 포함 할 수 있으므로 필요한 모든 유스 케이스를 유닛 테스트들 밖에 없는 테스트 스위트로 처리하는 것은 불가능합니다.  유닛 테스트는 통합되지 않은, 격리 된 테스트 단위를 의미하므로 유닛 테스트로만 이루어진 테스트 스위트는 항상 통합 및 기능 유스  케이스 시나리오에 대해 거의 0%의 커버리지를 달성하게 될 것입니다.</p>\n<p>100% 코드 커버리지는 100% 케이스 커버리지를 보장하지 않습니다.</p>\n<p>100% 코드 커버리지를 목표로 하는 개발자는 잘못된 목표를 쫓고 있습니다.</p>\n<h2 id=\"단단한-결합tight-coupling이란-무엇입니까\">단단한 결합(Tight Coupling)이란 무엇입니까?</h2>\n<p>모의 객체가 필요하다는 것은 유닛 테스트를 위해 유닛을 분리해야 하며 이 때 유닛간의 결합이 있기 때문입니다.  긴밀한 결합은 코드를보다 단단하고 부서지기 쉽게 만듭니다. 코드가 변경되었을 때 프로그램이 멈추게 됩니다.  일반적으로 느슨한 결합은 코드를 확장하고 유지하기 쉽게 만듭니다. 여기에 더해 mocking에 대한 필요성을 없앰으로써 테스트를 더 쉽게한다는 사실은 두말할 필요도 없습니다.</p>\n<p>이것으로부터 우리가 뭔가를 mocking 하고있다면 그 대신에 유닛간의 결합을 줄임으로써 코드를보다 유연하게 만들 수 있는 가능성이 존재한다는 것을 추론 할 수 있습니다.  그리하면 더 이상 가짜 코드들이 필요하지 않습니다.</p>\n<p>커플링(또는 결합)이란 코드 유닛(모듈, 함수, 클래스 등)이 다른 코드 유닛에 종속되는 정도입니다.  밀접한 결합 또는 높은 결합도는 종속된 코드들이 변경 될 때 유닛이 망가질 가능성을 나타냅니다.  즉, 커플링이 빡빡할수록 응용 프로그램을 유지 관리하거나 확장하는 것이 어렵습니다.  느슨한 결합은 버그를 수정하고 응용 프로그램을 새로운 유스 케이스로 확장 할 때 마주치는 복잡성을 줄입니다.</p>\n<p>커플링에는 여러 형태가 있습니다.</p>\n<ul>\n<li><strong>하위 클래스 커플링 :</strong>  하위 클래스는 상위 클래스의 구현 및 전체 계층 구조에 의존합니다. OO 디자인에서 사용할 수있는 가장 단단한 형태의 결합입니다.</li>\n<li><strong>의존 코드 제어 :</strong>  전달받은 메소드 이름으로 수행 할 작업을 지시하는 것처럼 종속된 유닛들을 제어하는 ​​코드.  API가 변경되면 종속된 코드가 중단됩니다.</li>\n<li><strong>변경 가능한 상태 :</strong>  다른 코드와 변경 가능한 상태를 공유하는 코드. (e.g.공유된 객체의 속성을 변경하는 일)  코드가 실행되는 상대적인 타이밍이 바뀔 경우 종속 코드가 손상 될 수 있습니다.  타이밍이 비 결정적이라면, 모든 종속 유닛을 완전히 뜯어보지 않는 이상 프로그램 정확성을 달성하는 것이 불가능할 수 있습니다. 예를 들어, 해결 불가능한 레이스 컨디션이 있을 수 있습니다.  한 버그를 수정하면 다른 종속 유닛에 새로운 버그가 나타날 수 있습니다.</li>\n<li><strong>형태적 종속성 :</strong>  다른 코드와 특정 데이터 구조를 공유하며 구조의 일부분만 사용하는 코드입니다.  구조적인의 형태가 변경되면 종속 코드가 손상 될 수 있습니다.</li>\n<li><strong>이벤트 / 메시지 커플링 :</strong>  메시지 전달, 이벤트 등을 통해 다른 유닛과 통신하는 코드.</li>\n</ul>\n<h2 id=\"무엇이-단단한-결합을-만드는가\">무엇이 단단한 결합을 만드는가?</h2>\n<p>단단한 결합에는 많은 원인이 있습니다.</p>\n<ul>\n<li><strong>변이</strong>  vs  <em>불변성</em></li>\n<li><strong>부수효과</strong>  vs  <em>순수함 /부수효과를 분리</em></li>\n<li><strong>책임 과부하</strong>  vs  <em>Do One Thing (DOT)</em></li>\n<li><strong>절차를 기술</strong>  vs  <em>구조를 기술</em></li>\n<li><strong>명령형 구성</strong>  vs  <em>선언적인 구성</em></li>\n</ul>\n<p>명령형 및 객체 지향 코드는 함수형 코드보다 단단하게 결합되기 쉽습니다.  그러나  함수형 스타일로 프로그래밍한다고 해서 단단한 결합에 무적이 되진 않습니다. 다만 함수형 프로그래밍은 프로그램의 기본 구성 단위로 순수 함수를 사용하며 이는  본질적으로 느슨한 결합들을 형성합니다.</p>\n<p>순수 함수 :</p>\n<ul>\n<li>동일한 입력이 주어지면 항상 동일한 출력을 반환</li>\n<li>부수효과 없음</li>\n</ul>\n<p>순수 함수는 어떻게 결합도를 낮출까요?</p>\n<ul>\n<li><strong>Immutability :</strong>  순수 함수는 기존 값을 변경하지 않습니다.  대신 새로운 값을 반환합니다.</li>\n<li><strong>No side effects :</strong>  순수 함수가 유일하게 표현하는 것은 리턴 값입니다. 따라서 화면, DOM, 콘솔, 표준 입출력, 네트워크, 디스크 입출력 등과 같은 외부 상태와 연관있는 다른 함수의 조작을 방해할 가능성이 없습니다.</li>\n<li><strong>Do One Thing :</strong>  순수 함수는 단일 임무를 수행합니다. 입력과 출력을 맵핑하는 임무입니다.  객체 및 클래스 기반 코드는 몇줄 안되는 코드에게 과한 책임을 지우는 경향이 있습니다. 책임 과부하를 피하십시오.</li>\n<li><strong>Structure, not instructions :</strong>  순수 함수는 안전하게 메모이제이션 할 수 있습니다. 즉, 시스템 메모리가 무한하다고 가정할 때  함수 입력을 인덱스로 사용하여 테이블에서 해당 값을 검색하는 조회 테이블로 바꿀 수 있습니다.  다시 말해 순수 함수는 컴퓨터에게 내리는 명령이 아닌 데이터 간의 구조적 관계를 설명하므로 서로 충돌하는 두 가지 명령이 서로의 발가락을 밟고 문제를 일으킬 수 없습니다.</li>\n</ul>\n<h2 id=\"합성은-mocking과-무슨-관계가-있습니까\">합성은 mocking과 무슨 관계가 있습니까?</h2>\n<p><strong>Everything</strong>.  소프트웨어 개발의 본질은 큰 문제를 작고 독립적인 조각으로 분해하고 작은 솔루션들을 합쳐 큰 문제를 해결하는 과정입니다.</p>\n<blockquote>\n<p>문제를 분해하는 전략이 실패했을 때 mocking이 필요해집니다.</p>\n</blockquote>\n<p>큰 문제를 작은 부분으로 나누는 데 사용되는 조그만  유닛이 서로 의존 할 때 mocking이 필요합니다.  다시 말하자면  <em>우리가 생각한  원자 단위가 실제로 원자가 아니며,</em>  우리의 분해 전략이 큰 문제를 더 작고 독립적인 문제로 분해하지 못했을 때 필요합니다.</p>\n<p>문제를 성공적으로 분해했다면 일반적인 합성 유틸리티들을 사용해 솔루션 조각들을 다시 합칠 수 있습니다.  예 :</p>\n<ul>\n<li><strong>함수 합성</strong>  e.g.,  <code>lodash/fp/compose</code></li>\n<li><strong>컴포넌트 합성</strong>  e.g., 함수 합성으로 고차 컴포넌트 작성</li>\n<li><strong>상태 저장소/모델 합성</strong>  e.g.,  <a href=\"http://redux.js.org/docs/api/combineReducers.html\" target=\"_blank\" rel=\"noopener\">Redux combineReducers</a></li>\n<li><strong>객체 또는 팩토리 합성</strong> e.g. 객체 믹스인 또는 함수형 믹스인</li>\n<li><strong>프로세스 합성</strong>  e.g. 트랜스듀서<sup>transducer</sup> <sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup></li>\n<li><strong>프로미스 또는 모나드 합성</strong>  e.g., <code>asyncPipe()</code>  또는  <code>composeM()</code>,  <code>composeK()</code> Kleisli 합성</li>\n<li>기타…</li>\n</ul>\n<p>이러한 유틸리티들을 사용하는 경우 합성의 재료가 되는 각 요소들은 다른 요소를  <em>mocking하지 않고도</em>  격리 된 유닛 테스트를 수행 할 수 있습니다  <em>.</em></p>\n<p>합성 자체는 완벽하게 선언적이므로  <em>유닛 테스트</em> 가 필요한 로직이 없습니다. (그리고 이런 합성 유틸리티는 자체적인 유닛 테스트가 있는 서드파티 라이브러리입니다).</p>\n<p>이러한 상황에서 유닛 테스트를 하는 건 아무런 의미가 없습니다.  대신 통합 테스트가 필요합니다.</p>\n<p>익숙한 예제를 가지고 명령적<sup>Imperative</sup> 합성과 선언적<sup>Declarative</sup> 합성을 비교해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Function composition OR  </span></span><br><span class=\"line\"><span class=\"comment\">// import pipe from 'lodash/fp/flow';  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Functions to compose  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Imperative composition  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doStuffBadly = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterG = g(x);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterF = f(afterG);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> afterF;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Declarative composition  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doStuffBetter = pipe(g, f);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  doStuffBadly(<span class=\"number\">20</span>), <span class=\"comment\">// 42  </span></span><br><span class=\"line\">  doStuffBetter(<span class=\"number\">20</span>) <span class=\"comment\">// 42  </span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>함수 합성은 함수의 반환 값에 다른 함수를 적용하는 프로세스입니다.  즉, 함수의 파이프 라인을 만든 다음 입력 값을 파이프 라인에 전달하면 물건이 공장 조립 라인을 통과하듯 값이 개별 함수들을 거쳐가며 변환됩니다.  결국, 파이프 라인의 마지막 함수는 최종 값을 반환합니다.</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">initialValue</span> -&gt;</span> [<span class=\"function\"><span class=\"title\">g</span>] -&gt;</span> [<span class=\"function\"><span class=\"title\">f</span>] -&gt;</span> result</span><br></pre></td></tr></table></figure>\n<p>이는 패러다임과 무관하게 모든 주류 언어들이 애플리케이션 코드를 구성하는 주요 수단입니다.  자바조차도 클래스 인스턴스간 메세지를 전달하는 기본 메커니즘으로 함수 (메소드)를 사용합니다.</p>\n<p>함수를 수동으로(명령형으로) 합성하거나 자동으로(선언적으로) 합성할 수 있습니다. 함수가 퍼스트 클래스가 아닌 언어에서는 선택권이 많지 않습니다. 명령형으로 할 수 밖에 없습니다.  자바 스크립트 (그리고 거의 모든 주요 대중 언어)에서는 선언적으로 합성할 수 있습니다.</p>\n<p>명령형이란 컴퓨터에게 단계적으로 뭔가를 수행하도록 명령한다는 의미입니다. How-To 가이드입니다.  위의 예에서 명령형 스타일은 다음과 같습니다.</p>\n<ol>\n<li>인수를 취하여  <code>x</code> 를 대입하십시오.</li>\n<li><code>afterG</code>  라는 바인딩을 선언하고 <code>g(x)</code> 의 결과를 할당하십시오.</li>\n<li><code>afterF</code>  라는 바인딩을 선언하고  <code>f(afterG)</code>  의 결과를 할당합니다.</li>\n<li><code>afterF</code>  의 값을 리턴합니다.</li>\n</ol>\n<p>명령형 버전에는 테스트해야 할 로직들이 있습니다.  비록 단순한 과제일지라도 잘못된 변수를 전달하거나 리턴하는 곳에서 버그가 발생하는 것을 자주 보았습니다.</p>\n<p>선언적 스타일은 우리가 사물 간의 관계를 컴퓨터에 알리는 것을 의미합니다. 그것은 등식을 사용해서 구조에 대해 설명하는 것 입니다.  선언적 스타일은 다음과 같습니다 :</p>\n<ul>\n<li><code>doStuffBetter</code> 는  <code>g</code> 와  <code>f</code> 의 파이프 컴포지션입니다.</li>\n</ul>\n<p>이게 전부입니다.</p>\n<p><code>f</code>와  <code>g</code>에 대한 유닛 테스트가 존재하고  <code>pipe()</code>가 자체 유닛 테스트 (Ramda의  <code>pipe()</code>  또는 Lodash의 <code>flow()</code> 를 사용)를 사용한다고 가정하면 더이상 유닛 테스트를 해야될 로직이 없습니다.</p>\n<p>이 스타일이 올바르게 작동하려면 유닛들이  <em>분리</em> 되어야 합니다.</p>\n<h2 id=\"커플링을-제거하려면-어떻게-해야합니까\">커플링을 제거하려면 어떻게 해야합니까?</h2>\n<p>커플링을 제거하려면 먼저 종속성이 어디서 발생하며 그 형태가 어떤지 알아야 합니다. 다음은 중요한 예들입니다. 그 순서는 대략적으로 커플링의 긴밀한 정도입니다.</p>\n<p>단단한 결합 :</p>\n<ul>\n<li>클래스 상속 (상속 계층이 증가할 때마다, 각 자손 클래스가 많아질 때 마다 결합도는 배가 됩니다)</li>\n<li>전역 변수</li>\n<li>변경 가능한 전역 상태 (브라우저 DOM, 공유 저장소, 네트워크 등)</li>\n<li>부수효과가 있는 모듈 가져오기</li>\n<li>합성 과정에 숨어든 암시적인 종속성  e.g., <code>const enhancedWidgetFactory = compose(eventEmitter, widgetFactory, enhancements);</code>  <code>widgetFactory</code>는 <code>eventEmitter</code>에게 의존합니다.</li>\n<li>의존성 주입 컨테이너</li>\n<li>의존성 주입 파라미터</li>\n<li>컨트롤 파라미터 (외부 유닛이 해당 유닛의행동을 지시하고 통제하는 것)</li>\n<li>변경 가능한 매개 변수</li>\n</ul>\n<p>느슨한 결합:</p>\n<ul>\n<li>부수효과가 없는 모듈 가져오기 (블랙 박스 테스트를 할 때 import된 모든 모듈을 분리할 필요는 없음)</li>\n<li>메시지 전달 / pubsub</li>\n<li>변경 불가능한 매개 변수</li>\n</ul>\n<p>아이러니하게도, 커플링을 발생시키는 원인의 대부분은 원래 커플링을 줄이기 위해 설계된 메커니즘들입니다. 왜냐하면 문제를 풀기 위한 작은 솔루션들을 완전한 애플리케이션으로 재구성하기 위해 어떻게든 이들을 통합하고 연결해야 했기 때문입니다.  좋은 방법과 나쁜 방법이 있을 뿐입니다.  단단한 커플링을 유발하는 원인들이 실제로 그렇게 되는 경우에는 피해야 합니다.  느슨한 커플링 옵션은 일반적으로 건강한 앱을 만드는 바람직한 방법입니다.</p>\n<p>많은 책과 블로그 포스트에서 의존성 주입 컨테이너와 매개 변수를 &quot;느슨한 결합&quot;으로 분류합니다. 왜 이들이 “단단한 커플링” 그룹에 속하는지 혼란스러울 수 있습니다.  커플링은 바이너리가 아닙니다.  그라디언트 스케일입니다.  즉, 어떤 그룹에든 다소 주관적이고 임의적으로 속할 수 있습니다.</p>\n<p>따라서 제가 간단하고 객관적인 리트머스 테스트를 준비했습니다.</p>\n<p>의존성을 mocking하지 않고 유닛을 테스트 할 수 있습니까?  그렇게 할 수 없다면 mocking은 의존성과  <em>밀접하게 결합</em>  되어 있는 것입니다.</p>\n<p>유닛의 종속성이 높을수록 문제가 되는 커플링이 발생할 가능성이 커집니다. 커플링이 어디서 발생하는지 이해했습니다. 이제 어떻게 해야 하는지 알아보겠습니다.</p>\n<ol>\n<li>클래스, 명령형 프로시저 또는 무언가를 변경하는 함수 대신 <strong>순수 함수</strong>를 프로그램의 원자 단위로 사용하십시오.</li>\n<li>프로그램 로직과  <strong>부수효과</strong>를  <strong>격리</strong>하십시오.  즉, I/O (네트워크, 디스크 I/O, UI 렌더링, 로깅 등)와 로직을 섞지 마십시오.</li>\n<li>독립적인 구성 요소에서  <strong>종속성을 만드는 로직</strong>을  <strong>제거</strong>하여 유닛 테스트가 필요없는 선언적 구성이 될 수 있도록 하십시오.  로직이 없다면 단위 테스트에 아무런 의미가 없습니다.</li>\n</ol>\n<p>즉, 네트워크 요청을 설정하고 핸들러를 요청하는 코드는 유닛 테스트가 필요하지 않습니다. 대신 통합 테스트를 하십시오.</p>\n<blockquote>\n<p><em>I/O를 유닛 테스트 하지 마십시오.</em></p>\n</blockquote>\n<blockquote>\n<p><em>I/O는 통합을 위한 것입니다.</em>  <em>통합 테스트를 하십시오.</em></p>\n</blockquote>\n<p>통합 테스트를 위해 mocking하고 가짜를 만드는 것은 전혀 문제되지 않습니다.</p>\n<h2 id=\"순수-함수-사용\">순수 함수 사용</h2>\n<p>순수 함수를 사용하기 위해선 약간의 연습이 필요하며, 그러한 연습 없이는 원하는 작업을 수행하기 위해 코드를 작성하는 방법이 명확하지 않을 수 있습니다. 순수 함수는 전역 변수, 전달 된 인수, 네트워크, 디스크 또는 화면을 직접 변경할 수 없습니다. 오로지 값을 반환하는 일만 할 수 있습니다.</p>\n<p>순수 함수가 배열이나 객체를 전달받아 해당 객체의 변경된 버전을 반환는 경우 객체를 변경하고 리턴할 수 없습니다. 객체의 새 사본을 만들어 변경사항을 적용하고 리턴해야 합니다. 배열  <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype\" target=\"_blank\" rel=\"noopener\">접근 메소드</a>  (변경 메소드가 아님),  <code>Object.assign()</code>, 빈 객체를 생성, 배열 또는 객체 스프레드 구문을 사용하여 이를 수행 할 수 있습니다.  예 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Not pure  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> signInUser = <span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.isSignedIn = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;  </span><br><span class=\"line\">  name: <span class=\"string\">'Foo'</span>,  </span><br><span class=\"line\">  isSignedIn: <span class=\"literal\">false</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Foo was mutated  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  signInUser(foo), <span class=\"comment\">// true  </span></span><br><span class=\"line\">  foo              <span class=\"comment\">// &#123; name: \"Foo\", isSignedIn: true &#125;  </span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>vs…</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Pure  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> signInUser = <span class=\"function\"><span class=\"params\">user</span> =&gt;</span> (&#123;...user, <span class=\"attr\">isSignedIn</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;  </span><br><span class=\"line\">  name: <span class=\"string\">'Foo'</span>,  </span><br><span class=\"line\">  isSignedIn: <span class=\"literal\">false</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Foo was not mutated  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  signInUser(foo), <span class=\"comment\">// &#123; name: \"Foo\", isSignedIn: true &#125;  </span></span><br><span class=\"line\">  foo              <span class=\"comment\">// &#123; name: \"Foo\", isSignedIn: false &#125;  </span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>또는 <a href=\"http://swannodette.github.io/mori/\" target=\"_blank\" rel=\"noopener\">Mori</a>,  <a href=\"https://facebook.github.io/immutable-js/\" target=\"_blank\" rel=\"noopener\">Immutable.js</a>와 같은 불변 데이터 타입 라이브러리를 사용하는 방법도 있습니다.  언젠가 JavaScript가 Clojure와 비슷한 불변 데이터 타입을 지원해주기를 바라고 있습니다.</p>\n<p>기존 객체를 재사용하는 대신 새 객체를 생성하기 때문에 성능이 저하될 수 있다고 생각할 수도 있지만, 여기엔 사실 좋은 부수효과 있습니다. 객체의 변경여부를 항등연산자로 (  <code>===</code>  ) 확인할 수 있습니다. 즉, 우리는 하나라도 변경된 것을 발견하기 위해 객체 내부를 구석구석 확인하지 않아도 됩니다.</p>\n<p>이 방법을 사용하면 복잡한 상태 트리가 있는 React 구성 요소를 더 빨리 렌더링할 수 있습니다. 각 렌더 패스 별로 심도있게 순회할 필요가 없어지기 때문입니다. <code>PureComponent</code>를 상속하여 얕은 <code>prop</code> 및 <code>state</code> 비교로  <code>shouldComponentUpdate()</code>를 구현할 수 있게됩니다.  객체의 주소가 변경되지 않았음을 탐지하면 상태 트리의 해당 부분에서 아무 것도 변하지 않았으며 트리를 모두 순회하지 않고도 계속 진행하면 된다는 것을 알 수 있습니다.</p>\n<p>순수 함수는 메모이제이션 할 수 있습니다. 이전에 동일한 입력을 처리한적이 있다면 전체 객체를 다시 만들 필요가 없습니다. 미리 계산 된 값을 테이블에 저장하는 방식으로 계산 복잡도를 메모리와 교환할 수 있습니다. 많은 메모리가 필요하지 않고 계산적으로 비싼 프로세스의 경우, 이는 훌륭한 최적화 전략이 될 수 있습니다.</p>\n<p>순수 함수는 또한 부수효과가 없기 때문에 <strong>분할-정복</strong> 전략을 사용하여 분산처리시스템에게 계산을 맡기는 것이 안전합니다.  이 전략은 원래 그래픽 용으로 설계된  GPU를 사용하여 이미지, 비디오 또는 오디오 프레임을 처리하는 데 주로 사용되지만 시뮬레이션, 과학실험 컴퓨팅과 같은 다른 용도로 많이 사용됩니다.</p>\n<p>다시 말해, 값을 변경하는 방식이 항상 빠르지는 않으며 매크로 최적화를 희생하여 마이크로 최적화를 수행하기 때문에 더 느린 경우가 많습니다.</p>\n<h2 id=\"프로그램의-주요-로직과-부수효과를-분리\">프로그램의 주요 로직과 부수효과를 분리</h2>\n<p>부수효과와 나머지 프로그램 로직을 분리하는데 도움이 되는 몇 가지 전략이 있습니다.  다음은 그 중 일부입니다.</p>\n<ol>\n<li>pub/sub 패턴을 사용하여 뷰와 프로그램 로직에서 I/O를 분리하십시오.  UI 뷰와 프로그램 로직에서 부수효과를 발생시키는 코드를 직접 호출하는 대신 이벤트 또는 액션 객체를 보내 통신하는게 좋습니다.</li>\n<li>I/O에서 로직을 분리하십시오. e.g.,  <code>asyncPipe()</code>를 사용해 프로미스를 리턴하는 함수를 합성</li>\n<li>I/O 코드에서 직접 계산 하지 않고 지연된 계산을 표현하는 객체를 사용하십시오. e.g.,  <a href=\"https://github.com/redux-saga/redux-saga\" target=\"_blank\" rel=\"noopener\">redux-saga</a>의  <code>call()</code>  은 실제로 함수를 호출하지 않습니다.  대신, 함수와 인수에 대한 레퍼런스가 담긴 객체를 반환하며, saga 미들웨어가 이를 호출합니다.  따라서  <code>call()</code>과 그것을 사용하는 모든 함수가  <em>순수 함수가되고</em>, 쉽게 유닛 테스트를 만들 수 있으며  <em>mocking이 필요하지 않습니다.</em></li>\n</ol>\n<h3 id=\"pub-sub-사용\">pub / sub 사용</h3>\n<p>Pub/sub은 게시<sup>Publish</sup>/구독<sup>Subscribe</sup> 패턴의 약자입니다.  이 패턴에서 유닛은 서로 직접 호출하지 않습니다.  대신, 다른 유닛(구독자)가 들을 수있는 메시지를 게시합니다.  게시자는 어떤 유닛이 자신을 구독할지 알지 못하며 구독자는 게시자가 게시할 내용을 알지 못합니다.</p>\n<p>Pub/sub의 좋은 예로 DOM(Document Object Model)이 있습니다.  애플리케이션의 모든 컴포넌트는 마우스 이동, 클릭, 스크롤 이벤트, 키 입력 등과 같이 DOM 요소에서 전달 된 이벤트를 수신 할 수 있습니다.  모든 사람들이 jQuery로 웹 애플리케이션을 만들던 시절, jQuery의 커스텀 이벤트는 DOM을 pub/sub 이벤트 버스로 사용하여 렌더링과 로직을 분리했습니다.</p>\n<p>Pub/sub는 또한 Redux에서 볼 수 있습니다.  Redux에서는 애플리케이션 상태에 대한 전역 모델(저장소라고 함)을 만듭니다. 직접 모델을 조작하는 대신 뷰 및 I/O 핸들러는 액션 객체를 저장소에 보냅니다(dispatch라고 표현합니다).  액션 객체가 가지고 있는 <code>type</code>이라는 특별한 키를 다양한 reducers들이 듣고 응답할 수 있습니다. 또한 Redux는 특정 액션 타입을 수신하고 응답 할 수있는 미들웨어를 지원합니다.  이렇게하면 뷰에서 애플리케이션 상태가 처리되는 방법을 알 필요가 없으며 상태 로직이 뷰에 대해 알 필요가 없습니다.</p>\n<p>덕분에 디스패처를 간단하게 수정하는 것 만으로 미들웨어를 통해 액션 로깅/분석, 저장소 또는 서버와의 상태 동기화, 서버 및 네트워크 피어와의 실시간 통신 기능 패치와 같은 복잡한 문제들을 다룰 수 있습니다.</p>\n<h3 id=\"io와-로직을-분리\">I/O와 로직을 분리</h3>\n<p>모나드(e.g., 프로미스) 합성을 ​​사용해 프로그램의 의존 로직을 제거할 수 있습니다. 예를 들어 다음 함수의 로직은 모든 비동기 함수를 mocking하지 않고서는 유닛 테스트를 할 수 없게 설계되어있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uploadFiles</span>(<span class=\"params\">&#123;user, folder, files&#125;</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> dbUser = <span class=\"keyword\">await</span> readUser(user);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> folderInfo = <span class=\"keyword\">await</span> getFolderInfo(folder);  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">await</span> haveWriteAccess(&#123;dbUser, folderInfo&#125;)) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> uploadToFolder(&#123;dbUser, folderInfo, files &#125;);  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"No write access to that folder\"</span>);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이를 실행할 수 있도록 도와주는 의사 코드를 작성해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(...args);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Ignore these. In your real code you'd import  </span></span><br><span class=\"line\"><span class=\"comment\">// the real things.  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> readUser = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"literal\">true</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> getFolderInfo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"literal\">true</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> haveWriteAccess = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"literal\">true</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> uploadToFolder = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'Success!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gibberish starting variables  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"string\">'123'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> folder = <span class=\"string\">'456'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> files = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uploadFiles</span>(<span class=\"params\">&#123;user, folder, files&#125;</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> dbUser = <span class=\"keyword\">await</span> readUser(&#123; user &#125;);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> folderInfo = <span class=\"keyword\">await</span> getFolderInfo(&#123; folder &#125;);  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">await</span> haveWriteAccess(&#123;dbUser, folderInfo&#125;)) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> uploadToFolder(&#123;dbUser, folderInfo, files &#125;);  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"No write access to that folder\"</span>);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uploadFiles(&#123;user, folder, files&#125;)  </span><br><span class=\"line\">  .then(log)  </span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<p><code>asyncPipe()</code>로 프로미스를 합성할 수 있도록 리팩터링합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncPipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; (  </span><br><span class=\"line\">  fns.reduce(<span class=\"keyword\">async</span> (y, f) =&gt; f(<span class=\"keyword\">await</span> y), x)  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> uploadFiles = asyncPipe(  </span><br><span class=\"line\">  readUser,  </span><br><span class=\"line\">  getFolderInfo,  </span><br><span class=\"line\">  haveWriteAccess,  </span><br><span class=\"line\">  uploadToFolder  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">uploadFiles(&#123;user, folder, files&#125;)  </span><br><span class=\"line\">  .then(log)  </span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<p>프로미스는 자체적으로 조건부 분기하도록 설계되어있기 때문에 <code>if</code> 로직을 쉽게 제거 할 수 있습니다.  로직과 I/O는 잘 섞이지 않기 때문에 I/O 의존적인 코드에서 로직을 제거하는 것이 좋습니다.</p>\n<p>이러한 종류의 합성 작업을 하기 위해서는 다음 두 가지를 보장해야합니다.</p>\n<ol>\n<li><code>haveWriteAccess()</code>는 사용자가 쓰기 권한이 없는 경우 거절해야 합니다.  조건 로직을 프로미스 컨텍스트로 옮겼기에 따로 유닛 테스트를 할 필요가 없습니다.(JS 엔진 코드에 자체 테스트가 생성됩니다).</li>\n<li>각 함수는 동일한 데이터 타입을 사용하여 처리됩니다.  우리는 <code>{ user, folder, files, dbUser?, folderInfo? }</code>를 키로 사용하는 <code>pipelineData</code>  타입을 만든 것 입니다.  이렇게 하면 각 구성 요소들이 특정 구조를 공유한다는 종속성이 생기지만 이러한 함수를 추상화시켜 보다 일반적인 버전을 만들 수 있으며 간단하게 래핑하여 다양한 파이프라인에 적용할 수 있습니다.</li>\n</ol>\n<p>이러한 조건들이 충족되면 다른 함수들을 mocking하지 않고 각 함수를 서로 격리하여 테스트하기 쉬워집니다. 우리가 파이프라인에서 모든 로직을 추출했으므로,이 파일에서 유닛 테스트를 하는 것은 아무런 의미가 없습니다.  결국 테스트가 필요해지는 것은 통합 뿐입니다.</p>\n<blockquote>\n<p>기억하세요:   <em>로직과  I/O는 별도의 관심사입니다.</em><br>\n<em>로직이란 생각하는 것입니다.</em>  <em>효과란 행동입니다.</em>  <em>행동하기 전에 생각해야 합니다!</em></p>\n</blockquote>\n<h3 id=\"미래의-계산을-나타내는-객체-사용\">미래의 계산을 나타내는 객체 사용</h3>\n<p>redux-saga의 전략은 미래의 계산을 나타내는 객체를 사용하는 것입니다.  이 아이디어는 모나드를 반환하는 것과 유사합니다. 단, 항상 모나드가 반환되는 것은 아닙니다.  모나드는 체이닝으로 함수를 합성할 수 있지만, 대신 명령형 코드를 사용하여 함수를 수동으로 연결할 수 있습니다.  다음은 redux-saga가 어떻게 동작하는지에 대한 대략적인 스케치입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sugar for console.log we'll use later  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"function\"><span class=\"params\">msg</span> =&gt;</span> <span class=\"built_in\">console</span>.log(msg);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> call = <span class=\"function\">(<span class=\"params\">fn, ...args</span>) =&gt;</span> (&#123; fn, args &#125;);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> put = <span class=\"function\">(<span class=\"params\">msg</span>) =&gt;</span> (&#123; msg &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// imported from I/O API  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sendMessage = <span class=\"function\"><span class=\"params\">msg</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'some response'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// imported from state handler/Reducer  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> handleResponse = <span class=\"function\"><span class=\"params\">response</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  type: <span class=\"string\">'RECEIVED_RESPONSE'</span>,  </span><br><span class=\"line\">  payload: response  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> handleError = <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  type: <span class=\"string\">'IO_ERROR'</span>,  </span><br><span class=\"line\">  payload: err  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">sendMessageSaga</span> (<span class=\"params\">msg</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">yield</span> call(sendMessage, msg);  </span><br><span class=\"line\">    <span class=\"keyword\">yield</span> put(handleResponse(response));  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">yield</span> put(handleError(err));  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>네트워크 API를 mocking하거나 부수효과를 일으키지 않고도 모든 호출을 볼 수 있습니다.  보너스 : 비 결정적인 네트워크 상태 등을 걱정하지 않고도 애플리케이션을 매우 쉽게 디버깅 할 수 있습니다.</p>\n<p>네트워크 오류를 시뮬레이션하고 싶습니까?<br>\n간단하게 <code>iter.throw(NetworkError)</code>를 호출하면 됩니다.</p>\n<p>다른 곳에서는 일부 라이브러리 미들웨어가 함수를 작동시키고 실제로 프로덕션 애플리케이션에서 부수효과를 발생시킵니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> iter = sendMessageSaga(<span class=\"string\">'Hello, world!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns an object representing the status and value:  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> step1 = iter.next();</span><br><span class=\"line\"></span><br><span class=\"line\">log(step1);  </span><br><span class=\"line\"><span class=\"comment\">/* =&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">&#123;  </span></span><br><span class=\"line\"><span class=\"comment\">  done: false,  </span></span><br><span class=\"line\"><span class=\"comment\">  value: &#123;  </span></span><br><span class=\"line\"><span class=\"comment\">    fn: sendMessage  </span></span><br><span class=\"line\"><span class=\"comment\">    args: [\"Hello, world!\"]  </span></span><br><span class=\"line\"><span class=\"comment\">  &#125;  </span></span><br><span class=\"line\"><span class=\"comment\">&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p><code>call()</code>  객체를 해체하여 yield하는 방식으로 미래의 계산을 검사하거나 호출합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"attr\">value</span>: &#123;fn, args &#125;&#125; = step1;</span><br></pre></td></tr></table></figure>\n<p>실제로는 미들웨어에서 실행되며 테스트 및 디버깅 할 때는 이 부분을 건너뛸 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> step2 = fn(args);</span><br><span class=\"line\"></span><br><span class=\"line\">step2.then(log); <span class=\"comment\">// \"some response\"</span></span><br></pre></td></tr></table></figure>\n<p>API 또는 http 호출을 mocking하지 않고 네트워크 응답을 시뮬레이션 하려면  <code>.next()</code>에 가짜 리스폰스를 전달하면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iter.next (simulatedNetworkResponse);</span><br></pre></td></tr></table></figure>\n<p>결국  <code>done</code>이  <code>true</code>가 될 때까지  <code>.next()</code>를  계속 호출하면 됩니다.</p>\n<p>유닛 테스트에서 제너레이터와 계산 표현을 사용해 모든 것을 <strong>부수효과 없이</strong> 시뮬레이션할 수 있습니다.  값을  <code>.next()</code>에 전달해 가짜 응답을 만들거나 에러를 이터레이터로 전달해 가짜 에러상황 및 거절된 프로미스를 시뮬레이션할 수 있습니다.</p>\n<p>결국, 부수효과가 많은 복잡한 통합 워크 플로의 경우에서도 mocking을 할 필요가 없어집니다.</p>\n<h2 id=\"quot코드-냄새quot는-법칙이-아닌-경고-신호입니다-mock은-evil하지-않습니다\">&quot;코드 냄새&quot;는 법칙이 아닌 경고 신호입니다.  Mock은 Evil하지 않습니다.</h2>\n<p>더 나은 아키텍처를 사용할 수 있음에도 실제로는 다른 사람들의 API를 사용하고 레거시 코드와 통합해야 합니다. 이들 중에는 순수하지 않은 코드들이 많이 있습니다.  이러한 경우에 테스트 더블을 격리시켜 사용해야 합니다. 예를 들어, express는 컨티뉴에이션 패싱 기법으로 공유 가변 상태<sup>shared</sup> <sup>mutable</sup> <sup>state</sup> 및 모델의 부수효과들을 전달합니다.</p>\n<p>일반적인 예를 살펴 보겠습니다.  사람들은 익스프레스 서버 스크립트에 의존성 주입을 해야한다고 말합니다. 그렇지 않다면 어떻게 익스프레스 앱에 들어가는 것들을 테스트 할 수 있는지 궁금해합니다.  예 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;  </span><br><span class=\"line\">  res.send(<span class=\"string\">'Hello World!'</span>)  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Example app listening on port 3000!'</span>)  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><em>이 파일</em>  을 &quot;유닛 테스트&quot;하려면,  우리는 의존성 주입 솔루션을 개발한 다음 모든 것을 mocks으로 (아마도  <code>express()</code>  자체도 포함해서) 전달해야 할 것입니다.  그러나 이 파일이 매우 복잡해질 경우, 즉 여러 리퀘스트 핸들러들이 서로 다른 익스프레스 기능을 사용하고 있고 다양한 로직들에 의존하고 있다면 아마도 꽤 정교한 mock들을 만들어야 할 것입니다.  저는 개발자들이 익스프레스 인스턴스, 세션 미들웨어, 로그 처리기, 실시간 네트워크 프로토콜 등과 같은 정교한 가짜와 모의 객체를 생성하는 것을 자주 봤습니다.  어떻게 해야 할까요? 대답은 간단합니다.</p>\n<blockquote>\n<p>이 파일은 유닛 테스트하면 안됩니다.</p>\n</blockquote>\n<p>익스프레스 앱의 서버 정의 파일은 말 그대로 앱의 주요  <strong>통합</strong>  지점입니다. 이 파일을 테스트한다는 것은 프로그램 로직, 익스프레스 및 앱의 모든 핸들러 간의 통합을 테스트하는 것입니다.  100% 유닛 테스트 커버리지를 달성할 수 있다고 하더라도 통합 테스트를 건너 뛰면 <strong>절대로</strong> 안됩니다.</p>\n<p>이 파일을 유닛 테스트하려고 하는 대신 프로그램 로직을 별도의 유닛로 분리하고 유닛 테스트를 하십시오. 서버 파일은 실제 통합 테스트를 해야 합니다. 다시 말해 실제로 네트워크에 연결하고 실제 HTTP 메시지를 주고받고,  <a href=\"https://github.com/visionmedia/supertest\" target=\"_blank\" rel=\"noopener\">supertest</a>와 같은 도구를 사용해 헤더를 테스트하십시오.</p>\n<p>Hello World Express 예제를 더 쉽게 테스트 할 수 있도록 리팩터링 해 봅시다.</p>\n<p><code>hello</code>  핸들러를 자체 파일로 분리해 유닛 테스트를 만들어야 합니다.  앱의 나머지 구성 요소를 mocking할 필요가 없습니다.  이는 분명히 순수 함수가 아니므로  <code>.send()</code>  호출하도록 응답 객체를 mocking해야 합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> res.send ( <span class=\"string\">'Hello World!'</span>);</span><br></pre></td></tr></table></figure>\n<p>이런 식으로 테스트 해 볼 수 있습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> expected = <span class=\"string\">'Hello World!'</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> msg = <span class=\"string\">`should call .send() with <span class=\"subst\">$&#123; expected &#125;</span>`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;  </span><br><span class=\"line\">    send: <span class=\"function\">(<span class=\"params\">actual</span>) =&gt;</span> &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (actual !== expected) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`NOT OK <span class=\"subst\">$&#123; msg &#125;</span>`</span>);  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`OK: <span class=\"subst\">$&#123; msg &#125;</span>`</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  hello(&#123;&#125;, res);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Listen 핸들러를 자체 파일로 분리해 유닛 테스트를 만들겠습니다.  이 때도 같은 문제가 등장합니다.  익스프레스 핸들러들은 순수하지 않으므로 로거를 집어넣어 스파이웨어가 호출되는지 확인해야합니다.  테스트는 이전 예와 비슷합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handleListen = </span><br><span class=\"line\">       (log, port) =&gt; </span><br><span class=\"line\">                () =&gt; </span><br><span class=\"line\">        log(<span class=\"string\">`Example app listening on port <span class=\"subst\">$&#123; port &#125;</span>!`</span>);</span><br></pre></td></tr></table></figure>\n<p>이제 서버 파일엔 통합 로직만 남겨졌습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"built_in\">require</span>(<span class=\"string\">'./hello.js'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> handleListen = <span class=\"built_in\">require</span>(<span class=\"string\">'./handleListen'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"built_in\">require</span>(<span class=\"string\">'./log'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> port = <span class=\"number\">3000</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, hello);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(port, handleListen(port, log));</span><br></pre></td></tr></table></figure>\n<p>여전히 통합 테스트는 필요하지만 유닛 테스트를 아무리 추가해도 케이스 커버리지는 향상되지 않습니다.  우리는 logger를  <code>handleListen()</code>에 전달하기 위해 최소한의 의존성 주입 패턴을 사용하지만 의존성 주입 프레임 워크가 필요하진 않습니다.</p>\n<h2 id=\"모의mocking-테스트는-통합-테스트에-적합합니다\">모의(mocking) 테스트는 통합 테스트에 적합합니다.</h2>\n<p>통합 테스트는 유닛간의 상호작용과 통합을 테스트하기 때문에 CPU 클러스터 또는 네트워크상의 별도의 프로세스에 존재하는 다른 유닛과의 통신 중에 발생할 수있는 다양한 조건과 상황을 재현해야 합니다.  서버나 네트워크 프로토콜, 네트워크 메시지 등을 가짜로 만드는 것은 너무나 당연합니다.</p>\n<p>때로는 유닛이 타사 API와 통신하는 것을 테스트해야 하며 때로는 이러한 API가 실제로 테스트하려면 엄청나게 비쌉니다.  실제 서비스에 대한 워크 플로우 트랜잭션을 기록한 후 fake 서버에서 이를 다시 재생하면 유닛이 별도의 네트워크 프로세스에서 실행중인 타사 서비스와 얼마나 잘 통합되어 있는지 테스트할 수 있습니다.  &quot;이 메시지 헤더가 올바른 형식입니까?&quot;같은 상황을 테스트하는 가장 좋은 방법입니다.</p>\n<p>네트워크 대역폭을 제한하고, 네트워크 지연을 연출하고, 네트워크 오류를 생성하고, 통신 레이어를 mocking하는 등 유닛 테스트가 할 수 없는 많은 다른 조건을 테스트하는 통합 테스트 도구들이 많이 있습니다.</p>\n<p>통합 테스트없이 100% 케이스 커버리지를 달성하는 것은 불가능합니다.  100% 유닛 테스트 커버리지를 달성하더라도 이를 건너 뛰면 안됩니다. 100%가 100%가 아닙니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/\"><strong>다음: 객체 합성이라는 숨겨진 보물 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>test double, 여기서 double이란 스턴드 대역 배우(stunt double)와 같은 대역이란 뜻입니다. <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>테스트 적용 범위 <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>   <a href=\"https://medium.com/@roman01la/understanding-transducers-in-javascript-3500d3bd9624\" target=\"_blank\" rel=\"noopener\">Understanding Transducers in JavaScript</a>를 참고  <a href=\"#fnref3\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/\">다음&gt;</a></p>\n</blockquote>\n<p>TDD와 유닛 테스트를 할 때 가장 손이 많이 가는 부분은 테스트할 유닛을 분리하는 과정에서 필요한 <strong>mocking</strong>을 만드는 일 입니다. 몇몇 사람들은 유닛 테스트가 정말로 의미있는 일인지 의심스러워 하기도 합니다.  실제로, 저는 개발자들이 mock, fake, stub을 만들다 길을 잃고  <em>실제 코드가 전혀 실행되지 않는</em>  유닛 테스트를 작성하는걸 보았습니다. 아이고…</p>\n<p>다른 한편으로는 개발자가 TDD에 스스로를 너무 옭아매는 모습이 자주 보입니다. 이 경우 개발자는 코드베이스를 더 복잡하게 만들어버릴지라도 무조건 100% 코드 커버리지를 달성해야 한다고 생각합니다.</p>\n<p>저는 mocking에서 코드 냄새를 맡으라고  말합니다. 그러나 대부분의 개발자들은 100% 유닛 테스트 커버리지를 달성할 수 있다는 TDD 신봉자 단계를 거치게 되며 이 기간 동안에는 대규모의 모의 객체를 사용하지 않는 세상을 상상할 수 없습니다.  모의 객체<sup>mocks</sup>를 응용 프로그램에 집어 넣기 위해 의존성 주입<sup>dependency</sup> <sup>injection</sup> (DI)함수로 자신의 코드유닛을 감싸거나 더 안좋은 경우, 서비스를 의존성 주입 컨테이너로 만들어버리기도 합니다.</p>\n<p>Angular는 모든 컴포넌트 클래스에 의존성을 주입하며 DI를 기본적인 디커플링 수단으로 사용하도록 유혹합니다.  하지만 의존성 주입이 디커플링을 수행하는 가장 좋은 방법은 아닙니다.</p>\n<h2>TDD는 더 나은 디자인으로 이어질 때 그 의미가 있습니다.</h2>\n<blockquote>\n<p>제대로된 TDD를 배운다는 것은 제대로 앱을 모듈화시키는 법을 배우는 것과 같습니다.</p>\n</blockquote>\n<p>TDD는 코드를 복잡하게 만드는것이 아닌 단순하게 만들어야 합니다. 코드를 더 잘 테스트 할 수 있게 고치는 댓가로 가독성과 유지보수성을 내주어선 안됩니다.  DI 보일러 플레이트로 코드를 부풀리고 있다면 잘못된 TDD를 하고있는 겁니다.</p>\n<p>온 세상을 mocking할 수 있다는 환상을가지고 앱에 의존성을 주입하고 있다면 그것이 도움이 되기 보다는 해가 될 가능성이 매우 높습니다.  테스트 가능한 코드를 작성하는 과정에서 코드가 단순해져야 합니다.  우리에게 필요한 것은 적은 수의 코드 라인과 보다 읽기 쉽고 유연하며 유지 보수가 가능한 구조입니다.  의존성 주입은 반대 효과를냅니다.</p>\n<p>제가 말하고 싶은 것은 이 두 가지 입니다.</p>\n<ol>\n<li>의존성 주입 없이도 디커플링된 코드를 작성할 수 있습니다.</li>\n<li>코드 커버리지를 최대화하려는 시도는 좋지 않습니다. 100%에 다가갈수록 애플리케이션 코드는 복잡해지고 결국 버그를 줄인다는 목표를 뒤엎고 말게 됩니다.</li>\n</ol>\n<p>복잡한 코드에는 종종 자질구레한 코드들도 함께 있습니다. 잘 정돈된 코드를 작성하는 것은 집을 깔끔하게 유지하려는 것과 같은 이유입니다.</p>\n<ul>\n<li>코드가 어수선해지면 버그가 숨을 수 있는 편리한 장소가 생기고 더 많은 버그가 발생합니다.</li>\n<li>뭔가를 찾기 위해서는 우선 정돈된 환경이 필요합니다.</li>\n</ul>\n<h2>코드 냄새<sup>Code</sup> <sup>smell</sup>란 무엇입니까?</h2>\n<blockquote>\n<p><em>“코드 냄새란 일반적으로 시스템 깊숙히 숨어있는 문제를 드러내는 표면적인 표시입니다.”~ Martin Fowler</em></p>\n</blockquote>\n<blockquote>\n<p><strong>코드 스멜</strong>(code smell←코드 냄새)은 컴퓨터 프로그래밍 코드에서 더 심오한 문제를 일으킬 가능성이 있는 프로그램 소스 코드의 증상을 가리킨다.  ~ Wikipedia</p>\n</blockquote>\n<p>나쁜 코드 냄새를 맡았다고 해서 곧바로 뭔가 잘못 되었고 이를 고쳐야 한다는 것을 의미하진 않습니다.  코드 냄새란 당신에게 뭔가를 향상시킬 수있는 기회를 알려주는 <em>경험 법칙</em> 입니다.</p>\n<p>이 글은 모든 mocking이 나쁘다는 것을 의미하지 않으며 mocking을 절대 하면 안된다고 말하는게 아닙니다.</p>\n<p>코드의 유형에 따라 다양한 수준 (및 다른 종류)의 mocking이 필요합니다. I/O를 다루는 코드는 I/O 를 테스트하는 것 이외에 다른 방법은 거의 없습니다. 이 경우 모의 테스트를 줄이면 유닛 테스트 커버리지가 0%에 가까워 질 수 있습니다.</p>\n<p>로직이 없는 코드는(파이프와 순수 함수들로만 이루어진) 유닛 테스트 커버리지가 0%가 되어도 괜찮습니다. 대신 통합 또는 기능 테스트 커버리지가 100 %에 가까워질 것입니다.  그러나 로직(조건식, 변수 할당, 메소드 호출 등)이 있다면 유닛 테스트 커버리지가 필요하며, 이 때 코드를 단순화하고 mocking 요구사항을 줄이는 목표를 세울 수 있습니다.</p>\n<h2>Mock(모의)란 무엇입니까?</h2>\n<p>Mock이란 유닛 테스트에서 실제 구현 코드를 대신하는 <strong>테스트 더블</strong><sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>입니다.  모의 객체는 테스트가 진행되는 동안 테스트 코드에 의해 조작, 변경되고 이를 assert 구문으로 확인합니다. Assert 구문에 테스트 더블이 쓰인다면 이는 모의입니다.</p>\n<p>&quot;모의(mock)&quot;라는 용어는 여러 종류의 테스트 더블을 포괄하는 일반적인 용어입니다. 앞으로의 논의에서 우리는 &quot;모의(mock)&quot;와 &quot;테스트 더블(test double)&quot;이라는 단어를 동등하게, 상호 교환적으로 사용하겠습니다.  모든 테스트 더블 (dummies, spies, fake 등)은 테스트 대상과 단단하게 결합된 실제 코드를 나타냅니다. 따라서 테스트 더블은 일종의 커플링이 있다는 것을 뜻하며, 구현을 단순화하고 향상시킬 수 있다는 의미입니다. 그리고 모의 객체가 필요하지 않도록 코드를 바꾸는 것은 테스트를 근본적으로 단순화시키는 방법입니다.</p>\n<h2>유닛 테스트란 무엇입니까?</h2>\n<p><strong>유닛 테스트</strong>는 개별 유닛(모듈, 함수, 클래스)을 나머지 프로그램과 분리하여 테스트하는 행위입니다,</p>\n<p>유닛 테스트와 달리 <strong>통합 테스트</strong><sup>Integration</sup> <sup>test</sup>란 두 개 이상의 유닛 간의 통합을 테스트하는 것입니다.   <strong>기능 테스트</strong><sup>Functional</sup> <sup>test</sup>란 사용자의 관점에서 애플리케이션을 테스트하는 것 입니다.  사용자 워크 플로 테스트는 UI 조작에서 데이터 레이어가 업데이트되고 그것들이 다시 화면에 출력되는 과정을 모두 관찰합니다.  기능 테스트는 앱이 실행되는 맥락에서 모든 장치와 유닛을 테스트하기 때문에 통합 테스트의 하위 집합이라고 볼 수 있습니다.</p>\n<p>일반적으로 유닛은 유닛의 공용 인터페이스 (일명 &quot;퍼블릭 API&quot;또는 “surface area”) 만 사용하여 테스트됩니다.  이것을 <strong>블랙 박스 테스트</strong>라고합니다.  블랙 박스 테스팅은 고장나기 쉬운 테스트입니다.  왜냐하면 시간이 지남에 따라 퍼블릭 API는 그대로인데 유닛의 구현 세부 사항이 변경되기 때문입니다. 내부 구현 방식까지 다루는 화이트 박스 테스트는 더더욱 고장나기 쉬운데, 퍼블릭 API가 예상대로 계속 작동하더라도 구현 세부 사항을 변경하면 테스트가 중단 될 수 있기 때문입니다.  즉, 화이트 박스 테스트에는 훨씬 많은 시간과 노력이 들어갑니다.</p>\n<h2>테스트 커버리지<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>란 무엇입니까?</h2>\n<p>코드 커버리지란 테스트 케이스가 다루는 코드의 양을 의미합니다.  테스트 도중 어떤 코드의 행이 사용되었는지 기록하여 커버리지 리포트를 작성합니다. 일반적으로 우리는 커버리지를 높이려고 노력하지만 100 %에 가까워 질수록 테스트 효율이 감소하기 시작합니다.</p>\n<p>경험에 비추어 볼 때, 90%가 넘는 커버리지는 남은 버그들을 없애는데 거의 상관 관계가없는 것 같습니다.</p>\n<p>왜 그럴까요?  100% 테스트 된 코드란 코드가 의도 한대로 작동한다는 것을 100% 확신시켜주는 의미 아닙니까?</p>\n<p>이 문제는 그리 간단하지 않습니다.</p>\n<p>대부분의 사람들은 두 가지 종류의 커버리지가 있다는 것을 모릅니다.</p>\n<ol>\n<li><strong>코드 커버리지</strong> : 코드가 실행되는 정도</li>\n<li><strong>케이스 커버리지</strong> :  테스트 스위트가 커버하는 유스 케이스의 수</li>\n</ol>\n<p>케이스 커버리지는 유스 케이스 시나리오를 다룹니다 : 코드가 실제 환경, 실제 네트워크에서 어떻게 작동할 것인가? 악의적인 목적으로, 소프트웨어 설계를 의도적으로 파괴하려는 해커한테 어떻게 작동 할 것인가?</p>\n<p>커버리지 리포트는 케이스 커버리지가 아닌 코드 커버리지의 부족한 점을 알려줍니다.  그러나 동일한 코드가 둘 이상의 유스 케이스에 적용될 수 있을 뿐더러 단일 유즈 케이스가 테스트 대상 외부에 있는 코드, 별도의 애플리케이션 또는 서드파티 API에 의존 할 수도 있습니다.</p>\n<p>유스 케이스는 환경, 여러 단위, 사용자 및 네트워킹 조건을 포함 할 수 있으므로 필요한 모든 유스 케이스를 유닛 테스트들 밖에 없는 테스트 스위트로 처리하는 것은 불가능합니다.  유닛 테스트는 통합되지 않은, 격리 된 테스트 단위를 의미하므로 유닛 테스트로만 이루어진 테스트 스위트는 항상 통합 및 기능 유스  케이스 시나리오에 대해 거의 0%의 커버리지를 달성하게 될 것입니다.</p>\n<p>100% 코드 커버리지는 100% 케이스 커버리지를 보장하지 않습니다.</p>\n<p>100% 코드 커버리지를 목표로 하는 개발자는 잘못된 목표를 쫓고 있습니다.</p>\n<h2>단단한 결합(Tight Coupling)이란 무엇입니까?</h2>\n<p>모의 객체가 필요하다는 것은 유닛 테스트를 위해 유닛을 분리해야 하며 이 때 유닛간의 결합이 있기 때문입니다.  긴밀한 결합은 코드를보다 단단하고 부서지기 쉽게 만듭니다. 코드가 변경되었을 때 프로그램이 멈추게 됩니다.  일반적으로 느슨한 결합은 코드를 확장하고 유지하기 쉽게 만듭니다. 여기에 더해 mocking에 대한 필요성을 없앰으로써 테스트를 더 쉽게한다는 사실은 두말할 필요도 없습니다.</p>\n<p>이것으로부터 우리가 뭔가를 mocking 하고있다면 그 대신에 유닛간의 결합을 줄임으로써 코드를보다 유연하게 만들 수 있는 가능성이 존재한다는 것을 추론 할 수 있습니다.  그리하면 더 이상 가짜 코드들이 필요하지 않습니다.</p>\n<p>커플링(또는 결합)이란 코드 유닛(모듈, 함수, 클래스 등)이 다른 코드 유닛에 종속되는 정도입니다.  밀접한 결합 또는 높은 결합도는 종속된 코드들이 변경 될 때 유닛이 망가질 가능성을 나타냅니다.  즉, 커플링이 빡빡할수록 응용 프로그램을 유지 관리하거나 확장하는 것이 어렵습니다.  느슨한 결합은 버그를 수정하고 응용 프로그램을 새로운 유스 케이스로 확장 할 때 마주치는 복잡성을 줄입니다.</p>\n<p>커플링에는 여러 형태가 있습니다.</p>\n<ul>\n<li><strong>하위 클래스 커플링 :</strong>  하위 클래스는 상위 클래스의 구현 및 전체 계층 구조에 의존합니다. OO 디자인에서 사용할 수있는 가장 단단한 형태의 결합입니다.</li>\n<li><strong>의존 코드 제어 :</strong>  전달받은 메소드 이름으로 수행 할 작업을 지시하는 것처럼 종속된 유닛들을 제어하는 ​​코드.  API가 변경되면 종속된 코드가 중단됩니다.</li>\n<li><strong>변경 가능한 상태 :</strong>  다른 코드와 변경 가능한 상태를 공유하는 코드. (e.g.공유된 객체의 속성을 변경하는 일)  코드가 실행되는 상대적인 타이밍이 바뀔 경우 종속 코드가 손상 될 수 있습니다.  타이밍이 비 결정적이라면, 모든 종속 유닛을 완전히 뜯어보지 않는 이상 프로그램 정확성을 달성하는 것이 불가능할 수 있습니다. 예를 들어, 해결 불가능한 레이스 컨디션이 있을 수 있습니다.  한 버그를 수정하면 다른 종속 유닛에 새로운 버그가 나타날 수 있습니다.</li>\n<li><strong>형태적 종속성 :</strong>  다른 코드와 특정 데이터 구조를 공유하며 구조의 일부분만 사용하는 코드입니다.  구조적인의 형태가 변경되면 종속 코드가 손상 될 수 있습니다.</li>\n<li><strong>이벤트 / 메시지 커플링 :</strong>  메시지 전달, 이벤트 등을 통해 다른 유닛과 통신하는 코드.</li>\n</ul>\n<h2>무엇이 단단한 결합을 만드는가?</h2>\n<p>단단한 결합에는 많은 원인이 있습니다.</p>\n<ul>\n<li><strong>변이</strong>  vs  <em>불변성</em></li>\n<li><strong>부수효과</strong>  vs  <em>순수함 /부수효과를 분리</em></li>\n<li><strong>책임 과부하</strong>  vs  <em>Do One Thing (DOT)</em></li>\n<li><strong>절차를 기술</strong>  vs  <em>구조를 기술</em></li>\n<li><strong>명령형 구성</strong>  vs  <em>선언적인 구성</em></li>\n</ul>\n<p>명령형 및 객체 지향 코드는 함수형 코드보다 단단하게 결합되기 쉽습니다.  그러나  함수형 스타일로 프로그래밍한다고 해서 단단한 결합에 무적이 되진 않습니다. 다만 함수형 프로그래밍은 프로그램의 기본 구성 단위로 순수 함수를 사용하며 이는  본질적으로 느슨한 결합들을 형성합니다.</p>\n<p>순수 함수 :</p>\n<ul>\n<li>동일한 입력이 주어지면 항상 동일한 출력을 반환</li>\n<li>부수효과 없음</li>\n</ul>\n<p>순수 함수는 어떻게 결합도를 낮출까요?</p>\n<ul>\n<li><strong>Immutability :</strong>  순수 함수는 기존 값을 변경하지 않습니다.  대신 새로운 값을 반환합니다.</li>\n<li><strong>No side effects :</strong>  순수 함수가 유일하게 표현하는 것은 리턴 값입니다. 따라서 화면, DOM, 콘솔, 표준 입출력, 네트워크, 디스크 입출력 등과 같은 외부 상태와 연관있는 다른 함수의 조작을 방해할 가능성이 없습니다.</li>\n<li><strong>Do One Thing :</strong>  순수 함수는 단일 임무를 수행합니다. 입력과 출력을 맵핑하는 임무입니다.  객체 및 클래스 기반 코드는 몇줄 안되는 코드에게 과한 책임을 지우는 경향이 있습니다. 책임 과부하를 피하십시오.</li>\n<li><strong>Structure, not instructions :</strong>  순수 함수는 안전하게 메모이제이션 할 수 있습니다. 즉, 시스템 메모리가 무한하다고 가정할 때  함수 입력을 인덱스로 사용하여 테이블에서 해당 값을 검색하는 조회 테이블로 바꿀 수 있습니다.  다시 말해 순수 함수는 컴퓨터에게 내리는 명령이 아닌 데이터 간의 구조적 관계를 설명하므로 서로 충돌하는 두 가지 명령이 서로의 발가락을 밟고 문제를 일으킬 수 없습니다.</li>\n</ul>\n<h2>합성은 mocking과 무슨 관계가 있습니까?</h2>\n<p><strong>Everything</strong>.  소프트웨어 개발의 본질은 큰 문제를 작고 독립적인 조각으로 분해하고 작은 솔루션들을 합쳐 큰 문제를 해결하는 과정입니다.</p>\n<blockquote>\n<p>문제를 분해하는 전략이 실패했을 때 mocking이 필요해집니다.</p>\n</blockquote>\n<p>큰 문제를 작은 부분으로 나누는 데 사용되는 조그만  유닛이 서로 의존 할 때 mocking이 필요합니다.  다시 말하자면  <em>우리가 생각한  원자 단위가 실제로 원자가 아니며,</em>  우리의 분해 전략이 큰 문제를 더 작고 독립적인 문제로 분해하지 못했을 때 필요합니다.</p>\n<p>문제를 성공적으로 분해했다면 일반적인 합성 유틸리티들을 사용해 솔루션 조각들을 다시 합칠 수 있습니다.  예 :</p>\n<ul>\n<li><strong>함수 합성</strong>  e.g.,  <code>lodash/fp/compose</code></li>\n<li><strong>컴포넌트 합성</strong>  e.g., 함수 합성으로 고차 컴포넌트 작성</li>\n<li><strong>상태 저장소/모델 합성</strong>  e.g.,  <a href=\"http://redux.js.org/docs/api/combineReducers.html\" target=\"_blank\" rel=\"noopener\">Redux combineReducers</a></li>\n<li><strong>객체 또는 팩토리 합성</strong> e.g. 객체 믹스인 또는 함수형 믹스인</li>\n<li><strong>프로세스 합성</strong>  e.g. 트랜스듀서<sup>transducer</sup> <sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup></li>\n<li><strong>프로미스 또는 모나드 합성</strong>  e.g., <code>asyncPipe()</code>  또는  <code>composeM()</code>,  <code>composeK()</code> Kleisli 합성</li>\n<li>기타…</li>\n</ul>\n<p>이러한 유틸리티들을 사용하는 경우 합성의 재료가 되는 각 요소들은 다른 요소를  <em>mocking하지 않고도</em>  격리 된 유닛 테스트를 수행 할 수 있습니다  <em>.</em></p>\n<p>합성 자체는 완벽하게 선언적이므로  <em>유닛 테스트</em> 가 필요한 로직이 없습니다. (그리고 이런 합성 유틸리티는 자체적인 유닛 테스트가 있는 서드파티 라이브러리입니다).</p>\n<p>이러한 상황에서 유닛 테스트를 하는 건 아무런 의미가 없습니다.  대신 통합 테스트가 필요합니다.</p>\n<p>익숙한 예제를 가지고 명령적<sup>Imperative</sup> 합성과 선언적<sup>Declarative</sup> 합성을 비교해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Function composition OR  </span></span><br><span class=\"line\"><span class=\"comment\">// import pipe from 'lodash/fp/flow';  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">y, f</span>) =&gt;</span> f(y), x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Functions to compose  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Imperative composition  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doStuffBadly = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterG = g(x);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> afterF = f(afterG);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> afterF;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Declarative composition  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doStuffBetter = pipe(g, f);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  doStuffBadly(<span class=\"number\">20</span>), <span class=\"comment\">// 42  </span></span><br><span class=\"line\">  doStuffBetter(<span class=\"number\">20</span>) <span class=\"comment\">// 42  </span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>함수 합성은 함수의 반환 값에 다른 함수를 적용하는 프로세스입니다.  즉, 함수의 파이프 라인을 만든 다음 입력 값을 파이프 라인에 전달하면 물건이 공장 조립 라인을 통과하듯 값이 개별 함수들을 거쳐가며 변환됩니다.  결국, 파이프 라인의 마지막 함수는 최종 값을 반환합니다.</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">initialValue</span> -&gt;</span> [<span class=\"function\"><span class=\"title\">g</span>] -&gt;</span> [<span class=\"function\"><span class=\"title\">f</span>] -&gt;</span> result</span><br></pre></td></tr></table></figure>\n<p>이는 패러다임과 무관하게 모든 주류 언어들이 애플리케이션 코드를 구성하는 주요 수단입니다.  자바조차도 클래스 인스턴스간 메세지를 전달하는 기본 메커니즘으로 함수 (메소드)를 사용합니다.</p>\n<p>함수를 수동으로(명령형으로) 합성하거나 자동으로(선언적으로) 합성할 수 있습니다. 함수가 퍼스트 클래스가 아닌 언어에서는 선택권이 많지 않습니다. 명령형으로 할 수 밖에 없습니다.  자바 스크립트 (그리고 거의 모든 주요 대중 언어)에서는 선언적으로 합성할 수 있습니다.</p>\n<p>명령형이란 컴퓨터에게 단계적으로 뭔가를 수행하도록 명령한다는 의미입니다. How-To 가이드입니다.  위의 예에서 명령형 스타일은 다음과 같습니다.</p>\n<ol>\n<li>인수를 취하여  <code>x</code> 를 대입하십시오.</li>\n<li><code>afterG</code>  라는 바인딩을 선언하고 <code>g(x)</code> 의 결과를 할당하십시오.</li>\n<li><code>afterF</code>  라는 바인딩을 선언하고  <code>f(afterG)</code>  의 결과를 할당합니다.</li>\n<li><code>afterF</code>  의 값을 리턴합니다.</li>\n</ol>\n<p>명령형 버전에는 테스트해야 할 로직들이 있습니다.  비록 단순한 과제일지라도 잘못된 변수를 전달하거나 리턴하는 곳에서 버그가 발생하는 것을 자주 보았습니다.</p>\n<p>선언적 스타일은 우리가 사물 간의 관계를 컴퓨터에 알리는 것을 의미합니다. 그것은 등식을 사용해서 구조에 대해 설명하는 것 입니다.  선언적 스타일은 다음과 같습니다 :</p>\n<ul>\n<li><code>doStuffBetter</code> 는  <code>g</code> 와  <code>f</code> 의 파이프 컴포지션입니다.</li>\n</ul>\n<p>이게 전부입니다.</p>\n<p><code>f</code>와  <code>g</code>에 대한 유닛 테스트가 존재하고  <code>pipe()</code>가 자체 유닛 테스트 (Ramda의  <code>pipe()</code>  또는 Lodash의 <code>flow()</code> 를 사용)를 사용한다고 가정하면 더이상 유닛 테스트를 해야될 로직이 없습니다.</p>\n<p>이 스타일이 올바르게 작동하려면 유닛들이  <em>분리</em> 되어야 합니다.</p>\n<h2>커플링을 제거하려면 어떻게 해야합니까?</h2>\n<p>커플링을 제거하려면 먼저 종속성이 어디서 발생하며 그 형태가 어떤지 알아야 합니다. 다음은 중요한 예들입니다. 그 순서는 대략적으로 커플링의 긴밀한 정도입니다.</p>\n<p>단단한 결합 :</p>\n<ul>\n<li>클래스 상속 (상속 계층이 증가할 때마다, 각 자손 클래스가 많아질 때 마다 결합도는 배가 됩니다)</li>\n<li>전역 변수</li>\n<li>변경 가능한 전역 상태 (브라우저 DOM, 공유 저장소, 네트워크 등)</li>\n<li>부수효과가 있는 모듈 가져오기</li>\n<li>합성 과정에 숨어든 암시적인 종속성  e.g., <code>const enhancedWidgetFactory = compose(eventEmitter, widgetFactory, enhancements);</code>  <code>widgetFactory</code>는 <code>eventEmitter</code>에게 의존합니다.</li>\n<li>의존성 주입 컨테이너</li>\n<li>의존성 주입 파라미터</li>\n<li>컨트롤 파라미터 (외부 유닛이 해당 유닛의행동을 지시하고 통제하는 것)</li>\n<li>변경 가능한 매개 변수</li>\n</ul>\n<p>느슨한 결합:</p>\n<ul>\n<li>부수효과가 없는 모듈 가져오기 (블랙 박스 테스트를 할 때 import된 모든 모듈을 분리할 필요는 없음)</li>\n<li>메시지 전달 / pubsub</li>\n<li>변경 불가능한 매개 변수</li>\n</ul>\n<p>아이러니하게도, 커플링을 발생시키는 원인의 대부분은 원래 커플링을 줄이기 위해 설계된 메커니즘들입니다. 왜냐하면 문제를 풀기 위한 작은 솔루션들을 완전한 애플리케이션으로 재구성하기 위해 어떻게든 이들을 통합하고 연결해야 했기 때문입니다.  좋은 방법과 나쁜 방법이 있을 뿐입니다.  단단한 커플링을 유발하는 원인들이 실제로 그렇게 되는 경우에는 피해야 합니다.  느슨한 커플링 옵션은 일반적으로 건강한 앱을 만드는 바람직한 방법입니다.</p>\n<p>많은 책과 블로그 포스트에서 의존성 주입 컨테이너와 매개 변수를 &quot;느슨한 결합&quot;으로 분류합니다. 왜 이들이 “단단한 커플링” 그룹에 속하는지 혼란스러울 수 있습니다.  커플링은 바이너리가 아닙니다.  그라디언트 스케일입니다.  즉, 어떤 그룹에든 다소 주관적이고 임의적으로 속할 수 있습니다.</p>\n<p>따라서 제가 간단하고 객관적인 리트머스 테스트를 준비했습니다.</p>\n<p>의존성을 mocking하지 않고 유닛을 테스트 할 수 있습니까?  그렇게 할 수 없다면 mocking은 의존성과  <em>밀접하게 결합</em>  되어 있는 것입니다.</p>\n<p>유닛의 종속성이 높을수록 문제가 되는 커플링이 발생할 가능성이 커집니다. 커플링이 어디서 발생하는지 이해했습니다. 이제 어떻게 해야 하는지 알아보겠습니다.</p>\n<ol>\n<li>클래스, 명령형 프로시저 또는 무언가를 변경하는 함수 대신 <strong>순수 함수</strong>를 프로그램의 원자 단위로 사용하십시오.</li>\n<li>프로그램 로직과  <strong>부수효과</strong>를  <strong>격리</strong>하십시오.  즉, I/O (네트워크, 디스크 I/O, UI 렌더링, 로깅 등)와 로직을 섞지 마십시오.</li>\n<li>독립적인 구성 요소에서  <strong>종속성을 만드는 로직</strong>을  <strong>제거</strong>하여 유닛 테스트가 필요없는 선언적 구성이 될 수 있도록 하십시오.  로직이 없다면 단위 테스트에 아무런 의미가 없습니다.</li>\n</ol>\n<p>즉, 네트워크 요청을 설정하고 핸들러를 요청하는 코드는 유닛 테스트가 필요하지 않습니다. 대신 통합 테스트를 하십시오.</p>\n<blockquote>\n<p><em>I/O를 유닛 테스트 하지 마십시오.</em></p>\n</blockquote>\n<blockquote>\n<p><em>I/O는 통합을 위한 것입니다.</em>  <em>통합 테스트를 하십시오.</em></p>\n</blockquote>\n<p>통합 테스트를 위해 mocking하고 가짜를 만드는 것은 전혀 문제되지 않습니다.</p>\n<h2>순수 함수 사용</h2>\n<p>순수 함수를 사용하기 위해선 약간의 연습이 필요하며, 그러한 연습 없이는 원하는 작업을 수행하기 위해 코드를 작성하는 방법이 명확하지 않을 수 있습니다. 순수 함수는 전역 변수, 전달 된 인수, 네트워크, 디스크 또는 화면을 직접 변경할 수 없습니다. 오로지 값을 반환하는 일만 할 수 있습니다.</p>\n<p>순수 함수가 배열이나 객체를 전달받아 해당 객체의 변경된 버전을 반환는 경우 객체를 변경하고 리턴할 수 없습니다. 객체의 새 사본을 만들어 변경사항을 적용하고 리턴해야 합니다. 배열  <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype\" target=\"_blank\" rel=\"noopener\">접근 메소드</a>  (변경 메소드가 아님),  <code>Object.assign()</code>, 빈 객체를 생성, 배열 또는 객체 스프레드 구문을 사용하여 이를 수행 할 수 있습니다.  예 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Not pure  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> signInUser = <span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.isSignedIn = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;  </span><br><span class=\"line\">  name: <span class=\"string\">'Foo'</span>,  </span><br><span class=\"line\">  isSignedIn: <span class=\"literal\">false</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Foo was mutated  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  signInUser(foo), <span class=\"comment\">// true  </span></span><br><span class=\"line\">  foo              <span class=\"comment\">// &#123; name: \"Foo\", isSignedIn: true &#125;  </span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>vs…</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Pure  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> signInUser = <span class=\"function\"><span class=\"params\">user</span> =&gt;</span> (&#123;...user, <span class=\"attr\">isSignedIn</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;  </span><br><span class=\"line\">  name: <span class=\"string\">'Foo'</span>,  </span><br><span class=\"line\">  isSignedIn: <span class=\"literal\">false</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Foo was not mutated  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  signInUser(foo), <span class=\"comment\">// &#123; name: \"Foo\", isSignedIn: true &#125;  </span></span><br><span class=\"line\">  foo              <span class=\"comment\">// &#123; name: \"Foo\", isSignedIn: false &#125;  </span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>또는 <a href=\"http://swannodette.github.io/mori/\" target=\"_blank\" rel=\"noopener\">Mori</a>,  <a href=\"https://facebook.github.io/immutable-js/\" target=\"_blank\" rel=\"noopener\">Immutable.js</a>와 같은 불변 데이터 타입 라이브러리를 사용하는 방법도 있습니다.  언젠가 JavaScript가 Clojure와 비슷한 불변 데이터 타입을 지원해주기를 바라고 있습니다.</p>\n<p>기존 객체를 재사용하는 대신 새 객체를 생성하기 때문에 성능이 저하될 수 있다고 생각할 수도 있지만, 여기엔 사실 좋은 부수효과 있습니다. 객체의 변경여부를 항등연산자로 (  <code>===</code>  ) 확인할 수 있습니다. 즉, 우리는 하나라도 변경된 것을 발견하기 위해 객체 내부를 구석구석 확인하지 않아도 됩니다.</p>\n<p>이 방법을 사용하면 복잡한 상태 트리가 있는 React 구성 요소를 더 빨리 렌더링할 수 있습니다. 각 렌더 패스 별로 심도있게 순회할 필요가 없어지기 때문입니다. <code>PureComponent</code>를 상속하여 얕은 <code>prop</code> 및 <code>state</code> 비교로  <code>shouldComponentUpdate()</code>를 구현할 수 있게됩니다.  객체의 주소가 변경되지 않았음을 탐지하면 상태 트리의 해당 부분에서 아무 것도 변하지 않았으며 트리를 모두 순회하지 않고도 계속 진행하면 된다는 것을 알 수 있습니다.</p>\n<p>순수 함수는 메모이제이션 할 수 있습니다. 이전에 동일한 입력을 처리한적이 있다면 전체 객체를 다시 만들 필요가 없습니다. 미리 계산 된 값을 테이블에 저장하는 방식으로 계산 복잡도를 메모리와 교환할 수 있습니다. 많은 메모리가 필요하지 않고 계산적으로 비싼 프로세스의 경우, 이는 훌륭한 최적화 전략이 될 수 있습니다.</p>\n<p>순수 함수는 또한 부수효과가 없기 때문에 <strong>분할-정복</strong> 전략을 사용하여 분산처리시스템에게 계산을 맡기는 것이 안전합니다.  이 전략은 원래 그래픽 용으로 설계된  GPU를 사용하여 이미지, 비디오 또는 오디오 프레임을 처리하는 데 주로 사용되지만 시뮬레이션, 과학실험 컴퓨팅과 같은 다른 용도로 많이 사용됩니다.</p>\n<p>다시 말해, 값을 변경하는 방식이 항상 빠르지는 않으며 매크로 최적화를 희생하여 마이크로 최적화를 수행하기 때문에 더 느린 경우가 많습니다.</p>\n<h2>프로그램의 주요 로직과 부수효과를 분리</h2>\n<p>부수효과와 나머지 프로그램 로직을 분리하는데 도움이 되는 몇 가지 전략이 있습니다.  다음은 그 중 일부입니다.</p>\n<ol>\n<li>pub/sub 패턴을 사용하여 뷰와 프로그램 로직에서 I/O를 분리하십시오.  UI 뷰와 프로그램 로직에서 부수효과를 발생시키는 코드를 직접 호출하는 대신 이벤트 또는 액션 객체를 보내 통신하는게 좋습니다.</li>\n<li>I/O에서 로직을 분리하십시오. e.g.,  <code>asyncPipe()</code>를 사용해 프로미스를 리턴하는 함수를 합성</li>\n<li>I/O 코드에서 직접 계산 하지 않고 지연된 계산을 표현하는 객체를 사용하십시오. e.g.,  <a href=\"https://github.com/redux-saga/redux-saga\" target=\"_blank\" rel=\"noopener\">redux-saga</a>의  <code>call()</code>  은 실제로 함수를 호출하지 않습니다.  대신, 함수와 인수에 대한 레퍼런스가 담긴 객체를 반환하며, saga 미들웨어가 이를 호출합니다.  따라서  <code>call()</code>과 그것을 사용하는 모든 함수가  <em>순수 함수가되고</em>, 쉽게 유닛 테스트를 만들 수 있으며  <em>mocking이 필요하지 않습니다.</em></li>\n</ol>\n<h3>pub / sub 사용</h3>\n<p>Pub/sub은 게시<sup>Publish</sup>/구독<sup>Subscribe</sup> 패턴의 약자입니다.  이 패턴에서 유닛은 서로 직접 호출하지 않습니다.  대신, 다른 유닛(구독자)가 들을 수있는 메시지를 게시합니다.  게시자는 어떤 유닛이 자신을 구독할지 알지 못하며 구독자는 게시자가 게시할 내용을 알지 못합니다.</p>\n<p>Pub/sub의 좋은 예로 DOM(Document Object Model)이 있습니다.  애플리케이션의 모든 컴포넌트는 마우스 이동, 클릭, 스크롤 이벤트, 키 입력 등과 같이 DOM 요소에서 전달 된 이벤트를 수신 할 수 있습니다.  모든 사람들이 jQuery로 웹 애플리케이션을 만들던 시절, jQuery의 커스텀 이벤트는 DOM을 pub/sub 이벤트 버스로 사용하여 렌더링과 로직을 분리했습니다.</p>\n<p>Pub/sub는 또한 Redux에서 볼 수 있습니다.  Redux에서는 애플리케이션 상태에 대한 전역 모델(저장소라고 함)을 만듭니다. 직접 모델을 조작하는 대신 뷰 및 I/O 핸들러는 액션 객체를 저장소에 보냅니다(dispatch라고 표현합니다).  액션 객체가 가지고 있는 <code>type</code>이라는 특별한 키를 다양한 reducers들이 듣고 응답할 수 있습니다. 또한 Redux는 특정 액션 타입을 수신하고 응답 할 수있는 미들웨어를 지원합니다.  이렇게하면 뷰에서 애플리케이션 상태가 처리되는 방법을 알 필요가 없으며 상태 로직이 뷰에 대해 알 필요가 없습니다.</p>\n<p>덕분에 디스패처를 간단하게 수정하는 것 만으로 미들웨어를 통해 액션 로깅/분석, 저장소 또는 서버와의 상태 동기화, 서버 및 네트워크 피어와의 실시간 통신 기능 패치와 같은 복잡한 문제들을 다룰 수 있습니다.</p>\n<h3>I/O와 로직을 분리</h3>\n<p>모나드(e.g., 프로미스) 합성을 ​​사용해 프로그램의 의존 로직을 제거할 수 있습니다. 예를 들어 다음 함수의 로직은 모든 비동기 함수를 mocking하지 않고서는 유닛 테스트를 할 수 없게 설계되어있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uploadFiles</span>(<span class=\"params\">&#123;user, folder, files&#125;</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> dbUser = <span class=\"keyword\">await</span> readUser(user);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> folderInfo = <span class=\"keyword\">await</span> getFolderInfo(folder);  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">await</span> haveWriteAccess(&#123;dbUser, folderInfo&#125;)) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> uploadToFolder(&#123;dbUser, folderInfo, files &#125;);  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"No write access to that folder\"</span>);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이를 실행할 수 있도록 도와주는 의사 코드를 작성해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(...args);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Ignore these. In your real code you'd import  </span></span><br><span class=\"line\"><span class=\"comment\">// the real things.  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> readUser = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"literal\">true</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> getFolderInfo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"literal\">true</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> haveWriteAccess = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"literal\">true</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> uploadToFolder = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'Success!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gibberish starting variables  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"string\">'123'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> folder = <span class=\"string\">'456'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> files = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uploadFiles</span>(<span class=\"params\">&#123;user, folder, files&#125;</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> dbUser = <span class=\"keyword\">await</span> readUser(&#123; user &#125;);  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> folderInfo = <span class=\"keyword\">await</span> getFolderInfo(&#123; folder &#125;);  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">await</span> haveWriteAccess(&#123;dbUser, folderInfo&#125;)) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> uploadToFolder(&#123;dbUser, folderInfo, files &#125;);  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"No write access to that folder\"</span>);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uploadFiles(&#123;user, folder, files&#125;)  </span><br><span class=\"line\">  .then(log)  </span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<p><code>asyncPipe()</code>로 프로미스를 합성할 수 있도록 리팩터링합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncPipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; (  </span><br><span class=\"line\">  fns.reduce(<span class=\"keyword\">async</span> (y, f) =&gt; f(<span class=\"keyword\">await</span> y), x)  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> uploadFiles = asyncPipe(  </span><br><span class=\"line\">  readUser,  </span><br><span class=\"line\">  getFolderInfo,  </span><br><span class=\"line\">  haveWriteAccess,  </span><br><span class=\"line\">  uploadToFolder  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">uploadFiles(&#123;user, folder, files&#125;)  </span><br><span class=\"line\">  .then(log)  </span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n<p>프로미스는 자체적으로 조건부 분기하도록 설계되어있기 때문에 <code>if</code> 로직을 쉽게 제거 할 수 있습니다.  로직과 I/O는 잘 섞이지 않기 때문에 I/O 의존적인 코드에서 로직을 제거하는 것이 좋습니다.</p>\n<p>이러한 종류의 합성 작업을 하기 위해서는 다음 두 가지를 보장해야합니다.</p>\n<ol>\n<li><code>haveWriteAccess()</code>는 사용자가 쓰기 권한이 없는 경우 거절해야 합니다.  조건 로직을 프로미스 컨텍스트로 옮겼기에 따로 유닛 테스트를 할 필요가 없습니다.(JS 엔진 코드에 자체 테스트가 생성됩니다).</li>\n<li>각 함수는 동일한 데이터 타입을 사용하여 처리됩니다.  우리는 <code>{ user, folder, files, dbUser?, folderInfo? }</code>를 키로 사용하는 <code>pipelineData</code>  타입을 만든 것 입니다.  이렇게 하면 각 구성 요소들이 특정 구조를 공유한다는 종속성이 생기지만 이러한 함수를 추상화시켜 보다 일반적인 버전을 만들 수 있으며 간단하게 래핑하여 다양한 파이프라인에 적용할 수 있습니다.</li>\n</ol>\n<p>이러한 조건들이 충족되면 다른 함수들을 mocking하지 않고 각 함수를 서로 격리하여 테스트하기 쉬워집니다. 우리가 파이프라인에서 모든 로직을 추출했으므로,이 파일에서 유닛 테스트를 하는 것은 아무런 의미가 없습니다.  결국 테스트가 필요해지는 것은 통합 뿐입니다.</p>\n<blockquote>\n<p>기억하세요:   <em>로직과  I/O는 별도의 관심사입니다.</em><br>\n<em>로직이란 생각하는 것입니다.</em>  <em>효과란 행동입니다.</em>  <em>행동하기 전에 생각해야 합니다!</em></p>\n</blockquote>\n<h3>미래의 계산을 나타내는 객체 사용</h3>\n<p>redux-saga의 전략은 미래의 계산을 나타내는 객체를 사용하는 것입니다.  이 아이디어는 모나드를 반환하는 것과 유사합니다. 단, 항상 모나드가 반환되는 것은 아닙니다.  모나드는 체이닝으로 함수를 합성할 수 있지만, 대신 명령형 코드를 사용하여 함수를 수동으로 연결할 수 있습니다.  다음은 redux-saga가 어떻게 동작하는지에 대한 대략적인 스케치입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sugar for console.log we'll use later  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"function\"><span class=\"params\">msg</span> =&gt;</span> <span class=\"built_in\">console</span>.log(msg);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> call = <span class=\"function\">(<span class=\"params\">fn, ...args</span>) =&gt;</span> (&#123; fn, args &#125;);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> put = <span class=\"function\">(<span class=\"params\">msg</span>) =&gt;</span> (&#123; msg &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// imported from I/O API  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sendMessage = <span class=\"function\"><span class=\"params\">msg</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'some response'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// imported from state handler/Reducer  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> handleResponse = <span class=\"function\"><span class=\"params\">response</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  type: <span class=\"string\">'RECEIVED_RESPONSE'</span>,  </span><br><span class=\"line\">  payload: response  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> handleError = <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> (&#123;  </span><br><span class=\"line\">  type: <span class=\"string\">'IO_ERROR'</span>,  </span><br><span class=\"line\">  payload: err  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">sendMessageSaga</span> (<span class=\"params\">msg</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">yield</span> call(sendMessage, msg);  </span><br><span class=\"line\">    <span class=\"keyword\">yield</span> put(handleResponse(response));  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">yield</span> put(handleError(err));  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>네트워크 API를 mocking하거나 부수효과를 일으키지 않고도 모든 호출을 볼 수 있습니다.  보너스 : 비 결정적인 네트워크 상태 등을 걱정하지 않고도 애플리케이션을 매우 쉽게 디버깅 할 수 있습니다.</p>\n<p>네트워크 오류를 시뮬레이션하고 싶습니까?<br>\n간단하게 <code>iter.throw(NetworkError)</code>를 호출하면 됩니다.</p>\n<p>다른 곳에서는 일부 라이브러리 미들웨어가 함수를 작동시키고 실제로 프로덕션 애플리케이션에서 부수효과를 발생시킵니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> iter = sendMessageSaga(<span class=\"string\">'Hello, world!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns an object representing the status and value:  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> step1 = iter.next();</span><br><span class=\"line\"></span><br><span class=\"line\">log(step1);  </span><br><span class=\"line\"><span class=\"comment\">/* =&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">&#123;  </span></span><br><span class=\"line\"><span class=\"comment\">  done: false,  </span></span><br><span class=\"line\"><span class=\"comment\">  value: &#123;  </span></span><br><span class=\"line\"><span class=\"comment\">    fn: sendMessage  </span></span><br><span class=\"line\"><span class=\"comment\">    args: [\"Hello, world!\"]  </span></span><br><span class=\"line\"><span class=\"comment\">  &#125;  </span></span><br><span class=\"line\"><span class=\"comment\">&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p><code>call()</code>  객체를 해체하여 yield하는 방식으로 미래의 계산을 검사하거나 호출합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"attr\">value</span>: &#123;fn, args &#125;&#125; = step1;</span><br></pre></td></tr></table></figure>\n<p>실제로는 미들웨어에서 실행되며 테스트 및 디버깅 할 때는 이 부분을 건너뛸 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> step2 = fn(args);</span><br><span class=\"line\"></span><br><span class=\"line\">step2.then(log); <span class=\"comment\">// \"some response\"</span></span><br></pre></td></tr></table></figure>\n<p>API 또는 http 호출을 mocking하지 않고 네트워크 응답을 시뮬레이션 하려면  <code>.next()</code>에 가짜 리스폰스를 전달하면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iter.next (simulatedNetworkResponse);</span><br></pre></td></tr></table></figure>\n<p>결국  <code>done</code>이  <code>true</code>가 될 때까지  <code>.next()</code>를  계속 호출하면 됩니다.</p>\n<p>유닛 테스트에서 제너레이터와 계산 표현을 사용해 모든 것을 <strong>부수효과 없이</strong> 시뮬레이션할 수 있습니다.  값을  <code>.next()</code>에 전달해 가짜 응답을 만들거나 에러를 이터레이터로 전달해 가짜 에러상황 및 거절된 프로미스를 시뮬레이션할 수 있습니다.</p>\n<p>결국, 부수효과가 많은 복잡한 통합 워크 플로의 경우에서도 mocking을 할 필요가 없어집니다.</p>\n<h2>&quot;코드 냄새&quot;는 법칙이 아닌 경고 신호입니다.  Mock은 Evil하지 않습니다.</h2>\n<p>더 나은 아키텍처를 사용할 수 있음에도 실제로는 다른 사람들의 API를 사용하고 레거시 코드와 통합해야 합니다. 이들 중에는 순수하지 않은 코드들이 많이 있습니다.  이러한 경우에 테스트 더블을 격리시켜 사용해야 합니다. 예를 들어, express는 컨티뉴에이션 패싱 기법으로 공유 가변 상태<sup>shared</sup> <sup>mutable</sup> <sup>state</sup> 및 모델의 부수효과들을 전달합니다.</p>\n<p>일반적인 예를 살펴 보겠습니다.  사람들은 익스프레스 서버 스크립트에 의존성 주입을 해야한다고 말합니다. 그렇지 않다면 어떻게 익스프레스 앱에 들어가는 것들을 테스트 할 수 있는지 궁금해합니다.  예 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;  </span><br><span class=\"line\">  res.send(<span class=\"string\">'Hello World!'</span>)  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Example app listening on port 3000!'</span>)  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><em>이 파일</em>  을 &quot;유닛 테스트&quot;하려면,  우리는 의존성 주입 솔루션을 개발한 다음 모든 것을 mocks으로 (아마도  <code>express()</code>  자체도 포함해서) 전달해야 할 것입니다.  그러나 이 파일이 매우 복잡해질 경우, 즉 여러 리퀘스트 핸들러들이 서로 다른 익스프레스 기능을 사용하고 있고 다양한 로직들에 의존하고 있다면 아마도 꽤 정교한 mock들을 만들어야 할 것입니다.  저는 개발자들이 익스프레스 인스턴스, 세션 미들웨어, 로그 처리기, 실시간 네트워크 프로토콜 등과 같은 정교한 가짜와 모의 객체를 생성하는 것을 자주 봤습니다.  어떻게 해야 할까요? 대답은 간단합니다.</p>\n<blockquote>\n<p>이 파일은 유닛 테스트하면 안됩니다.</p>\n</blockquote>\n<p>익스프레스 앱의 서버 정의 파일은 말 그대로 앱의 주요  <strong>통합</strong>  지점입니다. 이 파일을 테스트한다는 것은 프로그램 로직, 익스프레스 및 앱의 모든 핸들러 간의 통합을 테스트하는 것입니다.  100% 유닛 테스트 커버리지를 달성할 수 있다고 하더라도 통합 테스트를 건너 뛰면 <strong>절대로</strong> 안됩니다.</p>\n<p>이 파일을 유닛 테스트하려고 하는 대신 프로그램 로직을 별도의 유닛로 분리하고 유닛 테스트를 하십시오. 서버 파일은 실제 통합 테스트를 해야 합니다. 다시 말해 실제로 네트워크에 연결하고 실제 HTTP 메시지를 주고받고,  <a href=\"https://github.com/visionmedia/supertest\" target=\"_blank\" rel=\"noopener\">supertest</a>와 같은 도구를 사용해 헤더를 테스트하십시오.</p>\n<p>Hello World Express 예제를 더 쉽게 테스트 할 수 있도록 리팩터링 해 봅시다.</p>\n<p><code>hello</code>  핸들러를 자체 파일로 분리해 유닛 테스트를 만들어야 합니다.  앱의 나머지 구성 요소를 mocking할 필요가 없습니다.  이는 분명히 순수 함수가 아니므로  <code>.send()</code>  호출하도록 응답 객체를 mocking해야 합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> res.send ( <span class=\"string\">'Hello World!'</span>);</span><br></pre></td></tr></table></figure>\n<p>이런 식으로 테스트 해 볼 수 있습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> expected = <span class=\"string\">'Hello World!'</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> msg = <span class=\"string\">`should call .send() with <span class=\"subst\">$&#123; expected &#125;</span>`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;  </span><br><span class=\"line\">    send: <span class=\"function\">(<span class=\"params\">actual</span>) =&gt;</span> &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (actual !== expected) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`NOT OK <span class=\"subst\">$&#123; msg &#125;</span>`</span>);  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`OK: <span class=\"subst\">$&#123; msg &#125;</span>`</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  hello(&#123;&#125;, res);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Listen 핸들러를 자체 파일로 분리해 유닛 테스트를 만들겠습니다.  이 때도 같은 문제가 등장합니다.  익스프레스 핸들러들은 순수하지 않으므로 로거를 집어넣어 스파이웨어가 호출되는지 확인해야합니다.  테스트는 이전 예와 비슷합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handleListen = </span><br><span class=\"line\">       (log, port) =&gt; </span><br><span class=\"line\">                () =&gt; </span><br><span class=\"line\">        log(<span class=\"string\">`Example app listening on port <span class=\"subst\">$&#123; port &#125;</span>!`</span>);</span><br></pre></td></tr></table></figure>\n<p>이제 서버 파일엔 통합 로직만 남겨졌습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"built_in\">require</span>(<span class=\"string\">'./hello.js'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> handleListen = <span class=\"built_in\">require</span>(<span class=\"string\">'./handleListen'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"built_in\">require</span>(<span class=\"string\">'./log'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> port = <span class=\"number\">3000</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, hello);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(port, handleListen(port, log));</span><br></pre></td></tr></table></figure>\n<p>여전히 통합 테스트는 필요하지만 유닛 테스트를 아무리 추가해도 케이스 커버리지는 향상되지 않습니다.  우리는 logger를  <code>handleListen()</code>에 전달하기 위해 최소한의 의존성 주입 패턴을 사용하지만 의존성 주입 프레임 워크가 필요하진 않습니다.</p>\n<h2>모의(mocking) 테스트는 통합 테스트에 적합합니다.</h2>\n<p>통합 테스트는 유닛간의 상호작용과 통합을 테스트하기 때문에 CPU 클러스터 또는 네트워크상의 별도의 프로세스에 존재하는 다른 유닛과의 통신 중에 발생할 수있는 다양한 조건과 상황을 재현해야 합니다.  서버나 네트워크 프로토콜, 네트워크 메시지 등을 가짜로 만드는 것은 너무나 당연합니다.</p>\n<p>때로는 유닛이 타사 API와 통신하는 것을 테스트해야 하며 때로는 이러한 API가 실제로 테스트하려면 엄청나게 비쌉니다.  실제 서비스에 대한 워크 플로우 트랜잭션을 기록한 후 fake 서버에서 이를 다시 재생하면 유닛이 별도의 네트워크 프로세스에서 실행중인 타사 서비스와 얼마나 잘 통합되어 있는지 테스트할 수 있습니다.  &quot;이 메시지 헤더가 올바른 형식입니까?&quot;같은 상황을 테스트하는 가장 좋은 방법입니다.</p>\n<p>네트워크 대역폭을 제한하고, 네트워크 지연을 연출하고, 네트워크 오류를 생성하고, 통신 레이어를 mocking하는 등 유닛 테스트가 할 수 없는 많은 다른 조건을 테스트하는 통합 테스트 도구들이 많이 있습니다.</p>\n<p>통합 테스트없이 100% 케이스 커버리지를 달성하는 것은 불가능합니다.  100% 유닛 테스트 커버리지를 달성하더라도 이를 건너 뛰면 안됩니다. 100%가 100%가 아닙니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/\"><strong>다음: 객체 합성이라는 숨겨진 보물 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>test double, 여기서 double이란 스턴드 대역 배우(stunt double)와 같은 대역이란 뜻입니다. <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>테스트 적용 범위 <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>   <a href=\"https://medium.com/@roman01la/understanding-transducers-in-javascript-3500d3bd9624\" target=\"_blank\" rel=\"noopener\">Understanding Transducers in JavaScript</a>를 참고  <a href=\"#fnref3\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n"},{"title":"삼항연산자의 멋짐을 모르는 당신이 불쌍해","catalog":true,"date":"2018-04-24T18:42:41.000Z","subtitle":"Nested Ternaries are Great","header-img":"bg.jpg","readingTime":6,"catagories":["개발"],"preview":"보통 삼항연산자를 중첩시키는 것은 가독성을 떨어트리기 때문에 피해야 한다고 합니다. Conventional wisdom is sometimes unwise. 사실,  삼항 연산자는 대개 if 문보다 훨씬 간단합니다.  사람들이 그 반대로 믿게되는 두 가지 이유가 있습니다. if 문에 익숙합니다.  친근성 편향^Familiarity^ ^bias^은 우리가 반대되는 증거를 제시 할지라도 사실이 아닌 것을 믿게합니다. 2.사람들은 삼항연산자를 `if` 문처럼 사용하려고합니다.  삼항연산자는  _명령문^statement^ 아니라 표현식^expression^_  이므로 이는 잘못된 용법입니다.세부사항에 대해 알아보기 전에 삼항연산자 표현식을 정의해 보겠습니다.삼항식은 값으로 평가되는 조건부 표현식입니다.  조건부,  진리 절 (조건부가 참인 경우 평가되는 값), 그리고 거짓 절(조건부가 거짓인 경우 평가되는 값)으로 구성됩니다.","_content":"\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/nested-ternaries-are-great-361bddd0f340)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/26/abstraction-and-composition/)\n\n보통 삼항연산자를 중첩시키는 것은 가독성을 떨어트리기 때문에 피해야 한다고 합니다.\n\n> Conventional wisdom is sometimes unwise.\n\n사실,  _삼항 연산자는 대개 if 문보다 훨씬 간단합니다._  사람들이 그 반대로 믿게되는 두 가지 이유가 있습니다.\n\n1.  if 문에 익숙합니다.  친근성 편향^Familiarity^ ^bias^은 우리가 반대되는 증거를 제시 할지라도 사실이 아닌 것을 믿게합니다.\n2.  사람들은 삼항연산자를 `if` 문처럼 사용하려고합니다.  삼항연산자는  _구문^statement^ 아니라 표현식^expression^_  이므로 이는 잘못된 용법입니다.\n\n세부사항에 대해 알아보기 전에 삼항연산자 표현식을 정의해 보겠습니다.\n\n삼항식은 값으로 평가되는 조건부 표현식입니다.  조건부,  진리 절 (조건부가 참인 경우 평가되는 값), 그리고 거짓 절(조건부가 거짓인 경우 평가되는 값)으로 구성됩니다.\n\n다음 처럼 표현됩니다 :\n\n```\n(conditional)  \n  ? truthyClause  \n  : falsyClause\n  ```\n\n## 표현식 대 명령문\n\n스몰 토크, 하스켈 및 대부분의 함수형 프로그래밍 언어를 포함한 몇 가지 프로그래밍 언어에는 `if`문이 전혀 없습니다.  대신에  `if` 표현식이 있습니다.\n\n`if` 표현식은 값으로 평가되는 조건식입니다.  조건부,  진리 절 (조건부가 참인 경우 평가되는 값), 그리고 거짓 절(조건부가 거짓인 경우 평가되는 값)으로 구성됩니다.\n\n비슷하지 않습니까?  대부분의 함수형 프로그래밍 언어에서는  `if`  키워드를 삼항식처럼 사용합니다. 어째서일까요?\n\n표현식은 단일 값으로 평가되는 코드 덩어리입니다.\n\n구문은 값으로 평가되지 않는 코드 덩어리입니다.  JavaScript에서는 if문이 값으로 평가되지 않습니다.  if문이 의미있는 일을 하게 하려면 부수효과를 발생시키거나 함수 안에서 값을 리턴해야 합니다.\n\n함수형 프로그래밍에서는 변이와 부수효과를 피하려는 경향이 있습니다.  JavaScript의 `if`는 자연스럽게 변이와 부수효과를 발생시키는 경우가 많으므로 저를 포함한 많은 함수형 프로그래머가 중첩 여부에 관계없이 삼항연산자를 사용합니다.\n\n삼항식의 관점으로 생각하는 것은 if문의 관점으로 생각하는 것과는 조금 다릅니다. 그러나 2주 정도만 의식해서 사용하다보면 자연스럽게 삼항식에 끌리기 시작할 것입니다. 단순히 타이핑할게 적기 때문에라도 말입니다.\n\n## 친숙함 편향 Familiarity Bias\n\n제가 본 공통적인 의견중 하나는 중첩된 삼항 표현식은 \"읽기가 어렵다\"는 것입니다.  몇 가지 코드 예제로 그 미신을 산산조각 내보겠습니다.\n\n```javascript\n const withIf = ({  \n  conditionA, conditionB  \n}) => {  \n  if (conditionA) {  \n    if (conditionB) {  \n      return valueA;  \n    }  \n    return valueB;  \n  }  \n  return valueC;  \n};\n```\n\n이 중첩된 `if`문 코드는 falsy 절과 truthy 절이 시각적으로 분리되어 매우 단절된 느낌을줍니다.  사실 매우 간단한 코드지만 구문을 분석하려면 살짝 주의깊게 봐야합니다.\n\n동일한 논리를 삼항 표현식으로 작성해보았습니다.\n\n```javascript\nconst withTernary = ({  \n  conditionA, conditionB  \n}) => (  \n  (!conditionA)  \n    ? valueC  \n    : (conditionB)  \n    ? valueA  \n    : valueB  \n);\n```\n\n여기에 몇 가지 흥미로운 점이 있습니다.\n\n## 데이지 체이닝^[전자공학에서 사용하는 용어로 연속적으로 연결되어 있는 하드웨어 장치들의 구성을 뜻합니다] vs 네스팅\n\n첫째로, 우리는 중첩을 평평하게 했습니다.  \"중첩된\" 삼항식은 약간의 잘못된  표현입니다. 삼항식은 직선적으로 쓰기 쉽기 때문에 들여쓰기로 중첩할 필요가 없습니다.  따라서, 단순하게 위에서 아래로 읽으면서 조건에 부합하는 순간 즉시 값을 반환합니다.\n\n올바르게 작성된 삼항식에는 해석해야될 중첩이 없습니다.  직선도로에서 길을 잃기란 꽤 어렵습니다.\n\n따라서 우리는 이를  \"삼항연산자 체이닝\"이라고 부를 것입니다.\n\n두 번째로 지적하고 싶은 것은 이 직선 연쇄를 단순화하기 위해 논리의 순서를 조금 바꿨다는 것입니다. 삼항 표현식의 끝으로 가서 두 개의 콜론 절 (`:`) 중, 마지막 절을 위로 이동시키고, 단순화하기 위해 첫 번째 조건의 논리를 역으로 바꿨습니다.  더 이상 복잡해질 이유가 없습니다.\n\n사실,  `if` 문을 단순화하기 위해 동일한 트릭을 사용할 수 있습니다.\n\n```javascript\nconst withIf = ({  \n  conditionA, conditionB  \n}) => {  \n  if (!conditionA) return valueC;  \n  if (conditionB) {  \n    return valueA;  \n  }  \n  return valueB;  \n};\n```\n\n훨씬 나아졌습니다. 그러나 아직도 시각적으로 분리된 `conditionB`절이 혼란을 야기 할 수 있습니다.  저는 이러한 문제들이 논리적 버그로 이어지는 것을 보았습니다.  논리가 평평 해졌음에도 불구하고이 버전은 삼항연산자 버전보다 여전히 혼란스럽습니다.\n\n## 어수선한 구문들\n\n`if`  버전에는 잡동사니들이 포함되어 있습니다.  `if`  키워드 ,  `return` 키워드, 여분의 세미콜론, 여분의 중괄호 등. 이 예제와 달리 대부분의 if 문장은 외부 상태를 변경하며 여분의 코드^Extra^ ^Code^와 복잡성이 더해집니다.\n\n_여분의 코드_  가 좋지 않은 몇 가지 중요한 이유가 있습니다. 이미 몇번씩 언급했었지만, 모든 개발자의 뇌에 화상을 입힐 때까지 반복 할 가치가 있습니다.\n\n\n### 단기 기억\n\n인간 두뇌의  [단기 기억력](http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html)은 서로 다른 항목을 저장하기 위한 공간이 한정되어있으며, 함수의 인자와 변수는 잠재적으로 그 공간 중 하나를 소비합니다.  변수가 늘어날 수록 각 변수의 의미를 기억하기 힘들어 집니다. 단기 기억 모형에 따르면 우리의 두뇌는 일반적으로 4-7 개의 항목을 단기 기억 공간에 저장할 수 있으며 이 보다 크면 오류율이 급격히 증가합니다.\n\n우리는 함수 파이프라이닝을 사용해 변수 3개를 소거하였고 다른 변수를 기억하는데 사용할 수  있게 됐습니다.  단기 기억 공간의 거의 절반을 확보한 것입니다. 이는 인지 부하를 상당히 줄여줍니다.  소프트웨어 개발자는 데이터를 묶어 기억하는 경향이 있지만 그렇다고 이 개념의 중요성이 약해지는 것은 아닙니다.\n\n### 신호 대 잡음비\n간결함은 코드의 신호 대 잡음 비율^Signal^ ^to^ ^Noise^ ^Ratio^을 향상시킵니다.  라디오를 듣는 것과 같습니다. 라디오의 주파수가 제대로 맞춰져 있지 않으면 소음이 발생하며 음악을 듣기가 어려워집니다.  방송국 주파수로 정확하게 튜닝하면 소음이 사라지고 음악 신호가 강해집니다.\n\n코드도 마찬가지입니다.  간결한 표현은 이해력을 향상시킵니다. 일부 코드는 유용한 정보를 제공하고 일부 코드는 공간을 차지합니다.  전달되어야 할 의미를 변화시키지 않는 선에서 코드의 양을 줄이면 코드를 읽고 이해해야하는 다른 사람들이 더 쉽게 이해할 수 있습니다.^[개발자가 코드를 작성하고 다른 개발자가 이를 이해한다는 것을 라디오의 방송국과 청취자들의 관계에 비유했 습니다. 이 때 신호란 전달되어야하는 의미이고 잡음이란 공간만 차지하는 코드입니다. 즉 더 적은 코드로 같은 의미를 전달하는 것이 좋다는 말이 됩니다.]\n\n### 코드의 면적과 버그\n\n함수형으로 작성된 코드를 살펴보면 마치 코드가 살을 빼 다이어트 한 것처럼 보입니다. 이 비유가 중요한 이유는 여분의 코드가 버그를 숨길 수있는 추가 표면적을 의미하기 때문입니다 . 즉 더 많은 버그가 숨어 버릴 수 있음을 의미합니다.\n\n> _적은 코드 = 버그가 적은 표면 = 버그가 적습니다._\n\n## 부수효과 및 바뀔 수 있는 공유변수\n\n대부분의 경우 if 문은 값으로 평가되는 것 이상을 수행합니다.  이들은 부수효과를 발생시키고 변수를 변경합니다. 부수효과의 영향과 가변적인 공유변수를 다루는 제어 흐름을 완전히 파악하지 못한다면 if 문이 작동하는 모든 그림을 볼 수 없습니다.\n\n언제나 값이 리턴 되도록 하는 것은 일련의 규율을 만듭니다. 즉, 프로그램을 이해하고 디버그하고 리팩토링하고 유지 관리하기가 쉽도록 종속성을 끊어내는 실천입니다.\n\n그리고 이 부분이 바로 삼항연산자의 이점 중 제가 가장 좋아하는 것입니다.\n\n> _삼항연산자를 사용하면 더 나은 개발자가 될 것입니다._\n\n## 결론\n\n모든 삼항식은 위에서 아래로 일직선으로 배열하기 쉽기 때문에 \"중첩 삼항식\"이라고 하는 것은 잘못된 표현입니다.  대신, 이들을 \"삼항식 체이닝\"라고 부르겠습니다.\n\n체인된 삼항연산자는 if 문과 비교해 몇 가지 장점이 있습니다.\n\n-   항상 위에서 아래로 일직선으로 읽을 수 있도록 작성하는 것이 좋습니다. 직선을 따라 읽으면 체인된 삼항식을 무리없이 읽을 수 있습니다.\n-   삼항 연산자는 구문의 혼란을 줄입니다.  적은 코드 = 버그가 적은 표면 = 버그가 적습니다.\n-   삼항 연산자는 임시 변수를 필요로하지 않으므로 단기기억력의 부하가 줄어 듭니다.\n-   삼항식은 신호 대 잡음비가 더 좋습니다.\n-   `if`문은  부수작용과 변이를 권장하지만,  삼항연산자는 순수한 코드를 권장합니다.\n-   순수한 코드는 표현과 기능을 서로 분리시킴으로써 우리가 더 나은 개발자가 될 수 있도록 합니다.\n\n[**다음: 합성과 추상화 >**](https://midojeong.github.io/2018/04/26/abstraction-and-composition/)","source":"_posts/nested-ternaries-are-great.md","raw":"---\ntitle: 삼항연산자의 멋짐을 모르는 당신이 불쌍해\ncatalog: true\ndate: 2018-04-25 03:42:41\nsubtitle: Nested Ternaries are Great\nheader-img: \"bg.jpg\"\nreadingTime: 6\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 보통 삼항연산자를 중첩시키는 것은 가독성을 떨어트리기 때문에 피해야 한다고 합니다. Conventional wisdom is sometimes unwise. 사실,  삼항 연산자는 대개 if 문보다 훨씬 간단합니다.  사람들이 그 반대로 믿게되는 두 가지 이유가 있습니다. if 문에 익숙합니다.  친근성 편향^Familiarity^ ^bias^은 우리가 반대되는 증거를 제시 할지라도 사실이 아닌 것을 믿게합니다. 2.사람들은 삼항연산자를 `if` 문처럼 사용하려고합니다.  삼항연산자는  _명령문^statement^ 아니라 표현식^expression^_  이므로 이는 잘못된 용법입니다.세부사항에 대해 알아보기 전에 삼항연산자 표현식을 정의해 보겠습니다.삼항식은 값으로 평가되는 조건부 표현식입니다.  조건부,  진리 절 (조건부가 참인 경우 평가되는 값), 그리고 거짓 절(조건부가 거짓인 경우 평가되는 값)으로 구성됩니다.\n---\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/nested-ternaries-are-great-361bddd0f340)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/26/abstraction-and-composition/)\n\n보통 삼항연산자를 중첩시키는 것은 가독성을 떨어트리기 때문에 피해야 한다고 합니다.\n\n> Conventional wisdom is sometimes unwise.\n\n사실,  _삼항 연산자는 대개 if 문보다 훨씬 간단합니다._  사람들이 그 반대로 믿게되는 두 가지 이유가 있습니다.\n\n1.  if 문에 익숙합니다.  친근성 편향^Familiarity^ ^bias^은 우리가 반대되는 증거를 제시 할지라도 사실이 아닌 것을 믿게합니다.\n2.  사람들은 삼항연산자를 `if` 문처럼 사용하려고합니다.  삼항연산자는  _구문^statement^ 아니라 표현식^expression^_  이므로 이는 잘못된 용법입니다.\n\n세부사항에 대해 알아보기 전에 삼항연산자 표현식을 정의해 보겠습니다.\n\n삼항식은 값으로 평가되는 조건부 표현식입니다.  조건부,  진리 절 (조건부가 참인 경우 평가되는 값), 그리고 거짓 절(조건부가 거짓인 경우 평가되는 값)으로 구성됩니다.\n\n다음 처럼 표현됩니다 :\n\n```\n(conditional)  \n  ? truthyClause  \n  : falsyClause\n  ```\n\n## 표현식 대 명령문\n\n스몰 토크, 하스켈 및 대부분의 함수형 프로그래밍 언어를 포함한 몇 가지 프로그래밍 언어에는 `if`문이 전혀 없습니다.  대신에  `if` 표현식이 있습니다.\n\n`if` 표현식은 값으로 평가되는 조건식입니다.  조건부,  진리 절 (조건부가 참인 경우 평가되는 값), 그리고 거짓 절(조건부가 거짓인 경우 평가되는 값)으로 구성됩니다.\n\n비슷하지 않습니까?  대부분의 함수형 프로그래밍 언어에서는  `if`  키워드를 삼항식처럼 사용합니다. 어째서일까요?\n\n표현식은 단일 값으로 평가되는 코드 덩어리입니다.\n\n구문은 값으로 평가되지 않는 코드 덩어리입니다.  JavaScript에서는 if문이 값으로 평가되지 않습니다.  if문이 의미있는 일을 하게 하려면 부수효과를 발생시키거나 함수 안에서 값을 리턴해야 합니다.\n\n함수형 프로그래밍에서는 변이와 부수효과를 피하려는 경향이 있습니다.  JavaScript의 `if`는 자연스럽게 변이와 부수효과를 발생시키는 경우가 많으므로 저를 포함한 많은 함수형 프로그래머가 중첩 여부에 관계없이 삼항연산자를 사용합니다.\n\n삼항식의 관점으로 생각하는 것은 if문의 관점으로 생각하는 것과는 조금 다릅니다. 그러나 2주 정도만 의식해서 사용하다보면 자연스럽게 삼항식에 끌리기 시작할 것입니다. 단순히 타이핑할게 적기 때문에라도 말입니다.\n\n## 친숙함 편향 Familiarity Bias\n\n제가 본 공통적인 의견중 하나는 중첩된 삼항 표현식은 \"읽기가 어렵다\"는 것입니다.  몇 가지 코드 예제로 그 미신을 산산조각 내보겠습니다.\n\n```javascript\n const withIf = ({  \n  conditionA, conditionB  \n}) => {  \n  if (conditionA) {  \n    if (conditionB) {  \n      return valueA;  \n    }  \n    return valueB;  \n  }  \n  return valueC;  \n};\n```\n\n이 중첩된 `if`문 코드는 falsy 절과 truthy 절이 시각적으로 분리되어 매우 단절된 느낌을줍니다.  사실 매우 간단한 코드지만 구문을 분석하려면 살짝 주의깊게 봐야합니다.\n\n동일한 논리를 삼항 표현식으로 작성해보았습니다.\n\n```javascript\nconst withTernary = ({  \n  conditionA, conditionB  \n}) => (  \n  (!conditionA)  \n    ? valueC  \n    : (conditionB)  \n    ? valueA  \n    : valueB  \n);\n```\n\n여기에 몇 가지 흥미로운 점이 있습니다.\n\n## 데이지 체이닝^[전자공학에서 사용하는 용어로 연속적으로 연결되어 있는 하드웨어 장치들의 구성을 뜻합니다] vs 네스팅\n\n첫째로, 우리는 중첩을 평평하게 했습니다.  \"중첩된\" 삼항식은 약간의 잘못된  표현입니다. 삼항식은 직선적으로 쓰기 쉽기 때문에 들여쓰기로 중첩할 필요가 없습니다.  따라서, 단순하게 위에서 아래로 읽으면서 조건에 부합하는 순간 즉시 값을 반환합니다.\n\n올바르게 작성된 삼항식에는 해석해야될 중첩이 없습니다.  직선도로에서 길을 잃기란 꽤 어렵습니다.\n\n따라서 우리는 이를  \"삼항연산자 체이닝\"이라고 부를 것입니다.\n\n두 번째로 지적하고 싶은 것은 이 직선 연쇄를 단순화하기 위해 논리의 순서를 조금 바꿨다는 것입니다. 삼항 표현식의 끝으로 가서 두 개의 콜론 절 (`:`) 중, 마지막 절을 위로 이동시키고, 단순화하기 위해 첫 번째 조건의 논리를 역으로 바꿨습니다.  더 이상 복잡해질 이유가 없습니다.\n\n사실,  `if` 문을 단순화하기 위해 동일한 트릭을 사용할 수 있습니다.\n\n```javascript\nconst withIf = ({  \n  conditionA, conditionB  \n}) => {  \n  if (!conditionA) return valueC;  \n  if (conditionB) {  \n    return valueA;  \n  }  \n  return valueB;  \n};\n```\n\n훨씬 나아졌습니다. 그러나 아직도 시각적으로 분리된 `conditionB`절이 혼란을 야기 할 수 있습니다.  저는 이러한 문제들이 논리적 버그로 이어지는 것을 보았습니다.  논리가 평평 해졌음에도 불구하고이 버전은 삼항연산자 버전보다 여전히 혼란스럽습니다.\n\n## 어수선한 구문들\n\n`if`  버전에는 잡동사니들이 포함되어 있습니다.  `if`  키워드 ,  `return` 키워드, 여분의 세미콜론, 여분의 중괄호 등. 이 예제와 달리 대부분의 if 문장은 외부 상태를 변경하며 여분의 코드^Extra^ ^Code^와 복잡성이 더해집니다.\n\n_여분의 코드_  가 좋지 않은 몇 가지 중요한 이유가 있습니다. 이미 몇번씩 언급했었지만, 모든 개발자의 뇌에 화상을 입힐 때까지 반복 할 가치가 있습니다.\n\n\n### 단기 기억\n\n인간 두뇌의  [단기 기억력](http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html)은 서로 다른 항목을 저장하기 위한 공간이 한정되어있으며, 함수의 인자와 변수는 잠재적으로 그 공간 중 하나를 소비합니다.  변수가 늘어날 수록 각 변수의 의미를 기억하기 힘들어 집니다. 단기 기억 모형에 따르면 우리의 두뇌는 일반적으로 4-7 개의 항목을 단기 기억 공간에 저장할 수 있으며 이 보다 크면 오류율이 급격히 증가합니다.\n\n우리는 함수 파이프라이닝을 사용해 변수 3개를 소거하였고 다른 변수를 기억하는데 사용할 수  있게 됐습니다.  단기 기억 공간의 거의 절반을 확보한 것입니다. 이는 인지 부하를 상당히 줄여줍니다.  소프트웨어 개발자는 데이터를 묶어 기억하는 경향이 있지만 그렇다고 이 개념의 중요성이 약해지는 것은 아닙니다.\n\n### 신호 대 잡음비\n간결함은 코드의 신호 대 잡음 비율^Signal^ ^to^ ^Noise^ ^Ratio^을 향상시킵니다.  라디오를 듣는 것과 같습니다. 라디오의 주파수가 제대로 맞춰져 있지 않으면 소음이 발생하며 음악을 듣기가 어려워집니다.  방송국 주파수로 정확하게 튜닝하면 소음이 사라지고 음악 신호가 강해집니다.\n\n코드도 마찬가지입니다.  간결한 표현은 이해력을 향상시킵니다. 일부 코드는 유용한 정보를 제공하고 일부 코드는 공간을 차지합니다.  전달되어야 할 의미를 변화시키지 않는 선에서 코드의 양을 줄이면 코드를 읽고 이해해야하는 다른 사람들이 더 쉽게 이해할 수 있습니다.^[개발자가 코드를 작성하고 다른 개발자가 이를 이해한다는 것을 라디오의 방송국과 청취자들의 관계에 비유했 습니다. 이 때 신호란 전달되어야하는 의미이고 잡음이란 공간만 차지하는 코드입니다. 즉 더 적은 코드로 같은 의미를 전달하는 것이 좋다는 말이 됩니다.]\n\n### 코드의 면적과 버그\n\n함수형으로 작성된 코드를 살펴보면 마치 코드가 살을 빼 다이어트 한 것처럼 보입니다. 이 비유가 중요한 이유는 여분의 코드가 버그를 숨길 수있는 추가 표면적을 의미하기 때문입니다 . 즉 더 많은 버그가 숨어 버릴 수 있음을 의미합니다.\n\n> _적은 코드 = 버그가 적은 표면 = 버그가 적습니다._\n\n## 부수효과 및 바뀔 수 있는 공유변수\n\n대부분의 경우 if 문은 값으로 평가되는 것 이상을 수행합니다.  이들은 부수효과를 발생시키고 변수를 변경합니다. 부수효과의 영향과 가변적인 공유변수를 다루는 제어 흐름을 완전히 파악하지 못한다면 if 문이 작동하는 모든 그림을 볼 수 없습니다.\n\n언제나 값이 리턴 되도록 하는 것은 일련의 규율을 만듭니다. 즉, 프로그램을 이해하고 디버그하고 리팩토링하고 유지 관리하기가 쉽도록 종속성을 끊어내는 실천입니다.\n\n그리고 이 부분이 바로 삼항연산자의 이점 중 제가 가장 좋아하는 것입니다.\n\n> _삼항연산자를 사용하면 더 나은 개발자가 될 것입니다._\n\n## 결론\n\n모든 삼항식은 위에서 아래로 일직선으로 배열하기 쉽기 때문에 \"중첩 삼항식\"이라고 하는 것은 잘못된 표현입니다.  대신, 이들을 \"삼항식 체이닝\"라고 부르겠습니다.\n\n체인된 삼항연산자는 if 문과 비교해 몇 가지 장점이 있습니다.\n\n-   항상 위에서 아래로 일직선으로 읽을 수 있도록 작성하는 것이 좋습니다. 직선을 따라 읽으면 체인된 삼항식을 무리없이 읽을 수 있습니다.\n-   삼항 연산자는 구문의 혼란을 줄입니다.  적은 코드 = 버그가 적은 표면 = 버그가 적습니다.\n-   삼항 연산자는 임시 변수를 필요로하지 않으므로 단기기억력의 부하가 줄어 듭니다.\n-   삼항식은 신호 대 잡음비가 더 좋습니다.\n-   `if`문은  부수작용과 변이를 권장하지만,  삼항연산자는 순수한 코드를 권장합니다.\n-   순수한 코드는 표현과 기능을 서로 분리시킴으로써 우리가 더 나은 개발자가 될 수 있도록 합니다.\n\n[**다음: 합성과 추상화 >**](https://midojeong.github.io/2018/04/26/abstraction-and-composition/)","slug":"nested-ternaries-are-great","published":1,"updated":"2018-04-28T13:41:14.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83ee000pifp693h8bk3u","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/nested-ternaries-are-great-361bddd0f340\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/26/abstraction-and-composition/\">다음&gt;</a></p>\n</blockquote>\n<p>보통 삼항연산자를 중첩시키는 것은 가독성을 떨어트리기 때문에 피해야 한다고 합니다.</p>\n<blockquote>\n<p>Conventional wisdom is sometimes unwise.</p>\n</blockquote>\n<p>사실,  <em>삼항 연산자는 대개 if 문보다 훨씬 간단합니다.</em>  사람들이 그 반대로 믿게되는 두 가지 이유가 있습니다.</p>\n<ol>\n<li>if 문에 익숙합니다.  친근성 편향<sup>Familiarity</sup> <sup>bias</sup>은 우리가 반대되는 증거를 제시 할지라도 사실이 아닌 것을 믿게합니다.</li>\n<li>사람들은 삼항연산자를 <code>if</code> 문처럼 사용하려고합니다.  삼항연산자는  <em>구문<sup>statement</sup> 아니라 표현식<sup>expression</sup></em>  이므로 이는 잘못된 용법입니다.</li>\n</ol>\n<p>세부사항에 대해 알아보기 전에 삼항연산자 표현식을 정의해 보겠습니다.</p>\n<p>삼항식은 값으로 평가되는 조건부 표현식입니다.  조건부,  진리 절 (조건부가 참인 경우 평가되는 값), 그리고 거짓 절(조건부가 거짓인 경우 평가되는 값)으로 구성됩니다.</p>\n<p>다음 처럼 표현됩니다 :</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(conditional)  </span><br><span class=\"line\">  ? truthyClause  </span><br><span class=\"line\">  : <span class=\"type\">falsyClause</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"표현식-대-명령문\">표현식 대 명령문</h2>\n<p>스몰 토크, 하스켈 및 대부분의 함수형 프로그래밍 언어를 포함한 몇 가지 프로그래밍 언어에는 <code>if</code>문이 전혀 없습니다.  대신에  <code>if</code> 표현식이 있습니다.</p>\n<p><code>if</code> 표현식은 값으로 평가되는 조건식입니다.  조건부,  진리 절 (조건부가 참인 경우 평가되는 값), 그리고 거짓 절(조건부가 거짓인 경우 평가되는 값)으로 구성됩니다.</p>\n<p>비슷하지 않습니까?  대부분의 함수형 프로그래밍 언어에서는  <code>if</code>  키워드를 삼항식처럼 사용합니다. 어째서일까요?</p>\n<p>표현식은 단일 값으로 평가되는 코드 덩어리입니다.</p>\n<p>구문은 값으로 평가되지 않는 코드 덩어리입니다.  JavaScript에서는 if문이 값으로 평가되지 않습니다.  if문이 의미있는 일을 하게 하려면 부수효과를 발생시키거나 함수 안에서 값을 리턴해야 합니다.</p>\n<p>함수형 프로그래밍에서는 변이와 부수효과를 피하려는 경향이 있습니다.  JavaScript의 <code>if</code>는 자연스럽게 변이와 부수효과를 발생시키는 경우가 많으므로 저를 포함한 많은 함수형 프로그래머가 중첩 여부에 관계없이 삼항연산자를 사용합니다.</p>\n<p>삼항식의 관점으로 생각하는 것은 if문의 관점으로 생각하는 것과는 조금 다릅니다. 그러나 2주 정도만 의식해서 사용하다보면 자연스럽게 삼항식에 끌리기 시작할 것입니다. 단순히 타이핑할게 적기 때문에라도 말입니다.</p>\n<h2 id=\"친숙함-편향-familiarity-bias\">친숙함 편향 Familiarity Bias</h2>\n<p>제가 본 공통적인 의견중 하나는 중첩된 삼항 표현식은 &quot;읽기가 어렵다&quot;는 것입니다.  몇 가지 코드 예제로 그 미신을 산산조각 내보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">const</span> withIf = (&#123;  </span><br><span class=\"line\">  conditionA, conditionB  </span><br><span class=\"line\">&#125;) =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (conditionA) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (conditionB) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> valueA;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> valueB;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> valueC;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>이 중첩된 <code>if</code>문 코드는 falsy 절과 truthy 절이 시각적으로 분리되어 매우 단절된 느낌을줍니다.  사실 매우 간단한 코드지만 구문을 분석하려면 살짝 주의깊게 봐야합니다.</p>\n<p>동일한 논리를 삼항 표현식으로 작성해보았습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTernary = (&#123;  </span><br><span class=\"line\">  conditionA, conditionB  </span><br><span class=\"line\">&#125;) =&gt; (  </span><br><span class=\"line\">  (!conditionA)  </span><br><span class=\"line\">    ? valueC  </span><br><span class=\"line\">    : (conditionB)  </span><br><span class=\"line\">    ? valueA  </span><br><span class=\"line\">    : valueB  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>여기에 몇 가지 흥미로운 점이 있습니다.</p>\n<h2 id=\"데이지-체이닝1-vs-네스팅\">데이지 체이닝<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> vs 네스팅</h2>\n<p>첫째로, 우리는 중첩을 평평하게 했습니다.  “중첩된” 삼항식은 약간의 잘못된  표현입니다. 삼항식은 직선적으로 쓰기 쉽기 때문에 들여쓰기로 중첩할 필요가 없습니다.  따라서, 단순하게 위에서 아래로 읽으면서 조건에 부합하는 순간 즉시 값을 반환합니다.</p>\n<p>올바르게 작성된 삼항식에는 해석해야될 중첩이 없습니다.  직선도로에서 길을 잃기란 꽤 어렵습니다.</p>\n<p>따라서 우리는 이를  &quot;삼항연산자 체이닝&quot;이라고 부를 것입니다.</p>\n<p>두 번째로 지적하고 싶은 것은 이 직선 연쇄를 단순화하기 위해 논리의 순서를 조금 바꿨다는 것입니다. 삼항 표현식의 끝으로 가서 두 개의 콜론 절 (<code>:</code>) 중, 마지막 절을 위로 이동시키고, 단순화하기 위해 첫 번째 조건의 논리를 역으로 바꿨습니다.  더 이상 복잡해질 이유가 없습니다.</p>\n<p>사실,  <code>if</code> 문을 단순화하기 위해 동일한 트릭을 사용할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withIf = (&#123;  </span><br><span class=\"line\">  conditionA, conditionB  </span><br><span class=\"line\">&#125;) =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!conditionA) <span class=\"keyword\">return</span> valueC;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (conditionB) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> valueA;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> valueB;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>훨씬 나아졌습니다. 그러나 아직도 시각적으로 분리된 <code>conditionB</code>절이 혼란을 야기 할 수 있습니다.  저는 이러한 문제들이 논리적 버그로 이어지는 것을 보았습니다.  논리가 평평 해졌음에도 불구하고이 버전은 삼항연산자 버전보다 여전히 혼란스럽습니다.</p>\n<h2 id=\"어수선한-구문들\">어수선한 구문들</h2>\n<p><code>if</code>  버전에는 잡동사니들이 포함되어 있습니다.  <code>if</code>  키워드 ,  <code>return</code> 키워드, 여분의 세미콜론, 여분의 중괄호 등. 이 예제와 달리 대부분의 if 문장은 외부 상태를 변경하며 여분의 코드<sup>Extra</sup> <sup>Code</sup>와 복잡성이 더해집니다.</p>\n<p><em>여분의 코드</em>  가 좋지 않은 몇 가지 중요한 이유가 있습니다. 이미 몇번씩 언급했었지만, 모든 개발자의 뇌에 화상을 입힐 때까지 반복 할 가치가 있습니다.</p>\n<h3 id=\"단기-기억\">단기 기억</h3>\n<p>인간 두뇌의  <a href=\"http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html\" target=\"_blank\" rel=\"noopener\">단기 기억력</a>은 서로 다른 항목을 저장하기 위한 공간이 한정되어있으며, 함수의 인자와 변수는 잠재적으로 그 공간 중 하나를 소비합니다.  변수가 늘어날 수록 각 변수의 의미를 기억하기 힘들어 집니다. 단기 기억 모형에 따르면 우리의 두뇌는 일반적으로 4-7 개의 항목을 단기 기억 공간에 저장할 수 있으며 이 보다 크면 오류율이 급격히 증가합니다.</p>\n<p>우리는 함수 파이프라이닝을 사용해 변수 3개를 소거하였고 다른 변수를 기억하는데 사용할 수  있게 됐습니다.  단기 기억 공간의 거의 절반을 확보한 것입니다. 이는 인지 부하를 상당히 줄여줍니다.  소프트웨어 개발자는 데이터를 묶어 기억하는 경향이 있지만 그렇다고 이 개념의 중요성이 약해지는 것은 아닙니다.</p>\n<h3 id=\"신호-대-잡음비\">신호 대 잡음비</h3>\n<p>간결함은 코드의 신호 대 잡음 비율<sup>Signal</sup> <sup>to</sup> <sup>Noise</sup> <sup>Ratio</sup>을 향상시킵니다.  라디오를 듣는 것과 같습니다. 라디오의 주파수가 제대로 맞춰져 있지 않으면 소음이 발생하며 음악을 듣기가 어려워집니다.  방송국 주파수로 정확하게 튜닝하면 소음이 사라지고 음악 신호가 강해집니다.</p>\n<p>코드도 마찬가지입니다.  간결한 표현은 이해력을 향상시킵니다. 일부 코드는 유용한 정보를 제공하고 일부 코드는 공간을 차지합니다.  전달되어야 할 의미를 변화시키지 않는 선에서 코드의 양을 줄이면 코드를 읽고 이해해야하는 다른 사람들이 더 쉽게 이해할 수 있습니다.<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n<h3 id=\"코드의-면적과-버그\">코드의 면적과 버그</h3>\n<p>함수형으로 작성된 코드를 살펴보면 마치 코드가 살을 빼 다이어트 한 것처럼 보입니다. 이 비유가 중요한 이유는 여분의 코드가 버그를 숨길 수있는 추가 표면적을 의미하기 때문입니다 . 즉 더 많은 버그가 숨어 버릴 수 있음을 의미합니다.</p>\n<blockquote>\n<p><em>적은 코드 = 버그가 적은 표면 = 버그가 적습니다.</em></p>\n</blockquote>\n<h2 id=\"부수효과-및-바뀔-수-있는-공유변수\">부수효과 및 바뀔 수 있는 공유변수</h2>\n<p>대부분의 경우 if 문은 값으로 평가되는 것 이상을 수행합니다.  이들은 부수효과를 발생시키고 변수를 변경합니다. 부수효과의 영향과 가변적인 공유변수를 다루는 제어 흐름을 완전히 파악하지 못한다면 if 문이 작동하는 모든 그림을 볼 수 없습니다.</p>\n<p>언제나 값이 리턴 되도록 하는 것은 일련의 규율을 만듭니다. 즉, 프로그램을 이해하고 디버그하고 리팩토링하고 유지 관리하기가 쉽도록 종속성을 끊어내는 실천입니다.</p>\n<p>그리고 이 부분이 바로 삼항연산자의 이점 중 제가 가장 좋아하는 것입니다.</p>\n<blockquote>\n<p><em>삼항연산자를 사용하면 더 나은 개발자가 될 것입니다.</em></p>\n</blockquote>\n<h2 id=\"결론\">결론</h2>\n<p>모든 삼항식은 위에서 아래로 일직선으로 배열하기 쉽기 때문에 &quot;중첩 삼항식&quot;이라고 하는 것은 잘못된 표현입니다.  대신, 이들을 &quot;삼항식 체이닝&quot;라고 부르겠습니다.</p>\n<p>체인된 삼항연산자는 if 문과 비교해 몇 가지 장점이 있습니다.</p>\n<ul>\n<li>항상 위에서 아래로 일직선으로 읽을 수 있도록 작성하는 것이 좋습니다. 직선을 따라 읽으면 체인된 삼항식을 무리없이 읽을 수 있습니다.</li>\n<li>삼항 연산자는 구문의 혼란을 줄입니다.  적은 코드 = 버그가 적은 표면 = 버그가 적습니다.</li>\n<li>삼항 연산자는 임시 변수를 필요로하지 않으므로 단기기억력의 부하가 줄어 듭니다.</li>\n<li>삼항식은 신호 대 잡음비가 더 좋습니다.</li>\n<li><code>if</code>문은  부수작용과 변이를 권장하지만,  삼항연산자는 순수한 코드를 권장합니다.</li>\n<li>순수한 코드는 표현과 기능을 서로 분리시킴으로써 우리가 더 나은 개발자가 될 수 있도록 합니다.</li>\n</ul>\n<p><a href=\"https://midojeong.github.io/2018/04/26/abstraction-and-composition/\"><strong>다음: 합성과 추상화 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>전자공학에서 사용하는 용어로 연속적으로 연결되어 있는 하드웨어 장치들의 구성을 뜻합니다 <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>개발자가 코드를 작성하고 다른 개발자가 이를 이해한다는 것을 라디오의 방송국과 청취자들의 관계에 비유했 습니다. 이 때 신호란 전달되어야하는 의미이고 잡음이란 공간만 차지하는 코드입니다. 즉 더 적은 코드로 같은 의미를 전달하는 것이 좋다는 말이 됩니다. <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/nested-ternaries-are-great-361bddd0f340\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/26/abstraction-and-composition/\">다음&gt;</a></p>\n</blockquote>\n<p>보통 삼항연산자를 중첩시키는 것은 가독성을 떨어트리기 때문에 피해야 한다고 합니다.</p>\n<blockquote>\n<p>Conventional wisdom is sometimes unwise.</p>\n</blockquote>\n<p>사실,  <em>삼항 연산자는 대개 if 문보다 훨씬 간단합니다.</em>  사람들이 그 반대로 믿게되는 두 가지 이유가 있습니다.</p>\n<ol>\n<li>if 문에 익숙합니다.  친근성 편향<sup>Familiarity</sup> <sup>bias</sup>은 우리가 반대되는 증거를 제시 할지라도 사실이 아닌 것을 믿게합니다.</li>\n<li>사람들은 삼항연산자를 <code>if</code> 문처럼 사용하려고합니다.  삼항연산자는  <em>구문<sup>statement</sup> 아니라 표현식<sup>expression</sup></em>  이므로 이는 잘못된 용법입니다.</li>\n</ol>\n<p>세부사항에 대해 알아보기 전에 삼항연산자 표현식을 정의해 보겠습니다.</p>\n<p>삼항식은 값으로 평가되는 조건부 표현식입니다.  조건부,  진리 절 (조건부가 참인 경우 평가되는 값), 그리고 거짓 절(조건부가 거짓인 경우 평가되는 값)으로 구성됩니다.</p>\n<p>다음 처럼 표현됩니다 :</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(conditional)  </span><br><span class=\"line\">  ? truthyClause  </span><br><span class=\"line\">  : <span class=\"type\">falsyClause</span></span><br></pre></td></tr></table></figure>\n<h2>표현식 대 명령문</h2>\n<p>스몰 토크, 하스켈 및 대부분의 함수형 프로그래밍 언어를 포함한 몇 가지 프로그래밍 언어에는 <code>if</code>문이 전혀 없습니다.  대신에  <code>if</code> 표현식이 있습니다.</p>\n<p><code>if</code> 표현식은 값으로 평가되는 조건식입니다.  조건부,  진리 절 (조건부가 참인 경우 평가되는 값), 그리고 거짓 절(조건부가 거짓인 경우 평가되는 값)으로 구성됩니다.</p>\n<p>비슷하지 않습니까?  대부분의 함수형 프로그래밍 언어에서는  <code>if</code>  키워드를 삼항식처럼 사용합니다. 어째서일까요?</p>\n<p>표현식은 단일 값으로 평가되는 코드 덩어리입니다.</p>\n<p>구문은 값으로 평가되지 않는 코드 덩어리입니다.  JavaScript에서는 if문이 값으로 평가되지 않습니다.  if문이 의미있는 일을 하게 하려면 부수효과를 발생시키거나 함수 안에서 값을 리턴해야 합니다.</p>\n<p>함수형 프로그래밍에서는 변이와 부수효과를 피하려는 경향이 있습니다.  JavaScript의 <code>if</code>는 자연스럽게 변이와 부수효과를 발생시키는 경우가 많으므로 저를 포함한 많은 함수형 프로그래머가 중첩 여부에 관계없이 삼항연산자를 사용합니다.</p>\n<p>삼항식의 관점으로 생각하는 것은 if문의 관점으로 생각하는 것과는 조금 다릅니다. 그러나 2주 정도만 의식해서 사용하다보면 자연스럽게 삼항식에 끌리기 시작할 것입니다. 단순히 타이핑할게 적기 때문에라도 말입니다.</p>\n<h2>친숙함 편향 Familiarity Bias</h2>\n<p>제가 본 공통적인 의견중 하나는 중첩된 삼항 표현식은 &quot;읽기가 어렵다&quot;는 것입니다.  몇 가지 코드 예제로 그 미신을 산산조각 내보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">const</span> withIf = (&#123;  </span><br><span class=\"line\">  conditionA, conditionB  </span><br><span class=\"line\">&#125;) =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (conditionA) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (conditionB) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> valueA;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> valueB;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> valueC;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>이 중첩된 <code>if</code>문 코드는 falsy 절과 truthy 절이 시각적으로 분리되어 매우 단절된 느낌을줍니다.  사실 매우 간단한 코드지만 구문을 분석하려면 살짝 주의깊게 봐야합니다.</p>\n<p>동일한 논리를 삼항 표현식으로 작성해보았습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTernary = (&#123;  </span><br><span class=\"line\">  conditionA, conditionB  </span><br><span class=\"line\">&#125;) =&gt; (  </span><br><span class=\"line\">  (!conditionA)  </span><br><span class=\"line\">    ? valueC  </span><br><span class=\"line\">    : (conditionB)  </span><br><span class=\"line\">    ? valueA  </span><br><span class=\"line\">    : valueB  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>여기에 몇 가지 흥미로운 점이 있습니다.</p>\n<h2>데이지 체이닝<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> vs 네스팅</h2>\n<p>첫째로, 우리는 중첩을 평평하게 했습니다.  “중첩된” 삼항식은 약간의 잘못된  표현입니다. 삼항식은 직선적으로 쓰기 쉽기 때문에 들여쓰기로 중첩할 필요가 없습니다.  따라서, 단순하게 위에서 아래로 읽으면서 조건에 부합하는 순간 즉시 값을 반환합니다.</p>\n<p>올바르게 작성된 삼항식에는 해석해야될 중첩이 없습니다.  직선도로에서 길을 잃기란 꽤 어렵습니다.</p>\n<p>따라서 우리는 이를  &quot;삼항연산자 체이닝&quot;이라고 부를 것입니다.</p>\n<p>두 번째로 지적하고 싶은 것은 이 직선 연쇄를 단순화하기 위해 논리의 순서를 조금 바꿨다는 것입니다. 삼항 표현식의 끝으로 가서 두 개의 콜론 절 (<code>:</code>) 중, 마지막 절을 위로 이동시키고, 단순화하기 위해 첫 번째 조건의 논리를 역으로 바꿨습니다.  더 이상 복잡해질 이유가 없습니다.</p>\n<p>사실,  <code>if</code> 문을 단순화하기 위해 동일한 트릭을 사용할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withIf = (&#123;  </span><br><span class=\"line\">  conditionA, conditionB  </span><br><span class=\"line\">&#125;) =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!conditionA) <span class=\"keyword\">return</span> valueC;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (conditionB) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> valueA;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> valueB;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>훨씬 나아졌습니다. 그러나 아직도 시각적으로 분리된 <code>conditionB</code>절이 혼란을 야기 할 수 있습니다.  저는 이러한 문제들이 논리적 버그로 이어지는 것을 보았습니다.  논리가 평평 해졌음에도 불구하고이 버전은 삼항연산자 버전보다 여전히 혼란스럽습니다.</p>\n<h2>어수선한 구문들</h2>\n<p><code>if</code>  버전에는 잡동사니들이 포함되어 있습니다.  <code>if</code>  키워드 ,  <code>return</code> 키워드, 여분의 세미콜론, 여분의 중괄호 등. 이 예제와 달리 대부분의 if 문장은 외부 상태를 변경하며 여분의 코드<sup>Extra</sup> <sup>Code</sup>와 복잡성이 더해집니다.</p>\n<p><em>여분의 코드</em>  가 좋지 않은 몇 가지 중요한 이유가 있습니다. 이미 몇번씩 언급했었지만, 모든 개발자의 뇌에 화상을 입힐 때까지 반복 할 가치가 있습니다.</p>\n<h3>단기 기억</h3>\n<p>인간 두뇌의  <a href=\"http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html\" target=\"_blank\" rel=\"noopener\">단기 기억력</a>은 서로 다른 항목을 저장하기 위한 공간이 한정되어있으며, 함수의 인자와 변수는 잠재적으로 그 공간 중 하나를 소비합니다.  변수가 늘어날 수록 각 변수의 의미를 기억하기 힘들어 집니다. 단기 기억 모형에 따르면 우리의 두뇌는 일반적으로 4-7 개의 항목을 단기 기억 공간에 저장할 수 있으며 이 보다 크면 오류율이 급격히 증가합니다.</p>\n<p>우리는 함수 파이프라이닝을 사용해 변수 3개를 소거하였고 다른 변수를 기억하는데 사용할 수  있게 됐습니다.  단기 기억 공간의 거의 절반을 확보한 것입니다. 이는 인지 부하를 상당히 줄여줍니다.  소프트웨어 개발자는 데이터를 묶어 기억하는 경향이 있지만 그렇다고 이 개념의 중요성이 약해지는 것은 아닙니다.</p>\n<h3>신호 대 잡음비</h3>\n<p>간결함은 코드의 신호 대 잡음 비율<sup>Signal</sup> <sup>to</sup> <sup>Noise</sup> <sup>Ratio</sup>을 향상시킵니다.  라디오를 듣는 것과 같습니다. 라디오의 주파수가 제대로 맞춰져 있지 않으면 소음이 발생하며 음악을 듣기가 어려워집니다.  방송국 주파수로 정확하게 튜닝하면 소음이 사라지고 음악 신호가 강해집니다.</p>\n<p>코드도 마찬가지입니다.  간결한 표현은 이해력을 향상시킵니다. 일부 코드는 유용한 정보를 제공하고 일부 코드는 공간을 차지합니다.  전달되어야 할 의미를 변화시키지 않는 선에서 코드의 양을 줄이면 코드를 읽고 이해해야하는 다른 사람들이 더 쉽게 이해할 수 있습니다.<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n<h3>코드의 면적과 버그</h3>\n<p>함수형으로 작성된 코드를 살펴보면 마치 코드가 살을 빼 다이어트 한 것처럼 보입니다. 이 비유가 중요한 이유는 여분의 코드가 버그를 숨길 수있는 추가 표면적을 의미하기 때문입니다 . 즉 더 많은 버그가 숨어 버릴 수 있음을 의미합니다.</p>\n<blockquote>\n<p><em>적은 코드 = 버그가 적은 표면 = 버그가 적습니다.</em></p>\n</blockquote>\n<h2>부수효과 및 바뀔 수 있는 공유변수</h2>\n<p>대부분의 경우 if 문은 값으로 평가되는 것 이상을 수행합니다.  이들은 부수효과를 발생시키고 변수를 변경합니다. 부수효과의 영향과 가변적인 공유변수를 다루는 제어 흐름을 완전히 파악하지 못한다면 if 문이 작동하는 모든 그림을 볼 수 없습니다.</p>\n<p>언제나 값이 리턴 되도록 하는 것은 일련의 규율을 만듭니다. 즉, 프로그램을 이해하고 디버그하고 리팩토링하고 유지 관리하기가 쉽도록 종속성을 끊어내는 실천입니다.</p>\n<p>그리고 이 부분이 바로 삼항연산자의 이점 중 제가 가장 좋아하는 것입니다.</p>\n<blockquote>\n<p><em>삼항연산자를 사용하면 더 나은 개발자가 될 것입니다.</em></p>\n</blockquote>\n<h2>결론</h2>\n<p>모든 삼항식은 위에서 아래로 일직선으로 배열하기 쉽기 때문에 &quot;중첩 삼항식&quot;이라고 하는 것은 잘못된 표현입니다.  대신, 이들을 &quot;삼항식 체이닝&quot;라고 부르겠습니다.</p>\n<p>체인된 삼항연산자는 if 문과 비교해 몇 가지 장점이 있습니다.</p>\n<ul>\n<li>항상 위에서 아래로 일직선으로 읽을 수 있도록 작성하는 것이 좋습니다. 직선을 따라 읽으면 체인된 삼항식을 무리없이 읽을 수 있습니다.</li>\n<li>삼항 연산자는 구문의 혼란을 줄입니다.  적은 코드 = 버그가 적은 표면 = 버그가 적습니다.</li>\n<li>삼항 연산자는 임시 변수를 필요로하지 않으므로 단기기억력의 부하가 줄어 듭니다.</li>\n<li>삼항식은 신호 대 잡음비가 더 좋습니다.</li>\n<li><code>if</code>문은  부수작용과 변이를 권장하지만,  삼항연산자는 순수한 코드를 권장합니다.</li>\n<li>순수한 코드는 표현과 기능을 서로 분리시킴으로써 우리가 더 나은 개발자가 될 수 있도록 합니다.</li>\n</ul>\n<p><a href=\"https://midojeong.github.io/2018/04/26/abstraction-and-composition/\"><strong>다음: 합성과 추상화 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>전자공학에서 사용하는 용어로 연속적으로 연결되어 있는 하드웨어 장치들의 구성을 뜻합니다 <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>개발자가 코드를 작성하고 다른 개발자가 이를 이해한다는 것을 라디오의 방송국과 청취자들의 관계에 비유했 습니다. 이 때 신호란 전달되어야하는 의미이고 잡음이란 공간만 차지하는 코드입니다. 즉 더 적은 코드로 같은 의미를 전달하는 것이 좋다는 말이 됩니다. <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n"},{"title":"Reduce","catalog":true,"date":"2018-03-31T21:56:14.000Z","subtitle":"함수형 프로그래밍의 강력한 도구","header-img":"bg.jpg","readingTime":6,"catagories":["개발"],"preview":"함수형 프로그래밍에서 자주 보이는 Reduce(일명 fold, accumulate)는 배열을 순회하며 각 항목을 누적해서 리턴하는 함수입니다. 이 때 누적된 값을 변수로 저장해놓고 배열의 항목과 누적 값을 어떤 함수에 반복해서 전달합니다. 그 함수는 새로운 누적 값을 리턴하는 임의의 함수입니다. reduce를 사용하여 유용한 기능들을 구현할 수 있는데, 이는 보통 어떤 아이템 콜렉션을 가지고 중요한 계산을 수행하는 가장 우아한 방법입니다. reduce는 reducer 함수와 초기 값을 인자로 받고 누적 값을 리턴합니다. Array.prototype.reduce()에서 배열은 this로 참조할 수 있기 때문에 인자로 넣어줄 필요가 없습니다.","_content":"\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/reduce-composing-software-fe22f0c39a1d)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/03/29/higher-order-functions/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/07/functors-and-categories/)\n\n\n함수형 프로그래밍에서 자주 보이는  **Reduce**  (일명 : fold, accumulate)는 배열을 순회하며 각 항목을 누적해서 리턴하는 함수입니다. 이 때 누적된 값을 변수로 저장해놓고 배열의 항목과 누적 값을 어떤 함수에 반복해서 전달합니다. 그 함수는 새로운 누적 값을 리턴하는 임의의 함수입니다. reduce를 사용하여 유용한 기능들을 구현할 수 있는데, 이는 보통 어떤 아이템 콜렉션을 가지고 중요한 계산을 수행하는 가장 우아한 방법입니다.\n\nreduce는 reducer 함수와 초기 값을 인자로 받고 누적 값을 리턴합니다. `Array.prototype.reduce()`에서 배열은  `this`로 참조할 수 있기 때문에 인자로 넣어줄 필요가 없습니다.\n```\narray.reduce(  \n  reducer: (accumulator: Any, current: Any) => Any,  \n  initialValue: Any  \n) => accumulator: Any\n```\n배열의 총합을 구해보겠습니다.\n```javascript\n[2, 4, 6].reduce((acc, n) => acc + n, 0); // 12\n```\n배열의 각 요소가 현재 값이 되어 누적 값과 함께 reducer에 전달됩니다. reducer의 역할은 어떻게든 현재 값을 누적 값으로 \"폴드\"하는 것입니다.  reducer 함수의 역할은 누적되는 방식을 정의하는 것 입니다.  reducer가 새 누적 값을 리턴한 후  `reduce()`는 배열의 다음 값으로 이동합니다.  reducer는 누적될 초기 값이 필요하며 이는 매개 변수로 전달됩니다.\n\n위 코드에서 총합을 계산하는 reducer가 처음 호출되면  `acc`에  `0`  (두 번째 매개 변수로  `.reduce()`  전달 된 값)이 할당됩니다.  reducer는  `0`  +  `2` (배열의 첫 번째 요소)를 계산하여  `2`를 리턴합니다.  다음 호출에는  `acc = 2, n = 4`가 되며 reducer는  `2 + 4`( `6` )를 리턴합니다.  마지막 반복에서는  `acc = 6, n = 6`이 되고 reducer는  `12`반환합니다.  반복이 완료되면  `.reduce()`는 최종 누적 값  `12`리턴합니다.\n\n이 경우 익명 함수를 전달했지만 기명 함수를 전달 할 수도 있습니다.\n```javascript\n  const summingReducer = (acc, n) => acc + n;   \n  [2, 4, 6].reduce(summingReducer, 0);  // 12 \n```\n일반적으로  `reduce()`는 왼쪽에서 오른쪽으로 작동합니다.  JavaScript에는 그 반대로 작동하는  `[].reduceRight()`도 있습니다.  즉,  `[2, 4, 6]`에  `.reduceRight()`을 적용하면 `n`은  `6`으로 시작해서  `2`로 끝납니다.\n\n## 다양한 용도로 사용할 수 있습니다.\n\nReduce는 다재다능합니다.  reduce로  `map()`  ,  `filter()`  ,  `forEach()` 등 다양한 함수들을 쉽게 정의 할 수 있습니다.\n\n**Map:**\n```javascript\n  const map = (fn, arr) => arr.reduce((acc, item, index, arr) => {   \n  return acc.concat(fn(item, index, arr));   \n  }, []); \n```\nmap의 누적 값은 새로운 배열이 됩니다.  새 값은 `arr`의 각 요소에 맵핑 함수 (`fn`)을 적용한 값입니다. 즉, 현재 요소에  `fn`을 적용한 결과를 새 배열 `acc`에 추가하는 방식으로 누적합니다.\n\n**Filter:**\n```javascript\n  const filter = (fn, arr) => arr.reduce((newArr, item) => {  \n  return fn(item) ? newArr.concat([item]) : newArr;  \n}, []);\n```\n필터는 predicate함수를 사용하고 요소가 조건에 맞을경우 (`fn(item)`이  `true`를 리턴 함) 새 배열에 추가합니다. 맵과 거의 동일하게 작동합니다.\n\n여러분에게 임의의 데이터 리스트가 주어진다면 위 예제들을 활용해서 데이터들을 필터링하고 함수를 적용하고 결과를 특정한 값으로 누적할 수 있습니다. 수많은 응용 프로그램애플리케이션들이 이러한 방식으로 데이터를 다룹니다. 만약 데이터가 값이 아닌 함수일 경우는 어떻게 해야 할까요?\n\n**Compose:**\n\nReduce를 사용하면 손쉽게 함수를 합성할 수도 있습니다.  함수 합성 :  `x`에  `g`를 적용하고 다시 그 결과에 함수  `f`  를 적용하는 것을  `f . g`라고 하며 JavaScript에서 다음처럼 표현됩니다.\n```javascript\n  f(g(x)) \n```\nReduce를 사용하면 합성 과정을 추상화해서 다음과 같은 함수를 쉽게 정의할 수 있는데, \n```javascript\n  f(g(h(x))) \n```\n그렇게하기 위해서는 reduce를 역으로 실행해야합니다.  즉, 왼쪽에서 오른쪽 방향이 아닌 오른쪽에서 왼쪽 방향입니다.  다행히 JavaScript에는  `.reduceRight()`메소드가 있습니다.\n```javascript\n  const compose = (...fns) => \n                  x => fns.reduceRight ((v, f) => f (v), x); \n```\n> 참고 : JavaScript엔진 버전이  `[].reduceRight()`를  지원하지 않을 경우  `reduce()`를  사용하여  `reduceRight()`를  구현할 수 있습니다.  그 방법은 찾아내는 것은 여러분들에게 맡기겠습니다.\n\n**Pipe:**\n\n`compose()`는 안에서-밖으로 즉 수학 표기법으로 함수를 합성하려는 경우 유용합니다.  그러나 당신이 함수가 순서대로 적용되는 것을 일련의 사건들로 생각하고 싶다면 어떨까요?\n\n어떤 숫자에  `1`을 더한 다음 두 배로하고 싶다고 상상해보십시오를 하려면 어떻게 해야 할까요. `compose()`를 사용하면 다음처럼 됩니다.\n```javascript\nconst add1 = n => n + 1;  \nconst double = n => n * 2;\n\nconst add1ThenDouble = compose(  \n  double,  \n  add1  \n);\n\nadd1ThenDouble(2); // 6  \n// ((2 + 1 = 3) * 2 = 6)\n```\n문제점이 보입니까?  첫 번째 단계가 마지막에 나열되므로 함수가 적용되는 순서를 이해하려면 목록의 맨 아래에서 시작하여 위쪽으로 읽어야합니다.\n\n따라서 이 문제를 해결하려면 오른쪽에서 왼쪽으로 reduce하지 않고 평소처럼 왼쪽에서 오른쪽으로하면 됩니다.\n```javascript\nconst pipe = (...fns) => x => fns.reduce((v, f) => f(v), x);\n```\n이제 다시  `add1ThenDouble()`를 만들어 보겠습니다.\n```javascript\nconst add1ThenDouble = pipe(  \n  add1,  \n  double  \n);\n\nadd1ThenDouble(2); // 6  \n// ((2 + 1 = 3) * 2 = 6)\n```\n합성의 순서가 달라지면에 따라 다른 결과가 나올 수 있기 때문에 중요합니다.\n```javascript\nconst doubleThenAdd1 = pipe(  \n  double,  \n  add1  \n);\n\ndoubleThenAdd1(2); // 5\n```\n나중에  `compose()`및  `pipe()`에 대해 자세히 설명하겠습니다.  지금 당장은 `reduce()`가 매우 강력한 도구이며, 실제로 그것을 잘 익혀야 한다는 것만 이해하면 됩니다. reduce가 매우 까다로울 수 있습니다.  하지만 어떤 사람들은 전혀 따라 가지도 못한다는 것을 명심하십시오.\n\n## Redux에 관하여\n\nRedux에서 중요 상태 업데이트 비트를 설명하는 데 \"reducer\"라는 용어를 사용합니다.  이 글을 쓰는 시점에서, Redux는 React와 Angular(`ngrx/store`의 후속작)를 사용하여 구축 된 웹 어애플리케이션을 위한 가장 인기있는 상태 관리 라이브러리 / 아키텍처입니다.\n\nRedux는 reducer함수를 사용하여 애플리케이션 상태를 관리합니다.  Redux 스타일 reducer는 현재 상태와 액션 오브젝트를 받아서 새 상태를 리턴합니다.\n```\nreducer(state: Any, action: { type: String, payload: Any}) \n   => (newState: Any)\n```\nRedux에는 다음과 같은 몇 가지 reduce 규칙이 있습니다.\n\n1.  매개 변수없이 호출 된 reducer는 초기 상태를 그대로 리턴해야합니다.\n2.  reducer가 액션을 처리하지 않으면 상태를 리턴해야합니다.\n3.  Redux reducer는 **순수 함수**여야합니다.\n\n덧셈 reducer를 Redux 스타일 reducer로 다시 작성해 보겠습니다.\n```javascript\nconst ADD_VALUE = 'ADD_VALUE';\n\nconst summingReducer = (state = 0, action = {}) => {  \n  const { type, payload } = action;\n\n  switch (type) {  \n    case ADD_VALUE:  \n      return state + payload.value;  \n    default: return state;  \n  }  \n};\n```\nRedux의 reducer는  또한 `[].reduce()`포함하여 reducer 함수의 서명를 잘 따르는  `reduce()` 구현에 연결할 수 있습니다. 즉, 일련의 액션 오브젝트 배열을 만들어 reduce하면 상태의 스냅샷을 확보 할 수 있습니다. \n```javascript\nconst actions = [  \n  { type: 'ADD_VALUE', payload: { value: 1 } },  \n  { type: 'ADD_VALUE', payload: { value: 1 } },  \n  { type: 'ADD_VALUE', payload: { value: 1 } },  \n];\n\nactions.reduce(summingReducer, 0); // 3\n```\n따라서 Redux 스타일 reducer는 유닛테스트가 매우 쉽습니다.\n## 결론\n\n당신은 reduce가 매우 유용하고 다재다능한 추상화라는 것을 알아야합니다. 맵이나 필터보다 이해하기가 약간 까다롭긴 해도 함수형 프로그래밍의 필수 도구입니다. 다른 많은 훌륭한 도구를 만드는 데 사용할 수 있습니다.\n\n[**다음: Functor와 카테고리 >**](https://midojeong.github.io/2018/04/07/functors-and-categories/)","source":"_posts/reduce.md","raw":"---\ntitle: Reduce\ncatalog: true\ndate: 2018-04-01 06:56:14\nsubtitle: \"함수형 프로그래밍의 강력한 도구\"\nheader-img: \"bg.jpg\"\nreadingTime: 6\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 함수형 프로그래밍에서 자주 보이는 Reduce(일명 fold, accumulate)는 배열을 순회하며 각 항목을 누적해서 리턴하는 함수입니다. 이 때 누적된 값을 변수로 저장해놓고 배열의 항목과 누적 값을 어떤 함수에 반복해서 전달합니다. 그 함수는 새로운 누적 값을 리턴하는 임의의 함수입니다. reduce를 사용하여 유용한 기능들을 구현할 수 있는데, 이는 보통 어떤 아이템 콜렉션을 가지고 중요한 계산을 수행하는 가장 우아한 방법입니다. reduce는 reducer 함수와 초기 값을 인자로 받고 누적 값을 리턴합니다. Array.prototype.reduce()에서 배열은 this로 참조할 수 있기 때문에 인자로 넣어줄 필요가 없습니다.\n---\n\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/reduce-composing-software-fe22f0c39a1d)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/03/29/higher-order-functions/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/07/functors-and-categories/)\n\n\n함수형 프로그래밍에서 자주 보이는  **Reduce**  (일명 : fold, accumulate)는 배열을 순회하며 각 항목을 누적해서 리턴하는 함수입니다. 이 때 누적된 값을 변수로 저장해놓고 배열의 항목과 누적 값을 어떤 함수에 반복해서 전달합니다. 그 함수는 새로운 누적 값을 리턴하는 임의의 함수입니다. reduce를 사용하여 유용한 기능들을 구현할 수 있는데, 이는 보통 어떤 아이템 콜렉션을 가지고 중요한 계산을 수행하는 가장 우아한 방법입니다.\n\nreduce는 reducer 함수와 초기 값을 인자로 받고 누적 값을 리턴합니다. `Array.prototype.reduce()`에서 배열은  `this`로 참조할 수 있기 때문에 인자로 넣어줄 필요가 없습니다.\n```\narray.reduce(  \n  reducer: (accumulator: Any, current: Any) => Any,  \n  initialValue: Any  \n) => accumulator: Any\n```\n배열의 총합을 구해보겠습니다.\n```javascript\n[2, 4, 6].reduce((acc, n) => acc + n, 0); // 12\n```\n배열의 각 요소가 현재 값이 되어 누적 값과 함께 reducer에 전달됩니다. reducer의 역할은 어떻게든 현재 값을 누적 값으로 \"폴드\"하는 것입니다.  reducer 함수의 역할은 누적되는 방식을 정의하는 것 입니다.  reducer가 새 누적 값을 리턴한 후  `reduce()`는 배열의 다음 값으로 이동합니다.  reducer는 누적될 초기 값이 필요하며 이는 매개 변수로 전달됩니다.\n\n위 코드에서 총합을 계산하는 reducer가 처음 호출되면  `acc`에  `0`  (두 번째 매개 변수로  `.reduce()`  전달 된 값)이 할당됩니다.  reducer는  `0`  +  `2` (배열의 첫 번째 요소)를 계산하여  `2`를 리턴합니다.  다음 호출에는  `acc = 2, n = 4`가 되며 reducer는  `2 + 4`( `6` )를 리턴합니다.  마지막 반복에서는  `acc = 6, n = 6`이 되고 reducer는  `12`반환합니다.  반복이 완료되면  `.reduce()`는 최종 누적 값  `12`리턴합니다.\n\n이 경우 익명 함수를 전달했지만 기명 함수를 전달 할 수도 있습니다.\n```javascript\n  const summingReducer = (acc, n) => acc + n;   \n  [2, 4, 6].reduce(summingReducer, 0);  // 12 \n```\n일반적으로  `reduce()`는 왼쪽에서 오른쪽으로 작동합니다.  JavaScript에는 그 반대로 작동하는  `[].reduceRight()`도 있습니다.  즉,  `[2, 4, 6]`에  `.reduceRight()`을 적용하면 `n`은  `6`으로 시작해서  `2`로 끝납니다.\n\n## 다양한 용도로 사용할 수 있습니다.\n\nReduce는 다재다능합니다.  reduce로  `map()`  ,  `filter()`  ,  `forEach()` 등 다양한 함수들을 쉽게 정의 할 수 있습니다.\n\n**Map:**\n```javascript\n  const map = (fn, arr) => arr.reduce((acc, item, index, arr) => {   \n  return acc.concat(fn(item, index, arr));   \n  }, []); \n```\nmap의 누적 값은 새로운 배열이 됩니다.  새 값은 `arr`의 각 요소에 맵핑 함수 (`fn`)을 적용한 값입니다. 즉, 현재 요소에  `fn`을 적용한 결과를 새 배열 `acc`에 추가하는 방식으로 누적합니다.\n\n**Filter:**\n```javascript\n  const filter = (fn, arr) => arr.reduce((newArr, item) => {  \n  return fn(item) ? newArr.concat([item]) : newArr;  \n}, []);\n```\n필터는 predicate함수를 사용하고 요소가 조건에 맞을경우 (`fn(item)`이  `true`를 리턴 함) 새 배열에 추가합니다. 맵과 거의 동일하게 작동합니다.\n\n여러분에게 임의의 데이터 리스트가 주어진다면 위 예제들을 활용해서 데이터들을 필터링하고 함수를 적용하고 결과를 특정한 값으로 누적할 수 있습니다. 수많은 응용 프로그램애플리케이션들이 이러한 방식으로 데이터를 다룹니다. 만약 데이터가 값이 아닌 함수일 경우는 어떻게 해야 할까요?\n\n**Compose:**\n\nReduce를 사용하면 손쉽게 함수를 합성할 수도 있습니다.  함수 합성 :  `x`에  `g`를 적용하고 다시 그 결과에 함수  `f`  를 적용하는 것을  `f . g`라고 하며 JavaScript에서 다음처럼 표현됩니다.\n```javascript\n  f(g(x)) \n```\nReduce를 사용하면 합성 과정을 추상화해서 다음과 같은 함수를 쉽게 정의할 수 있는데, \n```javascript\n  f(g(h(x))) \n```\n그렇게하기 위해서는 reduce를 역으로 실행해야합니다.  즉, 왼쪽에서 오른쪽 방향이 아닌 오른쪽에서 왼쪽 방향입니다.  다행히 JavaScript에는  `.reduceRight()`메소드가 있습니다.\n```javascript\n  const compose = (...fns) => \n                  x => fns.reduceRight ((v, f) => f (v), x); \n```\n> 참고 : JavaScript엔진 버전이  `[].reduceRight()`를  지원하지 않을 경우  `reduce()`를  사용하여  `reduceRight()`를  구현할 수 있습니다.  그 방법은 찾아내는 것은 여러분들에게 맡기겠습니다.\n\n**Pipe:**\n\n`compose()`는 안에서-밖으로 즉 수학 표기법으로 함수를 합성하려는 경우 유용합니다.  그러나 당신이 함수가 순서대로 적용되는 것을 일련의 사건들로 생각하고 싶다면 어떨까요?\n\n어떤 숫자에  `1`을 더한 다음 두 배로하고 싶다고 상상해보십시오를 하려면 어떻게 해야 할까요. `compose()`를 사용하면 다음처럼 됩니다.\n```javascript\nconst add1 = n => n + 1;  \nconst double = n => n * 2;\n\nconst add1ThenDouble = compose(  \n  double,  \n  add1  \n);\n\nadd1ThenDouble(2); // 6  \n// ((2 + 1 = 3) * 2 = 6)\n```\n문제점이 보입니까?  첫 번째 단계가 마지막에 나열되므로 함수가 적용되는 순서를 이해하려면 목록의 맨 아래에서 시작하여 위쪽으로 읽어야합니다.\n\n따라서 이 문제를 해결하려면 오른쪽에서 왼쪽으로 reduce하지 않고 평소처럼 왼쪽에서 오른쪽으로하면 됩니다.\n```javascript\nconst pipe = (...fns) => x => fns.reduce((v, f) => f(v), x);\n```\n이제 다시  `add1ThenDouble()`를 만들어 보겠습니다.\n```javascript\nconst add1ThenDouble = pipe(  \n  add1,  \n  double  \n);\n\nadd1ThenDouble(2); // 6  \n// ((2 + 1 = 3) * 2 = 6)\n```\n합성의 순서가 달라지면에 따라 다른 결과가 나올 수 있기 때문에 중요합니다.\n```javascript\nconst doubleThenAdd1 = pipe(  \n  double,  \n  add1  \n);\n\ndoubleThenAdd1(2); // 5\n```\n나중에  `compose()`및  `pipe()`에 대해 자세히 설명하겠습니다.  지금 당장은 `reduce()`가 매우 강력한 도구이며, 실제로 그것을 잘 익혀야 한다는 것만 이해하면 됩니다. reduce가 매우 까다로울 수 있습니다.  하지만 어떤 사람들은 전혀 따라 가지도 못한다는 것을 명심하십시오.\n\n## Redux에 관하여\n\nRedux에서 중요 상태 업데이트 비트를 설명하는 데 \"reducer\"라는 용어를 사용합니다.  이 글을 쓰는 시점에서, Redux는 React와 Angular(`ngrx/store`의 후속작)를 사용하여 구축 된 웹 어애플리케이션을 위한 가장 인기있는 상태 관리 라이브러리 / 아키텍처입니다.\n\nRedux는 reducer함수를 사용하여 애플리케이션 상태를 관리합니다.  Redux 스타일 reducer는 현재 상태와 액션 오브젝트를 받아서 새 상태를 리턴합니다.\n```\nreducer(state: Any, action: { type: String, payload: Any}) \n   => (newState: Any)\n```\nRedux에는 다음과 같은 몇 가지 reduce 규칙이 있습니다.\n\n1.  매개 변수없이 호출 된 reducer는 초기 상태를 그대로 리턴해야합니다.\n2.  reducer가 액션을 처리하지 않으면 상태를 리턴해야합니다.\n3.  Redux reducer는 **순수 함수**여야합니다.\n\n덧셈 reducer를 Redux 스타일 reducer로 다시 작성해 보겠습니다.\n```javascript\nconst ADD_VALUE = 'ADD_VALUE';\n\nconst summingReducer = (state = 0, action = {}) => {  \n  const { type, payload } = action;\n\n  switch (type) {  \n    case ADD_VALUE:  \n      return state + payload.value;  \n    default: return state;  \n  }  \n};\n```\nRedux의 reducer는  또한 `[].reduce()`포함하여 reducer 함수의 서명를 잘 따르는  `reduce()` 구현에 연결할 수 있습니다. 즉, 일련의 액션 오브젝트 배열을 만들어 reduce하면 상태의 스냅샷을 확보 할 수 있습니다. \n```javascript\nconst actions = [  \n  { type: 'ADD_VALUE', payload: { value: 1 } },  \n  { type: 'ADD_VALUE', payload: { value: 1 } },  \n  { type: 'ADD_VALUE', payload: { value: 1 } },  \n];\n\nactions.reduce(summingReducer, 0); // 3\n```\n따라서 Redux 스타일 reducer는 유닛테스트가 매우 쉽습니다.\n## 결론\n\n당신은 reduce가 매우 유용하고 다재다능한 추상화라는 것을 알아야합니다. 맵이나 필터보다 이해하기가 약간 까다롭긴 해도 함수형 프로그래밍의 필수 도구입니다. 다른 많은 훌륭한 도구를 만드는 데 사용할 수 있습니다.\n\n[**다음: Functor와 카테고리 >**](https://midojeong.github.io/2018/04/07/functors-and-categories/)","slug":"reduce","published":1,"updated":"2018-04-28T13:33:42.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83el000rifp69otsm9t3","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/reduce-composing-software-fe22f0c39a1d\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/29/higher-order-functions/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/07/functors-and-categories/\">다음&gt;</a></p>\n</blockquote>\n<p>함수형 프로그래밍에서 자주 보이는  <strong>Reduce</strong>  (일명 : fold, accumulate)는 배열을 순회하며 각 항목을 누적해서 리턴하는 함수입니다. 이 때 누적된 값을 변수로 저장해놓고 배열의 항목과 누적 값을 어떤 함수에 반복해서 전달합니다. 그 함수는 새로운 누적 값을 리턴하는 임의의 함수입니다. reduce를 사용하여 유용한 기능들을 구현할 수 있는데, 이는 보통 어떤 아이템 콜렉션을 가지고 중요한 계산을 수행하는 가장 우아한 방법입니다.</p>\n<p>reduce는 reducer 함수와 초기 값을 인자로 받고 누적 값을 리턴합니다. <code>Array.prototype.reduce()</code>에서 배열은  <code>this</code>로 참조할 수 있기 때문에 인자로 넣어줄 필요가 없습니다.</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.reduce(  </span><br><span class=\"line\">  reducer: (accumulator: <span class=\"built_in\">Any</span>, current: <span class=\"built_in\">Any</span>) =&gt; <span class=\"built_in\">Any</span>,  </span><br><span class=\"line\">  initialValue: <span class=\"built_in\">Any</span>  </span><br><span class=\"line\">) =&gt; accumulator: <span class=\"built_in\">Any</span></span><br></pre></td></tr></table></figure>\n<p>배열의 총합을 구해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>].reduce(<span class=\"function\">(<span class=\"params\">acc, n</span>) =&gt;</span> acc + n, <span class=\"number\">0</span>); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<p>배열의 각 요소가 현재 값이 되어 누적 값과 함께 reducer에 전달됩니다. reducer의 역할은 어떻게든 현재 값을 누적 값으로 &quot;폴드&quot;하는 것입니다.  reducer 함수의 역할은 누적되는 방식을 정의하는 것 입니다.  reducer가 새 누적 값을 리턴한 후  <code>reduce()</code>는 배열의 다음 값으로 이동합니다.  reducer는 누적될 초기 값이 필요하며 이는 매개 변수로 전달됩니다.</p>\n<p>위 코드에서 총합을 계산하는 reducer가 처음 호출되면  <code>acc</code>에  <code>0</code>  (두 번째 매개 변수로  <code>.reduce()</code>  전달 된 값)이 할당됩니다.  reducer는  <code>0</code>  +  <code>2</code> (배열의 첫 번째 요소)를 계산하여  <code>2</code>를 리턴합니다.  다음 호출에는  <code>acc = 2, n = 4</code>가 되며 reducer는  <code>2 + 4</code>( <code>6</code> )를 리턴합니다.  마지막 반복에서는  <code>acc = 6, n = 6</code>이 되고 reducer는  <code>12</code>반환합니다.  반복이 완료되면  <code>.reduce()</code>는 최종 누적 값  <code>12</code>리턴합니다.</p>\n<p>이 경우 익명 함수를 전달했지만 기명 함수를 전달 할 수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> summingReducer = <span class=\"function\">(<span class=\"params\">acc, n</span>) =&gt;</span> acc + n;   </span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>].reduce(summingReducer, <span class=\"number\">0</span>);  <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<p>일반적으로  <code>reduce()</code>는 왼쪽에서 오른쪽으로 작동합니다.  JavaScript에는 그 반대로 작동하는  <code>[].reduceRight()</code>도 있습니다.  즉,  <code>[2, 4, 6]</code>에  <code>.reduceRight()</code>을 적용하면 <code>n</code>은  <code>6</code>으로 시작해서  <code>2</code>로 끝납니다.</p>\n<h2 id=\"다양한-용도로-사용할-수-있습니다\">다양한 용도로 사용할 수 있습니다.</h2>\n<p>Reduce는 다재다능합니다.  reduce로  <code>map()</code>  ,  <code>filter()</code>  ,  <code>forEach()</code> 등 다양한 함수들을 쉽게 정의 할 수 있습니다.</p>\n<p><strong>Map:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">fn, arr</span>) =&gt;</span> arr.reduce(<span class=\"function\">(<span class=\"params\">acc, item, index, arr</span>) =&gt;</span> &#123;   </span><br><span class=\"line\"><span class=\"keyword\">return</span> acc.concat(fn(item, index, arr));   </span><br><span class=\"line\">&#125;, []);</span><br></pre></td></tr></table></figure>\n<p>map의 누적 값은 새로운 배열이 됩니다.  새 값은 <code>arr</code>의 각 요소에 맵핑 함수 (<code>fn</code>)을 적용한 값입니다. 즉, 현재 요소에  <code>fn</code>을 적용한 결과를 새 배열 <code>acc</code>에 추가하는 방식으로 누적합니다.</p>\n<p><strong>Filter:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">const</span> filter = <span class=\"function\">(<span class=\"params\">fn, arr</span>) =&gt;</span> arr.reduce(<span class=\"function\">(<span class=\"params\">newArr, item</span>) =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(item) ? newArr.concat([item]) : newArr;  </span><br><span class=\"line\">&#125;, []);</span><br></pre></td></tr></table></figure>\n<p>필터는 predicate함수를 사용하고 요소가 조건에 맞을경우 (<code>fn(item)</code>이  <code>true</code>를 리턴 함) 새 배열에 추가합니다. 맵과 거의 동일하게 작동합니다.</p>\n<p>여러분에게 임의의 데이터 리스트가 주어진다면 위 예제들을 활용해서 데이터들을 필터링하고 함수를 적용하고 결과를 특정한 값으로 누적할 수 있습니다. 수많은 응용 프로그램애플리케이션들이 이러한 방식으로 데이터를 다룹니다. 만약 데이터가 값이 아닌 함수일 경우는 어떻게 해야 할까요?</p>\n<p><strong>Compose:</strong></p>\n<p>Reduce를 사용하면 손쉽게 함수를 합성할 수도 있습니다.  함수 합성 :  <code>x</code>에  <code>g</code>를 적용하고 다시 그 결과에 함수  <code>f</code>  를 적용하는 것을  <code>f . g</code>라고 하며 JavaScript에서 다음처럼 표현됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(g(x))</span><br></pre></td></tr></table></figure>\n<p>Reduce를 사용하면 합성 과정을 추상화해서 다음과 같은 함수를 쉽게 정의할 수 있는데,</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(g(h(x)))</span><br></pre></td></tr></table></figure>\n<p>그렇게하기 위해서는 reduce를 역으로 실행해야합니다.  즉, 왼쪽에서 오른쪽 방향이 아닌 오른쪽에서 왼쪽 방향입니다.  다행히 JavaScript에는  <code>.reduceRight()</code>메소드가 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> </span><br><span class=\"line\">                x =&gt; fns.reduceRight (<span class=\"function\">(<span class=\"params\">v, f</span>) =&gt;</span> f (v), x);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>참고 : JavaScript엔진 버전이  <code>[].reduceRight()</code>를  지원하지 않을 경우  <code>reduce()</code>를  사용하여  <code>reduceRight()</code>를  구현할 수 있습니다.  그 방법은 찾아내는 것은 여러분들에게 맡기겠습니다.</p>\n</blockquote>\n<p><strong>Pipe:</strong></p>\n<p><code>compose()</code>는 안에서-밖으로 즉 수학 표기법으로 함수를 합성하려는 경우 유용합니다.  그러나 당신이 함수가 순서대로 적용되는 것을 일련의 사건들로 생각하고 싶다면 어떨까요?</p>\n<p>어떤 숫자에  <code>1</code>을 더한 다음 두 배로하고 싶다고 상상해보십시오를 하려면 어떻게 해야 할까요. <code>compose()</code>를 사용하면 다음처럼 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add1 = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> add1ThenDouble = compose(  </span><br><span class=\"line\">  double,  </span><br><span class=\"line\">  add1  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">add1ThenDouble(<span class=\"number\">2</span>); <span class=\"comment\">// 6  </span></span><br><span class=\"line\"><span class=\"comment\">// ((2 + 1 = 3) * 2 = 6)</span></span><br></pre></td></tr></table></figure>\n<p>문제점이 보입니까?  첫 번째 단계가 마지막에 나열되므로 함수가 적용되는 순서를 이해하려면 목록의 맨 아래에서 시작하여 위쪽으로 읽어야합니다.</p>\n<p>따라서 이 문제를 해결하려면 오른쪽에서 왼쪽으로 reduce하지 않고 평소처럼 왼쪽에서 오른쪽으로하면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">v, f</span>) =&gt;</span> f(v), x);</span><br></pre></td></tr></table></figure>\n<p>이제 다시  <code>add1ThenDouble()</code>를 만들어 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add1ThenDouble = pipe(  </span><br><span class=\"line\">  add1,  </span><br><span class=\"line\">  double  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">add1ThenDouble(<span class=\"number\">2</span>); <span class=\"comment\">// 6  </span></span><br><span class=\"line\"><span class=\"comment\">// ((2 + 1 = 3) * 2 = 6)</span></span><br></pre></td></tr></table></figure>\n<p>합성의 순서가 달라지면에 따라 다른 결과가 나올 수 있기 때문에 중요합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doubleThenAdd1 = pipe(  </span><br><span class=\"line\">  double,  </span><br><span class=\"line\">  add1  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">doubleThenAdd1(<span class=\"number\">2</span>); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>나중에  <code>compose()</code>및  <code>pipe()</code>에 대해 자세히 설명하겠습니다.  지금 당장은 <code>reduce()</code>가 매우 강력한 도구이며, 실제로 그것을 잘 익혀야 한다는 것만 이해하면 됩니다. reduce가 매우 까다로울 수 있습니다.  하지만 어떤 사람들은 전혀 따라 가지도 못한다는 것을 명심하십시오.</p>\n<h2 id=\"redux에-관하여\">Redux에 관하여</h2>\n<p>Redux에서 중요 상태 업데이트 비트를 설명하는 데 &quot;reducer&quot;라는 용어를 사용합니다.  이 글을 쓰는 시점에서, Redux는 React와 Angular(<code>ngrx/store</code>의 후속작)를 사용하여 구축 된 웹 어애플리케이션을 위한 가장 인기있는 상태 관리 라이브러리 / 아키텍처입니다.</p>\n<p>Redux는 reducer함수를 사용하여 애플리케이션 상태를 관리합니다.  Redux 스타일 reducer는 현재 상태와 액션 오브젝트를 받아서 새 상태를 리턴합니다.</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">reducer</span>(<span class=\"attribute\">state</span>: Any, <span class=\"attribute\">action</span>: &#123; <span class=\"attribute\">type</span>: String, <span class=\"attribute\">payload</span>: Any&#125;) </span><br><span class=\"line\">   =&gt; (<span class=\"attribute\">newState</span>: Any)</span><br></pre></td></tr></table></figure>\n<p>Redux에는 다음과 같은 몇 가지 reduce 규칙이 있습니다.</p>\n<ol>\n<li>매개 변수없이 호출 된 reducer는 초기 상태를 그대로 리턴해야합니다.</li>\n<li>reducer가 액션을 처리하지 않으면 상태를 리턴해야합니다.</li>\n<li>Redux reducer는 <strong>순수 함수</strong>여야합니다.</li>\n</ol>\n<p>덧셈 reducer를 Redux 스타일 reducer로 다시 작성해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ADD_VALUE = <span class=\"string\">'ADD_VALUE'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> summingReducer = <span class=\"function\">(<span class=\"params\">state = <span class=\"number\">0</span>, action = &#123;&#125;</span>) =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; type, payload &#125; = action;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (type) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_VALUE:  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + payload.value;  </span><br><span class=\"line\">    <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> state;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Redux의 reducer는  또한 <code>[].reduce()</code>포함하여 reducer 함수의 서명를 잘 따르는  <code>reduce()</code> 구현에 연결할 수 있습니다. 즉, 일련의 액션 오브젝트 배열을 만들어 reduce하면 상태의 스냅샷을 확보 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> actions = [  </span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">'ADD_VALUE'</span>, <span class=\"attr\">payload</span>: &#123; <span class=\"attr\">value</span>: <span class=\"number\">1</span> &#125; &#125;,  </span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">'ADD_VALUE'</span>, <span class=\"attr\">payload</span>: &#123; <span class=\"attr\">value</span>: <span class=\"number\">1</span> &#125; &#125;,  </span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">'ADD_VALUE'</span>, <span class=\"attr\">payload</span>: &#123; <span class=\"attr\">value</span>: <span class=\"number\">1</span> &#125; &#125;,  </span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">actions.reduce(summingReducer, <span class=\"number\">0</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>따라서 Redux 스타일 reducer는 유닛테스트가 매우 쉽습니다.</p>\n<h2 id=\"결론\">결론</h2>\n<p>당신은 reduce가 매우 유용하고 다재다능한 추상화라는 것을 알아야합니다. 맵이나 필터보다 이해하기가 약간 까다롭긴 해도 함수형 프로그래밍의 필수 도구입니다. 다른 많은 훌륭한 도구를 만드는 데 사용할 수 있습니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/07/functors-and-categories/\"><strong>다음: Functor와 카테고리 &gt;</strong></a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/reduce-composing-software-fe22f0c39a1d\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/29/higher-order-functions/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/07/functors-and-categories/\">다음&gt;</a></p>\n</blockquote>\n<p>함수형 프로그래밍에서 자주 보이는  <strong>Reduce</strong>  (일명 : fold, accumulate)는 배열을 순회하며 각 항목을 누적해서 리턴하는 함수입니다. 이 때 누적된 값을 변수로 저장해놓고 배열의 항목과 누적 값을 어떤 함수에 반복해서 전달합니다. 그 함수는 새로운 누적 값을 리턴하는 임의의 함수입니다. reduce를 사용하여 유용한 기능들을 구현할 수 있는데, 이는 보통 어떤 아이템 콜렉션을 가지고 중요한 계산을 수행하는 가장 우아한 방법입니다.</p>\n<p>reduce는 reducer 함수와 초기 값을 인자로 받고 누적 값을 리턴합니다. <code>Array.prototype.reduce()</code>에서 배열은  <code>this</code>로 참조할 수 있기 때문에 인자로 넣어줄 필요가 없습니다.</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.reduce(  </span><br><span class=\"line\">  reducer: (accumulator: <span class=\"built_in\">Any</span>, current: <span class=\"built_in\">Any</span>) =&gt; <span class=\"built_in\">Any</span>,  </span><br><span class=\"line\">  initialValue: <span class=\"built_in\">Any</span>  </span><br><span class=\"line\">) =&gt; accumulator: <span class=\"built_in\">Any</span></span><br></pre></td></tr></table></figure>\n<p>배열의 총합을 구해보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>].reduce(<span class=\"function\">(<span class=\"params\">acc, n</span>) =&gt;</span> acc + n, <span class=\"number\">0</span>); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<p>배열의 각 요소가 현재 값이 되어 누적 값과 함께 reducer에 전달됩니다. reducer의 역할은 어떻게든 현재 값을 누적 값으로 &quot;폴드&quot;하는 것입니다.  reducer 함수의 역할은 누적되는 방식을 정의하는 것 입니다.  reducer가 새 누적 값을 리턴한 후  <code>reduce()</code>는 배열의 다음 값으로 이동합니다.  reducer는 누적될 초기 값이 필요하며 이는 매개 변수로 전달됩니다.</p>\n<p>위 코드에서 총합을 계산하는 reducer가 처음 호출되면  <code>acc</code>에  <code>0</code>  (두 번째 매개 변수로  <code>.reduce()</code>  전달 된 값)이 할당됩니다.  reducer는  <code>0</code>  +  <code>2</code> (배열의 첫 번째 요소)를 계산하여  <code>2</code>를 리턴합니다.  다음 호출에는  <code>acc = 2, n = 4</code>가 되며 reducer는  <code>2 + 4</code>( <code>6</code> )를 리턴합니다.  마지막 반복에서는  <code>acc = 6, n = 6</code>이 되고 reducer는  <code>12</code>반환합니다.  반복이 완료되면  <code>.reduce()</code>는 최종 누적 값  <code>12</code>리턴합니다.</p>\n<p>이 경우 익명 함수를 전달했지만 기명 함수를 전달 할 수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> summingReducer = <span class=\"function\">(<span class=\"params\">acc, n</span>) =&gt;</span> acc + n;   </span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>].reduce(summingReducer, <span class=\"number\">0</span>);  <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<p>일반적으로  <code>reduce()</code>는 왼쪽에서 오른쪽으로 작동합니다.  JavaScript에는 그 반대로 작동하는  <code>[].reduceRight()</code>도 있습니다.  즉,  <code>[2, 4, 6]</code>에  <code>.reduceRight()</code>을 적용하면 <code>n</code>은  <code>6</code>으로 시작해서  <code>2</code>로 끝납니다.</p>\n<h2>다양한 용도로 사용할 수 있습니다.</h2>\n<p>Reduce는 다재다능합니다.  reduce로  <code>map()</code>  ,  <code>filter()</code>  ,  <code>forEach()</code> 등 다양한 함수들을 쉽게 정의 할 수 있습니다.</p>\n<p><strong>Map:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">fn, arr</span>) =&gt;</span> arr.reduce(<span class=\"function\">(<span class=\"params\">acc, item, index, arr</span>) =&gt;</span> &#123;   </span><br><span class=\"line\"><span class=\"keyword\">return</span> acc.concat(fn(item, index, arr));   </span><br><span class=\"line\">&#125;, []);</span><br></pre></td></tr></table></figure>\n<p>map의 누적 값은 새로운 배열이 됩니다.  새 값은 <code>arr</code>의 각 요소에 맵핑 함수 (<code>fn</code>)을 적용한 값입니다. 즉, 현재 요소에  <code>fn</code>을 적용한 결과를 새 배열 <code>acc</code>에 추가하는 방식으로 누적합니다.</p>\n<p><strong>Filter:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">const</span> filter = <span class=\"function\">(<span class=\"params\">fn, arr</span>) =&gt;</span> arr.reduce(<span class=\"function\">(<span class=\"params\">newArr, item</span>) =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(item) ? newArr.concat([item]) : newArr;  </span><br><span class=\"line\">&#125;, []);</span><br></pre></td></tr></table></figure>\n<p>필터는 predicate함수를 사용하고 요소가 조건에 맞을경우 (<code>fn(item)</code>이  <code>true</code>를 리턴 함) 새 배열에 추가합니다. 맵과 거의 동일하게 작동합니다.</p>\n<p>여러분에게 임의의 데이터 리스트가 주어진다면 위 예제들을 활용해서 데이터들을 필터링하고 함수를 적용하고 결과를 특정한 값으로 누적할 수 있습니다. 수많은 응용 프로그램애플리케이션들이 이러한 방식으로 데이터를 다룹니다. 만약 데이터가 값이 아닌 함수일 경우는 어떻게 해야 할까요?</p>\n<p><strong>Compose:</strong></p>\n<p>Reduce를 사용하면 손쉽게 함수를 합성할 수도 있습니다.  함수 합성 :  <code>x</code>에  <code>g</code>를 적용하고 다시 그 결과에 함수  <code>f</code>  를 적용하는 것을  <code>f . g</code>라고 하며 JavaScript에서 다음처럼 표현됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(g(x))</span><br></pre></td></tr></table></figure>\n<p>Reduce를 사용하면 합성 과정을 추상화해서 다음과 같은 함수를 쉽게 정의할 수 있는데,</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(g(h(x)))</span><br></pre></td></tr></table></figure>\n<p>그렇게하기 위해서는 reduce를 역으로 실행해야합니다.  즉, 왼쪽에서 오른쪽 방향이 아닌 오른쪽에서 왼쪽 방향입니다.  다행히 JavaScript에는  <code>.reduceRight()</code>메소드가 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> </span><br><span class=\"line\">                x =&gt; fns.reduceRight (<span class=\"function\">(<span class=\"params\">v, f</span>) =&gt;</span> f (v), x);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>참고 : JavaScript엔진 버전이  <code>[].reduceRight()</code>를  지원하지 않을 경우  <code>reduce()</code>를  사용하여  <code>reduceRight()</code>를  구현할 수 있습니다.  그 방법은 찾아내는 것은 여러분들에게 맡기겠습니다.</p>\n</blockquote>\n<p><strong>Pipe:</strong></p>\n<p><code>compose()</code>는 안에서-밖으로 즉 수학 표기법으로 함수를 합성하려는 경우 유용합니다.  그러나 당신이 함수가 순서대로 적용되는 것을 일련의 사건들로 생각하고 싶다면 어떨까요?</p>\n<p>어떤 숫자에  <code>1</code>을 더한 다음 두 배로하고 싶다고 상상해보십시오를 하려면 어떻게 해야 할까요. <code>compose()</code>를 사용하면 다음처럼 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add1 = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> add1ThenDouble = compose(  </span><br><span class=\"line\">  double,  </span><br><span class=\"line\">  add1  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">add1ThenDouble(<span class=\"number\">2</span>); <span class=\"comment\">// 6  </span></span><br><span class=\"line\"><span class=\"comment\">// ((2 + 1 = 3) * 2 = 6)</span></span><br></pre></td></tr></table></figure>\n<p>문제점이 보입니까?  첫 번째 단계가 마지막에 나열되므로 함수가 적용되는 순서를 이해하려면 목록의 맨 아래에서 시작하여 위쪽으로 읽어야합니다.</p>\n<p>따라서 이 문제를 해결하려면 오른쪽에서 왼쪽으로 reduce하지 않고 평소처럼 왼쪽에서 오른쪽으로하면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> x =&gt; fns.reduce(<span class=\"function\">(<span class=\"params\">v, f</span>) =&gt;</span> f(v), x);</span><br></pre></td></tr></table></figure>\n<p>이제 다시  <code>add1ThenDouble()</code>를 만들어 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add1ThenDouble = pipe(  </span><br><span class=\"line\">  add1,  </span><br><span class=\"line\">  double  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">add1ThenDouble(<span class=\"number\">2</span>); <span class=\"comment\">// 6  </span></span><br><span class=\"line\"><span class=\"comment\">// ((2 + 1 = 3) * 2 = 6)</span></span><br></pre></td></tr></table></figure>\n<p>합성의 순서가 달라지면에 따라 다른 결과가 나올 수 있기 때문에 중요합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doubleThenAdd1 = pipe(  </span><br><span class=\"line\">  double,  </span><br><span class=\"line\">  add1  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">doubleThenAdd1(<span class=\"number\">2</span>); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>나중에  <code>compose()</code>및  <code>pipe()</code>에 대해 자세히 설명하겠습니다.  지금 당장은 <code>reduce()</code>가 매우 강력한 도구이며, 실제로 그것을 잘 익혀야 한다는 것만 이해하면 됩니다. reduce가 매우 까다로울 수 있습니다.  하지만 어떤 사람들은 전혀 따라 가지도 못한다는 것을 명심하십시오.</p>\n<h2>Redux에 관하여</h2>\n<p>Redux에서 중요 상태 업데이트 비트를 설명하는 데 &quot;reducer&quot;라는 용어를 사용합니다.  이 글을 쓰는 시점에서, Redux는 React와 Angular(<code>ngrx/store</code>의 후속작)를 사용하여 구축 된 웹 어애플리케이션을 위한 가장 인기있는 상태 관리 라이브러리 / 아키텍처입니다.</p>\n<p>Redux는 reducer함수를 사용하여 애플리케이션 상태를 관리합니다.  Redux 스타일 reducer는 현재 상태와 액션 오브젝트를 받아서 새 상태를 리턴합니다.</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">reducer</span>(<span class=\"attribute\">state</span>: Any, <span class=\"attribute\">action</span>: &#123; <span class=\"attribute\">type</span>: String, <span class=\"attribute\">payload</span>: Any&#125;) </span><br><span class=\"line\">   =&gt; (<span class=\"attribute\">newState</span>: Any)</span><br></pre></td></tr></table></figure>\n<p>Redux에는 다음과 같은 몇 가지 reduce 규칙이 있습니다.</p>\n<ol>\n<li>매개 변수없이 호출 된 reducer는 초기 상태를 그대로 리턴해야합니다.</li>\n<li>reducer가 액션을 처리하지 않으면 상태를 리턴해야합니다.</li>\n<li>Redux reducer는 <strong>순수 함수</strong>여야합니다.</li>\n</ol>\n<p>덧셈 reducer를 Redux 스타일 reducer로 다시 작성해 보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ADD_VALUE = <span class=\"string\">'ADD_VALUE'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> summingReducer = <span class=\"function\">(<span class=\"params\">state = <span class=\"number\">0</span>, action = &#123;&#125;</span>) =&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; type, payload &#125; = action;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (type) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_VALUE:  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + payload.value;  </span><br><span class=\"line\">    <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> state;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Redux의 reducer는  또한 <code>[].reduce()</code>포함하여 reducer 함수의 서명를 잘 따르는  <code>reduce()</code> 구현에 연결할 수 있습니다. 즉, 일련의 액션 오브젝트 배열을 만들어 reduce하면 상태의 스냅샷을 확보 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> actions = [  </span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">'ADD_VALUE'</span>, <span class=\"attr\">payload</span>: &#123; <span class=\"attr\">value</span>: <span class=\"number\">1</span> &#125; &#125;,  </span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">'ADD_VALUE'</span>, <span class=\"attr\">payload</span>: &#123; <span class=\"attr\">value</span>: <span class=\"number\">1</span> &#125; &#125;,  </span><br><span class=\"line\">  &#123; <span class=\"attr\">type</span>: <span class=\"string\">'ADD_VALUE'</span>, <span class=\"attr\">payload</span>: &#123; <span class=\"attr\">value</span>: <span class=\"number\">1</span> &#125; &#125;,  </span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">actions.reduce(summingReducer, <span class=\"number\">0</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>따라서 Redux 스타일 reducer는 유닛테스트가 매우 쉽습니다.</p>\n<h2>결론</h2>\n<p>당신은 reduce가 매우 유용하고 다재다능한 추상화라는 것을 알아야합니다. 맵이나 필터보다 이해하기가 약간 까다롭긴 해도 함수형 프로그래밍의 필수 도구입니다. 다른 많은 훌륭한 도구를 만드는 데 사용할 수 있습니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/07/functors-and-categories/\"><strong>다음: Functor와 카테고리 &gt;</strong></a></p>\n"},{"title":"객체 합성이라는 숨겨진 보물","catalog":true,"date":"2018-04-23T06:05:12.000Z","subtitle":"The Hidden Treasures of Object Composition","header-img":"bg.jpg","readingTime":10,"catagories":["개발"],"preview":"소프트웨어를 개발하는 과정에서 가장 흔히 볼 수 있는 실수 중 하나는 클래스 상속을 과도하게 사용하는 경향입니다.  클래스 상속은 기본 클래스와 하위 클래스 사이에 는 이다(is a)  관계를 만들어 코드를 재사용하는 메커니즘입니다.   is a  관계 (e.g. 오리는 새이다)를 사용하여 도메인을 모델링하는 과정에서 문제가 발생할 수 있습니다.  그 이유는 클래스 상속이 객체 지향 디자인에서 사용할 수 있는 가장 단단한 형태의 결합이기 때문입니다. 결국 다음과 같은(그 외에도) 많은 문제들을 일으킵니다","_content":"\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/)\n\n\n> \"객체 합성, 보다 복잡한 동작을 하기 위해 객체를 조립 또는 합성하는 것\"~ 4 강  [\"디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소\"](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&qid=1494993475&sr=8-1&keywords=design+patterns&linkCode=ll1&tag=eejs-20&linkId=6c553f16325f3939e5abadd4ee04e8b4)\n\n> \"클래스 상속보다는 객체 합성을 우선해라\", Gang of Four,  \n\n소프트웨어를 개발하는 과정에서 가장 흔히 볼 수 있는 실수 중 하나는 클래스 상속을 과도하게 사용하는 경향입니다.  클래스 상속은 기본 클래스와 하위 클래스 사이에 **는-이다(is-a)**  관계를 만들어 코드를 재사용하는 메커니즘입니다.   _is-a_  관계 (e.g. 오리는 새이다)를 사용하여 도메인을 모델링하는 과정에서 문제가 발생할 수 있습니다.  그 이유는 클래스 상속이 객체 지향 디자인에서 사용할 수 있는 가장 단단한 형태의 결합이기 때문입니다. 결국 다음과 같은(그 외에도) 많은 문제들을 일으킵니다 :\n\n-   깨지기 쉬운 기본 클래스 문제\n-   고릴라 / 바나나 문제\n-   중복 필요성 문제\n\n상속은 하위 클래스가 상속, 추가 및 오버라이딩할 수 있는 기본 클래스를 공용 인터페이스로 추상화하여 코드를 재사용합니다.  **추상화**에는 두 가지 중요한 특징이 있습니다.\n\n-   **일반화^Generalization^**  일반적인 사용사례에 해당하는 공유 속성 및 동작들을 추출하는 과정\n-   **전문화^Specialization^**  특수한 경우를 처리하는 데 필요한 구현 세부 사항을 제공하는 과정\n\n코드를 일반화 및 전문화하는데는 여러 가지 방법이 있습니다.  클래스 상속대신 사용할 수 있는 좋은 대안으로는 단순 함수, 고차 함수 및  **객체 합성**이있습니다.\n\n불행히도, 많은 사람들이 객체 합성에 대해 오해하고 있으며 이러한 관점으로 생각하기 어려워 합니다.  주제에 대해 좀 더 깊이 알아봐야 할 필요가 있습니다.\n\n## 객체 합성^Object^ ^Composition^이란 무엇입니까?\n\n> \"컴퓨터 과학에서의 복합 자료형^Composite^ ^datatype^이란 프로그래밍 언어의 원시 자료형 및 기타 복합 유형을 사용하여 구성 할 수있는 모든 데이터 유형입니다.  [...] 복합 유형을 구성하는 행위는 합성^Composition^으로 알려져 있습니다. \"~ Wikipedia\n\n기본형들을 조립해 복합 객체를 만드는 모든 행위가 객체 합성입니다. 그러나 상속은 마치 객체 합성과는 전혀 관련이 없으며 심지어 정반대의 기술인 것처럼 논의되고 있습니다. 이러한 편견이 생기는 이유는 객체 합성의 문법과 의미간에 차이가 있기 때문입니다.\n\n지금부터 알아볼 객체 합성과 클래스 상속에 관한 논의는 특정 기법에 관한 것이 아닙니다.  구성 요소들 사이의  _의미론적_  관계와   _결합 정도에_  대한 것입니다.  우리는  _문법_ 이 아니라 _의미_ 에 대해 말하고 있습니다. 사람들은 종종 이 둘을 구별하지 못하고 세부적인 문법에만 집중합니다.  숲을 보지 못하고 나무만 보고있는 셈입니다.\n\n객체는 여러가지 다른 방법으로 합성됩니다.  합성 형태에 따라 복합체의 구조와 객체간의 관계가 달라집니다. 어떤 객체가 다른 객체에 종속되면 한 객체가 변경되었을 때 다른 객체가 손상 될 수 있습니다.\n\n\"클래스 상속보다는 객체 합성을 우선해라\"라는 조언은 우리가 객체를 바라보는 방식을 거대한 기본 클래스로부터 상속받는 것이 아닌 작고 느슨하게 결합 된 요소들의 합성으로 생각하라는 뜻입니다.  GoF는 단단히 결합 된 객체를 \"모놀리틱^[monolithic  단일체의, 한 덩어리로 뭉친, 단일 결정으로된] 시스템\"이라고 설명합니다. 이 시스템에서 어떤 클래스를 변경하거나 제거하려면 다른 수많은 클래스를 이해하고 변경해야 합니다. 결국 이러한 시스템은 이해하고, 이식하고, 유지하기 힘든 조밀한 덩어리가 됩니다. \"\n\n## 객체 합성의 세 가지 다른 형태\n\n\"Design Patterns\"에서 Gang of Four는 \"객체 합성은 여러 디자인 패턴에 다양하게 적용될 것 입니다\"라고 말하고 계속해서  _집합_  및  _위임_ 을 포함한 다양한 유형의 구성 관계를 설명합니다.\n\n\"Design Patterns\"의 저자는 주로 C ++ 및 Smalltalk (이후 Java) 환경에서 작업했습니다.  해당 언어로 런타임에 객체 관계를 정의하고 변경하는 작업은 JavaScript에서보다 훨씬 복잡하므로 해당 주제를 깊게 다루진 않을 것 입니다.  그러나 JavaScript의 객체 합성에 대해 논의하기 위해 먼저 동적 객체 확장 ( 일명, _concatenation_ )에 대한 논의가 우선되어야 합니다.\n\n각 용어들은 \"Design Patterns\"에 나오는 정의와 약간 차이가 있는데, 이는 JavaScript에 적용 하기 위함이며 좀 더 명확하게 일반화된 뜻을 다루기 위함입니다. 예를 들어 집합^Aggregation^이  하위 객체들의 수명주기를 책임져야 함을 뜻하지 않습니다. 동적으로 객체를 확장시킬 수 있는 언어에서는 그렇지 않습니다.\n\n잘못된 공리 및 정의는 일반화를 힘들게 만들며 같은 개념의 특수한 사례를 다른 이름으로 부르게 만듭니다. 개발자는 불팔요한 반복을 좋아하지 않습니다.\n\n-  **집합**^Aggregation^  객체가 열거 가능한 하위 객체 모음으로 구성되는 경우.  즉, 다른 객체들을  _포함_  하는 객체입니다.  각 하위 객체는 자신의 레퍼런스를 유지하므로 얼마든지 집합체에서 분리, 해체될 수 있습니다.\n-   **접합**^Concatenation^ ^[병합, 연결, 결합과 같은 용어로 번역됩니다. 배열, 문자열의 기본 연산에서 등장하는 용어이지만 객체를 합친다는 문맥에서는 접합이 적합하다고 판단했습니다] 기존 객체에 새 속성을 추가하여 객체를 형성하는 경우.  속성을 한 번에 하나씩 연결하거나 기존 개체를 통채로 복사 할 수도 있습니다. 예를 들어, jQuery 플러그인은 프로토타입으로 연결된  `jQuery.fn`에 새 메서드를 연결하여 만들어집니다.\n-   **위임**^Delegation^  객체를 다른 객체로 전달하거나 특정 기능을 **위임**  하는 경우.  예를 들어  [Ivan Sutherland의 Sketchpad](https://www.youtube.com/watch%3Fv%3DBKM3CmRqK2o)  (1962)에는 공유 속성을 \"마스터\"에게 위임하는 인스턴스가 있습니다. Photoshop에 포함된 \"스마트 오브젝트\"는 외부 리소스에게 동작을 위임하는 로컬 프록시가 있습니다. JavaScript의 프로토타입은 위임으로 작동합니다. Array 인스턴스로 배열 메소드를 호출하면 `Array.prototype`에게 전달되고,  Object 메소드들은 `Object.prototype`에게 전달됩니다.\n\n이러한 다른 형태의 구성은  **서로 배타적이지 않습니다.**  접합으로 위임을 구현할 수 있으며 JavaScript에서 클래스 상속은 위임으로 구현됩니다. 많은 소프트웨어 시스템은 객체를 합성할 때 하나 이상의 방법을 사용합니다. 예를 들어, jQuery의 플러그인은 프로토타입 프로퍼티인 `jQuery.fn`에 다른 메소드들을 접합하는 방식으로 확장합니다. 클라이언트 코드가 플러그인 메소드를 호출하면 프로토타입에 연결된 메소드에 위임됩니다.\n\n> 앞으로 나올 예제들에서 아래 코드를 계속 사용할 것 입니다.\n\n```javascript\nconst objs = [  \n  { a: 'a', b: 'ab' },  \n  { b: 'b' },  \n  { c: 'c', b: 'cb' }  \n];\n```\n## 집합 Aggregation\n\n집합은 객체가 열거 가능한 하위 객체 모음으로 구성되는 경우입니다.  즉, 다른 객체들을  _포함_  하는 객체입니다.  각 하위 객체는 자신의 레퍼런스를 유지하므로 얼마든지 집합체에서 분리, 해체될 수 있습니다.  다양한 구조로 표현 될 수 있습니다.\n\n### 예제들\n\n-   Array\n-   Map\n-   Set\n-   Graph\n-   Tree\n-   DOM node (DOM 노드는 자식 노드를  _포함_  )\n-   UI component (컴포넌트는 하위 컴포넌트들을 _포함_ )\n\n### 언제 사용 하는가?\n\n스택, 큐, 트리, 그래프, 상태 머신 또는 컴포지트 패턴에서처럼 공통 작업을 공유해야하는 객체 모음이있는 경우 (수많은 아이템들이 동일한 인터페이스를 공유하려는 경우)\n\n### 참고사항\n\n집합을 사용하면 각 멤버에게 함수를 적용하고( e.g.   `array.map(fn)` ) 단일 값인 것처럼 벡터를 변환하는 등 보편적인 추상화를 적용할 수 있습니다.  그러나 수십, 수백만개의 하위 객체를 다뤄야할 경우 스트림으로 처리하는 것이 더 효율적일 수 있습니다.\n\n### 코드 예제\n\nArray 집합 :\n\n```javascript\nconst collection = (a, e) => a.concat([e]);\n\nconst a = objs.reduce(collection, []);\n\nconsole.log(   \n  'collection aggregation',  \n  a,  \n  a[1].b,  \n  a[2].c,  \n  `enumerable keys: ${ Object.keys(a) }`  \n);\n```\n\n다음처럼 됩니다.\n\n```javascript\n collection aggregation   \n [{\"a\":\"a\",\"b\":\"ab\"},{\"b\":\"b\"},{\"c\":\"c\",\"b\":\"cb\"}]   \n b c   \n enumerable keys: 0,1,2\n```\n\npair를 사용하는 연결리스트^Linked-list^ 집합 :\n\n```javascript\nconst pair = (a, b) => [b, a];\n\nconst l = objs.reduceRight(pair, []);\n\nconsole.log(  \n  'linked list aggregation',  \n  l,  \n  `enumerable keys: ${ Object.keys(l) }`  \n);\n\n/*  \nlinked list aggregation  \n[  \n  {\"a\":\"a\",\"b\":\"ab\"}, [  \n    {\"b\":\"b\"}, [  \n      {\"c\":\"c\",\"b\":\"cb\"},  \n      []  \n    ]  \n  ]  \n]  \nenumerable keys: 0,1  \n*/\n```\n\n연결리스트는 배열, 문자열, 트리 및 다양한 종류의 데이터 구조 및 집합의 기초가 됩니다. 훨씬 많은 예가 있으며 여기서 그것들을 모두 다루진 않겠습니다.\n\n## 접합, 연결 Concatenation\n\n접합이란 기존 객체에 새 속성을 추가하여 객체를 형성하는 것 입니다.\n\n### 예제들\n\n-   `jQuery.fn`에 접합하는 방식으로 플러그인을 추가합니다.\n-   State reducers, 상태 관리 유틸리티 (예 : Redux)\n-   함수형 믹스인\n\n### 언제 사용하는가? \n\nJSON 객체 합치기, 여러 소스에서 애플리케이션 상태를 가져오기, 불변 상태를 업데이트 하기(이전 상태를 새 데이터와 병합)등 런타임에 점진적으로 데이터 구조를 조립하는 것이 필요하다면 언제든지\n\n### 참고사항\n\n-   기존 객체를 변이시킬 때 주의해야합니다. 변경 가능한 공유 상태는 많은 버그를 일으킬 수 있습니다.\n-   클래스 계층 구조를 모방하는 것이 가능합니다. 즉,  _is-a_ 관계를 만들 수 있습니다.  같은 문제가 적용됩니다.  \"기본\" 인스턴스에서 속성들을 상속하고 다중상속을 하는 대신 작고 독립적인 객체들을 \"합성\"한다는 아이디어로 접근해야합니다.\n-   구성요소들간의 암시적인 종속성에 주의하십시오.\n-   속성 이름 충돌은 연결 순서로 해결됩니다.(마지막 값이 적용됨)   이는 기본값을 지정하거나 오버라이딩 할 때 유용하지만 순서가 명확하지 않은 경우 문제가 될 수 있습니다.\n\n### 코드 예제\n\n```javascript\nconst c = objs.reduce(concatenate, {});\n\nconst concatenate = (a, o) => ({...a, ...o});\n\nconsole.log(  \n  'concatenation',  \n  c,  \n  `enumerable keys: ${ Object.keys(c) }`  \n);\n\n// concatenation { a: 'a', b: 'cb', c: 'c' } enumerable keys: a,b,c\n```\n\n\n## 위임 Delegation\n\n위임은 객체를 다른 객체로 전달하거나 특정 기능을 **위임**  하는 경우입니다.\n\n### 예제들\n\n-   JavaScript은 기본적으로 위임을 사용하여 메소드 호출을 프로토타입 체인으로 전달합니다.  e.g.  `[].map()`  은  `Array.prototype.map()`으로,  `obj.hasOwnProperty()`  는  `Object.prototype.hasOwnProperty()` 으로 호출이 위임됩니다.\n-   jQuery 플러그인은 위임을 사용해 모든 인스턴스에서 내장 및 플러그인 메소드를 공유합니다.\n-   Sketchpad의 \"마스터\"는 동적 위임자였습니다.  마스터의 변경사항은 모든 객체 인스턴스에 즉시 반영됩니다.\n-   Photoshop에서는 \"스마트 객체\"라는 위임자를 사용하여 별도의 파일에 정의 된 이미지와 리소스를 나타냅니다.  스마트 오브젝트가 참조하는 오브젝트에 대한 변경 사항은 스마트 오브젝트의 모든 인스턴스에 반영됩니다.\n\n### 언제 사용 하는가?\n\n1.  메모리 절약 : 객체의 인스턴스가 매우 많을 경우,  각 인스턴스마다 메모리를 더 많이 할당해하는 대신 인스턴스간에 동일한 속성이나 메소드를 공유하는 것이 유용할 수 있습니다.\n2.  많은 인스턴스를 동적으로 업데이트 : 많은 객체 인스턴스가 동일한 상태를 공유하고 동적으로 업데이트해야 하는 경우 변경사항을 즉석에서 모든 인스턴스에 반영시킬 수 있습니다.(예 : Sketchpad의 \"마스터\"또는 Photoshop의 \"스마트 객체\").\n\n### 참고사항\n\n-   위임은 일반적으로 JavaScript에서 클래스 상속을 모방하는 데 사용되며 (실제로 `extends`  키워드에 묶여 있음) 실제로는 거의 필요하지 않습니다.\n-   위임을 사용하여 클래스 상속의 동작 및 제한 사항을 정확하게 모방 할 수 있습니다.  사실 JavaScript의 클래스 상속은 프로토타입 위임 체인으로 구축되어 있습니다.\n-   위임된 속성은  `Object.keys(instanceObj)` 와 같은 일반적인 메커니즘을 사용하여 열거 할 수 없습니다.\n-   위임은 속성 조회 속도를 희생해 메모리를 절약합니다. JS 엔진은 일부 동적 위임자(생성 된 후에 변경되는 위임자)에 대한 최적화를 수행하지 못합니다. 그러나 가장 느린 경우에도 속성 조회 성능은 수백만 ops /초로 측정됩니다. 이벤트 스트림 처리용 혹은 그래픽 프로그래밍용 범용 유틸리티 라이브러리(e.g. RxJS 또는 three.js)가 아닌 이상 병목 현상이 발생하긴 쉽지 않습니다.\n-   인스턴스의 상태와 위임된 상태를 구별해야합니다.\n-   동적으로 위임된 공유 상태는 안전하지 않습니다.  변경사항은 모든 인스턴스간에 공유됩니다.  이는 일반적으로 (항상 그런 것은 아님) 버그를 발생시키는 원인입니다.\n-   ES6에서 클래스의 프로토타입은 재할당될 수 없습니다. 바벨로 컴파일했을 때 작동하는 것처럼 보일지라도 실제 ES6 환경에서는 오류가 발생합니다.\n\n### 코드 예제\n\n```javascript\nconst delegate = (a, b) => Object.assign(Object.create(a), b);  \n  \nconst d = objs.reduceRight(delegate, {});  \n  \nconsole.log(  \n  'delegation',  \n  d,  \n  `enumerable keys: ${ Object.keys(d) }`  \n);  \n  \n// delegation { a: 'a', b: 'ab' } enumerable keys: a,b  \n  \nconsole.log(d.b, d.c); // ab c\n```\n\n\n## 결론\n\n지금까지 배운 것들을 요약해보겠습니다.\n\n-   원시형 및 다른 객체들로 만들어진 모든 객체는  _복합 객체_  입니다.\n-   복합 객체를 만드는 행위를 합성이라고합니다.\n-   객체 합성에는 여러 종류가 있습니다.\n-   형성되는 관계와 의존성은 객체가 어떻게 합성되는지에 따라 다릅니다.\n-   Is-a 관계 (클래스 상속에 의해 형성된 종류)는 OO 디자인의 커플링 중 가장 단단한 형태이며 꼭 필요한 경우가 아니면 일반적으로 피해야합니다.\n-   Gang of Four는 모놀리틱한 기본 클래스 또는 기본 객체에서 상속하지 말고 작은 기능들을 조합하여 객체를 합성하도록 권장합니다.  \"클래스 상속보다는 객체 합성을 우선해라\"\n-   집합은 배열, DOM 트리 등 구성원들이 자신의 참조를 유지하는 열거형 컬렉션으로 객체를 합성합니다.\n-   위임은 프로토타입 위임 체인을 연결하여 객체를 합성합니다. 이 때 객체는 속성 조회 및 메소드 호출을 프로토타입에게 전달하거나 다른 객체에 위임합니다.  e.g.  `[].map()`  은  `Array.prototype.map()`을 호출합니다.\n-   접합(연결)은  `Object.assign(destination, a, b)`  ,  `{...a, ...b}`  와 같은 새 속성으로 기존 객체를 확장하여 객체를 합성합니다.\n-   객체 합성에 대한 서로 다른 정의들은 상호 배타적인 것이 아닙니다. 위임은 집합의 하위 집합이며, 연결을 사용하여 위임과 집합을 구현하는 등의 작업을 할 수 있습니다.\n\n단지 세 가지 종류의 객체 합성만 있는 것이 아닙니다.  또한 객체가 다른 객체에게 매개 변수로 전달되는(의존성 삽입) 등의 관계를 통해 객체간에 느슨하고 동적인 관계를 형성 할 수도 있습니다.\n\n모든 소프트웨어 개발은 합성입니다.  쉽고 유연한 방법도 있고 부서지기 쉬운 관절염도 있습니다.  객체 합성의 일부 형태는 느슨하게 연결된 관계를 형성하고, 다른 형태는 매우 단단한 결합을 형성합니다.\n\n프로그램 요구사항이 변경되었을 때 코드 구현을 조금만 변경하기 위해선 다양한 합성 형태를 찾아보십시오. 의도를 명확하고 간결하게 표현하고 기억하십시오 : 클래스 상속이 필요하다고 생각이 들 때 사실 더 좋은 방법이 많이 있을 것입니다.\n\n[**다음: 삼항연산자의 멋짐을 모르는 당신이 불쌍해 >**](https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/)","source":"_posts/the-hidden-treasures-of-object-composition.md","raw":"---\ntitle: 객체 합성이라는 숨겨진 보물\ncatalog: true\ndate: 2018-04-23 15:05:12\nsubtitle: The Hidden Treasures of Object Composition\nheader-img: \"bg.jpg\"\nreadingTime: 10\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 소프트웨어를 개발하는 과정에서 가장 흔히 볼 수 있는 실수 중 하나는 클래스 상속을 과도하게 사용하는 경향입니다.  클래스 상속은 기본 클래스와 하위 클래스 사이에 는 이다(is a)  관계를 만들어 코드를 재사용하는 메커니즘입니다.   is a  관계 (e.g. 오리는 새이다)를 사용하여 도메인을 모델링하는 과정에서 문제가 발생할 수 있습니다.  그 이유는 클래스 상속이 객체 지향 디자인에서 사용할 수 있는 가장 단단한 형태의 결합이기 때문입니다. 결국 다음과 같은(그 외에도) 많은 문제들을 일으킵니다\n---\n\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  [[원문보기]](https://medium.com/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [<이전](https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/)  |  [<< Part 1에서 다시 시작](https://midojeong.github.io/2018/03/16/composing-software-intro/)  |  [다음>](https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/)\n\n\n> \"객체 합성, 보다 복잡한 동작을 하기 위해 객체를 조립 또는 합성하는 것\"~ 4 강  [\"디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소\"](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&qid=1494993475&sr=8-1&keywords=design+patterns&linkCode=ll1&tag=eejs-20&linkId=6c553f16325f3939e5abadd4ee04e8b4)\n\n> \"클래스 상속보다는 객체 합성을 우선해라\", Gang of Four,  \n\n소프트웨어를 개발하는 과정에서 가장 흔히 볼 수 있는 실수 중 하나는 클래스 상속을 과도하게 사용하는 경향입니다.  클래스 상속은 기본 클래스와 하위 클래스 사이에 **는-이다(is-a)**  관계를 만들어 코드를 재사용하는 메커니즘입니다.   _is-a_  관계 (e.g. 오리는 새이다)를 사용하여 도메인을 모델링하는 과정에서 문제가 발생할 수 있습니다.  그 이유는 클래스 상속이 객체 지향 디자인에서 사용할 수 있는 가장 단단한 형태의 결합이기 때문입니다. 결국 다음과 같은(그 외에도) 많은 문제들을 일으킵니다 :\n\n-   깨지기 쉬운 기본 클래스 문제\n-   고릴라 / 바나나 문제\n-   중복 필요성 문제\n\n상속은 하위 클래스가 상속, 추가 및 오버라이딩할 수 있는 기본 클래스를 공용 인터페이스로 추상화하여 코드를 재사용합니다.  **추상화**에는 두 가지 중요한 특징이 있습니다.\n\n-   **일반화^Generalization^**  일반적인 사용사례에 해당하는 공유 속성 및 동작들을 추출하는 과정\n-   **전문화^Specialization^**  특수한 경우를 처리하는 데 필요한 구현 세부 사항을 제공하는 과정\n\n코드를 일반화 및 전문화하는데는 여러 가지 방법이 있습니다.  클래스 상속대신 사용할 수 있는 좋은 대안으로는 단순 함수, 고차 함수 및  **객체 합성**이있습니다.\n\n불행히도, 많은 사람들이 객체 합성에 대해 오해하고 있으며 이러한 관점으로 생각하기 어려워 합니다.  주제에 대해 좀 더 깊이 알아봐야 할 필요가 있습니다.\n\n## 객체 합성^Object^ ^Composition^이란 무엇입니까?\n\n> \"컴퓨터 과학에서의 복합 자료형^Composite^ ^datatype^이란 프로그래밍 언어의 원시 자료형 및 기타 복합 유형을 사용하여 구성 할 수있는 모든 데이터 유형입니다.  [...] 복합 유형을 구성하는 행위는 합성^Composition^으로 알려져 있습니다. \"~ Wikipedia\n\n기본형들을 조립해 복합 객체를 만드는 모든 행위가 객체 합성입니다. 그러나 상속은 마치 객체 합성과는 전혀 관련이 없으며 심지어 정반대의 기술인 것처럼 논의되고 있습니다. 이러한 편견이 생기는 이유는 객체 합성의 문법과 의미간에 차이가 있기 때문입니다.\n\n지금부터 알아볼 객체 합성과 클래스 상속에 관한 논의는 특정 기법에 관한 것이 아닙니다.  구성 요소들 사이의  _의미론적_  관계와   _결합 정도에_  대한 것입니다.  우리는  _문법_ 이 아니라 _의미_ 에 대해 말하고 있습니다. 사람들은 종종 이 둘을 구별하지 못하고 세부적인 문법에만 집중합니다.  숲을 보지 못하고 나무만 보고있는 셈입니다.\n\n객체는 여러가지 다른 방법으로 합성됩니다.  합성 형태에 따라 복합체의 구조와 객체간의 관계가 달라집니다. 어떤 객체가 다른 객체에 종속되면 한 객체가 변경되었을 때 다른 객체가 손상 될 수 있습니다.\n\n\"클래스 상속보다는 객체 합성을 우선해라\"라는 조언은 우리가 객체를 바라보는 방식을 거대한 기본 클래스로부터 상속받는 것이 아닌 작고 느슨하게 결합 된 요소들의 합성으로 생각하라는 뜻입니다.  GoF는 단단히 결합 된 객체를 \"모놀리틱^[monolithic  단일체의, 한 덩어리로 뭉친, 단일 결정으로된] 시스템\"이라고 설명합니다. 이 시스템에서 어떤 클래스를 변경하거나 제거하려면 다른 수많은 클래스를 이해하고 변경해야 합니다. 결국 이러한 시스템은 이해하고, 이식하고, 유지하기 힘든 조밀한 덩어리가 됩니다. \"\n\n## 객체 합성의 세 가지 다른 형태\n\n\"Design Patterns\"에서 Gang of Four는 \"객체 합성은 여러 디자인 패턴에 다양하게 적용될 것 입니다\"라고 말하고 계속해서  _집합_  및  _위임_ 을 포함한 다양한 유형의 구성 관계를 설명합니다.\n\n\"Design Patterns\"의 저자는 주로 C ++ 및 Smalltalk (이후 Java) 환경에서 작업했습니다.  해당 언어로 런타임에 객체 관계를 정의하고 변경하는 작업은 JavaScript에서보다 훨씬 복잡하므로 해당 주제를 깊게 다루진 않을 것 입니다.  그러나 JavaScript의 객체 합성에 대해 논의하기 위해 먼저 동적 객체 확장 ( 일명, _concatenation_ )에 대한 논의가 우선되어야 합니다.\n\n각 용어들은 \"Design Patterns\"에 나오는 정의와 약간 차이가 있는데, 이는 JavaScript에 적용 하기 위함이며 좀 더 명확하게 일반화된 뜻을 다루기 위함입니다. 예를 들어 집합^Aggregation^이  하위 객체들의 수명주기를 책임져야 함을 뜻하지 않습니다. 동적으로 객체를 확장시킬 수 있는 언어에서는 그렇지 않습니다.\n\n잘못된 공리 및 정의는 일반화를 힘들게 만들며 같은 개념의 특수한 사례를 다른 이름으로 부르게 만듭니다. 개발자는 불팔요한 반복을 좋아하지 않습니다.\n\n-  **집합**^Aggregation^  객체가 열거 가능한 하위 객체 모음으로 구성되는 경우.  즉, 다른 객체들을  _포함_  하는 객체입니다.  각 하위 객체는 자신의 레퍼런스를 유지하므로 얼마든지 집합체에서 분리, 해체될 수 있습니다.\n-   **접합**^Concatenation^ ^[병합, 연결, 결합과 같은 용어로 번역됩니다. 배열, 문자열의 기본 연산에서 등장하는 용어이지만 객체를 합친다는 문맥에서는 접합이 적합하다고 판단했습니다] 기존 객체에 새 속성을 추가하여 객체를 형성하는 경우.  속성을 한 번에 하나씩 연결하거나 기존 개체를 통채로 복사 할 수도 있습니다. 예를 들어, jQuery 플러그인은 프로토타입으로 연결된  `jQuery.fn`에 새 메서드를 연결하여 만들어집니다.\n-   **위임**^Delegation^  객체를 다른 객체로 전달하거나 특정 기능을 **위임**  하는 경우.  예를 들어  [Ivan Sutherland의 Sketchpad](https://www.youtube.com/watch%3Fv%3DBKM3CmRqK2o)  (1962)에는 공유 속성을 \"마스터\"에게 위임하는 인스턴스가 있습니다. Photoshop에 포함된 \"스마트 오브젝트\"는 외부 리소스에게 동작을 위임하는 로컬 프록시가 있습니다. JavaScript의 프로토타입은 위임으로 작동합니다. Array 인스턴스로 배열 메소드를 호출하면 `Array.prototype`에게 전달되고,  Object 메소드들은 `Object.prototype`에게 전달됩니다.\n\n이러한 다른 형태의 구성은  **서로 배타적이지 않습니다.**  접합으로 위임을 구현할 수 있으며 JavaScript에서 클래스 상속은 위임으로 구현됩니다. 많은 소프트웨어 시스템은 객체를 합성할 때 하나 이상의 방법을 사용합니다. 예를 들어, jQuery의 플러그인은 프로토타입 프로퍼티인 `jQuery.fn`에 다른 메소드들을 접합하는 방식으로 확장합니다. 클라이언트 코드가 플러그인 메소드를 호출하면 프로토타입에 연결된 메소드에 위임됩니다.\n\n> 앞으로 나올 예제들에서 아래 코드를 계속 사용할 것 입니다.\n\n```javascript\nconst objs = [  \n  { a: 'a', b: 'ab' },  \n  { b: 'b' },  \n  { c: 'c', b: 'cb' }  \n];\n```\n## 집합 Aggregation\n\n집합은 객체가 열거 가능한 하위 객체 모음으로 구성되는 경우입니다.  즉, 다른 객체들을  _포함_  하는 객체입니다.  각 하위 객체는 자신의 레퍼런스를 유지하므로 얼마든지 집합체에서 분리, 해체될 수 있습니다.  다양한 구조로 표현 될 수 있습니다.\n\n### 예제들\n\n-   Array\n-   Map\n-   Set\n-   Graph\n-   Tree\n-   DOM node (DOM 노드는 자식 노드를  _포함_  )\n-   UI component (컴포넌트는 하위 컴포넌트들을 _포함_ )\n\n### 언제 사용 하는가?\n\n스택, 큐, 트리, 그래프, 상태 머신 또는 컴포지트 패턴에서처럼 공통 작업을 공유해야하는 객체 모음이있는 경우 (수많은 아이템들이 동일한 인터페이스를 공유하려는 경우)\n\n### 참고사항\n\n집합을 사용하면 각 멤버에게 함수를 적용하고( e.g.   `array.map(fn)` ) 단일 값인 것처럼 벡터를 변환하는 등 보편적인 추상화를 적용할 수 있습니다.  그러나 수십, 수백만개의 하위 객체를 다뤄야할 경우 스트림으로 처리하는 것이 더 효율적일 수 있습니다.\n\n### 코드 예제\n\nArray 집합 :\n\n```javascript\nconst collection = (a, e) => a.concat([e]);\n\nconst a = objs.reduce(collection, []);\n\nconsole.log(   \n  'collection aggregation',  \n  a,  \n  a[1].b,  \n  a[2].c,  \n  `enumerable keys: ${ Object.keys(a) }`  \n);\n```\n\n다음처럼 됩니다.\n\n```javascript\n collection aggregation   \n [{\"a\":\"a\",\"b\":\"ab\"},{\"b\":\"b\"},{\"c\":\"c\",\"b\":\"cb\"}]   \n b c   \n enumerable keys: 0,1,2\n```\n\npair를 사용하는 연결리스트^Linked-list^ 집합 :\n\n```javascript\nconst pair = (a, b) => [b, a];\n\nconst l = objs.reduceRight(pair, []);\n\nconsole.log(  \n  'linked list aggregation',  \n  l,  \n  `enumerable keys: ${ Object.keys(l) }`  \n);\n\n/*  \nlinked list aggregation  \n[  \n  {\"a\":\"a\",\"b\":\"ab\"}, [  \n    {\"b\":\"b\"}, [  \n      {\"c\":\"c\",\"b\":\"cb\"},  \n      []  \n    ]  \n  ]  \n]  \nenumerable keys: 0,1  \n*/\n```\n\n연결리스트는 배열, 문자열, 트리 및 다양한 종류의 데이터 구조 및 집합의 기초가 됩니다. 훨씬 많은 예가 있으며 여기서 그것들을 모두 다루진 않겠습니다.\n\n## 접합, 연결 Concatenation\n\n접합이란 기존 객체에 새 속성을 추가하여 객체를 형성하는 것 입니다.\n\n### 예제들\n\n-   `jQuery.fn`에 접합하는 방식으로 플러그인을 추가합니다.\n-   State reducers, 상태 관리 유틸리티 (예 : Redux)\n-   함수형 믹스인\n\n### 언제 사용하는가? \n\nJSON 객체 합치기, 여러 소스에서 애플리케이션 상태를 가져오기, 불변 상태를 업데이트 하기(이전 상태를 새 데이터와 병합)등 런타임에 점진적으로 데이터 구조를 조립하는 것이 필요하다면 언제든지\n\n### 참고사항\n\n-   기존 객체를 변이시킬 때 주의해야합니다. 변경 가능한 공유 상태는 많은 버그를 일으킬 수 있습니다.\n-   클래스 계층 구조를 모방하는 것이 가능합니다. 즉,  _is-a_ 관계를 만들 수 있습니다.  같은 문제가 적용됩니다.  \"기본\" 인스턴스에서 속성들을 상속하고 다중상속을 하는 대신 작고 독립적인 객체들을 \"합성\"한다는 아이디어로 접근해야합니다.\n-   구성요소들간의 암시적인 종속성에 주의하십시오.\n-   속성 이름 충돌은 연결 순서로 해결됩니다.(마지막 값이 적용됨)   이는 기본값을 지정하거나 오버라이딩 할 때 유용하지만 순서가 명확하지 않은 경우 문제가 될 수 있습니다.\n\n### 코드 예제\n\n```javascript\nconst c = objs.reduce(concatenate, {});\n\nconst concatenate = (a, o) => ({...a, ...o});\n\nconsole.log(  \n  'concatenation',  \n  c,  \n  `enumerable keys: ${ Object.keys(c) }`  \n);\n\n// concatenation { a: 'a', b: 'cb', c: 'c' } enumerable keys: a,b,c\n```\n\n\n## 위임 Delegation\n\n위임은 객체를 다른 객체로 전달하거나 특정 기능을 **위임**  하는 경우입니다.\n\n### 예제들\n\n-   JavaScript은 기본적으로 위임을 사용하여 메소드 호출을 프로토타입 체인으로 전달합니다.  e.g.  `[].map()`  은  `Array.prototype.map()`으로,  `obj.hasOwnProperty()`  는  `Object.prototype.hasOwnProperty()` 으로 호출이 위임됩니다.\n-   jQuery 플러그인은 위임을 사용해 모든 인스턴스에서 내장 및 플러그인 메소드를 공유합니다.\n-   Sketchpad의 \"마스터\"는 동적 위임자였습니다.  마스터의 변경사항은 모든 객체 인스턴스에 즉시 반영됩니다.\n-   Photoshop에서는 \"스마트 객체\"라는 위임자를 사용하여 별도의 파일에 정의 된 이미지와 리소스를 나타냅니다.  스마트 오브젝트가 참조하는 오브젝트에 대한 변경 사항은 스마트 오브젝트의 모든 인스턴스에 반영됩니다.\n\n### 언제 사용 하는가?\n\n1.  메모리 절약 : 객체의 인스턴스가 매우 많을 경우,  각 인스턴스마다 메모리를 더 많이 할당해하는 대신 인스턴스간에 동일한 속성이나 메소드를 공유하는 것이 유용할 수 있습니다.\n2.  많은 인스턴스를 동적으로 업데이트 : 많은 객체 인스턴스가 동일한 상태를 공유하고 동적으로 업데이트해야 하는 경우 변경사항을 즉석에서 모든 인스턴스에 반영시킬 수 있습니다.(예 : Sketchpad의 \"마스터\"또는 Photoshop의 \"스마트 객체\").\n\n### 참고사항\n\n-   위임은 일반적으로 JavaScript에서 클래스 상속을 모방하는 데 사용되며 (실제로 `extends`  키워드에 묶여 있음) 실제로는 거의 필요하지 않습니다.\n-   위임을 사용하여 클래스 상속의 동작 및 제한 사항을 정확하게 모방 할 수 있습니다.  사실 JavaScript의 클래스 상속은 프로토타입 위임 체인으로 구축되어 있습니다.\n-   위임된 속성은  `Object.keys(instanceObj)` 와 같은 일반적인 메커니즘을 사용하여 열거 할 수 없습니다.\n-   위임은 속성 조회 속도를 희생해 메모리를 절약합니다. JS 엔진은 일부 동적 위임자(생성 된 후에 변경되는 위임자)에 대한 최적화를 수행하지 못합니다. 그러나 가장 느린 경우에도 속성 조회 성능은 수백만 ops /초로 측정됩니다. 이벤트 스트림 처리용 혹은 그래픽 프로그래밍용 범용 유틸리티 라이브러리(e.g. RxJS 또는 three.js)가 아닌 이상 병목 현상이 발생하긴 쉽지 않습니다.\n-   인스턴스의 상태와 위임된 상태를 구별해야합니다.\n-   동적으로 위임된 공유 상태는 안전하지 않습니다.  변경사항은 모든 인스턴스간에 공유됩니다.  이는 일반적으로 (항상 그런 것은 아님) 버그를 발생시키는 원인입니다.\n-   ES6에서 클래스의 프로토타입은 재할당될 수 없습니다. 바벨로 컴파일했을 때 작동하는 것처럼 보일지라도 실제 ES6 환경에서는 오류가 발생합니다.\n\n### 코드 예제\n\n```javascript\nconst delegate = (a, b) => Object.assign(Object.create(a), b);  \n  \nconst d = objs.reduceRight(delegate, {});  \n  \nconsole.log(  \n  'delegation',  \n  d,  \n  `enumerable keys: ${ Object.keys(d) }`  \n);  \n  \n// delegation { a: 'a', b: 'ab' } enumerable keys: a,b  \n  \nconsole.log(d.b, d.c); // ab c\n```\n\n\n## 결론\n\n지금까지 배운 것들을 요약해보겠습니다.\n\n-   원시형 및 다른 객체들로 만들어진 모든 객체는  _복합 객체_  입니다.\n-   복합 객체를 만드는 행위를 합성이라고합니다.\n-   객체 합성에는 여러 종류가 있습니다.\n-   형성되는 관계와 의존성은 객체가 어떻게 합성되는지에 따라 다릅니다.\n-   Is-a 관계 (클래스 상속에 의해 형성된 종류)는 OO 디자인의 커플링 중 가장 단단한 형태이며 꼭 필요한 경우가 아니면 일반적으로 피해야합니다.\n-   Gang of Four는 모놀리틱한 기본 클래스 또는 기본 객체에서 상속하지 말고 작은 기능들을 조합하여 객체를 합성하도록 권장합니다.  \"클래스 상속보다는 객체 합성을 우선해라\"\n-   집합은 배열, DOM 트리 등 구성원들이 자신의 참조를 유지하는 열거형 컬렉션으로 객체를 합성합니다.\n-   위임은 프로토타입 위임 체인을 연결하여 객체를 합성합니다. 이 때 객체는 속성 조회 및 메소드 호출을 프로토타입에게 전달하거나 다른 객체에 위임합니다.  e.g.  `[].map()`  은  `Array.prototype.map()`을 호출합니다.\n-   접합(연결)은  `Object.assign(destination, a, b)`  ,  `{...a, ...b}`  와 같은 새 속성으로 기존 객체를 확장하여 객체를 합성합니다.\n-   객체 합성에 대한 서로 다른 정의들은 상호 배타적인 것이 아닙니다. 위임은 집합의 하위 집합이며, 연결을 사용하여 위임과 집합을 구현하는 등의 작업을 할 수 있습니다.\n\n단지 세 가지 종류의 객체 합성만 있는 것이 아닙니다.  또한 객체가 다른 객체에게 매개 변수로 전달되는(의존성 삽입) 등의 관계를 통해 객체간에 느슨하고 동적인 관계를 형성 할 수도 있습니다.\n\n모든 소프트웨어 개발은 합성입니다.  쉽고 유연한 방법도 있고 부서지기 쉬운 관절염도 있습니다.  객체 합성의 일부 형태는 느슨하게 연결된 관계를 형성하고, 다른 형태는 매우 단단한 결합을 형성합니다.\n\n프로그램 요구사항이 변경되었을 때 코드 구현을 조금만 변경하기 위해선 다양한 합성 형태를 찾아보십시오. 의도를 명확하고 간결하게 표현하고 기억하십시오 : 클래스 상속이 필요하다고 생각이 들 때 사실 더 좋은 방법이 많이 있을 것입니다.\n\n[**다음: 삼항연산자의 멋짐을 모르는 당신이 불쌍해 >**](https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/)","slug":"the-hidden-treasures-of-object-composition","published":1,"updated":"2018-04-28T13:48:50.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83en000uifp6j0zusm4u","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/\">다음&gt;</a></p>\n</blockquote>\n<blockquote>\n<p>“객체 합성, 보다 복잡한 동작을 하기 위해 객체를 조립 또는 합성하는 것”~ 4 강  <a href=\"https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;qid=1494993475&amp;sr=8-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6c553f16325f3939e5abadd4ee04e8b4\" target=\"_blank\" rel=\"noopener\">“디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소”</a></p>\n</blockquote>\n<blockquote>\n<p>“클래스 상속보다는 객체 합성을 우선해라”, Gang of Four,</p>\n</blockquote>\n<p>소프트웨어를 개발하는 과정에서 가장 흔히 볼 수 있는 실수 중 하나는 클래스 상속을 과도하게 사용하는 경향입니다.  클래스 상속은 기본 클래스와 하위 클래스 사이에 <strong>는-이다(is-a)</strong>  관계를 만들어 코드를 재사용하는 메커니즘입니다.   <em>is-a</em>  관계 (e.g. 오리는 새이다)를 사용하여 도메인을 모델링하는 과정에서 문제가 발생할 수 있습니다.  그 이유는 클래스 상속이 객체 지향 디자인에서 사용할 수 있는 가장 단단한 형태의 결합이기 때문입니다. 결국 다음과 같은(그 외에도) 많은 문제들을 일으킵니다 :</p>\n<ul>\n<li>깨지기 쉬운 기본 클래스 문제</li>\n<li>고릴라 / 바나나 문제</li>\n<li>중복 필요성 문제</li>\n</ul>\n<p>상속은 하위 클래스가 상속, 추가 및 오버라이딩할 수 있는 기본 클래스를 공용 인터페이스로 추상화하여 코드를 재사용합니다.  <strong>추상화</strong>에는 두 가지 중요한 특징이 있습니다.</p>\n<ul>\n<li><strong>일반화<sup>Generalization</sup></strong>  일반적인 사용사례에 해당하는 공유 속성 및 동작들을 추출하는 과정</li>\n<li><strong>전문화<sup>Specialization</sup></strong>  특수한 경우를 처리하는 데 필요한 구현 세부 사항을 제공하는 과정</li>\n</ul>\n<p>코드를 일반화 및 전문화하는데는 여러 가지 방법이 있습니다.  클래스 상속대신 사용할 수 있는 좋은 대안으로는 단순 함수, 고차 함수 및  <strong>객체 합성</strong>이있습니다.</p>\n<p>불행히도, 많은 사람들이 객체 합성에 대해 오해하고 있으며 이러한 관점으로 생각하기 어려워 합니다.  주제에 대해 좀 더 깊이 알아봐야 할 필요가 있습니다.</p>\n<h2 id=\"객체-합성object-composition이란-무엇입니까\">객체 합성<sup>Object</sup> <sup>Composition</sup>이란 무엇입니까?</h2>\n<blockquote>\n<p>&quot;컴퓨터 과학에서의 복합 자료형<sup>Composite</sup> <sup>datatype</sup>이란 프로그래밍 언어의 원시 자료형 및 기타 복합 유형을 사용하여 구성 할 수있는 모든 데이터 유형입니다.  […] 복합 유형을 구성하는 행위는 합성<sup>Composition</sup>으로 알려져 있습니다. &quot;~ Wikipedia</p>\n</blockquote>\n<p>기본형들을 조립해 복합 객체를 만드는 모든 행위가 객체 합성입니다. 그러나 상속은 마치 객체 합성과는 전혀 관련이 없으며 심지어 정반대의 기술인 것처럼 논의되고 있습니다. 이러한 편견이 생기는 이유는 객체 합성의 문법과 의미간에 차이가 있기 때문입니다.</p>\n<p>지금부터 알아볼 객체 합성과 클래스 상속에 관한 논의는 특정 기법에 관한 것이 아닙니다.  구성 요소들 사이의  <em>의미론적</em>  관계와   <em>결합 정도에</em>  대한 것입니다.  우리는  <em>문법</em> 이 아니라 <em>의미</em> 에 대해 말하고 있습니다. 사람들은 종종 이 둘을 구별하지 못하고 세부적인 문법에만 집중합니다.  숲을 보지 못하고 나무만 보고있는 셈입니다.</p>\n<p>객체는 여러가지 다른 방법으로 합성됩니다.  합성 형태에 따라 복합체의 구조와 객체간의 관계가 달라집니다. 어떤 객체가 다른 객체에 종속되면 한 객체가 변경되었을 때 다른 객체가 손상 될 수 있습니다.</p>\n<p>&quot;클래스 상속보다는 객체 합성을 우선해라&quot;라는 조언은 우리가 객체를 바라보는 방식을 거대한 기본 클래스로부터 상속받는 것이 아닌 작고 느슨하게 결합 된 요소들의 합성으로 생각하라는 뜻입니다.  GoF는 단단히 결합 된 객체를 &quot;모놀리틱<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> 시스템&quot;이라고 설명합니다. 이 시스템에서 어떤 클래스를 변경하거나 제거하려면 다른 수많은 클래스를 이해하고 변경해야 합니다. 결국 이러한 시스템은 이해하고, 이식하고, 유지하기 힘든 조밀한 덩어리가 됩니다. &quot;</p>\n<h2 id=\"객체-합성의-세-가지-다른-형태\">객체 합성의 세 가지 다른 형태</h2>\n<p>&quot;Design Patterns&quot;에서 Gang of Four는 &quot;객체 합성은 여러 디자인 패턴에 다양하게 적용될 것 입니다&quot;라고 말하고 계속해서  <em>집합</em>  및  <em>위임</em> 을 포함한 다양한 유형의 구성 관계를 설명합니다.</p>\n<p>&quot;Design Patterns&quot;의 저자는 주로 C ++ 및 Smalltalk (이후 Java) 환경에서 작업했습니다.  해당 언어로 런타임에 객체 관계를 정의하고 변경하는 작업은 JavaScript에서보다 훨씬 복잡하므로 해당 주제를 깊게 다루진 않을 것 입니다.  그러나 JavaScript의 객체 합성에 대해 논의하기 위해 먼저 동적 객체 확장 ( 일명, <em>concatenation</em> )에 대한 논의가 우선되어야 합니다.</p>\n<p>각 용어들은 &quot;Design Patterns&quot;에 나오는 정의와 약간 차이가 있는데, 이는 JavaScript에 적용 하기 위함이며 좀 더 명확하게 일반화된 뜻을 다루기 위함입니다. 예를 들어 집합<sup>Aggregation</sup>이  하위 객체들의 수명주기를 책임져야 함을 뜻하지 않습니다. 동적으로 객체를 확장시킬 수 있는 언어에서는 그렇지 않습니다.</p>\n<p>잘못된 공리 및 정의는 일반화를 힘들게 만들며 같은 개념의 특수한 사례를 다른 이름으로 부르게 만듭니다. 개발자는 불팔요한 반복을 좋아하지 않습니다.</p>\n<ul>\n<li><strong>집합</strong><sup>Aggregation</sup>  객체가 열거 가능한 하위 객체 모음으로 구성되는 경우.  즉, 다른 객체들을  <em>포함</em>  하는 객체입니다.  각 하위 객체는 자신의 레퍼런스를 유지하므로 얼마든지 집합체에서 분리, 해체될 수 있습니다.</li>\n<li><strong>접합</strong><sup>Concatenation</sup> <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup> 기존 객체에 새 속성을 추가하여 객체를 형성하는 경우.  속성을 한 번에 하나씩 연결하거나 기존 개체를 통채로 복사 할 수도 있습니다. 예를 들어, jQuery 플러그인은 프로토타입으로 연결된  <code>jQuery.fn</code>에 새 메서드를 연결하여 만들어집니다.</li>\n<li><strong>위임</strong><sup>Delegation</sup>  객체를 다른 객체로 전달하거나 특정 기능을 <strong>위임</strong>  하는 경우.  예를 들어  <a href=\"https://www.youtube.com/watch%3Fv%3DBKM3CmRqK2o\" target=\"_blank\" rel=\"noopener\">Ivan Sutherland의 Sketchpad</a>  (1962)에는 공유 속성을 &quot;마스터&quot;에게 위임하는 인스턴스가 있습니다. Photoshop에 포함된 &quot;스마트 오브젝트&quot;는 외부 리소스에게 동작을 위임하는 로컬 프록시가 있습니다. JavaScript의 프로토타입은 위임으로 작동합니다. Array 인스턴스로 배열 메소드를 호출하면 <code>Array.prototype</code>에게 전달되고,  Object 메소드들은 <code>Object.prototype</code>에게 전달됩니다.</li>\n</ul>\n<p>이러한 다른 형태의 구성은  <strong>서로 배타적이지 않습니다.</strong>  접합으로 위임을 구현할 수 있으며 JavaScript에서 클래스 상속은 위임으로 구현됩니다. 많은 소프트웨어 시스템은 객체를 합성할 때 하나 이상의 방법을 사용합니다. 예를 들어, jQuery의 플러그인은 프로토타입 프로퍼티인 <code>jQuery.fn</code>에 다른 메소드들을 접합하는 방식으로 확장합니다. 클라이언트 코드가 플러그인 메소드를 호출하면 프로토타입에 연결된 메소드에 위임됩니다.</p>\n<blockquote>\n<p>앞으로 나올 예제들에서 아래 코드를 계속 사용할 것 입니다.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> objs = [  </span><br><span class=\"line\">  &#123; <span class=\"attr\">a</span>: <span class=\"string\">'a'</span>, <span class=\"attr\">b</span>: <span class=\"string\">'ab'</span> &#125;,  </span><br><span class=\"line\">  &#123; <span class=\"attr\">b</span>: <span class=\"string\">'b'</span> &#125;,  </span><br><span class=\"line\">  &#123; <span class=\"attr\">c</span>: <span class=\"string\">'c'</span>, <span class=\"attr\">b</span>: <span class=\"string\">'cb'</span> &#125;  </span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<h2 id=\"집합-aggregation\">집합 Aggregation</h2>\n<p>집합은 객체가 열거 가능한 하위 객체 모음으로 구성되는 경우입니다.  즉, 다른 객체들을  <em>포함</em>  하는 객체입니다.  각 하위 객체는 자신의 레퍼런스를 유지하므로 얼마든지 집합체에서 분리, 해체될 수 있습니다.  다양한 구조로 표현 될 수 있습니다.</p>\n<h3 id=\"예제들\">예제들</h3>\n<ul>\n<li>Array</li>\n<li>Map</li>\n<li>Set</li>\n<li>Graph</li>\n<li>Tree</li>\n<li>DOM node (DOM 노드는 자식 노드를  <em>포함</em>  )</li>\n<li>UI component (컴포넌트는 하위 컴포넌트들을 <em>포함</em> )</li>\n</ul>\n<h3 id=\"언제-사용-하는가\">언제 사용 하는가?</h3>\n<p>스택, 큐, 트리, 그래프, 상태 머신 또는 컴포지트 패턴에서처럼 공통 작업을 공유해야하는 객체 모음이있는 경우 (수많은 아이템들이 동일한 인터페이스를 공유하려는 경우)</p>\n<h3 id=\"참고사항\">참고사항</h3>\n<p>집합을 사용하면 각 멤버에게 함수를 적용하고( e.g.   <code>array.map(fn)</code> ) 단일 값인 것처럼 벡터를 변환하는 등 보편적인 추상화를 적용할 수 있습니다.  그러나 수십, 수백만개의 하위 객체를 다뤄야할 경우 스트림으로 처리하는 것이 더 효율적일 수 있습니다.</p>\n<h3 id=\"코드-예제\">코드 예제</h3>\n<p>Array 집합 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> collection = <span class=\"function\">(<span class=\"params\">a, e</span>) =&gt;</span> a.concat([e]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = objs.reduce(collection, []);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(   </span><br><span class=\"line\">  <span class=\"string\">'collection aggregation'</span>,  </span><br><span class=\"line\">  a,  </span><br><span class=\"line\">  a[<span class=\"number\">1</span>].b,  </span><br><span class=\"line\">  a[<span class=\"number\">2</span>].c,  </span><br><span class=\"line\">  <span class=\"string\">`enumerable keys: <span class=\"subst\">$&#123; <span class=\"built_in\">Object</span>.keys(a) &#125;</span>`</span>  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>다음처럼 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collection aggregation   </span><br><span class=\"line\">[&#123;<span class=\"string\">\"a\"</span>:<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>:<span class=\"string\">\"ab\"</span>&#125;,&#123;<span class=\"string\">\"b\"</span>:<span class=\"string\">\"b\"</span>&#125;,&#123;<span class=\"string\">\"c\"</span>:<span class=\"string\">\"c\"</span>,<span class=\"string\">\"b\"</span>:<span class=\"string\">\"cb\"</span>&#125;]   </span><br><span class=\"line\">b c   </span><br><span class=\"line\">enumerable keys: <span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>pair를 사용하는 연결리스트<sup>Linked-list</sup> 집합 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pair = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> [b, a];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> l = objs.reduceRight(pair, []);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  <span class=\"string\">'linked list aggregation'</span>,  </span><br><span class=\"line\">  l,  </span><br><span class=\"line\">  <span class=\"string\">`enumerable keys: <span class=\"subst\">$&#123; <span class=\"built_in\">Object</span>.keys(l) &#125;</span>`</span>  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">linked list aggregation  </span></span><br><span class=\"line\"><span class=\"comment\">[  </span></span><br><span class=\"line\"><span class=\"comment\">  &#123;\"a\":\"a\",\"b\":\"ab\"&#125;, [  </span></span><br><span class=\"line\"><span class=\"comment\">    &#123;\"b\":\"b\"&#125;, [  </span></span><br><span class=\"line\"><span class=\"comment\">      &#123;\"c\":\"c\",\"b\":\"cb\"&#125;,  </span></span><br><span class=\"line\"><span class=\"comment\">      []  </span></span><br><span class=\"line\"><span class=\"comment\">    ]  </span></span><br><span class=\"line\"><span class=\"comment\">  ]  </span></span><br><span class=\"line\"><span class=\"comment\">]  </span></span><br><span class=\"line\"><span class=\"comment\">enumerable keys: 0,1  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>연결리스트는 배열, 문자열, 트리 및 다양한 종류의 데이터 구조 및 집합의 기초가 됩니다. 훨씬 많은 예가 있으며 여기서 그것들을 모두 다루진 않겠습니다.</p>\n<h2 id=\"접합-연결-concatenation\">접합, 연결 Concatenation</h2>\n<p>접합이란 기존 객체에 새 속성을 추가하여 객체를 형성하는 것 입니다.</p>\n<h3 id=\"예제들\">예제들</h3>\n<ul>\n<li><code>jQuery.fn</code>에 접합하는 방식으로 플러그인을 추가합니다.</li>\n<li>State reducers, 상태 관리 유틸리티 (예 : Redux)</li>\n<li>함수형 믹스인</li>\n</ul>\n<h3 id=\"언제-사용하는가\">언제 사용하는가?</h3>\n<p>JSON 객체 합치기, 여러 소스에서 애플리케이션 상태를 가져오기, 불변 상태를 업데이트 하기(이전 상태를 새 데이터와 병합)등 런타임에 점진적으로 데이터 구조를 조립하는 것이 필요하다면 언제든지</p>\n<h3 id=\"참고사항\">참고사항</h3>\n<ul>\n<li>기존 객체를 변이시킬 때 주의해야합니다. 변경 가능한 공유 상태는 많은 버그를 일으킬 수 있습니다.</li>\n<li>클래스 계층 구조를 모방하는 것이 가능합니다. 즉,  <em>is-a</em> 관계를 만들 수 있습니다.  같은 문제가 적용됩니다.  “기본” 인스턴스에서 속성들을 상속하고 다중상속을 하는 대신 작고 독립적인 객체들을 &quot;합성&quot;한다는 아이디어로 접근해야합니다.</li>\n<li>구성요소들간의 암시적인 종속성에 주의하십시오.</li>\n<li>속성 이름 충돌은 연결 순서로 해결됩니다.(마지막 값이 적용됨)   이는 기본값을 지정하거나 오버라이딩 할 때 유용하지만 순서가 명확하지 않은 경우 문제가 될 수 있습니다.</li>\n</ul>\n<h3 id=\"코드-예제\">코드 예제</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> c = objs.reduce(concatenate, &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> concatenate = <span class=\"function\">(<span class=\"params\">a, o</span>) =&gt;</span> (&#123;...a, ...o&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  <span class=\"string\">'concatenation'</span>,  </span><br><span class=\"line\">  c,  </span><br><span class=\"line\">  <span class=\"string\">`enumerable keys: <span class=\"subst\">$&#123; <span class=\"built_in\">Object</span>.keys(c) &#125;</span>`</span>  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// concatenation &#123; a: 'a', b: 'cb', c: 'c' &#125; enumerable keys: a,b,c</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"위임-delegation\">위임 Delegation</h2>\n<p>위임은 객체를 다른 객체로 전달하거나 특정 기능을 <strong>위임</strong>  하는 경우입니다.</p>\n<h3 id=\"예제들\">예제들</h3>\n<ul>\n<li>JavaScript은 기본적으로 위임을 사용하여 메소드 호출을 프로토타입 체인으로 전달합니다.  e.g.  <code>[].map()</code>  은  <code>Array.prototype.map()</code>으로,  <code>obj.hasOwnProperty()</code>  는  <code>Object.prototype.hasOwnProperty()</code> 으로 호출이 위임됩니다.</li>\n<li>jQuery 플러그인은 위임을 사용해 모든 인스턴스에서 내장 및 플러그인 메소드를 공유합니다.</li>\n<li>Sketchpad의 &quot;마스터&quot;는 동적 위임자였습니다.  마스터의 변경사항은 모든 객체 인스턴스에 즉시 반영됩니다.</li>\n<li>Photoshop에서는 &quot;스마트 객체&quot;라는 위임자를 사용하여 별도의 파일에 정의 된 이미지와 리소스를 나타냅니다.  스마트 오브젝트가 참조하는 오브젝트에 대한 변경 사항은 스마트 오브젝트의 모든 인스턴스에 반영됩니다.</li>\n</ul>\n<h3 id=\"언제-사용-하는가\">언제 사용 하는가?</h3>\n<ol>\n<li>메모리 절약 : 객체의 인스턴스가 매우 많을 경우,  각 인스턴스마다 메모리를 더 많이 할당해하는 대신 인스턴스간에 동일한 속성이나 메소드를 공유하는 것이 유용할 수 있습니다.</li>\n<li>많은 인스턴스를 동적으로 업데이트 : 많은 객체 인스턴스가 동일한 상태를 공유하고 동적으로 업데이트해야 하는 경우 변경사항을 즉석에서 모든 인스턴스에 반영시킬 수 있습니다.(예 : Sketchpad의 &quot;마스터&quot;또는 Photoshop의 “스마트 객체”).</li>\n</ol>\n<h3 id=\"참고사항\">참고사항</h3>\n<ul>\n<li>위임은 일반적으로 JavaScript에서 클래스 상속을 모방하는 데 사용되며 (실제로 <code>extends</code>  키워드에 묶여 있음) 실제로는 거의 필요하지 않습니다.</li>\n<li>위임을 사용하여 클래스 상속의 동작 및 제한 사항을 정확하게 모방 할 수 있습니다.  사실 JavaScript의 클래스 상속은 프로토타입 위임 체인으로 구축되어 있습니다.</li>\n<li>위임된 속성은  <code>Object.keys(instanceObj)</code> 와 같은 일반적인 메커니즘을 사용하여 열거 할 수 없습니다.</li>\n<li>위임은 속성 조회 속도를 희생해 메모리를 절약합니다. JS 엔진은 일부 동적 위임자(생성 된 후에 변경되는 위임자)에 대한 최적화를 수행하지 못합니다. 그러나 가장 느린 경우에도 속성 조회 성능은 수백만 ops /초로 측정됩니다. 이벤트 스트림 처리용 혹은 그래픽 프로그래밍용 범용 유틸리티 라이브러리(e.g. RxJS 또는 three.js)가 아닌 이상 병목 현상이 발생하긴 쉽지 않습니다.</li>\n<li>인스턴스의 상태와 위임된 상태를 구별해야합니다.</li>\n<li>동적으로 위임된 공유 상태는 안전하지 않습니다.  변경사항은 모든 인스턴스간에 공유됩니다.  이는 일반적으로 (항상 그런 것은 아님) 버그를 발생시키는 원인입니다.</li>\n<li>ES6에서 클래스의 프로토타입은 재할당될 수 없습니다. 바벨로 컴파일했을 때 작동하는 것처럼 보일지라도 실제 ES6 환경에서는 오류가 발생합니다.</li>\n</ul>\n<h3 id=\"코드-예제\">코드 예제</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delegate = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> <span class=\"built_in\">Object</span>.assign(<span class=\"built_in\">Object</span>.create(a), b);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> d = objs.reduceRight(delegate, &#123;&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  <span class=\"string\">'delegation'</span>,  </span><br><span class=\"line\">  d,  </span><br><span class=\"line\">  <span class=\"string\">`enumerable keys: <span class=\"subst\">$&#123; <span class=\"built_in\">Object</span>.keys(d) &#125;</span>`</span>  </span><br><span class=\"line\">);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// delegation &#123; a: 'a', b: 'ab' &#125; enumerable keys: a,b  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(d.b, d.c); <span class=\"comment\">// ab c</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"결론\">결론</h2>\n<p>지금까지 배운 것들을 요약해보겠습니다.</p>\n<ul>\n<li>원시형 및 다른 객체들로 만들어진 모든 객체는  <em>복합 객체</em>  입니다.</li>\n<li>복합 객체를 만드는 행위를 합성이라고합니다.</li>\n<li>객체 합성에는 여러 종류가 있습니다.</li>\n<li>형성되는 관계와 의존성은 객체가 어떻게 합성되는지에 따라 다릅니다.</li>\n<li>Is-a 관계 (클래스 상속에 의해 형성된 종류)는 OO 디자인의 커플링 중 가장 단단한 형태이며 꼭 필요한 경우가 아니면 일반적으로 피해야합니다.</li>\n<li>Gang of Four는 모놀리틱한 기본 클래스 또는 기본 객체에서 상속하지 말고 작은 기능들을 조합하여 객체를 합성하도록 권장합니다.  “클래스 상속보다는 객체 합성을 우선해라”</li>\n<li>집합은 배열, DOM 트리 등 구성원들이 자신의 참조를 유지하는 열거형 컬렉션으로 객체를 합성합니다.</li>\n<li>위임은 프로토타입 위임 체인을 연결하여 객체를 합성합니다. 이 때 객체는 속성 조회 및 메소드 호출을 프로토타입에게 전달하거나 다른 객체에 위임합니다.  e.g.  <code>[].map()</code>  은  <code>Array.prototype.map()</code>을 호출합니다.</li>\n<li>접합(연결)은  <code>Object.assign(destination, a, b)</code>  ,  <code>{...a, ...b}</code>  와 같은 새 속성으로 기존 객체를 확장하여 객체를 합성합니다.</li>\n<li>객체 합성에 대한 서로 다른 정의들은 상호 배타적인 것이 아닙니다. 위임은 집합의 하위 집합이며, 연결을 사용하여 위임과 집합을 구현하는 등의 작업을 할 수 있습니다.</li>\n</ul>\n<p>단지 세 가지 종류의 객체 합성만 있는 것이 아닙니다.  또한 객체가 다른 객체에게 매개 변수로 전달되는(의존성 삽입) 등의 관계를 통해 객체간에 느슨하고 동적인 관계를 형성 할 수도 있습니다.</p>\n<p>모든 소프트웨어 개발은 합성입니다.  쉽고 유연한 방법도 있고 부서지기 쉬운 관절염도 있습니다.  객체 합성의 일부 형태는 느슨하게 연결된 관계를 형성하고, 다른 형태는 매우 단단한 결합을 형성합니다.</p>\n<p>프로그램 요구사항이 변경되었을 때 코드 구현을 조금만 변경하기 위해선 다양한 합성 형태를 찾아보십시오. 의도를 명확하고 간결하게 표현하고 기억하십시오 : 클래스 상속이 필요하다고 생각이 들 때 사실 더 좋은 방법이 많이 있을 것입니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/\"><strong>다음: 삼항연산자의 멋짐을 모르는 당신이 불쌍해 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>monolithic  단일체의, 한 덩어리로 뭉친, 단일 결정으로된 <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>병합, 연결, 결합과 같은 용어로 번역됩니다. 배열, 문자열의 기본 연산에서 등장하는 용어이지만 객체를 합친다는 문맥에서는 접합이 적합하다고 판단했습니다 <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href=\"https://medium.com/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/\">&lt;이전</a>  |  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href=\"https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/\">다음&gt;</a></p>\n</blockquote>\n<blockquote>\n<p>“객체 합성, 보다 복잡한 동작을 하기 위해 객체를 조립 또는 합성하는 것”~ 4 강  <a href=\"https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;qid=1494993475&amp;sr=8-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6c553f16325f3939e5abadd4ee04e8b4\" target=\"_blank\" rel=\"noopener\">“디자인 패턴 : 재사용 가능한 객체 지향 소프트웨어의 요소”</a></p>\n</blockquote>\n<blockquote>\n<p>“클래스 상속보다는 객체 합성을 우선해라”, Gang of Four,</p>\n</blockquote>\n<p>소프트웨어를 개발하는 과정에서 가장 흔히 볼 수 있는 실수 중 하나는 클래스 상속을 과도하게 사용하는 경향입니다.  클래스 상속은 기본 클래스와 하위 클래스 사이에 <strong>는-이다(is-a)</strong>  관계를 만들어 코드를 재사용하는 메커니즘입니다.   <em>is-a</em>  관계 (e.g. 오리는 새이다)를 사용하여 도메인을 모델링하는 과정에서 문제가 발생할 수 있습니다.  그 이유는 클래스 상속이 객체 지향 디자인에서 사용할 수 있는 가장 단단한 형태의 결합이기 때문입니다. 결국 다음과 같은(그 외에도) 많은 문제들을 일으킵니다 :</p>\n<ul>\n<li>깨지기 쉬운 기본 클래스 문제</li>\n<li>고릴라 / 바나나 문제</li>\n<li>중복 필요성 문제</li>\n</ul>\n<p>상속은 하위 클래스가 상속, 추가 및 오버라이딩할 수 있는 기본 클래스를 공용 인터페이스로 추상화하여 코드를 재사용합니다.  <strong>추상화</strong>에는 두 가지 중요한 특징이 있습니다.</p>\n<ul>\n<li><strong>일반화<sup>Generalization</sup></strong>  일반적인 사용사례에 해당하는 공유 속성 및 동작들을 추출하는 과정</li>\n<li><strong>전문화<sup>Specialization</sup></strong>  특수한 경우를 처리하는 데 필요한 구현 세부 사항을 제공하는 과정</li>\n</ul>\n<p>코드를 일반화 및 전문화하는데는 여러 가지 방법이 있습니다.  클래스 상속대신 사용할 수 있는 좋은 대안으로는 단순 함수, 고차 함수 및  <strong>객체 합성</strong>이있습니다.</p>\n<p>불행히도, 많은 사람들이 객체 합성에 대해 오해하고 있으며 이러한 관점으로 생각하기 어려워 합니다.  주제에 대해 좀 더 깊이 알아봐야 할 필요가 있습니다.</p>\n<h2>객체 합성<sup>Object</sup> <sup>Composition</sup>이란 무엇입니까?</h2>\n<blockquote>\n<p>&quot;컴퓨터 과학에서의 복합 자료형<sup>Composite</sup> <sup>datatype</sup>이란 프로그래밍 언어의 원시 자료형 및 기타 복합 유형을 사용하여 구성 할 수있는 모든 데이터 유형입니다.  […] 복합 유형을 구성하는 행위는 합성<sup>Composition</sup>으로 알려져 있습니다. &quot;~ Wikipedia</p>\n</blockquote>\n<p>기본형들을 조립해 복합 객체를 만드는 모든 행위가 객체 합성입니다. 그러나 상속은 마치 객체 합성과는 전혀 관련이 없으며 심지어 정반대의 기술인 것처럼 논의되고 있습니다. 이러한 편견이 생기는 이유는 객체 합성의 문법과 의미간에 차이가 있기 때문입니다.</p>\n<p>지금부터 알아볼 객체 합성과 클래스 상속에 관한 논의는 특정 기법에 관한 것이 아닙니다.  구성 요소들 사이의  <em>의미론적</em>  관계와   <em>결합 정도에</em>  대한 것입니다.  우리는  <em>문법</em> 이 아니라 <em>의미</em> 에 대해 말하고 있습니다. 사람들은 종종 이 둘을 구별하지 못하고 세부적인 문법에만 집중합니다.  숲을 보지 못하고 나무만 보고있는 셈입니다.</p>\n<p>객체는 여러가지 다른 방법으로 합성됩니다.  합성 형태에 따라 복합체의 구조와 객체간의 관계가 달라집니다. 어떤 객체가 다른 객체에 종속되면 한 객체가 변경되었을 때 다른 객체가 손상 될 수 있습니다.</p>\n<p>&quot;클래스 상속보다는 객체 합성을 우선해라&quot;라는 조언은 우리가 객체를 바라보는 방식을 거대한 기본 클래스로부터 상속받는 것이 아닌 작고 느슨하게 결합 된 요소들의 합성으로 생각하라는 뜻입니다.  GoF는 단단히 결합 된 객체를 &quot;모놀리틱<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> 시스템&quot;이라고 설명합니다. 이 시스템에서 어떤 클래스를 변경하거나 제거하려면 다른 수많은 클래스를 이해하고 변경해야 합니다. 결국 이러한 시스템은 이해하고, 이식하고, 유지하기 힘든 조밀한 덩어리가 됩니다. &quot;</p>\n<h2>객체 합성의 세 가지 다른 형태</h2>\n<p>&quot;Design Patterns&quot;에서 Gang of Four는 &quot;객체 합성은 여러 디자인 패턴에 다양하게 적용될 것 입니다&quot;라고 말하고 계속해서  <em>집합</em>  및  <em>위임</em> 을 포함한 다양한 유형의 구성 관계를 설명합니다.</p>\n<p>&quot;Design Patterns&quot;의 저자는 주로 C ++ 및 Smalltalk (이후 Java) 환경에서 작업했습니다.  해당 언어로 런타임에 객체 관계를 정의하고 변경하는 작업은 JavaScript에서보다 훨씬 복잡하므로 해당 주제를 깊게 다루진 않을 것 입니다.  그러나 JavaScript의 객체 합성에 대해 논의하기 위해 먼저 동적 객체 확장 ( 일명, <em>concatenation</em> )에 대한 논의가 우선되어야 합니다.</p>\n<p>각 용어들은 &quot;Design Patterns&quot;에 나오는 정의와 약간 차이가 있는데, 이는 JavaScript에 적용 하기 위함이며 좀 더 명확하게 일반화된 뜻을 다루기 위함입니다. 예를 들어 집합<sup>Aggregation</sup>이  하위 객체들의 수명주기를 책임져야 함을 뜻하지 않습니다. 동적으로 객체를 확장시킬 수 있는 언어에서는 그렇지 않습니다.</p>\n<p>잘못된 공리 및 정의는 일반화를 힘들게 만들며 같은 개념의 특수한 사례를 다른 이름으로 부르게 만듭니다. 개발자는 불팔요한 반복을 좋아하지 않습니다.</p>\n<ul>\n<li><strong>집합</strong><sup>Aggregation</sup>  객체가 열거 가능한 하위 객체 모음으로 구성되는 경우.  즉, 다른 객체들을  <em>포함</em>  하는 객체입니다.  각 하위 객체는 자신의 레퍼런스를 유지하므로 얼마든지 집합체에서 분리, 해체될 수 있습니다.</li>\n<li><strong>접합</strong><sup>Concatenation</sup> <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup> 기존 객체에 새 속성을 추가하여 객체를 형성하는 경우.  속성을 한 번에 하나씩 연결하거나 기존 개체를 통채로 복사 할 수도 있습니다. 예를 들어, jQuery 플러그인은 프로토타입으로 연결된  <code>jQuery.fn</code>에 새 메서드를 연결하여 만들어집니다.</li>\n<li><strong>위임</strong><sup>Delegation</sup>  객체를 다른 객체로 전달하거나 특정 기능을 <strong>위임</strong>  하는 경우.  예를 들어  <a href=\"https://www.youtube.com/watch%3Fv%3DBKM3CmRqK2o\" target=\"_blank\" rel=\"noopener\">Ivan Sutherland의 Sketchpad</a>  (1962)에는 공유 속성을 &quot;마스터&quot;에게 위임하는 인스턴스가 있습니다. Photoshop에 포함된 &quot;스마트 오브젝트&quot;는 외부 리소스에게 동작을 위임하는 로컬 프록시가 있습니다. JavaScript의 프로토타입은 위임으로 작동합니다. Array 인스턴스로 배열 메소드를 호출하면 <code>Array.prototype</code>에게 전달되고,  Object 메소드들은 <code>Object.prototype</code>에게 전달됩니다.</li>\n</ul>\n<p>이러한 다른 형태의 구성은  <strong>서로 배타적이지 않습니다.</strong>  접합으로 위임을 구현할 수 있으며 JavaScript에서 클래스 상속은 위임으로 구현됩니다. 많은 소프트웨어 시스템은 객체를 합성할 때 하나 이상의 방법을 사용합니다. 예를 들어, jQuery의 플러그인은 프로토타입 프로퍼티인 <code>jQuery.fn</code>에 다른 메소드들을 접합하는 방식으로 확장합니다. 클라이언트 코드가 플러그인 메소드를 호출하면 프로토타입에 연결된 메소드에 위임됩니다.</p>\n<blockquote>\n<p>앞으로 나올 예제들에서 아래 코드를 계속 사용할 것 입니다.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> objs = [  </span><br><span class=\"line\">  &#123; <span class=\"attr\">a</span>: <span class=\"string\">'a'</span>, <span class=\"attr\">b</span>: <span class=\"string\">'ab'</span> &#125;,  </span><br><span class=\"line\">  &#123; <span class=\"attr\">b</span>: <span class=\"string\">'b'</span> &#125;,  </span><br><span class=\"line\">  &#123; <span class=\"attr\">c</span>: <span class=\"string\">'c'</span>, <span class=\"attr\">b</span>: <span class=\"string\">'cb'</span> &#125;  </span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<h2>집합 Aggregation</h2>\n<p>집합은 객체가 열거 가능한 하위 객체 모음으로 구성되는 경우입니다.  즉, 다른 객체들을  <em>포함</em>  하는 객체입니다.  각 하위 객체는 자신의 레퍼런스를 유지하므로 얼마든지 집합체에서 분리, 해체될 수 있습니다.  다양한 구조로 표현 될 수 있습니다.</p>\n<h3>예제들</h3>\n<ul>\n<li>Array</li>\n<li>Map</li>\n<li>Set</li>\n<li>Graph</li>\n<li>Tree</li>\n<li>DOM node (DOM 노드는 자식 노드를  <em>포함</em>  )</li>\n<li>UI component (컴포넌트는 하위 컴포넌트들을 <em>포함</em> )</li>\n</ul>\n<h3>언제 사용 하는가?</h3>\n<p>스택, 큐, 트리, 그래프, 상태 머신 또는 컴포지트 패턴에서처럼 공통 작업을 공유해야하는 객체 모음이있는 경우 (수많은 아이템들이 동일한 인터페이스를 공유하려는 경우)</p>\n<h3>참고사항</h3>\n<p>집합을 사용하면 각 멤버에게 함수를 적용하고( e.g.   <code>array.map(fn)</code> ) 단일 값인 것처럼 벡터를 변환하는 등 보편적인 추상화를 적용할 수 있습니다.  그러나 수십, 수백만개의 하위 객체를 다뤄야할 경우 스트림으로 처리하는 것이 더 효율적일 수 있습니다.</p>\n<h3>코드 예제</h3>\n<p>Array 집합 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> collection = <span class=\"function\">(<span class=\"params\">a, e</span>) =&gt;</span> a.concat([e]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = objs.reduce(collection, []);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(   </span><br><span class=\"line\">  <span class=\"string\">'collection aggregation'</span>,  </span><br><span class=\"line\">  a,  </span><br><span class=\"line\">  a[<span class=\"number\">1</span>].b,  </span><br><span class=\"line\">  a[<span class=\"number\">2</span>].c,  </span><br><span class=\"line\">  <span class=\"string\">`enumerable keys: <span class=\"subst\">$&#123; <span class=\"built_in\">Object</span>.keys(a) &#125;</span>`</span>  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>다음처럼 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collection aggregation   </span><br><span class=\"line\">[&#123;<span class=\"string\">\"a\"</span>:<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>:<span class=\"string\">\"ab\"</span>&#125;,&#123;<span class=\"string\">\"b\"</span>:<span class=\"string\">\"b\"</span>&#125;,&#123;<span class=\"string\">\"c\"</span>:<span class=\"string\">\"c\"</span>,<span class=\"string\">\"b\"</span>:<span class=\"string\">\"cb\"</span>&#125;]   </span><br><span class=\"line\">b c   </span><br><span class=\"line\">enumerable keys: <span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>pair를 사용하는 연결리스트<sup>Linked-list</sup> 집합 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pair = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> [b, a];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> l = objs.reduceRight(pair, []);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  <span class=\"string\">'linked list aggregation'</span>,  </span><br><span class=\"line\">  l,  </span><br><span class=\"line\">  <span class=\"string\">`enumerable keys: <span class=\"subst\">$&#123; <span class=\"built_in\">Object</span>.keys(l) &#125;</span>`</span>  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">linked list aggregation  </span></span><br><span class=\"line\"><span class=\"comment\">[  </span></span><br><span class=\"line\"><span class=\"comment\">  &#123;\"a\":\"a\",\"b\":\"ab\"&#125;, [  </span></span><br><span class=\"line\"><span class=\"comment\">    &#123;\"b\":\"b\"&#125;, [  </span></span><br><span class=\"line\"><span class=\"comment\">      &#123;\"c\":\"c\",\"b\":\"cb\"&#125;,  </span></span><br><span class=\"line\"><span class=\"comment\">      []  </span></span><br><span class=\"line\"><span class=\"comment\">    ]  </span></span><br><span class=\"line\"><span class=\"comment\">  ]  </span></span><br><span class=\"line\"><span class=\"comment\">]  </span></span><br><span class=\"line\"><span class=\"comment\">enumerable keys: 0,1  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>연결리스트는 배열, 문자열, 트리 및 다양한 종류의 데이터 구조 및 집합의 기초가 됩니다. 훨씬 많은 예가 있으며 여기서 그것들을 모두 다루진 않겠습니다.</p>\n<h2>접합, 연결 Concatenation</h2>\n<p>접합이란 기존 객체에 새 속성을 추가하여 객체를 형성하는 것 입니다.</p>\n<h3>예제들</h3>\n<ul>\n<li><code>jQuery.fn</code>에 접합하는 방식으로 플러그인을 추가합니다.</li>\n<li>State reducers, 상태 관리 유틸리티 (예 : Redux)</li>\n<li>함수형 믹스인</li>\n</ul>\n<h3>언제 사용하는가?</h3>\n<p>JSON 객체 합치기, 여러 소스에서 애플리케이션 상태를 가져오기, 불변 상태를 업데이트 하기(이전 상태를 새 데이터와 병합)등 런타임에 점진적으로 데이터 구조를 조립하는 것이 필요하다면 언제든지</p>\n<h3>참고사항</h3>\n<ul>\n<li>기존 객체를 변이시킬 때 주의해야합니다. 변경 가능한 공유 상태는 많은 버그를 일으킬 수 있습니다.</li>\n<li>클래스 계층 구조를 모방하는 것이 가능합니다. 즉,  <em>is-a</em> 관계를 만들 수 있습니다.  같은 문제가 적용됩니다.  “기본” 인스턴스에서 속성들을 상속하고 다중상속을 하는 대신 작고 독립적인 객체들을 &quot;합성&quot;한다는 아이디어로 접근해야합니다.</li>\n<li>구성요소들간의 암시적인 종속성에 주의하십시오.</li>\n<li>속성 이름 충돌은 연결 순서로 해결됩니다.(마지막 값이 적용됨)   이는 기본값을 지정하거나 오버라이딩 할 때 유용하지만 순서가 명확하지 않은 경우 문제가 될 수 있습니다.</li>\n</ul>\n<h3>코드 예제</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> c = objs.reduce(concatenate, &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> concatenate = <span class=\"function\">(<span class=\"params\">a, o</span>) =&gt;</span> (&#123;...a, ...o&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  <span class=\"string\">'concatenation'</span>,  </span><br><span class=\"line\">  c,  </span><br><span class=\"line\">  <span class=\"string\">`enumerable keys: <span class=\"subst\">$&#123; <span class=\"built_in\">Object</span>.keys(c) &#125;</span>`</span>  </span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// concatenation &#123; a: 'a', b: 'cb', c: 'c' &#125; enumerable keys: a,b,c</span></span><br></pre></td></tr></table></figure>\n<h2>위임 Delegation</h2>\n<p>위임은 객체를 다른 객체로 전달하거나 특정 기능을 <strong>위임</strong>  하는 경우입니다.</p>\n<h3>예제들</h3>\n<ul>\n<li>JavaScript은 기본적으로 위임을 사용하여 메소드 호출을 프로토타입 체인으로 전달합니다.  e.g.  <code>[].map()</code>  은  <code>Array.prototype.map()</code>으로,  <code>obj.hasOwnProperty()</code>  는  <code>Object.prototype.hasOwnProperty()</code> 으로 호출이 위임됩니다.</li>\n<li>jQuery 플러그인은 위임을 사용해 모든 인스턴스에서 내장 및 플러그인 메소드를 공유합니다.</li>\n<li>Sketchpad의 &quot;마스터&quot;는 동적 위임자였습니다.  마스터의 변경사항은 모든 객체 인스턴스에 즉시 반영됩니다.</li>\n<li>Photoshop에서는 &quot;스마트 객체&quot;라는 위임자를 사용하여 별도의 파일에 정의 된 이미지와 리소스를 나타냅니다.  스마트 오브젝트가 참조하는 오브젝트에 대한 변경 사항은 스마트 오브젝트의 모든 인스턴스에 반영됩니다.</li>\n</ul>\n<h3>언제 사용 하는가?</h3>\n<ol>\n<li>메모리 절약 : 객체의 인스턴스가 매우 많을 경우,  각 인스턴스마다 메모리를 더 많이 할당해하는 대신 인스턴스간에 동일한 속성이나 메소드를 공유하는 것이 유용할 수 있습니다.</li>\n<li>많은 인스턴스를 동적으로 업데이트 : 많은 객체 인스턴스가 동일한 상태를 공유하고 동적으로 업데이트해야 하는 경우 변경사항을 즉석에서 모든 인스턴스에 반영시킬 수 있습니다.(예 : Sketchpad의 &quot;마스터&quot;또는 Photoshop의 “스마트 객체”).</li>\n</ol>\n<h3>참고사항</h3>\n<ul>\n<li>위임은 일반적으로 JavaScript에서 클래스 상속을 모방하는 데 사용되며 (실제로 <code>extends</code>  키워드에 묶여 있음) 실제로는 거의 필요하지 않습니다.</li>\n<li>위임을 사용하여 클래스 상속의 동작 및 제한 사항을 정확하게 모방 할 수 있습니다.  사실 JavaScript의 클래스 상속은 프로토타입 위임 체인으로 구축되어 있습니다.</li>\n<li>위임된 속성은  <code>Object.keys(instanceObj)</code> 와 같은 일반적인 메커니즘을 사용하여 열거 할 수 없습니다.</li>\n<li>위임은 속성 조회 속도를 희생해 메모리를 절약합니다. JS 엔진은 일부 동적 위임자(생성 된 후에 변경되는 위임자)에 대한 최적화를 수행하지 못합니다. 그러나 가장 느린 경우에도 속성 조회 성능은 수백만 ops /초로 측정됩니다. 이벤트 스트림 처리용 혹은 그래픽 프로그래밍용 범용 유틸리티 라이브러리(e.g. RxJS 또는 three.js)가 아닌 이상 병목 현상이 발생하긴 쉽지 않습니다.</li>\n<li>인스턴스의 상태와 위임된 상태를 구별해야합니다.</li>\n<li>동적으로 위임된 공유 상태는 안전하지 않습니다.  변경사항은 모든 인스턴스간에 공유됩니다.  이는 일반적으로 (항상 그런 것은 아님) 버그를 발생시키는 원인입니다.</li>\n<li>ES6에서 클래스의 프로토타입은 재할당될 수 없습니다. 바벨로 컴파일했을 때 작동하는 것처럼 보일지라도 실제 ES6 환경에서는 오류가 발생합니다.</li>\n</ul>\n<h3>코드 예제</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delegate = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> <span class=\"built_in\">Object</span>.assign(<span class=\"built_in\">Object</span>.create(a), b);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> d = objs.reduceRight(delegate, &#123;&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(  </span><br><span class=\"line\">  <span class=\"string\">'delegation'</span>,  </span><br><span class=\"line\">  d,  </span><br><span class=\"line\">  <span class=\"string\">`enumerable keys: <span class=\"subst\">$&#123; <span class=\"built_in\">Object</span>.keys(d) &#125;</span>`</span>  </span><br><span class=\"line\">);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// delegation &#123; a: 'a', b: 'ab' &#125; enumerable keys: a,b  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(d.b, d.c); <span class=\"comment\">// ab c</span></span><br></pre></td></tr></table></figure>\n<h2>결론</h2>\n<p>지금까지 배운 것들을 요약해보겠습니다.</p>\n<ul>\n<li>원시형 및 다른 객체들로 만들어진 모든 객체는  <em>복합 객체</em>  입니다.</li>\n<li>복합 객체를 만드는 행위를 합성이라고합니다.</li>\n<li>객체 합성에는 여러 종류가 있습니다.</li>\n<li>형성되는 관계와 의존성은 객체가 어떻게 합성되는지에 따라 다릅니다.</li>\n<li>Is-a 관계 (클래스 상속에 의해 형성된 종류)는 OO 디자인의 커플링 중 가장 단단한 형태이며 꼭 필요한 경우가 아니면 일반적으로 피해야합니다.</li>\n<li>Gang of Four는 모놀리틱한 기본 클래스 또는 기본 객체에서 상속하지 말고 작은 기능들을 조합하여 객체를 합성하도록 권장합니다.  “클래스 상속보다는 객체 합성을 우선해라”</li>\n<li>집합은 배열, DOM 트리 등 구성원들이 자신의 참조를 유지하는 열거형 컬렉션으로 객체를 합성합니다.</li>\n<li>위임은 프로토타입 위임 체인을 연결하여 객체를 합성합니다. 이 때 객체는 속성 조회 및 메소드 호출을 프로토타입에게 전달하거나 다른 객체에 위임합니다.  e.g.  <code>[].map()</code>  은  <code>Array.prototype.map()</code>을 호출합니다.</li>\n<li>접합(연결)은  <code>Object.assign(destination, a, b)</code>  ,  <code>{...a, ...b}</code>  와 같은 새 속성으로 기존 객체를 확장하여 객체를 합성합니다.</li>\n<li>객체 합성에 대한 서로 다른 정의들은 상호 배타적인 것이 아닙니다. 위임은 집합의 하위 집합이며, 연결을 사용하여 위임과 집합을 구현하는 등의 작업을 할 수 있습니다.</li>\n</ul>\n<p>단지 세 가지 종류의 객체 합성만 있는 것이 아닙니다.  또한 객체가 다른 객체에게 매개 변수로 전달되는(의존성 삽입) 등의 관계를 통해 객체간에 느슨하고 동적인 관계를 형성 할 수도 있습니다.</p>\n<p>모든 소프트웨어 개발은 합성입니다.  쉽고 유연한 방법도 있고 부서지기 쉬운 관절염도 있습니다.  객체 합성의 일부 형태는 느슨하게 연결된 관계를 형성하고, 다른 형태는 매우 단단한 결합을 형성합니다.</p>\n<p>프로그램 요구사항이 변경되었을 때 코드 구현을 조금만 변경하기 위해선 다양한 합성 형태를 찾아보십시오. 의도를 명확하고 간결하게 표현하고 기억하십시오 : 클래스 상속이 필요하다고 생각이 들 때 사실 더 좋은 방법이 많이 있을 것입니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/\"><strong>다음: 삼항연산자의 멋짐을 모르는 당신이 불쌍해 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>monolithic  단일체의, 한 덩어리로 뭉친, 단일 결정으로된 <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>병합, 연결, 결합과 같은 용어로 번역됩니다. 배열, 문자열의 기본 연산에서 등장하는 용어이지만 객체를 합친다는 문맥에서는 접합이 적합하다고 판단했습니다 <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n"},{"title":"함수형 프로그래밍의 역사","catalog":true,"date":"2018-03-20T05:13:44.000Z","subtitle":"the rise and fall and rise of functional programming","header-img":"bg.jpg","readingTime":10,"catagories":["개발"],"preview":"컴퓨터 과학의 초기, 대부분의 연구가 실제 컴퓨터에서 이루어지기 전 Alonzo Church와 Alan Turing이라는 두 명의 위대한 컴퓨터 과학자가 있었습니다.  그들은 서로 다른 동시에 동등한 두가지 보편적인 계산 모델을 만들었는데, 두 모델 모두 계산가능한 모든 것을 계산할 수 있었습니다. Alonzo Church는 람다 대수를lambda calculus 만들었습니다.  람다 대수는 함수 합성을 기반으로 하는 계산의 보편적인 모델입니다.  Alan Turing은 튜링 머신로 유명합니다.  튜링 머신은 이론상으로 존재하는 기계이며 테이프의 기호을 조작하는 보편적인 계산 모델입니다.그들은 함께 람다 대수와 튜링 머신이 결국 같은 것임을 보여주기 위해 협력했습니다.람다 대수는 함수 합성에 관한 것입니다.  함수 합성의 관점에서 생각하는 것은 소프트웨어를 작성하는데 있어 매우 직관적이고 표현적인 접근방식입니다.  이번 편에서는 소프트웨어 설계에서 함수 합성이 얼마나 중요한 지 논의 할 것입니다.","_content":"\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  [[원문보기]](https://medium.com/javascript-scene/the-rise-and-fall-and-rise-of-functional-programming-composable-software-c2d91b424c8c)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 제 1 부입니다.  앞으로 계속하여 연재될 것입니다.\n> [_<< Part 1에서 다시 시작_](https://midojeong.github.io/2018/03/16/composing-software-intro/)  _|_  [_다음>_](https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/)\n\n전 6 살 때 가장 친했던 친구와 컴퓨터 게임을 하며 많은 시간을 보냈습니다.  그의 집에는  저를 유혹하는 컴퓨터로 가득 찬 방이 하나 있었고 우리는 많은 시간을 들여 거의 대부분의 게임을 탐험했습니다.  어느날 저는 친구에게 \"게임을 만드려면 어떻게 해야 할까?\"라고 물었습니다.\n\n둘다 게임 개발에 전혀 아는게 없었고 친구의 아버지에게 여쭤보았습니다. 그러자 그분은 높은 선반에 올라가 BASIC으로 쓰여진 게임에 관한 책을 꺼내주셨 습니다.  그 때부터 프로그래밍이라는 기나긴 여정을 시작했습니다. 학교에서 대수학을  배우기도 전에 프로그래밍을 통해 주제를 다 익힐 수 있을 정도였습니다.\n\n## 합성 가능한 소프트웨어의 부상\n\n컴퓨터 과학의 초기, 대부분의 연구가 실제 컴퓨터에서 이루어지기 전 Alonzo Church와 Alan Turing이라는 두 명의 위대한 컴퓨터 과학자가 있었습니다.  그들은 서로 다른 동시에 동등한 두가지 보편적인^universal^ 계산 모델을 만들었는데, 두 모델 모두 계산가능한 모든 것을 계산할 수 있었습니다. \n\nAlonzo Church는 람다 대수를^lambda^ ^calculus^ 만들었습니다.  람다 대수는 함수 합성을 기반으로 하는 계산의 보편적인 모델입니다.  Alan Turing은 튜링 머신로 유명합니다.  튜링 머신은 이론상으로 존재하는 기계이며 테이프의 기호을 조작하는 보편적인 계산 모델입니다.\n\n그들은 함께 람다 대수와 튜링 머신이 결국 같은 것임을 보여주기 위해 협력했습니다.\n\n람다 대수는 함수 합성에 관한 것입니다.  함수 합성의 관점에서 생각하는 것은 소프트웨어를 작성하는데 있어 매우 직관적이고 표현적인 접근방식입니다.  이번 편에서는 소프트웨어 설계에서 함수 합성이 얼마나 중요한 지 논의 할 것입니다.\n\n람다 대수를 특별하게 하는 세 가지 중요한 점이 있습니다 :\n\n1.  함수는 항상 익명입니다.  JavaScript에서  `const sum = (x, y) => x + y`  의 오른쪽은  _익명의_  함수 표현식  `(x, y) => x + y`  입니다.\n2.  람다 대수의 함수는 단일 입력 만 허용합니다.  그들은 단항입니다. 하나 이상의 매개 변수가 필요한 경우 함수는 하나의 입력을 받아 다음 함수를 사용하는 등의 새로운 함수를 반환합니다.  n 항 함수  `(x, y) => x + y`  는  `x => y => x + y`  와 같은 단항 함수로 표현 될 수 있습니다.  다항^n-ary^ 함수에서 단항 함수로의 변환은 currying으로 알려져 있습니다.\n3.  함수는 first class이므로 함수를 다른 함수에 대한 입력으로 사용할 수 있으며 함수는 함수를 반환 할 수 있습니다.\n\n이러한 특성들로 기본 빌딩 블록을 구성하게되면 소프트웨어를 작성하기위한 간단하면서도 표현력있는 어휘가 됩니다.  JavaScript에서 익명 함수 및 currying은 선택사항입니다.  JavaScript는 람다 대수의 중요 특성을 지원하지만 강제하지는 않습니다.\n\n고전적인 함수 합성은 한 함수의 출력을 가져 와서 다른 함수의 입력으로 사용합니다.  예를 들어, 합성 :\n\n```\n  f . g\n```\n\n다음과 같이 구현할 수 있습니다 :\n\n```javascript\ncompose2 = f => g => x => f(g(x))\n```\n\n사용 방법은 다음과 같습니다.\n\n```javascript\ndouble = n => n * 2  \ninc = n => n + 1\n\ncompose2(double)(inc)(3)\n```\n\n`compose2()`  함수의 첫번째 인수로  `double`  함수를 사용하고  두 번째 인수로로 `inc`  함수를 사용합니다. 그리고 마지막으로 인수  `3`  을 적용^apply^합니다.  `compose2()` 함수 서명^function^ ^signature^을 다시 보면,  `f`  는  `double()`  ,  `g`  는  `inc()`  ,  `x`  는  `3`  입니다.`compose2(double)(inc)(3)`  은 실제로는 3 세번의 호출과정을 거칩니다.\n\n1.  첫 번째는  `double`  을 받고 새 함수를 리턴합니다.\n2.  리턴 된 함수는  `inc`  를 받고 새 함수를 리턴합니다.\n3.  다음에 리턴 된 함수는  `3`  취하여  `f(g(x))`를 평가하는데, 이제는  `double(inc(3))`  됩니다.\n4.  `x`  는  `3`으로  평가되고  `inc()`  로 전달됩니다.\n5.  `inc(3)`  은  `4`로  평가됩니다.\n6.  `double(4)`  는  `8` 로 평가됩니다.\n7.  최종적으로 `8`이  리턴됩니다.\n\n소프트웨어가 합성되면 합성 함수 그래프로 나타낼 수 있습니다.  \n\n```\nappend = s1 => s2 => s1 + s2  \nappend('Hello, ')('world!')\n```\n\n위 코드를 시각적으로 표현한 것입니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*LSXnRbKzQ4yhq1fjZjvq6Q.png)\n\n람다 대수는 소프트웨어 설계에 엄청난 영향을 주었고 1980년 이전 컴퓨터 과학분야에서 영향력있는 많은 사람들은 함수를 합성하며 소프트웨어를 작성했습니다.  Lisp은 1958 년에 만들어졌고 람다 대수의 영향을 많이 받았습니다.  오늘날, Lisp은 여전히 ​​널리 쓰이는 두 번째로 오래된 언어입니다.\n\n저는 AutoLISP으로 Lisp을 처음 접했습니다. 이는 CAD 소프트웨어 인 AutoCAD에서 사용하는 스크립트 언어입니다.  AutoCAD는 인기가 높으며, 거의 모든 CAD 응용 프로그램애플리케이션이 AutoLISP를 지원하므로 호환성이 좋습니다. 또한 Lisp은 컴퓨터 과학 커리큘럼에서 인기있는 교육용 언어이기도합니다.\n\n1.  Lisp은 매우 단순해서 하루 만에 기본 문법과 의미를 배울 수 있습니다.\n2.  Lisp은 모두 함수 합성에 관한 것이고, 함수 합성은 어플리케이션을 구조화하는 우아한 방법이다.\n3.  제가 아는 최고의 컴퓨터 과학 교과서는 Lisp 을 사용합니다 :  [컴퓨터 프로그램의 구조와 해석](https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871/ref=as_li_ss_tl?ie=UTF8&linkCode=ll1&tag=eejs-20&linkId=4896ed63eee8657b6379c2acd99dd3f3)  \n\n## 합성 가능한 소프트웨어의 몰락\n\n1970 년에서 1980 년 사이에 소프트웨어 작성 방법이 단순히 합성하는 것에서 벗어나 컴퓨터에게 일련의 명령^Instruction^을 내리는 방식으로 바뀌었습니다.  그리고 객체지향 프로그래밍(OOP)이 등장했습니다.  구성 요소를 캡슐화 하고 메세지를 전달한다는 위대한 아이디어는 대중적인 프로그래밍 언어들에 의해 왜곡되었습니다. 이들은 기능을 재사용하기 위해 상속에 의한 계층 구조와 is-a관계라는 끔찍한 아이디어를 생각해냈습니다. \n\n결국 함수형 프로그래밍은 학계로 밀려났습니다. 괴짜 중의 괴짜 프로그래머들, 아이비 리그의 교수들, 그리고 1990 ~ 2010년대의 **강제 자바 수용 메타**에서 탈출 한 일부 운 좋은 학생들만이 사용하게 되었습니다.\n\n30년의 암흑기 동안 대부분의 사람들에게 소프트웨어를 만드는 것은 마치 악몽과 같았습니다.\n\n## 합성 가능한 소프트웨어의 부상\n\n2010년 경 JavaScript의 사용이 폭발적으로 증가했습니다.  2006년 이전 JavaScript는 웹 브라우저에서 귀여운 애니메이션을 만드는 데 사용되는 장난감 언어로 취급받았지만 사실 강력한 기능이 숨겨져있었습니다.  즉,  람다 대수의 중요한 특징들이 포함되어 있었습니다.  사람들은 \"함수형 프로그래밍\"이라는 새롭고 멋진 무언가에 대해 그림자 속에서 속삭이기 시작했습니다.\n\n2015년, 함수 합성으로 소프트웨어를 개발하려는 아이디어가 다시 인기를 얻었습니다.  JavaScript는 10년 만에 이루어진 첫 번째 주요 업그레이드에서 화살표 함수를 추가하여 함수, currying 및 lambda 표현을 쉽게 읽고 만들 수 있게 했습니다.\n\n함수형 프로그래밍 붐에서 JavaScript의 화살표 함수는 로켓 연료와 같았습니다. 오늘날 널리 쓰이는 응용 프로그램애플리케이션들 중에서 함수형 프로그래밍 기술이 사용되지 않은 경우는 거의 없습니다. \n\n합성은 소프트웨어의 동작을 명료하게 모델링하는 간단하고 우아한 표현 방법입니다.  작은 소프트웨어 구성 요소들을 합성하여 더 큰 구성 요소와 기능을 만드는 프로세스는 조직화, 이해, 디버그, 확장, 테스트 및 유지 관리가 더 쉬운 소프트웨어를 만듭니다.\n\n다음 글 부터는 여러 예제들을 함께 실습해 볼 것입니다.  어린 시절 우리는 사물들을 가지고 놀며 학습했습니다.  발견의 즐거움을 재발견하십시오.  마술을 부려 볼 시간입니다.\n\n[다음: \"왜 JavaScript로 함수형 프로그래밍을 배우는가? >\"](https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/)\n\n\n","source":"_posts/the-rise-and-fall-and-rise-of-functional-programming-composable-software.md","raw":"---\ntitle: \"함수형 프로그래밍의 역사\"\ncatalog: true\ndate: 2018-03-20 14:13:44\nsubtitle: \"the rise and fall and rise of functional programming\"\nheader-img: \"bg.jpg\"\nreadingTime: 10\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 컴퓨터 과학의 초기, 대부분의 연구가 실제 컴퓨터에서 이루어지기 전 Alonzo Church와 Alan Turing이라는 두 명의 위대한 컴퓨터 과학자가 있었습니다.  그들은 서로 다른 동시에 동등한 두가지 보편적인 계산 모델을 만들었는데, 두 모델 모두 계산가능한 모든 것을 계산할 수 있었습니다. Alonzo Church는 람다 대수를lambda calculus 만들었습니다.  람다 대수는 함수 합성을 기반으로 하는 계산의 보편적인 모델입니다.  Alan Turing은 튜링 머신로 유명합니다.  튜링 머신은 이론상으로 존재하는 기계이며 테이프의 기호을 조작하는 보편적인 계산 모델입니다.그들은 함께 람다 대수와 튜링 머신이 결국 같은 것임을 보여주기 위해 협력했습니다.람다 대수는 함수 합성에 관한 것입니다.  함수 합성의 관점에서 생각하는 것은 소프트웨어를 작성하는데 있어 매우 직관적이고 표현적인 접근방식입니다.  이번 편에서는 소프트웨어 설계에서 함수 합성이 얼마나 중요한 지 논의 할 것입니다.\n---\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  [[원문보기]](https://medium.com/javascript-scene/the-rise-and-fall-and-rise-of-functional-programming-composable-software-c2d91b424c8c)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 제 1 부입니다.  앞으로 계속하여 연재될 것입니다.\n> [_<< Part 1에서 다시 시작_](https://midojeong.github.io/2018/03/16/composing-software-intro/)  _|_  [_다음>_](https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/)\n\n전 6 살 때 가장 친했던 친구와 컴퓨터 게임을 하며 많은 시간을 보냈습니다.  그의 집에는  저를 유혹하는 컴퓨터로 가득 찬 방이 하나 있었고 우리는 많은 시간을 들여 거의 대부분의 게임을 탐험했습니다.  어느날 저는 친구에게 \"게임을 만드려면 어떻게 해야 할까?\"라고 물었습니다.\n\n둘다 게임 개발에 전혀 아는게 없었고 친구의 아버지에게 여쭤보았습니다. 그러자 그분은 높은 선반에 올라가 BASIC으로 쓰여진 게임에 관한 책을 꺼내주셨 습니다.  그 때부터 프로그래밍이라는 기나긴 여정을 시작했습니다. 학교에서 대수학을  배우기도 전에 프로그래밍을 통해 주제를 다 익힐 수 있을 정도였습니다.\n\n## 합성 가능한 소프트웨어의 부상\n\n컴퓨터 과학의 초기, 대부분의 연구가 실제 컴퓨터에서 이루어지기 전 Alonzo Church와 Alan Turing이라는 두 명의 위대한 컴퓨터 과학자가 있었습니다.  그들은 서로 다른 동시에 동등한 두가지 보편적인^universal^ 계산 모델을 만들었는데, 두 모델 모두 계산가능한 모든 것을 계산할 수 있었습니다. \n\nAlonzo Church는 람다 대수를^lambda^ ^calculus^ 만들었습니다.  람다 대수는 함수 합성을 기반으로 하는 계산의 보편적인 모델입니다.  Alan Turing은 튜링 머신로 유명합니다.  튜링 머신은 이론상으로 존재하는 기계이며 테이프의 기호을 조작하는 보편적인 계산 모델입니다.\n\n그들은 함께 람다 대수와 튜링 머신이 결국 같은 것임을 보여주기 위해 협력했습니다.\n\n람다 대수는 함수 합성에 관한 것입니다.  함수 합성의 관점에서 생각하는 것은 소프트웨어를 작성하는데 있어 매우 직관적이고 표현적인 접근방식입니다.  이번 편에서는 소프트웨어 설계에서 함수 합성이 얼마나 중요한 지 논의 할 것입니다.\n\n람다 대수를 특별하게 하는 세 가지 중요한 점이 있습니다 :\n\n1.  함수는 항상 익명입니다.  JavaScript에서  `const sum = (x, y) => x + y`  의 오른쪽은  _익명의_  함수 표현식  `(x, y) => x + y`  입니다.\n2.  람다 대수의 함수는 단일 입력 만 허용합니다.  그들은 단항입니다. 하나 이상의 매개 변수가 필요한 경우 함수는 하나의 입력을 받아 다음 함수를 사용하는 등의 새로운 함수를 반환합니다.  n 항 함수  `(x, y) => x + y`  는  `x => y => x + y`  와 같은 단항 함수로 표현 될 수 있습니다.  다항^n-ary^ 함수에서 단항 함수로의 변환은 currying으로 알려져 있습니다.\n3.  함수는 first class이므로 함수를 다른 함수에 대한 입력으로 사용할 수 있으며 함수는 함수를 반환 할 수 있습니다.\n\n이러한 특성들로 기본 빌딩 블록을 구성하게되면 소프트웨어를 작성하기위한 간단하면서도 표현력있는 어휘가 됩니다.  JavaScript에서 익명 함수 및 currying은 선택사항입니다.  JavaScript는 람다 대수의 중요 특성을 지원하지만 강제하지는 않습니다.\n\n고전적인 함수 합성은 한 함수의 출력을 가져 와서 다른 함수의 입력으로 사용합니다.  예를 들어, 합성 :\n\n```\n  f . g\n```\n\n다음과 같이 구현할 수 있습니다 :\n\n```javascript\ncompose2 = f => g => x => f(g(x))\n```\n\n사용 방법은 다음과 같습니다.\n\n```javascript\ndouble = n => n * 2  \ninc = n => n + 1\n\ncompose2(double)(inc)(3)\n```\n\n`compose2()`  함수의 첫번째 인수로  `double`  함수를 사용하고  두 번째 인수로로 `inc`  함수를 사용합니다. 그리고 마지막으로 인수  `3`  을 적용^apply^합니다.  `compose2()` 함수 서명^function^ ^signature^을 다시 보면,  `f`  는  `double()`  ,  `g`  는  `inc()`  ,  `x`  는  `3`  입니다.`compose2(double)(inc)(3)`  은 실제로는 3 세번의 호출과정을 거칩니다.\n\n1.  첫 번째는  `double`  을 받고 새 함수를 리턴합니다.\n2.  리턴 된 함수는  `inc`  를 받고 새 함수를 리턴합니다.\n3.  다음에 리턴 된 함수는  `3`  취하여  `f(g(x))`를 평가하는데, 이제는  `double(inc(3))`  됩니다.\n4.  `x`  는  `3`으로  평가되고  `inc()`  로 전달됩니다.\n5.  `inc(3)`  은  `4`로  평가됩니다.\n6.  `double(4)`  는  `8` 로 평가됩니다.\n7.  최종적으로 `8`이  리턴됩니다.\n\n소프트웨어가 합성되면 합성 함수 그래프로 나타낼 수 있습니다.  \n\n```\nappend = s1 => s2 => s1 + s2  \nappend('Hello, ')('world!')\n```\n\n위 코드를 시각적으로 표현한 것입니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*LSXnRbKzQ4yhq1fjZjvq6Q.png)\n\n람다 대수는 소프트웨어 설계에 엄청난 영향을 주었고 1980년 이전 컴퓨터 과학분야에서 영향력있는 많은 사람들은 함수를 합성하며 소프트웨어를 작성했습니다.  Lisp은 1958 년에 만들어졌고 람다 대수의 영향을 많이 받았습니다.  오늘날, Lisp은 여전히 ​​널리 쓰이는 두 번째로 오래된 언어입니다.\n\n저는 AutoLISP으로 Lisp을 처음 접했습니다. 이는 CAD 소프트웨어 인 AutoCAD에서 사용하는 스크립트 언어입니다.  AutoCAD는 인기가 높으며, 거의 모든 CAD 응용 프로그램애플리케이션이 AutoLISP를 지원하므로 호환성이 좋습니다. 또한 Lisp은 컴퓨터 과학 커리큘럼에서 인기있는 교육용 언어이기도합니다.\n\n1.  Lisp은 매우 단순해서 하루 만에 기본 문법과 의미를 배울 수 있습니다.\n2.  Lisp은 모두 함수 합성에 관한 것이고, 함수 합성은 어플리케이션을 구조화하는 우아한 방법이다.\n3.  제가 아는 최고의 컴퓨터 과학 교과서는 Lisp 을 사용합니다 :  [컴퓨터 프로그램의 구조와 해석](https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871/ref=as_li_ss_tl?ie=UTF8&linkCode=ll1&tag=eejs-20&linkId=4896ed63eee8657b6379c2acd99dd3f3)  \n\n## 합성 가능한 소프트웨어의 몰락\n\n1970 년에서 1980 년 사이에 소프트웨어 작성 방법이 단순히 합성하는 것에서 벗어나 컴퓨터에게 일련의 명령^Instruction^을 내리는 방식으로 바뀌었습니다.  그리고 객체지향 프로그래밍(OOP)이 등장했습니다.  구성 요소를 캡슐화 하고 메세지를 전달한다는 위대한 아이디어는 대중적인 프로그래밍 언어들에 의해 왜곡되었습니다. 이들은 기능을 재사용하기 위해 상속에 의한 계층 구조와 is-a관계라는 끔찍한 아이디어를 생각해냈습니다. \n\n결국 함수형 프로그래밍은 학계로 밀려났습니다. 괴짜 중의 괴짜 프로그래머들, 아이비 리그의 교수들, 그리고 1990 ~ 2010년대의 **강제 자바 수용 메타**에서 탈출 한 일부 운 좋은 학생들만이 사용하게 되었습니다.\n\n30년의 암흑기 동안 대부분의 사람들에게 소프트웨어를 만드는 것은 마치 악몽과 같았습니다.\n\n## 합성 가능한 소프트웨어의 부상\n\n2010년 경 JavaScript의 사용이 폭발적으로 증가했습니다.  2006년 이전 JavaScript는 웹 브라우저에서 귀여운 애니메이션을 만드는 데 사용되는 장난감 언어로 취급받았지만 사실 강력한 기능이 숨겨져있었습니다.  즉,  람다 대수의 중요한 특징들이 포함되어 있었습니다.  사람들은 \"함수형 프로그래밍\"이라는 새롭고 멋진 무언가에 대해 그림자 속에서 속삭이기 시작했습니다.\n\n2015년, 함수 합성으로 소프트웨어를 개발하려는 아이디어가 다시 인기를 얻었습니다.  JavaScript는 10년 만에 이루어진 첫 번째 주요 업그레이드에서 화살표 함수를 추가하여 함수, currying 및 lambda 표현을 쉽게 읽고 만들 수 있게 했습니다.\n\n함수형 프로그래밍 붐에서 JavaScript의 화살표 함수는 로켓 연료와 같았습니다. 오늘날 널리 쓰이는 응용 프로그램애플리케이션들 중에서 함수형 프로그래밍 기술이 사용되지 않은 경우는 거의 없습니다. \n\n합성은 소프트웨어의 동작을 명료하게 모델링하는 간단하고 우아한 표현 방법입니다.  작은 소프트웨어 구성 요소들을 합성하여 더 큰 구성 요소와 기능을 만드는 프로세스는 조직화, 이해, 디버그, 확장, 테스트 및 유지 관리가 더 쉬운 소프트웨어를 만듭니다.\n\n다음 글 부터는 여러 예제들을 함께 실습해 볼 것입니다.  어린 시절 우리는 사물들을 가지고 놀며 학습했습니다.  발견의 즐거움을 재발견하십시오.  마술을 부려 볼 시간입니다.\n\n[다음: \"왜 JavaScript로 함수형 프로그래밍을 배우는가? >\"](https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/)\n\n\n","slug":"the-rise-and-fall-and-rise-of-functional-programming-composable-software","published":1,"updated":"2018-04-06T10:29:46.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83ep000wifp6zbood6jy","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  <a href=\"https://medium.com/javascript-scene/the-rise-and-fall-and-rise-of-functional-programming-composable-software-c2d91b424c8c\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 제 1 부입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\"><em>&lt;&lt; Part 1에서 다시 시작</em></a>  <em>|</em>  <a href=\"https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/\"><em>다음&gt;</em></a></p>\n</blockquote>\n<p>전 6 살 때 가장 친했던 친구와 컴퓨터 게임을 하며 많은 시간을 보냈습니다.  그의 집에는  저를 유혹하는 컴퓨터로 가득 찬 방이 하나 있었고 우리는 많은 시간을 들여 거의 대부분의 게임을 탐험했습니다.  어느날 저는 친구에게 &quot;게임을 만드려면 어떻게 해야 할까?&quot;라고 물었습니다.</p>\n<p>둘다 게임 개발에 전혀 아는게 없었고 친구의 아버지에게 여쭤보았습니다. 그러자 그분은 높은 선반에 올라가 BASIC으로 쓰여진 게임에 관한 책을 꺼내주셨 습니다.  그 때부터 프로그래밍이라는 기나긴 여정을 시작했습니다. 학교에서 대수학을  배우기도 전에 프로그래밍을 통해 주제를 다 익힐 수 있을 정도였습니다.</p>\n<h2 id=\"합성-가능한-소프트웨어의-부상\">합성 가능한 소프트웨어의 부상</h2>\n<p>컴퓨터 과학의 초기, 대부분의 연구가 실제 컴퓨터에서 이루어지기 전 Alonzo Church와 Alan Turing이라는 두 명의 위대한 컴퓨터 과학자가 있었습니다.  그들은 서로 다른 동시에 동등한 두가지 보편적인<sup>universal</sup> 계산 모델을 만들었는데, 두 모델 모두 계산가능한 모든 것을 계산할 수 있었습니다.</p>\n<p>Alonzo Church는 람다 대수를<sup>lambda</sup> <sup>calculus</sup> 만들었습니다.  람다 대수는 함수 합성을 기반으로 하는 계산의 보편적인 모델입니다.  Alan Turing은 튜링 머신로 유명합니다.  튜링 머신은 이론상으로 존재하는 기계이며 테이프의 기호을 조작하는 보편적인 계산 모델입니다.</p>\n<p>그들은 함께 람다 대수와 튜링 머신이 결국 같은 것임을 보여주기 위해 협력했습니다.</p>\n<p>람다 대수는 함수 합성에 관한 것입니다.  함수 합성의 관점에서 생각하는 것은 소프트웨어를 작성하는데 있어 매우 직관적이고 표현적인 접근방식입니다.  이번 편에서는 소프트웨어 설계에서 함수 합성이 얼마나 중요한 지 논의 할 것입니다.</p>\n<p>람다 대수를 특별하게 하는 세 가지 중요한 점이 있습니다 :</p>\n<ol>\n<li>함수는 항상 익명입니다.  JavaScript에서  <code>const sum = (x, y) =&gt; x + y</code>  의 오른쪽은  <em>익명의</em>  함수 표현식  <code>(x, y) =&gt; x + y</code>  입니다.</li>\n<li>람다 대수의 함수는 단일 입력 만 허용합니다.  그들은 단항입니다. 하나 이상의 매개 변수가 필요한 경우 함수는 하나의 입력을 받아 다음 함수를 사용하는 등의 새로운 함수를 반환합니다.  n 항 함수  <code>(x, y) =&gt; x + y</code>  는  <code>x =&gt; y =&gt; x + y</code>  와 같은 단항 함수로 표현 될 수 있습니다.  다항<sup>n-ary</sup> 함수에서 단항 함수로의 변환은 currying으로 알려져 있습니다.</li>\n<li>함수는 first class이므로 함수를 다른 함수에 대한 입력으로 사용할 수 있으며 함수는 함수를 반환 할 수 있습니다.</li>\n</ol>\n<p>이러한 특성들로 기본 빌딩 블록을 구성하게되면 소프트웨어를 작성하기위한 간단하면서도 표현력있는 어휘가 됩니다.  JavaScript에서 익명 함수 및 currying은 선택사항입니다.  JavaScript는 람다 대수의 중요 특성을 지원하지만 강제하지는 않습니다.</p>\n<p>고전적인 함수 합성은 한 함수의 출력을 가져 와서 다른 함수의 입력으로 사용합니다.  예를 들어, 합성 :</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">f</span> . g</span><br></pre></td></tr></table></figure>\n<p>다음과 같이 구현할 수 있습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compose2 = <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> g =&gt; <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> f(g(x))</span><br></pre></td></tr></table></figure>\n<p>사용 방법은 다음과 같습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>  </span><br><span class=\"line\">inc = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">compose2(double)(inc)(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p><code>compose2()</code>  함수의 첫번째 인수로  <code>double</code>  함수를 사용하고  두 번째 인수로로 <code>inc</code>  함수를 사용합니다. 그리고 마지막으로 인수  <code>3</code>  을 적용<sup>apply</sup>합니다.  <code>compose2()</code> 함수 서명<sup>function</sup> <sup>signature</sup>을 다시 보면,  <code>f</code>  는  <code>double()</code>  ,  <code>g</code>  는  <code>inc()</code>  ,  <code>x</code>  는  <code>3</code>  입니다.<code>compose2(double)(inc)(3)</code>  은 실제로는 3 세번의 호출과정을 거칩니다.</p>\n<ol>\n<li>첫 번째는  <code>double</code>  을 받고 새 함수를 리턴합니다.</li>\n<li>리턴 된 함수는  <code>inc</code>  를 받고 새 함수를 리턴합니다.</li>\n<li>다음에 리턴 된 함수는  <code>3</code>  취하여  <code>f(g(x))</code>를 평가하는데, 이제는  <code>double(inc(3))</code>  됩니다.</li>\n<li><code>x</code>  는  <code>3</code>으로  평가되고  <code>inc()</code>  로 전달됩니다.</li>\n<li><code>inc(3)</code>  은  <code>4</code>로  평가됩니다.</li>\n<li><code>double(4)</code>  는  <code>8</code> 로 평가됩니다.</li>\n<li>최종적으로 <code>8</code>이  리턴됩니다.</li>\n</ol>\n<p>소프트웨어가 합성되면 합성 함수 그래프로 나타낼 수 있습니다.</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">append = s1 =&gt; s2 =&gt; s1 + s2  </span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">append</span><span class=\"params\">(<span class=\"string\">'Hello, '</span>)</span><span class=\"params\">(<span class=\"string\">'world!'</span>)</span></span></span><br></pre></td></tr></table></figure>\n<p>위 코드를 시각적으로 표현한 것입니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*LSXnRbKzQ4yhq1fjZjvq6Q.png\" alt=\"\"></p>\n<p>람다 대수는 소프트웨어 설계에 엄청난 영향을 주었고 1980년 이전 컴퓨터 과학분야에서 영향력있는 많은 사람들은 함수를 합성하며 소프트웨어를 작성했습니다.  Lisp은 1958 년에 만들어졌고 람다 대수의 영향을 많이 받았습니다.  오늘날, Lisp은 여전히 ​​널리 쓰이는 두 번째로 오래된 언어입니다.</p>\n<p>저는 AutoLISP으로 Lisp을 처음 접했습니다. 이는 CAD 소프트웨어 인 AutoCAD에서 사용하는 스크립트 언어입니다.  AutoCAD는 인기가 높으며, 거의 모든 CAD 응용 프로그램애플리케이션이 AutoLISP를 지원하므로 호환성이 좋습니다. 또한 Lisp은 컴퓨터 과학 커리큘럼에서 인기있는 교육용 언어이기도합니다.</p>\n<ol>\n<li>Lisp은 매우 단순해서 하루 만에 기본 문법과 의미를 배울 수 있습니다.</li>\n<li>Lisp은 모두 함수 합성에 관한 것이고, 함수 합성은 어플리케이션을 구조화하는 우아한 방법이다.</li>\n<li>제가 아는 최고의 컴퓨터 과학 교과서는 Lisp 을 사용합니다 :  <a href=\"https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=4896ed63eee8657b6379c2acd99dd3f3\" target=\"_blank\" rel=\"noopener\">컴퓨터 프로그램의 구조와 해석</a></li>\n</ol>\n<h2 id=\"합성-가능한-소프트웨어의-몰락\">합성 가능한 소프트웨어의 몰락</h2>\n<p>1970 년에서 1980 년 사이에 소프트웨어 작성 방법이 단순히 합성하는 것에서 벗어나 컴퓨터에게 일련의 명령<sup>Instruction</sup>을 내리는 방식으로 바뀌었습니다.  그리고 객체지향 프로그래밍(OOP)이 등장했습니다.  구성 요소를 캡슐화 하고 메세지를 전달한다는 위대한 아이디어는 대중적인 프로그래밍 언어들에 의해 왜곡되었습니다. 이들은 기능을 재사용하기 위해 상속에 의한 계층 구조와 is-a관계라는 끔찍한 아이디어를 생각해냈습니다.</p>\n<p>결국 함수형 프로그래밍은 학계로 밀려났습니다. 괴짜 중의 괴짜 프로그래머들, 아이비 리그의 교수들, 그리고 1990 ~ 2010년대의 <strong>강제 자바 수용 메타</strong>에서 탈출 한 일부 운 좋은 학생들만이 사용하게 되었습니다.</p>\n<p>30년의 암흑기 동안 대부분의 사람들에게 소프트웨어를 만드는 것은 마치 악몽과 같았습니다.</p>\n<h2 id=\"합성-가능한-소프트웨어의-부상\">합성 가능한 소프트웨어의 부상</h2>\n<p>2010년 경 JavaScript의 사용이 폭발적으로 증가했습니다.  2006년 이전 JavaScript는 웹 브라우저에서 귀여운 애니메이션을 만드는 데 사용되는 장난감 언어로 취급받았지만 사실 강력한 기능이 숨겨져있었습니다.  즉,  람다 대수의 중요한 특징들이 포함되어 있었습니다.  사람들은 &quot;함수형 프로그래밍&quot;이라는 새롭고 멋진 무언가에 대해 그림자 속에서 속삭이기 시작했습니다.</p>\n<p>2015년, 함수 합성으로 소프트웨어를 개발하려는 아이디어가 다시 인기를 얻었습니다.  JavaScript는 10년 만에 이루어진 첫 번째 주요 업그레이드에서 화살표 함수를 추가하여 함수, currying 및 lambda 표현을 쉽게 읽고 만들 수 있게 했습니다.</p>\n<p>함수형 프로그래밍 붐에서 JavaScript의 화살표 함수는 로켓 연료와 같았습니다. 오늘날 널리 쓰이는 응용 프로그램애플리케이션들 중에서 함수형 프로그래밍 기술이 사용되지 않은 경우는 거의 없습니다.</p>\n<p>합성은 소프트웨어의 동작을 명료하게 모델링하는 간단하고 우아한 표현 방법입니다.  작은 소프트웨어 구성 요소들을 합성하여 더 큰 구성 요소와 기능을 만드는 프로세스는 조직화, 이해, 디버그, 확장, 테스트 및 유지 관리가 더 쉬운 소프트웨어를 만듭니다.</p>\n<p>다음 글 부터는 여러 예제들을 함께 실습해 볼 것입니다.  어린 시절 우리는 사물들을 가지고 놀며 학습했습니다.  발견의 즐거움을 재발견하십시오.  마술을 부려 볼 시간입니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/\">다음: “왜 JavaScript로 함수형 프로그래밍을 배우는가? &gt;”</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  <a href=\"https://medium.com/javascript-scene/the-rise-and-fall-and-rise-of-functional-programming-composable-software-c2d91b424c8c\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"></p>\n<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 제 1 부입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\"><em>&lt;&lt; Part 1에서 다시 시작</em></a>  <em>|</em>  <a href=\"https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/\"><em>다음&gt;</em></a></p>\n</blockquote>\n<p>전 6 살 때 가장 친했던 친구와 컴퓨터 게임을 하며 많은 시간을 보냈습니다.  그의 집에는  저를 유혹하는 컴퓨터로 가득 찬 방이 하나 있었고 우리는 많은 시간을 들여 거의 대부분의 게임을 탐험했습니다.  어느날 저는 친구에게 &quot;게임을 만드려면 어떻게 해야 할까?&quot;라고 물었습니다.</p>\n<p>둘다 게임 개발에 전혀 아는게 없었고 친구의 아버지에게 여쭤보았습니다. 그러자 그분은 높은 선반에 올라가 BASIC으로 쓰여진 게임에 관한 책을 꺼내주셨 습니다.  그 때부터 프로그래밍이라는 기나긴 여정을 시작했습니다. 학교에서 대수학을  배우기도 전에 프로그래밍을 통해 주제를 다 익힐 수 있을 정도였습니다.</p>\n<h2>합성 가능한 소프트웨어의 부상</h2>\n<p>컴퓨터 과학의 초기, 대부분의 연구가 실제 컴퓨터에서 이루어지기 전 Alonzo Church와 Alan Turing이라는 두 명의 위대한 컴퓨터 과학자가 있었습니다.  그들은 서로 다른 동시에 동등한 두가지 보편적인<sup>universal</sup> 계산 모델을 만들었는데, 두 모델 모두 계산가능한 모든 것을 계산할 수 있었습니다.</p>\n<p>Alonzo Church는 람다 대수를<sup>lambda</sup> <sup>calculus</sup> 만들었습니다.  람다 대수는 함수 합성을 기반으로 하는 계산의 보편적인 모델입니다.  Alan Turing은 튜링 머신로 유명합니다.  튜링 머신은 이론상으로 존재하는 기계이며 테이프의 기호을 조작하는 보편적인 계산 모델입니다.</p>\n<p>그들은 함께 람다 대수와 튜링 머신이 결국 같은 것임을 보여주기 위해 협력했습니다.</p>\n<p>람다 대수는 함수 합성에 관한 것입니다.  함수 합성의 관점에서 생각하는 것은 소프트웨어를 작성하는데 있어 매우 직관적이고 표현적인 접근방식입니다.  이번 편에서는 소프트웨어 설계에서 함수 합성이 얼마나 중요한 지 논의 할 것입니다.</p>\n<p>람다 대수를 특별하게 하는 세 가지 중요한 점이 있습니다 :</p>\n<ol>\n<li>함수는 항상 익명입니다.  JavaScript에서  <code>const sum = (x, y) =&gt; x + y</code>  의 오른쪽은  <em>익명의</em>  함수 표현식  <code>(x, y) =&gt; x + y</code>  입니다.</li>\n<li>람다 대수의 함수는 단일 입력 만 허용합니다.  그들은 단항입니다. 하나 이상의 매개 변수가 필요한 경우 함수는 하나의 입력을 받아 다음 함수를 사용하는 등의 새로운 함수를 반환합니다.  n 항 함수  <code>(x, y) =&gt; x + y</code>  는  <code>x =&gt; y =&gt; x + y</code>  와 같은 단항 함수로 표현 될 수 있습니다.  다항<sup>n-ary</sup> 함수에서 단항 함수로의 변환은 currying으로 알려져 있습니다.</li>\n<li>함수는 first class이므로 함수를 다른 함수에 대한 입력으로 사용할 수 있으며 함수는 함수를 반환 할 수 있습니다.</li>\n</ol>\n<p>이러한 특성들로 기본 빌딩 블록을 구성하게되면 소프트웨어를 작성하기위한 간단하면서도 표현력있는 어휘가 됩니다.  JavaScript에서 익명 함수 및 currying은 선택사항입니다.  JavaScript는 람다 대수의 중요 특성을 지원하지만 강제하지는 않습니다.</p>\n<p>고전적인 함수 합성은 한 함수의 출력을 가져 와서 다른 함수의 입력으로 사용합니다.  예를 들어, 합성 :</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">f</span> . g</span><br></pre></td></tr></table></figure>\n<p>다음과 같이 구현할 수 있습니다 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compose2 = <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> g =&gt; <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> f(g(x))</span><br></pre></td></tr></table></figure>\n<p>사용 방법은 다음과 같습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>  </span><br><span class=\"line\">inc = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">compose2(double)(inc)(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p><code>compose2()</code>  함수의 첫번째 인수로  <code>double</code>  함수를 사용하고  두 번째 인수로로 <code>inc</code>  함수를 사용합니다. 그리고 마지막으로 인수  <code>3</code>  을 적용<sup>apply</sup>합니다.  <code>compose2()</code> 함수 서명<sup>function</sup> <sup>signature</sup>을 다시 보면,  <code>f</code>  는  <code>double()</code>  ,  <code>g</code>  는  <code>inc()</code>  ,  <code>x</code>  는  <code>3</code>  입니다.<code>compose2(double)(inc)(3)</code>  은 실제로는 3 세번의 호출과정을 거칩니다.</p>\n<ol>\n<li>첫 번째는  <code>double</code>  을 받고 새 함수를 리턴합니다.</li>\n<li>리턴 된 함수는  <code>inc</code>  를 받고 새 함수를 리턴합니다.</li>\n<li>다음에 리턴 된 함수는  <code>3</code>  취하여  <code>f(g(x))</code>를 평가하는데, 이제는  <code>double(inc(3))</code>  됩니다.</li>\n<li><code>x</code>  는  <code>3</code>으로  평가되고  <code>inc()</code>  로 전달됩니다.</li>\n<li><code>inc(3)</code>  은  <code>4</code>로  평가됩니다.</li>\n<li><code>double(4)</code>  는  <code>8</code> 로 평가됩니다.</li>\n<li>최종적으로 <code>8</code>이  리턴됩니다.</li>\n</ol>\n<p>소프트웨어가 합성되면 합성 함수 그래프로 나타낼 수 있습니다.</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">append = s1 =&gt; s2 =&gt; s1 + s2  </span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">append</span><span class=\"params\">(<span class=\"string\">'Hello, '</span>)</span><span class=\"params\">(<span class=\"string\">'world!'</span>)</span></span></span><br></pre></td></tr></table></figure>\n<p>위 코드를 시각적으로 표현한 것입니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*LSXnRbKzQ4yhq1fjZjvq6Q.png\" alt=\"\"></p>\n<p>람다 대수는 소프트웨어 설계에 엄청난 영향을 주었고 1980년 이전 컴퓨터 과학분야에서 영향력있는 많은 사람들은 함수를 합성하며 소프트웨어를 작성했습니다.  Lisp은 1958 년에 만들어졌고 람다 대수의 영향을 많이 받았습니다.  오늘날, Lisp은 여전히 ​​널리 쓰이는 두 번째로 오래된 언어입니다.</p>\n<p>저는 AutoLISP으로 Lisp을 처음 접했습니다. 이는 CAD 소프트웨어 인 AutoCAD에서 사용하는 스크립트 언어입니다.  AutoCAD는 인기가 높으며, 거의 모든 CAD 응용 프로그램애플리케이션이 AutoLISP를 지원하므로 호환성이 좋습니다. 또한 Lisp은 컴퓨터 과학 커리큘럼에서 인기있는 교육용 언어이기도합니다.</p>\n<ol>\n<li>Lisp은 매우 단순해서 하루 만에 기본 문법과 의미를 배울 수 있습니다.</li>\n<li>Lisp은 모두 함수 합성에 관한 것이고, 함수 합성은 어플리케이션을 구조화하는 우아한 방법이다.</li>\n<li>제가 아는 최고의 컴퓨터 과학 교과서는 Lisp 을 사용합니다 :  <a href=\"https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=4896ed63eee8657b6379c2acd99dd3f3\" target=\"_blank\" rel=\"noopener\">컴퓨터 프로그램의 구조와 해석</a></li>\n</ol>\n<h2>합성 가능한 소프트웨어의 몰락</h2>\n<p>1970 년에서 1980 년 사이에 소프트웨어 작성 방법이 단순히 합성하는 것에서 벗어나 컴퓨터에게 일련의 명령<sup>Instruction</sup>을 내리는 방식으로 바뀌었습니다.  그리고 객체지향 프로그래밍(OOP)이 등장했습니다.  구성 요소를 캡슐화 하고 메세지를 전달한다는 위대한 아이디어는 대중적인 프로그래밍 언어들에 의해 왜곡되었습니다. 이들은 기능을 재사용하기 위해 상속에 의한 계층 구조와 is-a관계라는 끔찍한 아이디어를 생각해냈습니다.</p>\n<p>결국 함수형 프로그래밍은 학계로 밀려났습니다. 괴짜 중의 괴짜 프로그래머들, 아이비 리그의 교수들, 그리고 1990 ~ 2010년대의 <strong>강제 자바 수용 메타</strong>에서 탈출 한 일부 운 좋은 학생들만이 사용하게 되었습니다.</p>\n<p>30년의 암흑기 동안 대부분의 사람들에게 소프트웨어를 만드는 것은 마치 악몽과 같았습니다.</p>\n<h2>합성 가능한 소프트웨어의 부상</h2>\n<p>2010년 경 JavaScript의 사용이 폭발적으로 증가했습니다.  2006년 이전 JavaScript는 웹 브라우저에서 귀여운 애니메이션을 만드는 데 사용되는 장난감 언어로 취급받았지만 사실 강력한 기능이 숨겨져있었습니다.  즉,  람다 대수의 중요한 특징들이 포함되어 있었습니다.  사람들은 &quot;함수형 프로그래밍&quot;이라는 새롭고 멋진 무언가에 대해 그림자 속에서 속삭이기 시작했습니다.</p>\n<p>2015년, 함수 합성으로 소프트웨어를 개발하려는 아이디어가 다시 인기를 얻었습니다.  JavaScript는 10년 만에 이루어진 첫 번째 주요 업그레이드에서 화살표 함수를 추가하여 함수, currying 및 lambda 표현을 쉽게 읽고 만들 수 있게 했습니다.</p>\n<p>함수형 프로그래밍 붐에서 JavaScript의 화살표 함수는 로켓 연료와 같았습니다. 오늘날 널리 쓰이는 응용 프로그램애플리케이션들 중에서 함수형 프로그래밍 기술이 사용되지 않은 경우는 거의 없습니다.</p>\n<p>합성은 소프트웨어의 동작을 명료하게 모델링하는 간단하고 우아한 표현 방법입니다.  작은 소프트웨어 구성 요소들을 합성하여 더 큰 구성 요소와 기능을 만드는 프로세스는 조직화, 이해, 디버그, 확장, 테스트 및 유지 관리가 더 쉬운 소프트웨어를 만듭니다.</p>\n<p>다음 글 부터는 여러 예제들을 함께 실습해 볼 것입니다.  어린 시절 우리는 사물들을 가지고 놀며 학습했습니다.  발견의 즐거움을 재발견하십시오.  마술을 부려 볼 시간입니다.</p>\n<p><a href=\"https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/\">다음: “왜 JavaScript로 함수형 프로그래밍을 배우는가? &gt;”</a></p>\n"},{"title":"왜 JavaScript로 함수형 프로그래밍을 배우는가?","catalog":true,"date":"2018-03-24T20:46:23.000Z","subtitle":"Why learn functional programming in JavaScript?","header-img":"bg.jpg","readingTime":11,"catagories":["개발"],"preview":"그동안 JavaScript에 대해 가지고 있었던 생각들은 모두 잊어 버리고 초심자의 마음으로 이 글을 읽어주세요. JavaScript를 사용해 본 적 없는 이들을 위해 JavaScript의 기본 사항을 처음부터 다룰 것입니다.  당신이 초보자라면 행운입니다.  드디어 ES6 및 함수형 프로그래밍을 처음부터 다루는 글이 나왔습니다!  모든 새로운 개념에 대해 하나씩 알아볼 예정입니다. 그러나 너무 모든 것을 다 이해하려고 노력하지는 않아도 됩니다. JavaScript나 순수 함수 언어에 익숙한 노련한 개발자라면 어쩌면 JavaScript가 함수 프로그래밍을 탐구하기위한 재미있는 선택이라고 생각할 수도 있습니다.  그러한 생각을 잠깐 옆으로 두고 열린 마음으로 글을 읽어주세요.  JavaScript 프로그래밍에 또 다른 레벨이 있다는 것을 알 수 있습니다.  당신이 결코 알지 못했던 것이 있습니다.","_content":"\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  [[원문보기]](https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [_<이전_](https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/)  _|_  [_<< Part 1에서 다시 시작_](https://midojeong.github.io/2018/03/16/composing-software-intro/)  _|_  [_다음>_](https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/)\n\n그동안 JavaScript에 대해 가지고 있었던 생각들은 모두 잊어 버리고 초심자의 마음으로 이 글을 읽어주세요. JavaScript를 사용해 본 적 없는 이들을 위해 JavaScript의 기본 사항을 처음부터 다룰 것입니다.  당신이 초보자라면 행운입니다.  드디어 ES6 및 함수형 프로그래밍을 처음부터 다루는 글이 나왔습니다!  모든 새로운 개념에 대해 하나씩 알아볼 예정입니다. 그러나 너무 모든 것을 다 이해하려고 노력하지는 않아도 됩니다.\n\nJavaScript나 순수 함수 언어에 익숙한 노련한 개발자라면 어쩌면 JavaScript가 함수 프로그래밍을 탐구하기위한 재미있는 선택이라고 생각할 수도 있습니다.  그러한 생각을 잠깐 옆으로 두고 열린 마음으로 글을 읽어주세요.  JavaScript 프로그래밍에 또 다른 레벨이 있다는 것을 알 수 있습니다.  당신이 결코 알지 못했던 것이 있습니다.\n\n이 글은 \"소프트웨어 합성\"이라고 불리며, 함수형 프로그래밍이란 함수 합성, 고차 함수 등을 사용하여 소프트웨어를 작성하는 방법입니다. 왜 내가 하스켈, ClojureScript 또는 Elm 대신에 JavaScript를 택했는지 궁금해 할 수 있습니다.\n\nJavaScript는 함수형 프로그래밍에 필요한 가장 중요한 기능을 가지고 있습니다.\n\n1.  **first class 함수 :**  함수를 값으로 사용하는 기능 : 함수를 인수로 전달하고, 함수를 반환하고, 함수를 변수 및 객체 속성에 할당합니다. 이는 고차 함수^high-order-function^를 허용하여 부분 적용 ^partial^ ^application^, currying 및 합성을 가능하게합니다.\n2.  **익명 함수와 간결한 람다 구문 :**  `x => x * 2`  는 JavaScript에서 유효한 함수 표현식입니다.  간결한 람다^lambda^는 고차원 함수로 작업하기가 더 쉽습니다.\n3.  **클로저^closure^ :**  클로저는 어휘 스코프과 함수의 묶음입니다.  클로저는 함수가 만들어질 때 함께 만들어집니다.  함수가 다른 함수 내부에서 정의되면 외부 함수가 종료 된 후에도 외부 함수의 변수 바인딩에 액세스 할 수 있습니다.  클로저는 부분 적용에서 고정 된 인수를 얻는 방법입니다.  고정 인수는 반환된 함수의 클로저 범위에 바인딩 된 인수입니다.  `add2(1)(2)`  에서  `1`  은  `add2(1)`의해 리턴된 함수의 고정 인수입니다.\n\n## JavaScript가 놓치고 있는 것들\n\nJavaScript는여러 가지 스타일로 프로그래밍 할 수 있는 멀티 패러다임 언어입니다.  우리는 JavaScript로 절차적(명령형) 프로그래밍(C와 같은)을 할 수 있으며 이 때 함수란 반복적으로 호출 할 수있는 명령어의 서브 루틴을 나타냅니다. 함수가 아닌 객체가 기본 빌딩 블록인 객체지향 프로그래밍을 할 수 도 있으며 물론 당연히 함수형 프로그래밍도 가능합니다.  멀티 패러다임 언어의 단점은 절차적 및 객체 지향 방식의 프로그래밍으로 접근 할 경우 거의 모든 것이 변경 가능해야한다는 것을 암시하는 경향이 있다는 것입니다.\n\n변이^mutation^는 내부에서 일어나는 데이터 변화입니다.  예를 들자면 :\n\n```javascript\nconst foo = {  \n  bar: 'baz'  \n};\n\nfoo.bar = 'qux'; // mutation\n```\n메소드는 객체의 속성을 업데이트하기 때문에 객체는 일반적으로 변경 가능해야 합니다. 명령형 프로그래밍에서 대부분의 자료 구조는 객체 및 배열을 효율적으로 조작 하기 위해 변경가능합니다.\n\n다음은 JavaScript에 없는 일부 함수형 언어의 특징입니다.\n\n1.  **순수^Purity^ :**  일부 FP 언어에서는 순수성이 언어에 의해 시행됩니다.  부수효과가 발생할 수 있는 표현식은 허용되지 않습니다.\n2.  **불변성^Immutability^ :**  일부 FP 언어는 변이를 금지합니다.  기존 데이터 구조 (예 : 배열 또는 객체)를 변경하는 대신 표현식은 새로운 데이터 구조를 생성합니다.  이것을 비효율적이라고 생각할 수 있지만 대부분의 함수형 언어의 기저에는 트라이^trie^ 기반 데이터 구조가 있습니다. 즉, 이전 객체와 새 객체가 동일한 데이터에 대한 참조를 공유한다는 의미입니다.\n3.  **재귀^recursion^ :**  재귀는 반복을 목적으로 함수를 참조하는 기능입니다.  많은 FP 언어에서 재귀는 반복작업을 수행 할 수있는 유일한 방법입니다.  `for`  ,  `while`  또는  `do`  루프와 같은 루프 문은 없습니다.^[JavaScript로 재귀적 코드를 작성할 수 없다는 것이 아닌 재귀만을 사용해 반복적인 작업을 수행해야 하는 제약이 없다는 뜻입니다.]\n\n**순수 :**  JavaScript에서는 코딩 컨벤션으로 순수함을 달성해야합니다.  순수 함수로 응용 프로그램의 대부분을 작성하지 않으면 함수형 스타일로 프로그래밍했다고 할 수 없습니다. 유감스럽게도 JavaScript에서는 의도치 않게 불순한 함수를 작성하기 쉽습니다.\n\n**불변성 :**  순수 함수형 언어에서 불변성이 종종 강요됩니다.  JavaScript는 대부분의 함수 언어에서 사용되는 효율적이고 불변의 트라이 기반 데이터 구조가 부족하지만  [Immutable.js](https://facebook.github.io/immutable-js/)  와  [Mori](https://github.com/swannodette/mori)등 이를 도와주는 라이브러리가 있습니다.  저는 향후 ECMAScript 스펙이 불변 데이터 구조를 지원해주길 바라고 있습니다.\n\nES6에서  `const`  키워드를 추가한 것을 보면 가능성 있는 이야기 입니다.  `const`  로 선언된 변수에 다른 값을 재 할당 할 수 없습니다.  그러나 `const`  가 불변값을 뜻하는 것은 아닙니다.\n\n`const` 로 선언된 변수에 완전히 다른 객체를 참조하기 위해 다시 할당 할 수는 없지만 참조하는 _객체의 속성_ 이 변경 될 수 있습니다.  JavaScript는 또한 객체를  `freeze()`  수 있지만 그 객체는 루트 수준에서만 고정되어 있습니다. 즉, 중첩 된 객체의 속성은 변형 될 수 있습니다.  다시 말하자면 JavaScript에서 진정한 불변성을 보기 까지는 아직 갈 길이 멉니다.\n\n**재귀 :**  JavaScript는 재귀를 지원하지만 대부분의 함수형 언어에는 꼬리 호출 최적화^tail^ ^call^ ^optimization^라는 기능이 있습니다.  꼬리 호출 최적화는 재귀 함수가 스택 프레임을 재사용하여 재귀호출을 할 수 있게 해주는 기능입니다.\n\n꼬리 호출 최적화가 없으면 스택이 계속 증가하여 스택 오버플로를 일으킬 수 있습니다.  JavaScript는 ES6 명세에서 꼬리 호출 최적화를 명시했습니다.  불행하게도 아직까지는 주요 브라우저 엔진 중 하나만이 이를 구현했으며, 최적화가 부분적으로 구현 된 후 Babel (구 브라우저에서 사용하기 위해 ES6에서 ES5로 컴파일하는 데 사용되는 가장 보편적 인 표준 JavaScript 컴파일러)에서 제거되었습니다.\n\n결론 : 꼬리 위치에서 함수를 주의해서 호출하더라도 대용량 반복에 대해 재귀를 사용하는 것은 여전히 ​​안전하지 않습니다.\n\n## JavaScript가 순수한 함수형 언어로서 부족한 점\n\n순수 주의자들은 자바 스크립트의 변이 가능성이 가장 큰 단점이라고 말합니다. 그러나 부수효과와 변이가 도움이 되는 경우가 있습니다.  사실, 부수효과 없이 쓸모있는 최신 응용 프로그램을 만드는 것은 불가능합니다.^[입출력이 가장 근본적인 부수효과이기 때문입니다]  Haskell과 같은 순수 함수형 언어에서는 모나드^monad^라는 상자를 사용하여 부수효과를 순수 함수로 감쌉니다. 따라서 모나드가 나타내는 부수효과가 불명확하더라도 프로그램을 순수하게 유지할 수 있습니다.\n\n모나드의 사용법이 간단하더라도 모나드가 많은 사람들에게 익숙하지 않다는 문제점이 있습니다. 이를 처음 보는 사람에게 모나드가 무엇인지 설명하는 것은 색맹인 사람에게 \"푸른 색\"이 어떻게 보이는지 설명하는 것과 비슷합니다.\n\n> _\"모나드는 endofunctor라는 범주에 속한 한 monoid에 불과해. 뭐가 문제야?\" 제임스 아이리 (James Iry)는 필립 와들러 (Phillip Wadler)의 의역을 들먹이며 손더스 맥 레인 (Shanders Mac Lane)을 인용했다._  [“A Brief, Incomplete, and Mostly Wrong History of Programming Languages”](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html)\n\n일반적으로 패러디란 재미있는 부분을 더 재미있게 만들기 위해 과장하는 경향이 있습니다. 위의 인용문에서 모나드에 대한 설명은 실제로  _다음_  에 나오는 원래의 인용구에서  _단순화_  된 것 입니다.\n\n> _\"_  `x`  _의 모나드는_`x`의 endofunctor라는 범주에 속한 한 monoid이다.  `×`의 연산은 endofunctor들의 조합과 항등 endofunctor의 단위로 구성된 일련의 연산 집합들로 치환 가능하다\"~ Saunders Mac Lane._  [_\"Categories for the Working Mathematician\"_](https://www.amazon.com/Categories-Working-Mathematician-Graduate-Mathematics/dp/0387984038//ref=as_li_ss_tl?ie=UTF8&linkCode=ll1&tag=eejs-20&linkId=de6f23899da4b5892f562413173be4f0)\n\n그럼에도 불구하고, 전 모나드에 대한 두려움이 과장되어 있다고 생각합니다. 모나드를 배우는 가장 좋은 방법은 그 주제에 관한 책과 블로그 글을 읽지 않고, 바로 사용해 보는 것입니다. 함수형 프로그래밍의 다른 주제들과 마찬가지로, 학문적 어휘는 그것의 개념과 사용법보다 이해하기가 훨씬 어렵습니다. 믿어주세요. 함수형 프로그래밍을 하기 위해 손더스 맥 레인(Saunders Mac Lane)을 이해할 필요는 없습니다.\n\n모든 프로그래밍 스타일에 완전히 적합하다고 할 수는 없지만 JavaScript는 다양한 프로그래밍 스타일과 배경을 가진 사람들이 사용할 수 있도록 고안된 범용 언어입니다.\n\n이는 처음부터 의도된 것이라고 [브랜던 아이크(Brendan Eich)](https://brendaneich.com/2008/04/popularity/)가 말했습니다. ^[브랜던 아이크는 자바스크립트를 만든 프로그래머입니다]   Netscape는 두 종류의 프로그래머를 지원해야했습니다.\n\n> _\"... C ++ 또는 (우리가 희망하는) Java로 컴포넌트를 작성하는 프로그래머._  _HTML에 직접 삽입 된 코드를 작성하는 '스크립터', 아마추어 또는 프로. \"_\n\n원래 Netscape는 두 가지 언어를 지원할 것이고 스크립트 언어는 아마도 Scheme (Lisp의 방언)과 비슷할 예정이었습니다.  브랜던 아이크 :\n\n> _\"저는 넷플릭스에 채용될 때 브라우저에서 Scheme을 구현하는 계획을 맡게 됐습니다.\"_\n\nJavaScript는 새로운 언어여야 했습니다.\n\n> _\"엔지니어링 경영진의 요구사항은 '자바처럼 보일 것'이었습니다.  이는 Scheme과 함께 Perl, Python, Tcl을 배제하는 결과로 이어졌습니다. \"_\n\n그 때 브랜던의 머리에서 나온 아이디어는 다음과 같습니다.\n\n1.  브라우저에서 돌아가는 Scheme.\n2.  자바처럼 보일 것.\n\n결국 잿더미가 되고 말았습니다.\n\n> _\"나는 자랑스럽지 않지만 Scheme스러운 first class 함수와 Self-ish (단 하나 임에도 불구하고) 프로토 타입을 이 언어의 특징으로 채택하게되어 기쁩니다. 자바의 영향, 특히 y2k 날짜 버그뿐만 아니라 원시타입와 객체의 구분 (예 : string 대 String)은 불행했습니다. \"_\n\n여기에 Java와 유사한 \"불행한\"기능들을 추가하여 마침내 JavaScript가 됐습니다. \n\n불행한 기능들:\n\n- 생성자 함수 및 `new` 키워드는 팩토리 함수와 동일한 일을 하기 위해 다른 호출 방식과 문법을 사용하게 합니다.\n- `class`  키워드는 단일 조상으로부터 `extend` 하는 기본 상속 메커니즘입니다.\n- 많은 이들이  `class`  를 정적 타입인 것처럼 생각하는 경향이 있습니다 (그렇지 않습니다).\n\n충고를 드리자면: 가능한 사용하지 마세요.\n\n오늘날 Java, Flash 및 ActiveX 확장 프로그램은 대부분의 브라우저에서 더이상 지원되지 않습니다. 즉 스크립팅 방식이 \"컴포넌트\"접근 방식 보다 우위를 점하는 것으로 밝혀 졌고 JavaScript는 유연한 언어가 되었습니다.\n\n결국 JavaScript는 브라우저에서 직접 지원하는 유일한 언어가 되었습니다.\n\n브라우저는 JavaScript라는 단일 언어 바인딩 만 지원하기 때문에 덜 비대해지고 버그가 적어졌습니다.  WebAssembly가 예외라고 생각할 수도 있지만 WebAssembly의 디자인 목표 중 하나는 호환 가능한 추상 구문 트리 (AST)를 사용하여 JavaScript의 언어 바인딩을 공유하는 것입니다.  실제로 첫 번째 데모에서는 WebAssembly를 ASM.js라는 JavaScript의 하위 집합으로 컴파일했습니다.\n\n웹 플랫폼을 위한 유일한 표준 범용 프로그래밍 언어로서의 위치는 JavaScript가 소프트웨어 역사상 가장 큰 인기의 물결을 탈 수 있게 해 주었습니다.\n\n**앱은 세상을 먹었고 웹은 앱을 먹었고 JavaScript는 웹을 먹었습니다.**\n>Apps ate the world, the web ate apps, and JavaScript ate the web.\n\n[많은](http://redmonk.com/sogrady/2016/07/20/language-rankings-6-16/)  [통계에](http://stackoverflow.com/research/developer-survey-2016)  따르면  [JavaScript](https://octoverse.github.com/)  는 현재 세계에서 가장 인기있는 프로그래밍 언어입니다.\n\n자바 스크립트는 함수형 프로그래밍을위한 이상적인 도구는 아니지만 규모가 크고 분산 된 팀에서 대규모 응용 프로그램을 작성하기 위한 훌륭한 도구입니다. 서로 다른 팀에서는 응용 프로그램을 작성하는 방법에 대한 아이디어가 다를 수 있습니다.\n\n스크립팅을 주로 하는 팀은 명령형 프로그래밍을 사용해 모듈을 붙이는데 집중할 수 있습니다.  다른 사람들은 아키텍처 추상화에 집중할 수 있습니다. 이 때는 (신중한) 객체 지향적 접근방식이 괜찮은 방법일 수도 있습니다.  또 다른 사람들은 함수형 프로그래밍을 채택해 순수 함수를 사용하여 응용 프로그램 상태를 결정적인 동시에 테스트 가능하도록 관리하고 사용자의 작업을 줄입니다.  이러한 팀들의 구성원은 모두 같은 언어를 사용하므로 서로 쉽게 아이디어를 교환하고 서로에게서 배우며 서로의 작업을 도와줄 수 있습니다.\n\nJavaScript에서는 이러한 모든 아이디어가 공존 할 수 있습니다. 따라서 더 많은 사람들이 JavaScript를 채택 하게 되었고 이는 [세계에서 가장 큰 오픈 소스 패키지 저장소](http://www.modulecounts.com/)  (2017년 2월),  [npm](https://www.npmjs.com/)의 등장으로 이어졌습니다 .\n\nJavaScript의 진정한 강점은 다양한 사고방식을 가진 사용자가 함께 있는 생태계입니다.  순수 함수형 프로그래밍주의자들을 위한 이상적인 언어는 아닐지라도 Java, Lisp, C와 같은 대중적인 언어에서 온 사람들이 모든 플랫폼에서 작동하는 동일한 문법을 사용하여 함께 작업하기에 이상적인 언어일 수 있습니다. JavaScript는 그러한 배경을 가진 사람들에게 이상적일 만큼 편하지는 않지만 언어를 배우고 빠르게 생산적이 될  만큼 편합니다.\n\n저는 JavaScript가 함수형 프로그래머를위한 최고의 언어가 아니라는 것에 동의합니다.  그러나 다른 모든 함수형 언어는 누구나 이해하고 사용할 수 있다고 말할 수 없으며 JavaScript는 ES6에서 함수형 프로그래밍에 관심이있는 사용자의 요구에 부응 할 수 있음을 보여줬고 점차 나아질 것입니다. 전 세계의 거의 모든 회사에서 사용하는 JavaScript와 놀라운 생태계를 포기하지 마십시오, 이를 포용해서 소프트웨어 구성을 위한 더 나은 언어를 만들어 가는게 좋지 않을까요?\n\nJavaScript는 이미 함수형 프로그래밍 언어로  _충분_  합니다. 즉, 사람들은 함수형 프로그래밍 기술을 사용하여 JavaScript에서 유용하고 흥미로운 모든 것을 구축하고 있습니다.  Netflix (및 Angular 2+로 작성된 모든 앱)는 RxJS 기반의 함수형 유틸리티를 사용합니다.  [Facebook](https://github.com/facebook/react/wiki/sites-using-react)  은 React의 순수 함수, 고차 함수 및 고차원 컴포넌트의 개념을 사용하여 Facebook 및 Instagram을 구축합니다.[PayPal, KhanAcademy 및 Flipkart](https://github.com/reactjs/redux/issues/310)  는 상태 관리를 위해 Redux를 사용합니다.\n\nAngular, React, Redux 및 Lodash는 JavaScript 생태계의 주요 프레임 워크이자 라이브러리이며, 모두 함수형 프로그래밍의 직접적인 영향을 받았습니다. Lodash 및 Redux의 경우 실제 JavaScript 애플리케이션에서 함수형 프로그래밍 패턴을 가능하게하는 목적을 가지고 제작되었습니다.\n\n\"어째서 JavaScript인가?\" JavaScript는 실제로 회사가 실제 소프트웨어를 만드는 데 사용하는 언어이기 때문에.  좋아하든 싫어하든, JavaScript는 수십 년 동안 지속되었던 Lisp의 \"가장 인기있는 함수형 프로그래밍 언어\"라는 타이틀을 빼앗았습니다.  사실, Haskell이 오늘날의 함수형 프로그래밍 개념에 훨씬 더 적합한 표준 무기이지만, 사람들은 하스켈로 실제 응용 프로그램을 거의 구축하지 않고 있습니다.\n\n언제나 미국에는 수십만 개의 JavaScript 일자리가 있으며, 전 세계적으로 수십만 가지가 있습니다.  하스켈을 배우는 것은 함수 프로그래밍에 대해 많은 것을 가르쳐 주지만, JavaScript를 배우는 것은 실제 직업을 위한 프로덕션 애플리케이션을 구축하는 것에 대해 가르쳐 줄 것입니다.\n\n> **앱은 세상을 먹었고 웹은 앱을 먹었고 JavaScript는 웹을 먹었습니다.**\n\n[**다음: 함수형 프로그래머를 위한 JavaScript 개요 >**](https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/)","source":"_posts/why-learn-functional-programming-in-javascript.md","raw":"---\ntitle: 왜 JavaScript로 함수형 프로그래밍을 배우는가?\ncatalog: true\ndate: 2018-03-25 05:46:23\nsubtitle: \"Why learn functional programming in JavaScript?\"\nheader-img: \"bg.jpg\"\nreadingTime: 11\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 그동안 JavaScript에 대해 가지고 있었던 생각들은 모두 잊어 버리고 초심자의 마음으로 이 글을 읽어주세요. JavaScript를 사용해 본 적 없는 이들을 위해 JavaScript의 기본 사항을 처음부터 다룰 것입니다.  당신이 초보자라면 행운입니다.  드디어 ES6 및 함수형 프로그래밍을 처음부터 다루는 글이 나왔습니다!  모든 새로운 개념에 대해 하나씩 알아볼 예정입니다. 그러나 너무 모든 것을 다 이해하려고 노력하지는 않아도 됩니다. JavaScript나 순수 함수 언어에 익숙한 노련한 개발자라면 어쩌면 JavaScript가 함수 프로그래밍을 탐구하기위한 재미있는 선택이라고 생각할 수도 있습니다.  그러한 생각을 잠깐 옆으로 두고 열린 마음으로 글을 읽어주세요.  JavaScript 프로그래밍에 또 다른 레벨이 있다는 것을 알 수 있습니다.  당신이 결코 알지 못했던 것이 있습니다.\n---\n\n> 이 글은  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup) 이 **medium**에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  [[원문보기]](https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257)\n\n![](https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg)\n*Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)*\n\n>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 \"소프트웨어 합성\"시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.\n> [_<이전_](https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/)  _|_  [_<< Part 1에서 다시 시작_](https://midojeong.github.io/2018/03/16/composing-software-intro/)  _|_  [_다음>_](https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/)\n\n그동안 JavaScript에 대해 가지고 있었던 생각들은 모두 잊어 버리고 초심자의 마음으로 이 글을 읽어주세요. JavaScript를 사용해 본 적 없는 이들을 위해 JavaScript의 기본 사항을 처음부터 다룰 것입니다.  당신이 초보자라면 행운입니다.  드디어 ES6 및 함수형 프로그래밍을 처음부터 다루는 글이 나왔습니다!  모든 새로운 개념에 대해 하나씩 알아볼 예정입니다. 그러나 너무 모든 것을 다 이해하려고 노력하지는 않아도 됩니다.\n\nJavaScript나 순수 함수 언어에 익숙한 노련한 개발자라면 어쩌면 JavaScript가 함수 프로그래밍을 탐구하기위한 재미있는 선택이라고 생각할 수도 있습니다.  그러한 생각을 잠깐 옆으로 두고 열린 마음으로 글을 읽어주세요.  JavaScript 프로그래밍에 또 다른 레벨이 있다는 것을 알 수 있습니다.  당신이 결코 알지 못했던 것이 있습니다.\n\n이 글은 \"소프트웨어 합성\"이라고 불리며, 함수형 프로그래밍이란 함수 합성, 고차 함수 등을 사용하여 소프트웨어를 작성하는 방법입니다. 왜 내가 하스켈, ClojureScript 또는 Elm 대신에 JavaScript를 택했는지 궁금해 할 수 있습니다.\n\nJavaScript는 함수형 프로그래밍에 필요한 가장 중요한 기능을 가지고 있습니다.\n\n1.  **first class 함수 :**  함수를 값으로 사용하는 기능 : 함수를 인수로 전달하고, 함수를 반환하고, 함수를 변수 및 객체 속성에 할당합니다. 이는 고차 함수^high-order-function^를 허용하여 부분 적용 ^partial^ ^application^, currying 및 합성을 가능하게합니다.\n2.  **익명 함수와 간결한 람다 구문 :**  `x => x * 2`  는 JavaScript에서 유효한 함수 표현식입니다.  간결한 람다^lambda^는 고차원 함수로 작업하기가 더 쉽습니다.\n3.  **클로저^closure^ :**  클로저는 어휘 스코프과 함수의 묶음입니다.  클로저는 함수가 만들어질 때 함께 만들어집니다.  함수가 다른 함수 내부에서 정의되면 외부 함수가 종료 된 후에도 외부 함수의 변수 바인딩에 액세스 할 수 있습니다.  클로저는 부분 적용에서 고정 된 인수를 얻는 방법입니다.  고정 인수는 반환된 함수의 클로저 범위에 바인딩 된 인수입니다.  `add2(1)(2)`  에서  `1`  은  `add2(1)`의해 리턴된 함수의 고정 인수입니다.\n\n## JavaScript가 놓치고 있는 것들\n\nJavaScript는여러 가지 스타일로 프로그래밍 할 수 있는 멀티 패러다임 언어입니다.  우리는 JavaScript로 절차적(명령형) 프로그래밍(C와 같은)을 할 수 있으며 이 때 함수란 반복적으로 호출 할 수있는 명령어의 서브 루틴을 나타냅니다. 함수가 아닌 객체가 기본 빌딩 블록인 객체지향 프로그래밍을 할 수 도 있으며 물론 당연히 함수형 프로그래밍도 가능합니다.  멀티 패러다임 언어의 단점은 절차적 및 객체 지향 방식의 프로그래밍으로 접근 할 경우 거의 모든 것이 변경 가능해야한다는 것을 암시하는 경향이 있다는 것입니다.\n\n변이^mutation^는 내부에서 일어나는 데이터 변화입니다.  예를 들자면 :\n\n```javascript\nconst foo = {  \n  bar: 'baz'  \n};\n\nfoo.bar = 'qux'; // mutation\n```\n메소드는 객체의 속성을 업데이트하기 때문에 객체는 일반적으로 변경 가능해야 합니다. 명령형 프로그래밍에서 대부분의 자료 구조는 객체 및 배열을 효율적으로 조작 하기 위해 변경가능합니다.\n\n다음은 JavaScript에 없는 일부 함수형 언어의 특징입니다.\n\n1.  **순수^Purity^ :**  일부 FP 언어에서는 순수성이 언어에 의해 시행됩니다.  부수효과가 발생할 수 있는 표현식은 허용되지 않습니다.\n2.  **불변성^Immutability^ :**  일부 FP 언어는 변이를 금지합니다.  기존 데이터 구조 (예 : 배열 또는 객체)를 변경하는 대신 표현식은 새로운 데이터 구조를 생성합니다.  이것을 비효율적이라고 생각할 수 있지만 대부분의 함수형 언어의 기저에는 트라이^trie^ 기반 데이터 구조가 있습니다. 즉, 이전 객체와 새 객체가 동일한 데이터에 대한 참조를 공유한다는 의미입니다.\n3.  **재귀^recursion^ :**  재귀는 반복을 목적으로 함수를 참조하는 기능입니다.  많은 FP 언어에서 재귀는 반복작업을 수행 할 수있는 유일한 방법입니다.  `for`  ,  `while`  또는  `do`  루프와 같은 루프 문은 없습니다.^[JavaScript로 재귀적 코드를 작성할 수 없다는 것이 아닌 재귀만을 사용해 반복적인 작업을 수행해야 하는 제약이 없다는 뜻입니다.]\n\n**순수 :**  JavaScript에서는 코딩 컨벤션으로 순수함을 달성해야합니다.  순수 함수로 응용 프로그램의 대부분을 작성하지 않으면 함수형 스타일로 프로그래밍했다고 할 수 없습니다. 유감스럽게도 JavaScript에서는 의도치 않게 불순한 함수를 작성하기 쉽습니다.\n\n**불변성 :**  순수 함수형 언어에서 불변성이 종종 강요됩니다.  JavaScript는 대부분의 함수 언어에서 사용되는 효율적이고 불변의 트라이 기반 데이터 구조가 부족하지만  [Immutable.js](https://facebook.github.io/immutable-js/)  와  [Mori](https://github.com/swannodette/mori)등 이를 도와주는 라이브러리가 있습니다.  저는 향후 ECMAScript 스펙이 불변 데이터 구조를 지원해주길 바라고 있습니다.\n\nES6에서  `const`  키워드를 추가한 것을 보면 가능성 있는 이야기 입니다.  `const`  로 선언된 변수에 다른 값을 재 할당 할 수 없습니다.  그러나 `const`  가 불변값을 뜻하는 것은 아닙니다.\n\n`const` 로 선언된 변수에 완전히 다른 객체를 참조하기 위해 다시 할당 할 수는 없지만 참조하는 _객체의 속성_ 이 변경 될 수 있습니다.  JavaScript는 또한 객체를  `freeze()`  수 있지만 그 객체는 루트 수준에서만 고정되어 있습니다. 즉, 중첩 된 객체의 속성은 변형 될 수 있습니다.  다시 말하자면 JavaScript에서 진정한 불변성을 보기 까지는 아직 갈 길이 멉니다.\n\n**재귀 :**  JavaScript는 재귀를 지원하지만 대부분의 함수형 언어에는 꼬리 호출 최적화^tail^ ^call^ ^optimization^라는 기능이 있습니다.  꼬리 호출 최적화는 재귀 함수가 스택 프레임을 재사용하여 재귀호출을 할 수 있게 해주는 기능입니다.\n\n꼬리 호출 최적화가 없으면 스택이 계속 증가하여 스택 오버플로를 일으킬 수 있습니다.  JavaScript는 ES6 명세에서 꼬리 호출 최적화를 명시했습니다.  불행하게도 아직까지는 주요 브라우저 엔진 중 하나만이 이를 구현했으며, 최적화가 부분적으로 구현 된 후 Babel (구 브라우저에서 사용하기 위해 ES6에서 ES5로 컴파일하는 데 사용되는 가장 보편적 인 표준 JavaScript 컴파일러)에서 제거되었습니다.\n\n결론 : 꼬리 위치에서 함수를 주의해서 호출하더라도 대용량 반복에 대해 재귀를 사용하는 것은 여전히 ​​안전하지 않습니다.\n\n## JavaScript가 순수한 함수형 언어로서 부족한 점\n\n순수 주의자들은 자바 스크립트의 변이 가능성이 가장 큰 단점이라고 말합니다. 그러나 부수효과와 변이가 도움이 되는 경우가 있습니다.  사실, 부수효과 없이 쓸모있는 최신 응용 프로그램을 만드는 것은 불가능합니다.^[입출력이 가장 근본적인 부수효과이기 때문입니다]  Haskell과 같은 순수 함수형 언어에서는 모나드^monad^라는 상자를 사용하여 부수효과를 순수 함수로 감쌉니다. 따라서 모나드가 나타내는 부수효과가 불명확하더라도 프로그램을 순수하게 유지할 수 있습니다.\n\n모나드의 사용법이 간단하더라도 모나드가 많은 사람들에게 익숙하지 않다는 문제점이 있습니다. 이를 처음 보는 사람에게 모나드가 무엇인지 설명하는 것은 색맹인 사람에게 \"푸른 색\"이 어떻게 보이는지 설명하는 것과 비슷합니다.\n\n> _\"모나드는 endofunctor라는 범주에 속한 한 monoid에 불과해. 뭐가 문제야?\" 제임스 아이리 (James Iry)는 필립 와들러 (Phillip Wadler)의 의역을 들먹이며 손더스 맥 레인 (Shanders Mac Lane)을 인용했다._  [“A Brief, Incomplete, and Mostly Wrong History of Programming Languages”](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html)\n\n일반적으로 패러디란 재미있는 부분을 더 재미있게 만들기 위해 과장하는 경향이 있습니다. 위의 인용문에서 모나드에 대한 설명은 실제로  _다음_  에 나오는 원래의 인용구에서  _단순화_  된 것 입니다.\n\n> _\"_  `x`  _의 모나드는_`x`의 endofunctor라는 범주에 속한 한 monoid이다.  `×`의 연산은 endofunctor들의 조합과 항등 endofunctor의 단위로 구성된 일련의 연산 집합들로 치환 가능하다\"~ Saunders Mac Lane._  [_\"Categories for the Working Mathematician\"_](https://www.amazon.com/Categories-Working-Mathematician-Graduate-Mathematics/dp/0387984038//ref=as_li_ss_tl?ie=UTF8&linkCode=ll1&tag=eejs-20&linkId=de6f23899da4b5892f562413173be4f0)\n\n그럼에도 불구하고, 전 모나드에 대한 두려움이 과장되어 있다고 생각합니다. 모나드를 배우는 가장 좋은 방법은 그 주제에 관한 책과 블로그 글을 읽지 않고, 바로 사용해 보는 것입니다. 함수형 프로그래밍의 다른 주제들과 마찬가지로, 학문적 어휘는 그것의 개념과 사용법보다 이해하기가 훨씬 어렵습니다. 믿어주세요. 함수형 프로그래밍을 하기 위해 손더스 맥 레인(Saunders Mac Lane)을 이해할 필요는 없습니다.\n\n모든 프로그래밍 스타일에 완전히 적합하다고 할 수는 없지만 JavaScript는 다양한 프로그래밍 스타일과 배경을 가진 사람들이 사용할 수 있도록 고안된 범용 언어입니다.\n\n이는 처음부터 의도된 것이라고 [브랜던 아이크(Brendan Eich)](https://brendaneich.com/2008/04/popularity/)가 말했습니다. ^[브랜던 아이크는 자바스크립트를 만든 프로그래머입니다]   Netscape는 두 종류의 프로그래머를 지원해야했습니다.\n\n> _\"... C ++ 또는 (우리가 희망하는) Java로 컴포넌트를 작성하는 프로그래머._  _HTML에 직접 삽입 된 코드를 작성하는 '스크립터', 아마추어 또는 프로. \"_\n\n원래 Netscape는 두 가지 언어를 지원할 것이고 스크립트 언어는 아마도 Scheme (Lisp의 방언)과 비슷할 예정이었습니다.  브랜던 아이크 :\n\n> _\"저는 넷플릭스에 채용될 때 브라우저에서 Scheme을 구현하는 계획을 맡게 됐습니다.\"_\n\nJavaScript는 새로운 언어여야 했습니다.\n\n> _\"엔지니어링 경영진의 요구사항은 '자바처럼 보일 것'이었습니다.  이는 Scheme과 함께 Perl, Python, Tcl을 배제하는 결과로 이어졌습니다. \"_\n\n그 때 브랜던의 머리에서 나온 아이디어는 다음과 같습니다.\n\n1.  브라우저에서 돌아가는 Scheme.\n2.  자바처럼 보일 것.\n\n결국 잿더미가 되고 말았습니다.\n\n> _\"나는 자랑스럽지 않지만 Scheme스러운 first class 함수와 Self-ish (단 하나 임에도 불구하고) 프로토 타입을 이 언어의 특징으로 채택하게되어 기쁩니다. 자바의 영향, 특히 y2k 날짜 버그뿐만 아니라 원시타입와 객체의 구분 (예 : string 대 String)은 불행했습니다. \"_\n\n여기에 Java와 유사한 \"불행한\"기능들을 추가하여 마침내 JavaScript가 됐습니다. \n\n불행한 기능들:\n\n- 생성자 함수 및 `new` 키워드는 팩토리 함수와 동일한 일을 하기 위해 다른 호출 방식과 문법을 사용하게 합니다.\n- `class`  키워드는 단일 조상으로부터 `extend` 하는 기본 상속 메커니즘입니다.\n- 많은 이들이  `class`  를 정적 타입인 것처럼 생각하는 경향이 있습니다 (그렇지 않습니다).\n\n충고를 드리자면: 가능한 사용하지 마세요.\n\n오늘날 Java, Flash 및 ActiveX 확장 프로그램은 대부분의 브라우저에서 더이상 지원되지 않습니다. 즉 스크립팅 방식이 \"컴포넌트\"접근 방식 보다 우위를 점하는 것으로 밝혀 졌고 JavaScript는 유연한 언어가 되었습니다.\n\n결국 JavaScript는 브라우저에서 직접 지원하는 유일한 언어가 되었습니다.\n\n브라우저는 JavaScript라는 단일 언어 바인딩 만 지원하기 때문에 덜 비대해지고 버그가 적어졌습니다.  WebAssembly가 예외라고 생각할 수도 있지만 WebAssembly의 디자인 목표 중 하나는 호환 가능한 추상 구문 트리 (AST)를 사용하여 JavaScript의 언어 바인딩을 공유하는 것입니다.  실제로 첫 번째 데모에서는 WebAssembly를 ASM.js라는 JavaScript의 하위 집합으로 컴파일했습니다.\n\n웹 플랫폼을 위한 유일한 표준 범용 프로그래밍 언어로서의 위치는 JavaScript가 소프트웨어 역사상 가장 큰 인기의 물결을 탈 수 있게 해 주었습니다.\n\n**앱은 세상을 먹었고 웹은 앱을 먹었고 JavaScript는 웹을 먹었습니다.**\n>Apps ate the world, the web ate apps, and JavaScript ate the web.\n\n[많은](http://redmonk.com/sogrady/2016/07/20/language-rankings-6-16/)  [통계에](http://stackoverflow.com/research/developer-survey-2016)  따르면  [JavaScript](https://octoverse.github.com/)  는 현재 세계에서 가장 인기있는 프로그래밍 언어입니다.\n\n자바 스크립트는 함수형 프로그래밍을위한 이상적인 도구는 아니지만 규모가 크고 분산 된 팀에서 대규모 응용 프로그램을 작성하기 위한 훌륭한 도구입니다. 서로 다른 팀에서는 응용 프로그램을 작성하는 방법에 대한 아이디어가 다를 수 있습니다.\n\n스크립팅을 주로 하는 팀은 명령형 프로그래밍을 사용해 모듈을 붙이는데 집중할 수 있습니다.  다른 사람들은 아키텍처 추상화에 집중할 수 있습니다. 이 때는 (신중한) 객체 지향적 접근방식이 괜찮은 방법일 수도 있습니다.  또 다른 사람들은 함수형 프로그래밍을 채택해 순수 함수를 사용하여 응용 프로그램 상태를 결정적인 동시에 테스트 가능하도록 관리하고 사용자의 작업을 줄입니다.  이러한 팀들의 구성원은 모두 같은 언어를 사용하므로 서로 쉽게 아이디어를 교환하고 서로에게서 배우며 서로의 작업을 도와줄 수 있습니다.\n\nJavaScript에서는 이러한 모든 아이디어가 공존 할 수 있습니다. 따라서 더 많은 사람들이 JavaScript를 채택 하게 되었고 이는 [세계에서 가장 큰 오픈 소스 패키지 저장소](http://www.modulecounts.com/)  (2017년 2월),  [npm](https://www.npmjs.com/)의 등장으로 이어졌습니다 .\n\nJavaScript의 진정한 강점은 다양한 사고방식을 가진 사용자가 함께 있는 생태계입니다.  순수 함수형 프로그래밍주의자들을 위한 이상적인 언어는 아닐지라도 Java, Lisp, C와 같은 대중적인 언어에서 온 사람들이 모든 플랫폼에서 작동하는 동일한 문법을 사용하여 함께 작업하기에 이상적인 언어일 수 있습니다. JavaScript는 그러한 배경을 가진 사람들에게 이상적일 만큼 편하지는 않지만 언어를 배우고 빠르게 생산적이 될  만큼 편합니다.\n\n저는 JavaScript가 함수형 프로그래머를위한 최고의 언어가 아니라는 것에 동의합니다.  그러나 다른 모든 함수형 언어는 누구나 이해하고 사용할 수 있다고 말할 수 없으며 JavaScript는 ES6에서 함수형 프로그래밍에 관심이있는 사용자의 요구에 부응 할 수 있음을 보여줬고 점차 나아질 것입니다. 전 세계의 거의 모든 회사에서 사용하는 JavaScript와 놀라운 생태계를 포기하지 마십시오, 이를 포용해서 소프트웨어 구성을 위한 더 나은 언어를 만들어 가는게 좋지 않을까요?\n\nJavaScript는 이미 함수형 프로그래밍 언어로  _충분_  합니다. 즉, 사람들은 함수형 프로그래밍 기술을 사용하여 JavaScript에서 유용하고 흥미로운 모든 것을 구축하고 있습니다.  Netflix (및 Angular 2+로 작성된 모든 앱)는 RxJS 기반의 함수형 유틸리티를 사용합니다.  [Facebook](https://github.com/facebook/react/wiki/sites-using-react)  은 React의 순수 함수, 고차 함수 및 고차원 컴포넌트의 개념을 사용하여 Facebook 및 Instagram을 구축합니다.[PayPal, KhanAcademy 및 Flipkart](https://github.com/reactjs/redux/issues/310)  는 상태 관리를 위해 Redux를 사용합니다.\n\nAngular, React, Redux 및 Lodash는 JavaScript 생태계의 주요 프레임 워크이자 라이브러리이며, 모두 함수형 프로그래밍의 직접적인 영향을 받았습니다. Lodash 및 Redux의 경우 실제 JavaScript 애플리케이션에서 함수형 프로그래밍 패턴을 가능하게하는 목적을 가지고 제작되었습니다.\n\n\"어째서 JavaScript인가?\" JavaScript는 실제로 회사가 실제 소프트웨어를 만드는 데 사용하는 언어이기 때문에.  좋아하든 싫어하든, JavaScript는 수십 년 동안 지속되었던 Lisp의 \"가장 인기있는 함수형 프로그래밍 언어\"라는 타이틀을 빼앗았습니다.  사실, Haskell이 오늘날의 함수형 프로그래밍 개념에 훨씬 더 적합한 표준 무기이지만, 사람들은 하스켈로 실제 응용 프로그램을 거의 구축하지 않고 있습니다.\n\n언제나 미국에는 수십만 개의 JavaScript 일자리가 있으며, 전 세계적으로 수십만 가지가 있습니다.  하스켈을 배우는 것은 함수 프로그래밍에 대해 많은 것을 가르쳐 주지만, JavaScript를 배우는 것은 실제 직업을 위한 프로덕션 애플리케이션을 구축하는 것에 대해 가르쳐 줄 것입니다.\n\n> **앱은 세상을 먹었고 웹은 앱을 먹었고 JavaScript는 웹을 먹었습니다.**\n\n[**다음: 함수형 프로그래머를 위한 JavaScript 개요 >**](https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/)","slug":"why-learn-functional-programming-in-javascript","published":1,"updated":"2018-04-23T14:46:12.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgjh83er000zifp6jtvolntp","content":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  <a href=\"https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"><br>\n<em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/\"><em>&lt;이전</em></a>  <em>|</em>  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\"><em>&lt;&lt; Part 1에서 다시 시작</em></a>  <em>|</em>  <a href=\"https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/\"><em>다음&gt;</em></a></p>\n</blockquote>\n<p>그동안 JavaScript에 대해 가지고 있었던 생각들은 모두 잊어 버리고 초심자의 마음으로 이 글을 읽어주세요. JavaScript를 사용해 본 적 없는 이들을 위해 JavaScript의 기본 사항을 처음부터 다룰 것입니다.  당신이 초보자라면 행운입니다.  드디어 ES6 및 함수형 프로그래밍을 처음부터 다루는 글이 나왔습니다!  모든 새로운 개념에 대해 하나씩 알아볼 예정입니다. 그러나 너무 모든 것을 다 이해하려고 노력하지는 않아도 됩니다.</p>\n<p>JavaScript나 순수 함수 언어에 익숙한 노련한 개발자라면 어쩌면 JavaScript가 함수 프로그래밍을 탐구하기위한 재미있는 선택이라고 생각할 수도 있습니다.  그러한 생각을 잠깐 옆으로 두고 열린 마음으로 글을 읽어주세요.  JavaScript 프로그래밍에 또 다른 레벨이 있다는 것을 알 수 있습니다.  당신이 결코 알지 못했던 것이 있습니다.</p>\n<p>이 글은 &quot;소프트웨어 합성&quot;이라고 불리며, 함수형 프로그래밍이란 함수 합성, 고차 함수 등을 사용하여 소프트웨어를 작성하는 방법입니다. 왜 내가 하스켈, ClojureScript 또는 Elm 대신에 JavaScript를 택했는지 궁금해 할 수 있습니다.</p>\n<p>JavaScript는 함수형 프로그래밍에 필요한 가장 중요한 기능을 가지고 있습니다.</p>\n<ol>\n<li><strong>first class 함수 :</strong>  함수를 값으로 사용하는 기능 : 함수를 인수로 전달하고, 함수를 반환하고, 함수를 변수 및 객체 속성에 할당합니다. 이는 고차 함수<sup>high-order-function</sup>를 허용하여 부분 적용 <sup>partial</sup> <sup>application</sup>, currying 및 합성을 가능하게합니다.</li>\n<li><strong>익명 함수와 간결한 람다 구문 :</strong>  <code>x =&gt; x * 2</code>  는 JavaScript에서 유효한 함수 표현식입니다.  간결한 람다<sup>lambda</sup>는 고차원 함수로 작업하기가 더 쉽습니다.</li>\n<li><strong>클로저<sup>closure</sup> :</strong>  클로저는 어휘 스코프과 함수의 묶음입니다.  클로저는 함수가 만들어질 때 함께 만들어집니다.  함수가 다른 함수 내부에서 정의되면 외부 함수가 종료 된 후에도 외부 함수의 변수 바인딩에 액세스 할 수 있습니다.  클로저는 부분 적용에서 고정 된 인수를 얻는 방법입니다.  고정 인수는 반환된 함수의 클로저 범위에 바인딩 된 인수입니다.  <code>add2(1)(2)</code>  에서  <code>1</code>  은  <code>add2(1)</code>의해 리턴된 함수의 고정 인수입니다.</li>\n</ol>\n<h2 id=\"javascript가-놓치고-있는-것들\">JavaScript가 놓치고 있는 것들</h2>\n<p>JavaScript는여러 가지 스타일로 프로그래밍 할 수 있는 멀티 패러다임 언어입니다.  우리는 JavaScript로 절차적(명령형) 프로그래밍(C와 같은)을 할 수 있으며 이 때 함수란 반복적으로 호출 할 수있는 명령어의 서브 루틴을 나타냅니다. 함수가 아닌 객체가 기본 빌딩 블록인 객체지향 프로그래밍을 할 수 도 있으며 물론 당연히 함수형 프로그래밍도 가능합니다.  멀티 패러다임 언어의 단점은 절차적 및 객체 지향 방식의 프로그래밍으로 접근 할 경우 거의 모든 것이 변경 가능해야한다는 것을 암시하는 경향이 있다는 것입니다.</p>\n<p>변이<sup>mutation</sup>는 내부에서 일어나는 데이터 변화입니다.  예를 들자면 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;  </span><br><span class=\"line\">  bar: <span class=\"string\">'baz'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.bar = <span class=\"string\">'qux'</span>; <span class=\"comment\">// mutation</span></span><br></pre></td></tr></table></figure>\n<p>메소드는 객체의 속성을 업데이트하기 때문에 객체는 일반적으로 변경 가능해야 합니다. 명령형 프로그래밍에서 대부분의 자료 구조는 객체 및 배열을 효율적으로 조작 하기 위해 변경가능합니다.</p>\n<p>다음은 JavaScript에 없는 일부 함수형 언어의 특징입니다.</p>\n<ol>\n<li><strong>순수<sup>Purity</sup> :</strong>  일부 FP 언어에서는 순수성이 언어에 의해 시행됩니다.  부수효과가 발생할 수 있는 표현식은 허용되지 않습니다.</li>\n<li><strong>불변성<sup>Immutability</sup> :</strong>  일부 FP 언어는 변이를 금지합니다.  기존 데이터 구조 (예 : 배열 또는 객체)를 변경하는 대신 표현식은 새로운 데이터 구조를 생성합니다.  이것을 비효율적이라고 생각할 수 있지만 대부분의 함수형 언어의 기저에는 트라이<sup>trie</sup> 기반 데이터 구조가 있습니다. 즉, 이전 객체와 새 객체가 동일한 데이터에 대한 참조를 공유한다는 의미입니다.</li>\n<li><strong>재귀<sup>recursion</sup> :</strong>  재귀는 반복을 목적으로 함수를 참조하는 기능입니다.  많은 FP 언어에서 재귀는 반복작업을 수행 할 수있는 유일한 방법입니다.  <code>for</code>  ,  <code>while</code>  또는  <code>do</code>  루프와 같은 루프 문은 없습니다.<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></li>\n</ol>\n<p><strong>순수 :</strong>  JavaScript에서는 코딩 컨벤션으로 순수함을 달성해야합니다.  순수 함수로 응용 프로그램의 대부분을 작성하지 않으면 함수형 스타일로 프로그래밍했다고 할 수 없습니다. 유감스럽게도 JavaScript에서는 의도치 않게 불순한 함수를 작성하기 쉽습니다.</p>\n<p><strong>불변성 :</strong>  순수 함수형 언어에서 불변성이 종종 강요됩니다.  JavaScript는 대부분의 함수 언어에서 사용되는 효율적이고 불변의 트라이 기반 데이터 구조가 부족하지만  <a href=\"https://facebook.github.io/immutable-js/\" target=\"_blank\" rel=\"noopener\">Immutable.js</a>  와  <a href=\"https://github.com/swannodette/mori\" target=\"_blank\" rel=\"noopener\">Mori</a>등 이를 도와주는 라이브러리가 있습니다.  저는 향후 ECMAScript 스펙이 불변 데이터 구조를 지원해주길 바라고 있습니다.</p>\n<p>ES6에서  <code>const</code>  키워드를 추가한 것을 보면 가능성 있는 이야기 입니다.  <code>const</code>  로 선언된 변수에 다른 값을 재 할당 할 수 없습니다.  그러나 <code>const</code>  가 불변값을 뜻하는 것은 아닙니다.</p>\n<p><code>const</code> 로 선언된 변수에 완전히 다른 객체를 참조하기 위해 다시 할당 할 수는 없지만 참조하는 <em>객체의 속성</em> 이 변경 될 수 있습니다.  JavaScript는 또한 객체를  <code>freeze()</code>  수 있지만 그 객체는 루트 수준에서만 고정되어 있습니다. 즉, 중첩 된 객체의 속성은 변형 될 수 있습니다.  다시 말하자면 JavaScript에서 진정한 불변성을 보기 까지는 아직 갈 길이 멉니다.</p>\n<p><strong>재귀 :</strong>  JavaScript는 재귀를 지원하지만 대부분의 함수형 언어에는 꼬리 호출 최적화<sup>tail</sup> <sup>call</sup> <sup>optimization</sup>라는 기능이 있습니다.  꼬리 호출 최적화는 재귀 함수가 스택 프레임을 재사용하여 재귀호출을 할 수 있게 해주는 기능입니다.</p>\n<p>꼬리 호출 최적화가 없으면 스택이 계속 증가하여 스택 오버플로를 일으킬 수 있습니다.  JavaScript는 ES6 명세에서 꼬리 호출 최적화를 명시했습니다.  불행하게도 아직까지는 주요 브라우저 엔진 중 하나만이 이를 구현했으며, 최적화가 부분적으로 구현 된 후 Babel (구 브라우저에서 사용하기 위해 ES6에서 ES5로 컴파일하는 데 사용되는 가장 보편적 인 표준 JavaScript 컴파일러)에서 제거되었습니다.</p>\n<p>결론 : 꼬리 위치에서 함수를 주의해서 호출하더라도 대용량 반복에 대해 재귀를 사용하는 것은 여전히 ​​안전하지 않습니다.</p>\n<h2 id=\"javascript가-순수한-함수형-언어로서-부족한-점\">JavaScript가 순수한 함수형 언어로서 부족한 점</h2>\n<p>순수 주의자들은 자바 스크립트의 변이 가능성이 가장 큰 단점이라고 말합니다. 그러나 부수효과와 변이가 도움이 되는 경우가 있습니다.  사실, 부수효과 없이 쓸모있는 최신 응용 프로그램을 만드는 것은 불가능합니다.<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>  Haskell과 같은 순수 함수형 언어에서는 모나드<sup>monad</sup>라는 상자를 사용하여 부수효과를 순수 함수로 감쌉니다. 따라서 모나드가 나타내는 부수효과가 불명확하더라도 프로그램을 순수하게 유지할 수 있습니다.</p>\n<p>모나드의 사용법이 간단하더라도 모나드가 많은 사람들에게 익숙하지 않다는 문제점이 있습니다. 이를 처음 보는 사람에게 모나드가 무엇인지 설명하는 것은 색맹인 사람에게 &quot;푸른 색&quot;이 어떻게 보이는지 설명하는 것과 비슷합니다.</p>\n<blockquote>\n<p><em>“모나드는 endofunctor라는 범주에 속한 한 monoid에 불과해. 뭐가 문제야?” 제임스 아이리 (James Iry)는 필립 와들러 (Phillip Wadler)의 의역을 들먹이며 손더스 맥 레인 (Shanders Mac Lane)을 인용했다.</em>  <a href=\"http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html\" target=\"_blank\" rel=\"noopener\">“A Brief, Incomplete, and Mostly Wrong History of Programming Languages”</a></p>\n</blockquote>\n<p>일반적으로 패러디란 재미있는 부분을 더 재미있게 만들기 위해 과장하는 경향이 있습니다. 위의 인용문에서 모나드에 대한 설명은 실제로  <em>다음</em>  에 나오는 원래의 인용구에서  <em>단순화</em>  된 것 입니다.</p>\n<blockquote>\n<p><em>&quot;</em>  <code>x</code>  <em>의 모나드는</em><code>x</code>의 endofunctor라는 범주에 속한 한 monoid이다.  <code>×</code>의 연산은 endofunctor들의 조합과 항등 endofunctor의 단위로 구성된 일련의 연산 집합들로 치환 가능하다&quot;~ Saunders Mac Lane._  <a href=\"https://www.amazon.com/Categories-Working-Mathematician-Graduate-Mathematics/dp/0387984038//ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=de6f23899da4b5892f562413173be4f0\" target=\"_blank\" rel=\"noopener\"><em>“Categories for the Working Mathematician”</em></a></p>\n</blockquote>\n<p>그럼에도 불구하고, 전 모나드에 대한 두려움이 과장되어 있다고 생각합니다. 모나드를 배우는 가장 좋은 방법은 그 주제에 관한 책과 블로그 글을 읽지 않고, 바로 사용해 보는 것입니다. 함수형 프로그래밍의 다른 주제들과 마찬가지로, 학문적 어휘는 그것의 개념과 사용법보다 이해하기가 훨씬 어렵습니다. 믿어주세요. 함수형 프로그래밍을 하기 위해 손더스 맥 레인(Saunders Mac Lane)을 이해할 필요는 없습니다.</p>\n<p>모든 프로그래밍 스타일에 완전히 적합하다고 할 수는 없지만 JavaScript는 다양한 프로그래밍 스타일과 배경을 가진 사람들이 사용할 수 있도록 고안된 범용 언어입니다.</p>\n<p>이는 처음부터 의도된 것이라고 <a href=\"https://brendaneich.com/2008/04/popularity/\" target=\"_blank\" rel=\"noopener\">브랜던 아이크(Brendan Eich)</a>가 말했습니다. <sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>   Netscape는 두 종류의 프로그래머를 지원해야했습니다.</p>\n<blockquote>\n<p><em>&quot;… C ++ 또는 (우리가 희망하는) Java로 컴포넌트를 작성하는 프로그래머.</em>  <em>HTML에 직접 삽입 된 코드를 작성하는 ‘스크립터’, 아마추어 또는 프로. &quot;</em></p>\n</blockquote>\n<p>원래 Netscape는 두 가지 언어를 지원할 것이고 스크립트 언어는 아마도 Scheme (Lisp의 방언)과 비슷할 예정이었습니다.  브랜던 아이크 :</p>\n<blockquote>\n<p><em>“저는 넷플릭스에 채용될 때 브라우저에서 Scheme을 구현하는 계획을 맡게 됐습니다.”</em></p>\n</blockquote>\n<p>JavaScript는 새로운 언어여야 했습니다.</p>\n<blockquote>\n<p><em>&quot;엔지니어링 경영진의 요구사항은 '자바처럼 보일 것’이었습니다.  이는 Scheme과 함께 Perl, Python, Tcl을 배제하는 결과로 이어졌습니다. &quot;</em></p>\n</blockquote>\n<p>그 때 브랜던의 머리에서 나온 아이디어는 다음과 같습니다.</p>\n<ol>\n<li>브라우저에서 돌아가는 Scheme.</li>\n<li>자바처럼 보일 것.</li>\n</ol>\n<p>결국 잿더미가 되고 말았습니다.</p>\n<blockquote>\n<p><em>&quot;나는 자랑스럽지 않지만 Scheme스러운 first class 함수와 Self-ish (단 하나 임에도 불구하고) 프로토 타입을 이 언어의 특징으로 채택하게되어 기쁩니다. 자바의 영향, 특히 y2k 날짜 버그뿐만 아니라 원시타입와 객체의 구분 (예 : string 대 String)은 불행했습니다. &quot;</em></p>\n</blockquote>\n<p>여기에 Java와 유사한 &quot;불행한&quot;기능들을 추가하여 마침내 JavaScript가 됐습니다.</p>\n<p>불행한 기능들:</p>\n<ul>\n<li>생성자 함수 및 <code>new</code> 키워드는 팩토리 함수와 동일한 일을 하기 위해 다른 호출 방식과 문법을 사용하게 합니다.</li>\n<li><code>class</code>  키워드는 단일 조상으로부터 <code>extend</code> 하는 기본 상속 메커니즘입니다.</li>\n<li>많은 이들이  <code>class</code>  를 정적 타입인 것처럼 생각하는 경향이 있습니다 (그렇지 않습니다).</li>\n</ul>\n<p>충고를 드리자면: 가능한 사용하지 마세요.</p>\n<p>오늘날 Java, Flash 및 ActiveX 확장 프로그램은 대부분의 브라우저에서 더이상 지원되지 않습니다. 즉 스크립팅 방식이 &quot;컴포넌트&quot;접근 방식 보다 우위를 점하는 것으로 밝혀 졌고 JavaScript는 유연한 언어가 되었습니다.</p>\n<p>결국 JavaScript는 브라우저에서 직접 지원하는 유일한 언어가 되었습니다.</p>\n<p>브라우저는 JavaScript라는 단일 언어 바인딩 만 지원하기 때문에 덜 비대해지고 버그가 적어졌습니다.  WebAssembly가 예외라고 생각할 수도 있지만 WebAssembly의 디자인 목표 중 하나는 호환 가능한 추상 구문 트리 (AST)를 사용하여 JavaScript의 언어 바인딩을 공유하는 것입니다.  실제로 첫 번째 데모에서는 WebAssembly를 ASM.js라는 JavaScript의 하위 집합으로 컴파일했습니다.</p>\n<p>웹 플랫폼을 위한 유일한 표준 범용 프로그래밍 언어로서의 위치는 JavaScript가 소프트웨어 역사상 가장 큰 인기의 물결을 탈 수 있게 해 주었습니다.</p>\n<p><strong>앱은 세상을 먹었고 웹은 앱을 먹었고 JavaScript는 웹을 먹었습니다.</strong></p>\n<blockquote>\n<p>Apps ate the world, the web ate apps, and JavaScript ate the web.</p>\n</blockquote>\n<p><a href=\"http://redmonk.com/sogrady/2016/07/20/language-rankings-6-16/\" target=\"_blank\" rel=\"noopener\">많은</a>  <a href=\"http://stackoverflow.com/research/developer-survey-2016\" target=\"_blank\" rel=\"noopener\">통계에</a>  따르면  <a href=\"https://octoverse.github.com/\" target=\"_blank\" rel=\"noopener\">JavaScript</a>  는 현재 세계에서 가장 인기있는 프로그래밍 언어입니다.</p>\n<p>자바 스크립트는 함수형 프로그래밍을위한 이상적인 도구는 아니지만 규모가 크고 분산 된 팀에서 대규모 응용 프로그램을 작성하기 위한 훌륭한 도구입니다. 서로 다른 팀에서는 응용 프로그램을 작성하는 방법에 대한 아이디어가 다를 수 있습니다.</p>\n<p>스크립팅을 주로 하는 팀은 명령형 프로그래밍을 사용해 모듈을 붙이는데 집중할 수 있습니다.  다른 사람들은 아키텍처 추상화에 집중할 수 있습니다. 이 때는 (신중한) 객체 지향적 접근방식이 괜찮은 방법일 수도 있습니다.  또 다른 사람들은 함수형 프로그래밍을 채택해 순수 함수를 사용하여 응용 프로그램 상태를 결정적인 동시에 테스트 가능하도록 관리하고 사용자의 작업을 줄입니다.  이러한 팀들의 구성원은 모두 같은 언어를 사용하므로 서로 쉽게 아이디어를 교환하고 서로에게서 배우며 서로의 작업을 도와줄 수 있습니다.</p>\n<p>JavaScript에서는 이러한 모든 아이디어가 공존 할 수 있습니다. 따라서 더 많은 사람들이 JavaScript를 채택 하게 되었고 이는 <a href=\"http://www.modulecounts.com/\" target=\"_blank\" rel=\"noopener\">세계에서 가장 큰 오픈 소스 패키지 저장소</a>  (2017년 2월),  <a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">npm</a>의 등장으로 이어졌습니다 .</p>\n<p>JavaScript의 진정한 강점은 다양한 사고방식을 가진 사용자가 함께 있는 생태계입니다.  순수 함수형 프로그래밍주의자들을 위한 이상적인 언어는 아닐지라도 Java, Lisp, C와 같은 대중적인 언어에서 온 사람들이 모든 플랫폼에서 작동하는 동일한 문법을 사용하여 함께 작업하기에 이상적인 언어일 수 있습니다. JavaScript는 그러한 배경을 가진 사람들에게 이상적일 만큼 편하지는 않지만 언어를 배우고 빠르게 생산적이 될  만큼 편합니다.</p>\n<p>저는 JavaScript가 함수형 프로그래머를위한 최고의 언어가 아니라는 것에 동의합니다.  그러나 다른 모든 함수형 언어는 누구나 이해하고 사용할 수 있다고 말할 수 없으며 JavaScript는 ES6에서 함수형 프로그래밍에 관심이있는 사용자의 요구에 부응 할 수 있음을 보여줬고 점차 나아질 것입니다. 전 세계의 거의 모든 회사에서 사용하는 JavaScript와 놀라운 생태계를 포기하지 마십시오, 이를 포용해서 소프트웨어 구성을 위한 더 나은 언어를 만들어 가는게 좋지 않을까요?</p>\n<p>JavaScript는 이미 함수형 프로그래밍 언어로  <em>충분</em>  합니다. 즉, 사람들은 함수형 프로그래밍 기술을 사용하여 JavaScript에서 유용하고 흥미로운 모든 것을 구축하고 있습니다.  Netflix (및 Angular 2+로 작성된 모든 앱)는 RxJS 기반의 함수형 유틸리티를 사용합니다.  <a href=\"https://github.com/facebook/react/wiki/sites-using-react\" target=\"_blank\" rel=\"noopener\">Facebook</a>  은 React의 순수 함수, 고차 함수 및 고차원 컴포넌트의 개념을 사용하여 Facebook 및 Instagram을 구축합니다.<a href=\"https://github.com/reactjs/redux/issues/310\" target=\"_blank\" rel=\"noopener\">PayPal, KhanAcademy 및 Flipkart</a>  는 상태 관리를 위해 Redux를 사용합니다.</p>\n<p>Angular, React, Redux 및 Lodash는 JavaScript 생태계의 주요 프레임 워크이자 라이브러리이며, 모두 함수형 프로그래밍의 직접적인 영향을 받았습니다. Lodash 및 Redux의 경우 실제 JavaScript 애플리케이션에서 함수형 프로그래밍 패턴을 가능하게하는 목적을 가지고 제작되었습니다.</p>\n<p>“어째서 JavaScript인가?” JavaScript는 실제로 회사가 실제 소프트웨어를 만드는 데 사용하는 언어이기 때문에.  좋아하든 싫어하든, JavaScript는 수십 년 동안 지속되었던 Lisp의 &quot;가장 인기있는 함수형 프로그래밍 언어&quot;라는 타이틀을 빼앗았습니다.  사실, Haskell이 오늘날의 함수형 프로그래밍 개념에 훨씬 더 적합한 표준 무기이지만, 사람들은 하스켈로 실제 응용 프로그램을 거의 구축하지 않고 있습니다.</p>\n<p>언제나 미국에는 수십만 개의 JavaScript 일자리가 있으며, 전 세계적으로 수십만 가지가 있습니다.  하스켈을 배우는 것은 함수 프로그래밍에 대해 많은 것을 가르쳐 주지만, JavaScript를 배우는 것은 실제 직업을 위한 프로덕션 애플리케이션을 구축하는 것에 대해 가르쳐 줄 것입니다.</p>\n<blockquote>\n<p><strong>앱은 세상을 먹었고 웹은 앱을 먹었고 JavaScript는 웹을 먹었습니다.</strong></p>\n</blockquote>\n<p><a href=\"https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/\"><strong>다음: 함수형 프로그래머를 위한 JavaScript 개요 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>JavaScript로 재귀적 코드를 작성할 수 없다는 것이 아닌 재귀만을 사용해 반복적인 작업을 수행해야 하는 제약이 없다는 뜻입니다. <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>입출력이 가장 근본적인 부수효과이기 때문입니다 <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>브랜던 아이크는 자바스크립트를 만든 프로그래머입니다 <a href=\"#fnref3\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>이 글은  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한  것입니다.  <a href=\"https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257\" target=\"_blank\" rel=\"noopener\">[원문보기]</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg\" alt=\"\"><br>\n<em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>\n<blockquote>\n<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>\n<a href=\"https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/\"><em>&lt;이전</em></a>  <em>|</em>  <a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\"><em>&lt;&lt; Part 1에서 다시 시작</em></a>  <em>|</em>  <a href=\"https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/\"><em>다음&gt;</em></a></p>\n</blockquote>\n<p>그동안 JavaScript에 대해 가지고 있었던 생각들은 모두 잊어 버리고 초심자의 마음으로 이 글을 읽어주세요. JavaScript를 사용해 본 적 없는 이들을 위해 JavaScript의 기본 사항을 처음부터 다룰 것입니다.  당신이 초보자라면 행운입니다.  드디어 ES6 및 함수형 프로그래밍을 처음부터 다루는 글이 나왔습니다!  모든 새로운 개념에 대해 하나씩 알아볼 예정입니다. 그러나 너무 모든 것을 다 이해하려고 노력하지는 않아도 됩니다.</p>\n<p>JavaScript나 순수 함수 언어에 익숙한 노련한 개발자라면 어쩌면 JavaScript가 함수 프로그래밍을 탐구하기위한 재미있는 선택이라고 생각할 수도 있습니다.  그러한 생각을 잠깐 옆으로 두고 열린 마음으로 글을 읽어주세요.  JavaScript 프로그래밍에 또 다른 레벨이 있다는 것을 알 수 있습니다.  당신이 결코 알지 못했던 것이 있습니다.</p>\n<p>이 글은 &quot;소프트웨어 합성&quot;이라고 불리며, 함수형 프로그래밍이란 함수 합성, 고차 함수 등을 사용하여 소프트웨어를 작성하는 방법입니다. 왜 내가 하스켈, ClojureScript 또는 Elm 대신에 JavaScript를 택했는지 궁금해 할 수 있습니다.</p>\n<p>JavaScript는 함수형 프로그래밍에 필요한 가장 중요한 기능을 가지고 있습니다.</p>\n<ol>\n<li><strong>first class 함수 :</strong>  함수를 값으로 사용하는 기능 : 함수를 인수로 전달하고, 함수를 반환하고, 함수를 변수 및 객체 속성에 할당합니다. 이는 고차 함수<sup>high-order-function</sup>를 허용하여 부분 적용 <sup>partial</sup> <sup>application</sup>, currying 및 합성을 가능하게합니다.</li>\n<li><strong>익명 함수와 간결한 람다 구문 :</strong>  <code>x =&gt; x * 2</code>  는 JavaScript에서 유효한 함수 표현식입니다.  간결한 람다<sup>lambda</sup>는 고차원 함수로 작업하기가 더 쉽습니다.</li>\n<li><strong>클로저<sup>closure</sup> :</strong>  클로저는 어휘 스코프과 함수의 묶음입니다.  클로저는 함수가 만들어질 때 함께 만들어집니다.  함수가 다른 함수 내부에서 정의되면 외부 함수가 종료 된 후에도 외부 함수의 변수 바인딩에 액세스 할 수 있습니다.  클로저는 부분 적용에서 고정 된 인수를 얻는 방법입니다.  고정 인수는 반환된 함수의 클로저 범위에 바인딩 된 인수입니다.  <code>add2(1)(2)</code>  에서  <code>1</code>  은  <code>add2(1)</code>의해 리턴된 함수의 고정 인수입니다.</li>\n</ol>\n<h2>JavaScript가 놓치고 있는 것들</h2>\n<p>JavaScript는여러 가지 스타일로 프로그래밍 할 수 있는 멀티 패러다임 언어입니다.  우리는 JavaScript로 절차적(명령형) 프로그래밍(C와 같은)을 할 수 있으며 이 때 함수란 반복적으로 호출 할 수있는 명령어의 서브 루틴을 나타냅니다. 함수가 아닌 객체가 기본 빌딩 블록인 객체지향 프로그래밍을 할 수 도 있으며 물론 당연히 함수형 프로그래밍도 가능합니다.  멀티 패러다임 언어의 단점은 절차적 및 객체 지향 방식의 프로그래밍으로 접근 할 경우 거의 모든 것이 변경 가능해야한다는 것을 암시하는 경향이 있다는 것입니다.</p>\n<p>변이<sup>mutation</sup>는 내부에서 일어나는 데이터 변화입니다.  예를 들자면 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;  </span><br><span class=\"line\">  bar: <span class=\"string\">'baz'</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.bar = <span class=\"string\">'qux'</span>; <span class=\"comment\">// mutation</span></span><br></pre></td></tr></table></figure>\n<p>메소드는 객체의 속성을 업데이트하기 때문에 객체는 일반적으로 변경 가능해야 합니다. 명령형 프로그래밍에서 대부분의 자료 구조는 객체 및 배열을 효율적으로 조작 하기 위해 변경가능합니다.</p>\n<p>다음은 JavaScript에 없는 일부 함수형 언어의 특징입니다.</p>\n<ol>\n<li><strong>순수<sup>Purity</sup> :</strong>  일부 FP 언어에서는 순수성이 언어에 의해 시행됩니다.  부수효과가 발생할 수 있는 표현식은 허용되지 않습니다.</li>\n<li><strong>불변성<sup>Immutability</sup> :</strong>  일부 FP 언어는 변이를 금지합니다.  기존 데이터 구조 (예 : 배열 또는 객체)를 변경하는 대신 표현식은 새로운 데이터 구조를 생성합니다.  이것을 비효율적이라고 생각할 수 있지만 대부분의 함수형 언어의 기저에는 트라이<sup>trie</sup> 기반 데이터 구조가 있습니다. 즉, 이전 객체와 새 객체가 동일한 데이터에 대한 참조를 공유한다는 의미입니다.</li>\n<li><strong>재귀<sup>recursion</sup> :</strong>  재귀는 반복을 목적으로 함수를 참조하는 기능입니다.  많은 FP 언어에서 재귀는 반복작업을 수행 할 수있는 유일한 방법입니다.  <code>for</code>  ,  <code>while</code>  또는  <code>do</code>  루프와 같은 루프 문은 없습니다.<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></li>\n</ol>\n<p><strong>순수 :</strong>  JavaScript에서는 코딩 컨벤션으로 순수함을 달성해야합니다.  순수 함수로 응용 프로그램의 대부분을 작성하지 않으면 함수형 스타일로 프로그래밍했다고 할 수 없습니다. 유감스럽게도 JavaScript에서는 의도치 않게 불순한 함수를 작성하기 쉽습니다.</p>\n<p><strong>불변성 :</strong>  순수 함수형 언어에서 불변성이 종종 강요됩니다.  JavaScript는 대부분의 함수 언어에서 사용되는 효율적이고 불변의 트라이 기반 데이터 구조가 부족하지만  <a href=\"https://facebook.github.io/immutable-js/\" target=\"_blank\" rel=\"noopener\">Immutable.js</a>  와  <a href=\"https://github.com/swannodette/mori\" target=\"_blank\" rel=\"noopener\">Mori</a>등 이를 도와주는 라이브러리가 있습니다.  저는 향후 ECMAScript 스펙이 불변 데이터 구조를 지원해주길 바라고 있습니다.</p>\n<p>ES6에서  <code>const</code>  키워드를 추가한 것을 보면 가능성 있는 이야기 입니다.  <code>const</code>  로 선언된 변수에 다른 값을 재 할당 할 수 없습니다.  그러나 <code>const</code>  가 불변값을 뜻하는 것은 아닙니다.</p>\n<p><code>const</code> 로 선언된 변수에 완전히 다른 객체를 참조하기 위해 다시 할당 할 수는 없지만 참조하는 <em>객체의 속성</em> 이 변경 될 수 있습니다.  JavaScript는 또한 객체를  <code>freeze()</code>  수 있지만 그 객체는 루트 수준에서만 고정되어 있습니다. 즉, 중첩 된 객체의 속성은 변형 될 수 있습니다.  다시 말하자면 JavaScript에서 진정한 불변성을 보기 까지는 아직 갈 길이 멉니다.</p>\n<p><strong>재귀 :</strong>  JavaScript는 재귀를 지원하지만 대부분의 함수형 언어에는 꼬리 호출 최적화<sup>tail</sup> <sup>call</sup> <sup>optimization</sup>라는 기능이 있습니다.  꼬리 호출 최적화는 재귀 함수가 스택 프레임을 재사용하여 재귀호출을 할 수 있게 해주는 기능입니다.</p>\n<p>꼬리 호출 최적화가 없으면 스택이 계속 증가하여 스택 오버플로를 일으킬 수 있습니다.  JavaScript는 ES6 명세에서 꼬리 호출 최적화를 명시했습니다.  불행하게도 아직까지는 주요 브라우저 엔진 중 하나만이 이를 구현했으며, 최적화가 부분적으로 구현 된 후 Babel (구 브라우저에서 사용하기 위해 ES6에서 ES5로 컴파일하는 데 사용되는 가장 보편적 인 표준 JavaScript 컴파일러)에서 제거되었습니다.</p>\n<p>결론 : 꼬리 위치에서 함수를 주의해서 호출하더라도 대용량 반복에 대해 재귀를 사용하는 것은 여전히 ​​안전하지 않습니다.</p>\n<h2>JavaScript가 순수한 함수형 언어로서 부족한 점</h2>\n<p>순수 주의자들은 자바 스크립트의 변이 가능성이 가장 큰 단점이라고 말합니다. 그러나 부수효과와 변이가 도움이 되는 경우가 있습니다.  사실, 부수효과 없이 쓸모있는 최신 응용 프로그램을 만드는 것은 불가능합니다.<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>  Haskell과 같은 순수 함수형 언어에서는 모나드<sup>monad</sup>라는 상자를 사용하여 부수효과를 순수 함수로 감쌉니다. 따라서 모나드가 나타내는 부수효과가 불명확하더라도 프로그램을 순수하게 유지할 수 있습니다.</p>\n<p>모나드의 사용법이 간단하더라도 모나드가 많은 사람들에게 익숙하지 않다는 문제점이 있습니다. 이를 처음 보는 사람에게 모나드가 무엇인지 설명하는 것은 색맹인 사람에게 &quot;푸른 색&quot;이 어떻게 보이는지 설명하는 것과 비슷합니다.</p>\n<blockquote>\n<p><em>“모나드는 endofunctor라는 범주에 속한 한 monoid에 불과해. 뭐가 문제야?” 제임스 아이리 (James Iry)는 필립 와들러 (Phillip Wadler)의 의역을 들먹이며 손더스 맥 레인 (Shanders Mac Lane)을 인용했다.</em>  <a href=\"http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html\" target=\"_blank\" rel=\"noopener\">“A Brief, Incomplete, and Mostly Wrong History of Programming Languages”</a></p>\n</blockquote>\n<p>일반적으로 패러디란 재미있는 부분을 더 재미있게 만들기 위해 과장하는 경향이 있습니다. 위의 인용문에서 모나드에 대한 설명은 실제로  <em>다음</em>  에 나오는 원래의 인용구에서  <em>단순화</em>  된 것 입니다.</p>\n<blockquote>\n<p><em>&quot;</em>  <code>x</code>  <em>의 모나드는</em><code>x</code>의 endofunctor라는 범주에 속한 한 monoid이다.  <code>×</code>의 연산은 endofunctor들의 조합과 항등 endofunctor의 단위로 구성된 일련의 연산 집합들로 치환 가능하다&quot;~ Saunders Mac Lane._  <a href=\"https://www.amazon.com/Categories-Working-Mathematician-Graduate-Mathematics/dp/0387984038//ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=de6f23899da4b5892f562413173be4f0\" target=\"_blank\" rel=\"noopener\"><em>“Categories for the Working Mathematician”</em></a></p>\n</blockquote>\n<p>그럼에도 불구하고, 전 모나드에 대한 두려움이 과장되어 있다고 생각합니다. 모나드를 배우는 가장 좋은 방법은 그 주제에 관한 책과 블로그 글을 읽지 않고, 바로 사용해 보는 것입니다. 함수형 프로그래밍의 다른 주제들과 마찬가지로, 학문적 어휘는 그것의 개념과 사용법보다 이해하기가 훨씬 어렵습니다. 믿어주세요. 함수형 프로그래밍을 하기 위해 손더스 맥 레인(Saunders Mac Lane)을 이해할 필요는 없습니다.</p>\n<p>모든 프로그래밍 스타일에 완전히 적합하다고 할 수는 없지만 JavaScript는 다양한 프로그래밍 스타일과 배경을 가진 사람들이 사용할 수 있도록 고안된 범용 언어입니다.</p>\n<p>이는 처음부터 의도된 것이라고 <a href=\"https://brendaneich.com/2008/04/popularity/\" target=\"_blank\" rel=\"noopener\">브랜던 아이크(Brendan Eich)</a>가 말했습니다. <sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>   Netscape는 두 종류의 프로그래머를 지원해야했습니다.</p>\n<blockquote>\n<p><em>&quot;… C ++ 또는 (우리가 희망하는) Java로 컴포넌트를 작성하는 프로그래머.</em>  <em>HTML에 직접 삽입 된 코드를 작성하는 ‘스크립터’, 아마추어 또는 프로. &quot;</em></p>\n</blockquote>\n<p>원래 Netscape는 두 가지 언어를 지원할 것이고 스크립트 언어는 아마도 Scheme (Lisp의 방언)과 비슷할 예정이었습니다.  브랜던 아이크 :</p>\n<blockquote>\n<p><em>“저는 넷플릭스에 채용될 때 브라우저에서 Scheme을 구현하는 계획을 맡게 됐습니다.”</em></p>\n</blockquote>\n<p>JavaScript는 새로운 언어여야 했습니다.</p>\n<blockquote>\n<p><em>&quot;엔지니어링 경영진의 요구사항은 '자바처럼 보일 것’이었습니다.  이는 Scheme과 함께 Perl, Python, Tcl을 배제하는 결과로 이어졌습니다. &quot;</em></p>\n</blockquote>\n<p>그 때 브랜던의 머리에서 나온 아이디어는 다음과 같습니다.</p>\n<ol>\n<li>브라우저에서 돌아가는 Scheme.</li>\n<li>자바처럼 보일 것.</li>\n</ol>\n<p>결국 잿더미가 되고 말았습니다.</p>\n<blockquote>\n<p><em>&quot;나는 자랑스럽지 않지만 Scheme스러운 first class 함수와 Self-ish (단 하나 임에도 불구하고) 프로토 타입을 이 언어의 특징으로 채택하게되어 기쁩니다. 자바의 영향, 특히 y2k 날짜 버그뿐만 아니라 원시타입와 객체의 구분 (예 : string 대 String)은 불행했습니다. &quot;</em></p>\n</blockquote>\n<p>여기에 Java와 유사한 &quot;불행한&quot;기능들을 추가하여 마침내 JavaScript가 됐습니다.</p>\n<p>불행한 기능들:</p>\n<ul>\n<li>생성자 함수 및 <code>new</code> 키워드는 팩토리 함수와 동일한 일을 하기 위해 다른 호출 방식과 문법을 사용하게 합니다.</li>\n<li><code>class</code>  키워드는 단일 조상으로부터 <code>extend</code> 하는 기본 상속 메커니즘입니다.</li>\n<li>많은 이들이  <code>class</code>  를 정적 타입인 것처럼 생각하는 경향이 있습니다 (그렇지 않습니다).</li>\n</ul>\n<p>충고를 드리자면: 가능한 사용하지 마세요.</p>\n<p>오늘날 Java, Flash 및 ActiveX 확장 프로그램은 대부분의 브라우저에서 더이상 지원되지 않습니다. 즉 스크립팅 방식이 &quot;컴포넌트&quot;접근 방식 보다 우위를 점하는 것으로 밝혀 졌고 JavaScript는 유연한 언어가 되었습니다.</p>\n<p>결국 JavaScript는 브라우저에서 직접 지원하는 유일한 언어가 되었습니다.</p>\n<p>브라우저는 JavaScript라는 단일 언어 바인딩 만 지원하기 때문에 덜 비대해지고 버그가 적어졌습니다.  WebAssembly가 예외라고 생각할 수도 있지만 WebAssembly의 디자인 목표 중 하나는 호환 가능한 추상 구문 트리 (AST)를 사용하여 JavaScript의 언어 바인딩을 공유하는 것입니다.  실제로 첫 번째 데모에서는 WebAssembly를 ASM.js라는 JavaScript의 하위 집합으로 컴파일했습니다.</p>\n<p>웹 플랫폼을 위한 유일한 표준 범용 프로그래밍 언어로서의 위치는 JavaScript가 소프트웨어 역사상 가장 큰 인기의 물결을 탈 수 있게 해 주었습니다.</p>\n<p><strong>앱은 세상을 먹었고 웹은 앱을 먹었고 JavaScript는 웹을 먹었습니다.</strong></p>\n<blockquote>\n<p>Apps ate the world, the web ate apps, and JavaScript ate the web.</p>\n</blockquote>\n<p><a href=\"http://redmonk.com/sogrady/2016/07/20/language-rankings-6-16/\" target=\"_blank\" rel=\"noopener\">많은</a>  <a href=\"http://stackoverflow.com/research/developer-survey-2016\" target=\"_blank\" rel=\"noopener\">통계에</a>  따르면  <a href=\"https://octoverse.github.com/\" target=\"_blank\" rel=\"noopener\">JavaScript</a>  는 현재 세계에서 가장 인기있는 프로그래밍 언어입니다.</p>\n<p>자바 스크립트는 함수형 프로그래밍을위한 이상적인 도구는 아니지만 규모가 크고 분산 된 팀에서 대규모 응용 프로그램을 작성하기 위한 훌륭한 도구입니다. 서로 다른 팀에서는 응용 프로그램을 작성하는 방법에 대한 아이디어가 다를 수 있습니다.</p>\n<p>스크립팅을 주로 하는 팀은 명령형 프로그래밍을 사용해 모듈을 붙이는데 집중할 수 있습니다.  다른 사람들은 아키텍처 추상화에 집중할 수 있습니다. 이 때는 (신중한) 객체 지향적 접근방식이 괜찮은 방법일 수도 있습니다.  또 다른 사람들은 함수형 프로그래밍을 채택해 순수 함수를 사용하여 응용 프로그램 상태를 결정적인 동시에 테스트 가능하도록 관리하고 사용자의 작업을 줄입니다.  이러한 팀들의 구성원은 모두 같은 언어를 사용하므로 서로 쉽게 아이디어를 교환하고 서로에게서 배우며 서로의 작업을 도와줄 수 있습니다.</p>\n<p>JavaScript에서는 이러한 모든 아이디어가 공존 할 수 있습니다. 따라서 더 많은 사람들이 JavaScript를 채택 하게 되었고 이는 <a href=\"http://www.modulecounts.com/\" target=\"_blank\" rel=\"noopener\">세계에서 가장 큰 오픈 소스 패키지 저장소</a>  (2017년 2월),  <a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">npm</a>의 등장으로 이어졌습니다 .</p>\n<p>JavaScript의 진정한 강점은 다양한 사고방식을 가진 사용자가 함께 있는 생태계입니다.  순수 함수형 프로그래밍주의자들을 위한 이상적인 언어는 아닐지라도 Java, Lisp, C와 같은 대중적인 언어에서 온 사람들이 모든 플랫폼에서 작동하는 동일한 문법을 사용하여 함께 작업하기에 이상적인 언어일 수 있습니다. JavaScript는 그러한 배경을 가진 사람들에게 이상적일 만큼 편하지는 않지만 언어를 배우고 빠르게 생산적이 될  만큼 편합니다.</p>\n<p>저는 JavaScript가 함수형 프로그래머를위한 최고의 언어가 아니라는 것에 동의합니다.  그러나 다른 모든 함수형 언어는 누구나 이해하고 사용할 수 있다고 말할 수 없으며 JavaScript는 ES6에서 함수형 프로그래밍에 관심이있는 사용자의 요구에 부응 할 수 있음을 보여줬고 점차 나아질 것입니다. 전 세계의 거의 모든 회사에서 사용하는 JavaScript와 놀라운 생태계를 포기하지 마십시오, 이를 포용해서 소프트웨어 구성을 위한 더 나은 언어를 만들어 가는게 좋지 않을까요?</p>\n<p>JavaScript는 이미 함수형 프로그래밍 언어로  <em>충분</em>  합니다. 즉, 사람들은 함수형 프로그래밍 기술을 사용하여 JavaScript에서 유용하고 흥미로운 모든 것을 구축하고 있습니다.  Netflix (및 Angular 2+로 작성된 모든 앱)는 RxJS 기반의 함수형 유틸리티를 사용합니다.  <a href=\"https://github.com/facebook/react/wiki/sites-using-react\" target=\"_blank\" rel=\"noopener\">Facebook</a>  은 React의 순수 함수, 고차 함수 및 고차원 컴포넌트의 개념을 사용하여 Facebook 및 Instagram을 구축합니다.<a href=\"https://github.com/reactjs/redux/issues/310\" target=\"_blank\" rel=\"noopener\">PayPal, KhanAcademy 및 Flipkart</a>  는 상태 관리를 위해 Redux를 사용합니다.</p>\n<p>Angular, React, Redux 및 Lodash는 JavaScript 생태계의 주요 프레임 워크이자 라이브러리이며, 모두 함수형 프로그래밍의 직접적인 영향을 받았습니다. Lodash 및 Redux의 경우 실제 JavaScript 애플리케이션에서 함수형 프로그래밍 패턴을 가능하게하는 목적을 가지고 제작되었습니다.</p>\n<p>“어째서 JavaScript인가?” JavaScript는 실제로 회사가 실제 소프트웨어를 만드는 데 사용하는 언어이기 때문에.  좋아하든 싫어하든, JavaScript는 수십 년 동안 지속되었던 Lisp의 &quot;가장 인기있는 함수형 프로그래밍 언어&quot;라는 타이틀을 빼앗았습니다.  사실, Haskell이 오늘날의 함수형 프로그래밍 개념에 훨씬 더 적합한 표준 무기이지만, 사람들은 하스켈로 실제 응용 프로그램을 거의 구축하지 않고 있습니다.</p>\n<p>언제나 미국에는 수십만 개의 JavaScript 일자리가 있으며, 전 세계적으로 수십만 가지가 있습니다.  하스켈을 배우는 것은 함수 프로그래밍에 대해 많은 것을 가르쳐 주지만, JavaScript를 배우는 것은 실제 직업을 위한 프로덕션 애플리케이션을 구축하는 것에 대해 가르쳐 줄 것입니다.</p>\n<blockquote>\n<p><strong>앱은 세상을 먹었고 웹은 앱을 먹었고 JavaScript는 웹을 먹었습니다.</strong></p>\n</blockquote>\n<p><a href=\"https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/\"><strong>다음: 함수형 프로그래머를 위한 JavaScript 개요 &gt;</strong></a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>JavaScript로 재귀적 코드를 작성할 수 없다는 것이 아닌 재귀만을 사용해 반복적인 작업을 수행해야 하는 제약이 없다는 뜻입니다. <a href=\"#fnref1\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>입출력이 가장 근본적인 부수효과이기 때문입니다 <a href=\"#fnref2\" class=\"footnote-backref\">↩</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>브랜던 아이크는 자바스크립트를 만든 프로그래머입니다 <a href=\"#fnref3\" class=\"footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>\n"},{"title":"소프트웨어 합성 Index 및 번역후기","catalog":true,"date":"2018-04-28T05:21:32.000Z","subtitle":"Translation Epilogue","header-img":"bg.jpg","readingTime":2,"catagories":["개발"],"preview":"함수형 자바스크립트를 주제로  Eric Elliott이 medium에서 연재하는 시리즈입니다.  배열 연산, 대수적 자료구조 등 특정 주제에 초점을 맞춘 tips & tricks 이 아닌 좀 더 넓은 관점에서 함수형 패러다임을 조망하고 있으며 특히 소프트웨어 개발에서 마주칠 수 있는 많은 주제들을 합성Composition의 맥락으로 풀어내었습니다. 특히 객체지향 및 절차지향 패러다임의 부족한 점과 이를 함수형 패러다임으로 극복할 수 있는 전략을 여러장에 걸쳐 개관하는 점에 있어서 자바스크립트가 주요 언어가 아닌 독자들도 새로운 소프트웨어 설계 전략을 세울 때 참고하기 괜찮은 시리즈입니다.","_content":"\n## 소프트웨어 합성 시리즈란?\n\n함수형 자바스크립트를 주제로  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup)이 **medium**에서 연재하는 시리즈입니다.  배열 연산, 대수적 자료구조 등 특정 주제에 초점을 맞춘 _tips & tricks_ 이 아닌 좀 더 넓은 관점에서 함수형 패러다임을 조망하고 있으며 소프트웨어 개발에서 마주칠 수 있는 많은 주제들을 **합성**^Composition^의 맥락으로 풀어내었습니다. \n\n특히 객체지향 및 절차지향 패러다임의 부족한 점과 이를 함수형 패러다임으로 극복할 수 있는 전략을 여러장에 걸쳐 개관하기 때문에 자바스크립트가 주요 언어가 아닌 독자들도 새로운 소프트웨어 설계 전략을 세울 때 참고하기 괜찮은 시리즈입니다.  \n\n\n## Index\n\n1. [소프트웨어 합성 : 개요](https://midojeong.github.io/2018/03/16/composing-software-intro/)\n2. [함수형 프로그래밍의 역사 ](https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/)\n3. [왜 JavaScript로 함수형 프로그래밍을 배우는가?](https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/)\n4. [함수형 프로그래머를 위한 JavaScript 개요](https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/)\n5. [고차 함수](https://midojeong.github.io/2018/03/29/higher-order-functions/)\n6. [Reduce](https://midojeong.github.io/2018/03/31/reduce/)\n7. [Functor와 카테고리](https://midojeong.github.io/2018/04/07/functors-and-categories/)\n8. [함수형 믹스인](https://midojeong.github.io/2018/04/07/functional-mixins/)\n9. [ES6+와 팩토리 함수](https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/)\n10. [클래스로 합성하기가 까다로운 이유](https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/)\n11. [함수형 자료구조](https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/)\n12. [JavaScript 모나드](https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/)\n13. [Mocking은 코드 냄새(Code Smell)입니다](https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/)\n14. [객체 합성이라는 숨겨진 보물](https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/)\n15. [삼항연산자의 멋짐을 모르는 당신이 불쌍해](https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/)\n16. [합성과 추상화](https://midojeong.github.io/2018/04/26/abstraction-and-composition/)\n\n\n## 번역 후기\n\n함수형 프로그래밍을 공부하다가 이 시리즈를 읽게되었고 네 편째 읽는 동안 이 글을 번역해야겠다는 생각이 떠올랐습니다. 곧 바로 에디터를 열어 한 문장씩 한글로 옮기기 시작했으나 약 118페이지(165,113자) 정도의 분량을 마치는데는 적지 않은 시간이 걸린 것 같습니다. 명료한 표현들과 독자 친화적 구성으로 쓰인 Eric Elliot의 글을 읽다보면 이를 빠짐없이 옮겨 담기엔 역자의 실력이 많이 부족했음을 느낍니다.  \n\n용어 선택과 번역의 질에 있어서 미흡한 점이 보일 경우 제 이메일로 (minidonut03@gmail.com) 보내주시면 반영하겠습니다. 감사합니다.\n\n","source":"_posts/composing-software-translation-epilogue.md","raw":"---\ntitle: 소프트웨어 합성 Index 및 번역후기\ncatalog: true\ndate: 2018-04-28 14:21:32\nsubtitle: Translation Epilogue\nheader-img: \"bg.jpg\"\nreadingTime: 2\ntags:\n  - 자바스크립트\n  - 함수형\ncatagories:\n- 개발\npreview: 함수형 자바스크립트를 주제로  Eric Elliott이 medium에서 연재하는 시리즈입니다.  배열 연산, 대수적 자료구조 등 특정 주제에 초점을 맞춘 tips & tricks 이 아닌 좀 더 넓은 관점에서 함수형 패러다임을 조망하고 있으며 특히 소프트웨어 개발에서 마주칠 수 있는 많은 주제들을 합성Composition의 맥락으로 풀어내었습니다. 특히 객체지향 및 절차지향 패러다임의 부족한 점과 이를 함수형 패러다임으로 극복할 수 있는 전략을 여러장에 걸쳐 개관하는 점에 있어서 자바스크립트가 주요 언어가 아닌 독자들도 새로운 소프트웨어 설계 전략을 세울 때 참고하기 괜찮은 시리즈입니다.  \n---\n\n## 소프트웨어 합성 시리즈란?\n\n함수형 자바스크립트를 주제로  [Eric Elliott](https://medium.com/@_ericelliott?source=post_header_lockup)이 **medium**에서 연재하는 시리즈입니다.  배열 연산, 대수적 자료구조 등 특정 주제에 초점을 맞춘 _tips & tricks_ 이 아닌 좀 더 넓은 관점에서 함수형 패러다임을 조망하고 있으며 소프트웨어 개발에서 마주칠 수 있는 많은 주제들을 **합성**^Composition^의 맥락으로 풀어내었습니다. \n\n특히 객체지향 및 절차지향 패러다임의 부족한 점과 이를 함수형 패러다임으로 극복할 수 있는 전략을 여러장에 걸쳐 개관하기 때문에 자바스크립트가 주요 언어가 아닌 독자들도 새로운 소프트웨어 설계 전략을 세울 때 참고하기 괜찮은 시리즈입니다.  \n\n\n## Index\n\n1. [소프트웨어 합성 : 개요](https://midojeong.github.io/2018/03/16/composing-software-intro/)\n2. [함수형 프로그래밍의 역사 ](https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/)\n3. [왜 JavaScript로 함수형 프로그래밍을 배우는가?](https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/)\n4. [함수형 프로그래머를 위한 JavaScript 개요](https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/)\n5. [고차 함수](https://midojeong.github.io/2018/03/29/higher-order-functions/)\n6. [Reduce](https://midojeong.github.io/2018/03/31/reduce/)\n7. [Functor와 카테고리](https://midojeong.github.io/2018/04/07/functors-and-categories/)\n8. [함수형 믹스인](https://midojeong.github.io/2018/04/07/functional-mixins/)\n9. [ES6+와 팩토리 함수](https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/)\n10. [클래스로 합성하기가 까다로운 이유](https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/)\n11. [함수형 자료구조](https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/)\n12. [JavaScript 모나드](https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/)\n13. [Mocking은 코드 냄새(Code Smell)입니다](https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/)\n14. [객체 합성이라는 숨겨진 보물](https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/)\n15. [삼항연산자의 멋짐을 모르는 당신이 불쌍해](https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/)\n16. [합성과 추상화](https://midojeong.github.io/2018/04/26/abstraction-and-composition/)\n\n\n## 번역 후기\n\n함수형 프로그래밍을 공부하다가 이 시리즈를 읽게되었고 네 편째 읽는 동안 이 글을 번역해야겠다는 생각이 떠올랐습니다. 곧 바로 에디터를 열어 한 문장씩 한글로 옮기기 시작했으나 약 118페이지(165,113자) 정도의 분량을 마치는데는 적지 않은 시간이 걸린 것 같습니다. 명료한 표현들과 독자 친화적 구성으로 쓰인 Eric Elliot의 글을 읽다보면 이를 빠짐없이 옮겨 담기엔 역자의 실력이 많이 부족했음을 느낍니다.  \n\n용어 선택과 번역의 질에 있어서 미흡한 점이 보일 경우 제 이메일로 (minidonut03@gmail.com) 보내주시면 반영하겠습니다. 감사합니다.\n\n","slug":"composing-software-translation-epilogue","published":1,"updated":"2018-04-28T14:33:26.680Z","_id":"cjgjh9s4o0000jbp6avyu18rk","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"소프트웨어-합성-시리즈란\">소프트웨어 합성 시리즈란?</h2>\n<p>함수형 자바스크립트를 주제로  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a>이 <strong>medium</strong>에서 연재하는 시리즈입니다.  배열 연산, 대수적 자료구조 등 특정 주제에 초점을 맞춘 <em>tips &amp; tricks</em> 이 아닌 좀 더 넓은 관점에서 함수형 패러다임을 조망하고 있으며 소프트웨어 개발에서 마주칠 수 있는 많은 주제들을 <strong>합성</strong><sup>Composition</sup>의 맥락으로 풀어내었습니다.</p>\n<p>특히 객체지향 및 절차지향 패러다임의 부족한 점과 이를 함수형 패러다임으로 극복할 수 있는 전략을 여러장에 걸쳐 개관하기 때문에 자바스크립트가 주요 언어가 아닌 독자들도 새로운 소프트웨어 설계 전략을 세울 때 참고하기 괜찮은 시리즈입니다.</p>\n<h2 id=\"index\">Index</h2>\n<ol>\n<li><a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">소프트웨어 합성 : 개요</a></li>\n<li><a href=\"https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/\">함수형 프로그래밍의 역사 </a></li>\n<li><a href=\"https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/\">왜 JavaScript로 함수형 프로그래밍을 배우는가?</a></li>\n<li><a href=\"https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/\">함수형 프로그래머를 위한 JavaScript 개요</a></li>\n<li><a href=\"https://midojeong.github.io/2018/03/29/higher-order-functions/\">고차 함수</a></li>\n<li><a href=\"https://midojeong.github.io/2018/03/31/reduce/\">Reduce</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/07/functors-and-categories/\">Functor와 카테고리</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/07/functional-mixins/\">함수형 믹스인</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/\">ES6+와 팩토리 함수</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/\">클래스로 합성하기가 까다로운 이유</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/\">함수형 자료구조</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/\">JavaScript 모나드</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/\">Mocking은 코드 냄새(Code Smell)입니다</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/\">객체 합성이라는 숨겨진 보물</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/\">삼항연산자의 멋짐을 모르는 당신이 불쌍해</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/26/abstraction-and-composition/\">합성과 추상화</a></li>\n</ol>\n<h2 id=\"번역-후기\">번역 후기</h2>\n<p>함수형 프로그래밍을 공부하다가 이 시리즈를 읽게되었고 네 편째 읽는 동안 이 글을 번역해야겠다는 생각이 떠올랐습니다. 곧 바로 에디터를 열어 한 문장씩 한글로 옮기기 시작했으나 약 118페이지(165,113자) 정도의 분량을 마치는데는 적지 않은 시간이 걸린 것 같습니다. 명료한 표현들과 독자 친화적 구성으로 쓰인 Eric Elliot의 글을 읽다보면 이를 빠짐없이 옮겨 담기엔 역자의 실력이 많이 부족했음을 느낍니다.</p>\n<p>용어 선택과 번역의 질에 있어서 미흡한 점이 보일 경우 제 이메일로 (<a href=\"mailto:minidonut03@gmail.com\" target=\"_blank\" rel=\"noopener\">minidonut03@gmail.com</a>) 보내주시면 반영하겠습니다. 감사합니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>소프트웨어 합성 시리즈란?</h2>\n<p>함수형 자바스크립트를 주제로  <a href=\"https://medium.com/@_ericelliott?source=post_header_lockup\" target=\"_blank\" rel=\"noopener\">Eric Elliott</a>이 <strong>medium</strong>에서 연재하는 시리즈입니다.  배열 연산, 대수적 자료구조 등 특정 주제에 초점을 맞춘 <em>tips &amp; tricks</em> 이 아닌 좀 더 넓은 관점에서 함수형 패러다임을 조망하고 있으며 소프트웨어 개발에서 마주칠 수 있는 많은 주제들을 <strong>합성</strong><sup>Composition</sup>의 맥락으로 풀어내었습니다.</p>\n<p>특히 객체지향 및 절차지향 패러다임의 부족한 점과 이를 함수형 패러다임으로 극복할 수 있는 전략을 여러장에 걸쳐 개관하기 때문에 자바스크립트가 주요 언어가 아닌 독자들도 새로운 소프트웨어 설계 전략을 세울 때 참고하기 괜찮은 시리즈입니다.</p>\n<h2>Index</h2>\n<ol>\n<li><a href=\"https://midojeong.github.io/2018/03/16/composing-software-intro/\">소프트웨어 합성 : 개요</a></li>\n<li><a href=\"https://midojeong.github.io/2018/03/20/the-rise-and-fall-and-rise-of-functional-programming-composable-software/\">함수형 프로그래밍의 역사 </a></li>\n<li><a href=\"https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/\">왜 JavaScript로 함수형 프로그래밍을 배우는가?</a></li>\n<li><a href=\"https://midojeong.github.io/2018/03/28/a-functional-programmers-introduction-to-javascript/\">함수형 프로그래머를 위한 JavaScript 개요</a></li>\n<li><a href=\"https://midojeong.github.io/2018/03/29/higher-order-functions/\">고차 함수</a></li>\n<li><a href=\"https://midojeong.github.io/2018/03/31/reduce/\">Reduce</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/07/functors-and-categories/\">Functor와 카테고리</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/07/functional-mixins/\">함수형 믹스인</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/08/javaScript-factory-function-with-es6/\">ES6+와 팩토리 함수</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/12/Why-Composition-is-Harder-with-Classes/\">클래스로 합성하기가 까다로운 이유</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/14/composable-datatype-with-functions/\">함수형 자료구조</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/18/javascript-monads-made-simple/\">JavaScript 모나드</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/\">Mocking은 코드 냄새(Code Smell)입니다</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/23/the-hidden-treasures-of-object-composition/\">객체 합성이라는 숨겨진 보물</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/24/nested-ternaries-are-great/\">삼항연산자의 멋짐을 모르는 당신이 불쌍해</a></li>\n<li><a href=\"https://midojeong.github.io/2018/04/26/abstraction-and-composition/\">합성과 추상화</a></li>\n</ol>\n<h2>번역 후기</h2>\n<p>함수형 프로그래밍을 공부하다가 이 시리즈를 읽게되었고 네 편째 읽는 동안 이 글을 번역해야겠다는 생각이 떠올랐습니다. 곧 바로 에디터를 열어 한 문장씩 한글로 옮기기 시작했으나 약 118페이지(165,113자) 정도의 분량을 마치는데는 적지 않은 시간이 걸린 것 같습니다. 명료한 표현들과 독자 친화적 구성으로 쓰인 Eric Elliot의 글을 읽다보면 이를 빠짐없이 옮겨 담기엔 역자의 실력이 많이 부족했음을 느낍니다.</p>\n<p>용어 선택과 번역의 질에 있어서 미흡한 점이 보일 경우 제 이메일로 (<a href=\"mailto:minidonut03@gmail.com\" target=\"_blank\" rel=\"noopener\">minidonut03@gmail.com</a>) 보내주시면 반영하겠습니다. 감사합니다.</p>\n"}],"PostAsset":[{"_id":"source/_posts/Why-Composition-is-Harder-with-Classes/bg.jpg","slug":"bg.jpg","post":"cjgjh83bo0001ifp64uwl31wz","modified":0,"renderable":0},{"_id":"source/_posts/a-functional-programmers-introduction-to-javascript/bg.jpg","slug":"bg.jpg","post":"cjgjh83c20003ifp6cjmcoqvc","modified":0,"renderable":0},{"_id":"source/_posts/abstraction-and-composition/bg.jpg","slug":"bg.jpg","post":"cjgjh83ce0006ifp6nwryvtyn","modified":0,"renderable":0},{"_id":"source/_posts/composable-datatype-with-functions/bg.jpg","slug":"bg.jpg","post":"cjgjh83cn0008ifp6yt02c4o1","modified":0,"renderable":0},{"_id":"source/_posts/composing-software-intro/bg.jpg","slug":"bg.jpg","post":"cjgjh83ct0009ifp63u10tt0s","modified":0,"renderable":0},{"_id":"source/_posts/functional-mixins/bg.jpg","slug":"bg.jpg","post":"cjgjh83d2000bifp6djenm1k2","modified":0,"renderable":0},{"_id":"source/_posts/functors-and-categories/bg.jpg","slug":"bg.jpg","post":"cjgjh83d7000cifp6r0u9xkw4","modified":0,"renderable":0},{"_id":"source/_posts/higher-order-functions/bg.jpg","slug":"bg.jpg","post":"cjgjh83de000fifp69v1889kf","modified":0,"renderable":0},{"_id":"source/_posts/javaScript-factory-function-with-es6/bg.jpg","slug":"bg.jpg","post":"cjgjh83dn000hifp6mpforyb1","modified":0,"renderable":0},{"_id":"source/_posts/javascript-monads-made-simple/bg.jpg","slug":"bg.jpg","post":"cjgjh83dz000kifp665ciwfo8","modified":0,"renderable":0},{"_id":"source/_posts/mocking-is-a-code-smell/bg.jpg","slug":"bg.jpg","post":"cjgjh83e6000mifp6a04foe4k","modified":0,"renderable":0},{"_id":"source/_posts/nested-ternaries-are-great/bg.jpg","slug":"bg.jpg","post":"cjgjh83ee000pifp693h8bk3u","modified":0,"renderable":0},{"_id":"source/_posts/reduce/bg.jpg","slug":"bg.jpg","post":"cjgjh83el000rifp69otsm9t3","modified":0,"renderable":0},{"_id":"source/_posts/the-hidden-treasures-of-object-composition/bg.jpg","slug":"bg.jpg","post":"cjgjh83en000uifp6j0zusm4u","modified":0,"renderable":0},{"_id":"source/_posts/why-learn-functional-programming-in-javascript/bg.jpg","slug":"bg.jpg","post":"cjgjh83er000zifp6jtvolntp","modified":0,"renderable":0},{"_id":"source/_posts/the-rise-and-fall-and-rise-of-functional-programming-composable-software/1_LSXnRbKzQ4yhq1fjZjvq6Q.png","slug":"1_LSXnRbKzQ4yhq1fjZjvq6Q.png","post":"cjgjh83ep000wifp6zbood6jy","modified":0,"renderable":0},{"_id":"source/_posts/the-rise-and-fall-and-rise-of-functional-programming-composable-software/bg.jpg","slug":"bg.jpg","post":"cjgjh83ep000wifp6zbood6jy","modified":0,"renderable":0},{"_id":"source/_posts/composing-software-translation-epilogue/bg.jpg","slug":"bg.jpg","post":"cjgjh9s4o0000jbp6avyu18rk","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjgjh83d2000bifp6djenm1k2","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83dd000eifp6iszb4onn"},{"post_id":"cjgjh83d2000bifp6djenm1k2","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83dm000gifp6r3swe6bp"},{"post_id":"cjgjh83bo0001ifp64uwl31wz","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83dy000jifp6s10kcf3k"},{"post_id":"cjgjh83bo0001ifp64uwl31wz","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83e6000lifp6ggwvgjx2"},{"post_id":"cjgjh83d7000cifp6r0u9xkw4","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83ee000oifp63m014ua9"},{"post_id":"cjgjh83d7000cifp6r0u9xkw4","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83ek000qifp6467wno7p"},{"post_id":"cjgjh83de000fifp69v1889kf","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83en000tifp66ocwa4ij"},{"post_id":"cjgjh83de000fifp69v1889kf","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83ep000vifp63lu2xape"},{"post_id":"cjgjh83dn000hifp6mpforyb1","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83er000yifp642y0ily7"},{"post_id":"cjgjh83dn000hifp6mpforyb1","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83et0010ifp6cek2h7yj"},{"post_id":"cjgjh83dz000kifp665ciwfo8","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83ew0012ifp6b33t5znw"},{"post_id":"cjgjh83dz000kifp665ciwfo8","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83ew0013ifp66w1nlrtf"},{"post_id":"cjgjh83c20003ifp6cjmcoqvc","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83ew0014ifp65tkrah4k"},{"post_id":"cjgjh83c20003ifp6cjmcoqvc","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83ex0015ifp6j97sw9re"},{"post_id":"cjgjh83e6000mifp6a04foe4k","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83ex0016ifp6707dwmdc"},{"post_id":"cjgjh83e6000mifp6a04foe4k","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83ex0017ifp6zy1s177f"},{"post_id":"cjgjh83ee000pifp693h8bk3u","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83ex0018ifp6rl88htwx"},{"post_id":"cjgjh83ee000pifp693h8bk3u","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83ex0019ifp6t4w9b2ja"},{"post_id":"cjgjh83el000rifp69otsm9t3","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83ex001aifp69bsu47fi"},{"post_id":"cjgjh83el000rifp69otsm9t3","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83f1001bifp6lft97lwf"},{"post_id":"cjgjh83en000uifp6j0zusm4u","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83f1001cifp6lc06hbhs"},{"post_id":"cjgjh83en000uifp6j0zusm4u","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83f1001difp6247se3kj"},{"post_id":"cjgjh83ce0006ifp6nwryvtyn","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83f1001eifp6c734k4b5"},{"post_id":"cjgjh83ce0006ifp6nwryvtyn","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83f1001fifp62jm79wrn"},{"post_id":"cjgjh83ep000wifp6zbood6jy","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83f1001gifp6k1a6skv5"},{"post_id":"cjgjh83ep000wifp6zbood6jy","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83f2001hifp6x9udui2m"},{"post_id":"cjgjh83er000zifp6jtvolntp","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83f2001iifp6g841ohci"},{"post_id":"cjgjh83er000zifp6jtvolntp","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83f2001jifp6dwmmetfs"},{"post_id":"cjgjh83cn0008ifp6yt02c4o1","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83f2001kifp6aj0qjtjy"},{"post_id":"cjgjh83cn0008ifp6yt02c4o1","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83f2001lifp65yndvs34"},{"post_id":"cjgjh83ct0009ifp63u10tt0s","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh83f2001mifp6rixm9lhq"},{"post_id":"cjgjh83ct0009ifp63u10tt0s","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh83f2001nifp67hytelfv"},{"post_id":"cjgjh9s4o0000jbp6avyu18rk","tag_id":"cjgjh83cb0005ifp6dw51exv4","_id":"cjgjh9s6w0001jbp6a44vihob"},{"post_id":"cjgjh9s4o0000jbp6avyu18rk","tag_id":"cjgjh83cw000aifp6sb8q9xt2","_id":"cjgjh9s6x0002jbp6xgdclqg2"}],"Tag":[{"name":"자바스크립트","_id":"cjgjh83cb0005ifp6dw51exv4"},{"name":"함수형","_id":"cjgjh83cw000aifp6sb8q9xt2"}]}}